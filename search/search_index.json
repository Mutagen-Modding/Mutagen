{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":"<p>Mutagen is a C# library for analyzing, modifying, and creating Bethesda mods. One of its main features is offering interfaces and classes for the records that exist at compile time and are first class citizens in C#. With actual members for each field they get the benefits of type safety, simple live debugging, Intellisense features such as autocomplete. The interfaces offer clean API to the user and abstract away much of the binary record specifics and oddities of how they are stored on disk, while the actual implementation remains very closely tied to the data offering as much speed as it can by leveraging some of the latest C# features. Most of the public facing API is created by code generation, with small manual snippets of code for the one-off special cases. This means the library is able to provide consistent API with very little manual work when adding new record definitions or features.</p> <p></p>"},{"location":"#goals","title":"Goals","text":"<p>What is Mutagen trying to provide?</p> <ul> <li>Ability to analyze, create, or manipulate Bethesda mods in C#.</li> <li>Strongly typed objects and fields for all records, which naturally offer Intellisense and type safety.</li> <li>User abstraction from complex binary record structures/patterns, when appropriate and beneficial.</li> <li>Frameworks for accomplishing common tasks</li> <li>Performance via intelligent short circuiting of work and minimal internal layers underneath the API.</li> <li>Heavy use of generated code to provide the above goals without requiring verbose manual development or maintenance.</li> <li>Powerful but gritty low level tools for those that want to forgo the autogenerated classes for special tasks.</li> </ul>"},{"location":"#sample-api","title":"Sample API","text":"<p>A small snippet showing how to print some EditorIDs </p><pre><code>// A function that loops over any major records, and prints their unique EditorIDs\nvoid PrintAll(IEnumerable&lt;IMajorRecordCommonGetter&gt; records)\n{\n    foreach (var editorId in records\n        .Select(record =&gt; record.EditorID)\n        .Where(edid =&gt; !edid.IsNullOrWhitespace())\n        .Distinct())\n    {\n        System.Console.WriteLine(editorId);\n    }\n}\n\n// Create a bootstrapping state object with entry points for a typical installation\nusing var env = GameEnvironment.Typical.Skyrim(SkyrimRelease.SkyrimSE);\n// Print all winning override weapon from all active mods in the game\nPrintAll(env.LoadOrder.PriorityOrder.Weapon().WinningOverrides());\n\n// Print all armors from a specific mod\nusing var mod = SkyrimMod.CreateFromBinaryOverlay(Path.Combine(env.DataFolderPath, \"MyMod.esp\"));\nPrintAll(mod.Armors);\n</code></pre><p></p>"},{"location":"#major-features","title":"Major Features","text":""},{"location":"#plugins","title":"Plugins","text":"<p>Importing, exporting, and manipulating plugins (esp/esm.esl files)</p> <ul> <li>Mutable Classes</li> <li>Lightweight Read-only Access</li> <li>Enhanced FormID Concepts</li> </ul>"},{"location":"#linking-and-record-lookups","title":"Linking and Record Lookups","text":"<p>Following FormID pointers and looking up records by FormID/FormKey/EditorID</p> <ul> <li>Record Lookup</li> <li>Context Concepts</li> <li>Mutable vs Immutable Caches</li> </ul>"},{"location":"#load-order","title":"Load Order","text":"<p>Accessing the order mods should load and override one another</p> <ul> <li>Read/Write support</li> <li>Live monitoring that adapts to on-disk changes</li> <li>Winning Override Iteration</li> </ul>"},{"location":"#archives-bsaba2","title":"Archives (Bsa/Ba2)","text":"<p>Extracting assets from archive files</p> <ul> <li>Read support</li> </ul>"},{"location":"#strings","title":"Strings","text":"<p>Multi language string support systems</p> <ul> <li>Dictionary Style API</li> <li>Read/Write support</li> </ul>"},{"location":"#wpf-ui-controls","title":"WPF UI Controls","text":"<p>Controls that can be used in any WPF app</p> <ul> <li>FormKey Pickers</li> <li>ModKey Pickers</li> <li>Load Order display and manipulation</li> </ul>"},{"location":"#seeing-mutagen-in-action","title":"Seeing Mutagen in Action","text":""},{"location":"#synthesis","title":"Synthesis","text":"<p>Synthesis is a patcher pipeline built on top of Mutagen, and it already has a large library of example patchers to study and get inspiration from.</p>"},{"location":"#example-project","title":"Example Project","text":"<p>Another option is the Mutagen Bootcamp project.  It contains a good number of example tasks which you can run after pointing it to your copy of Skyrim.  It should be a good starter to help you understand the basics and actually see some of the processing in action.</p>"},{"location":"#installing-mutagen","title":"Installing Mutagen","text":"<p>Mutagen can be added to your C# project via NuGet, under the package name <code>Mutagen.Bethesda</code>.  Search for it in Visual Studio, or find it here.</p> <p>If you're unfamiliar with setting up C# projects in general, a good place to start might be creating a simple Synthesis patcher, and be sure to ask questions on our Discord.</p>"},{"location":"Archives/","title":"Archives (BSAs)","text":""},{"location":"Archives/#archives-bsas","title":"Archives (BSAs)","text":"<p>Certain Bethesda files like textures, meshes, and similar assets are often stored in zipped up files with extensions like <code>.bsa</code> or <code>b2a</code>.</p> <p>Mutagen calls these <code>Archives</code> and offers API to read the contents from those.   Writing new Archives is not something Mutagen can currently do, but is on the list of features to eventually be added.</p>"},{"location":"Archives/#reading","title":"Reading","text":""},{"location":"Archives/#archive-reader","title":"Archive Reader","text":"<p>To start reading an Archive, you must make an Archive Reader: </p><pre><code>var reader = Archive.CreateReader(GameRelease.SkyrimSE, somePathToBSA);\n</code></pre><p></p>"},{"location":"Archives/#file-enumeration","title":"File Enumeration","text":"<p>With an Archive Reader, you can enumerate all the files it contains: </p><pre><code>foreach (var file in reader.Files)\n{\n    Console.WriteLine($\"File at {file.Path}, with size {file.Size}\");\n\n    var fileBytes = file.GetBytes();\n    // You can also get the file data by stream\n}\n</code></pre><p></p>"},{"location":"Archives/#folder-lookup","title":"Folder Lookup","text":"<p>Archive Readers can also look up specific folders: </p><pre><code>if (reader.TryGetFolder(\"some/sub/folder\", out var archiveFolder))\n{\n   // Found the folder inside the archive\n}\n</code></pre><p></p> <p>Folders have similar API of looping contained files as an Archive Reader</p>"},{"location":"Archives/#finding-applicable-archives","title":"Finding Applicable Archives","text":"<p>(Todo)</p>"},{"location":"Big-Cheat-Sheet/","title":"Big Cheat Sheet","text":""},{"location":"Big-Cheat-Sheet/#big-cheat-sheet","title":"Big Cheat Sheet","text":""},{"location":"Big-Cheat-Sheet/#overview","title":"Overview","text":"<p>A massive list of code snippets without much contextual explaination.</p>"},{"location":"Big-Cheat-Sheet/#target-game","title":"Target Game","text":"<p>Most code snippets will assume Skyrim SE, but code should work for any game, generally.</p>"},{"location":"Big-Cheat-Sheet/#preparing-the-examples","title":"Preparing the Examples","text":"<p>When <code>...</code> is seen, that generally means the example will not cover how that object might have been made.  <code>...</code> is not actually valid code to be copied and pasted.</p>"},{"location":"Big-Cheat-Sheet/#missing-namespaces","title":"Missing Namespaces","text":"<p>If you're just copy pasting code, often it will not compile because some required namespaces are missing.  You can have the IDE import them by clicking on the red object in question and activating quick fixes (<code>Ctrl - .</code> in Visual Studio).</p> <p> Namespaces</p>"},{"location":"Big-Cheat-Sheet/#construct-an-environment","title":"Construct an Environment","text":"Typical <pre><code>using var env = GameEnvironment.Typical.Skyrim(SkyrimRelease.SkyrimSE);\n\nConsole.WriteLine($\"Data folder is: {state.DataFolderPath}\");\n</code></pre> <p> Environments</p>"},{"location":"Big-Cheat-Sheet/#retrieve-a-mod-from-a-load-order","title":"Retrieve a Mod From a Load Order","text":"ResolveTryGet <pre><code>var mod = myLoadOrder.ResolveMod(\"MyMod.esp\");\n</code></pre> <pre><code>if (myLoadOrder.TryGetValue(\"MyMod.esp\", out var mod))\n{\n    // ..\n}\n</code></pre> <p> Mod Retrieval</p>"},{"location":"Big-Cheat-Sheet/#basic-record-inspection-and-override-example","title":"Basic Record Inspection and Override Example","text":"<pre><code>using var env = GameEnvironment.Typical.Skyrim(SkyrimRelease.SkyrimSE);\n\nvar outgoingPatch = new SkyrimMod(\"MyPatch.esp\", SkyrimRelease.SkyrimSE);\n\nforeach (var readonlyNpc in env.LoadOrder.PriorityOrder.Npc().WinningContextOverrides())\n{\n    // Readonly phase\n    // Skip npc if health offset greater than 100\n    if (readonlyNpc.Record.Configuration.HealthOffset &lt; 100) continue;\n    // Mutable phase\n    var npc = readonlyNpc.GetOrAddAsOverride(outgoingPatch);\n    // Set all lower health offsets to be at least 100\n    npc.Configuration.HealthOffset = 100;\n}\n\noutgoingPatch.BeginWrite\n    .ToPath(Path.Combine(\"SomePath\", outgoingPatch.ModKey.FileName))\n    .WithLoadOrder(env.LoadOrder)\n    .Write();\n</code></pre> <p> Environments</p> <p> Winning Overrides</p> <p> Readonly Best Practice</p>"},{"location":"Big-Cheat-Sheet/#construct-a-modkey","title":"Construct a ModKey","text":"FromFileNameTryFromFileNameNew <pre><code>var modKey = ModKey.FromFileName(\"Skyrim.esm\");\n</code></pre> <pre><code>if (ModKey.TryFromFileName(\"Skyrim.esm\", out var modKey))\n{\n   // If conversion successful.\n}\nelse\n{\n   // An unsuccessful conversion.\n   // Might occur if there was an extension typo, like \"Skyrim.esz\"\n}\n</code></pre> <pre><code>var modKey = new ModKey(\"Skyrim\", ModType.Plugin);\n</code></pre> <p> ModKeys</p>"},{"location":"Big-Cheat-Sheet/#get-list-of-masters-from-a-mod","title":"Get List of Masters From A Mod","text":"MasterReferenceCollectionMod Object <pre><code>var masterCollection = MasterReferenceCollection.FromPath(pathToMod, GameRelease.SkyrimSE);\n\nConsole.WriteLine($\"The mod {masterCollection.CurrentMod} has masters:\");\nforeach (var master in masterCollection.Masters)\n{\n    Console.WriteLine($\"  {master.Master.FileName}\");\n}\n</code></pre> <pre><code>using var mod = SkyrimMod.CreateFromBinaryOverlay(pathToMod, SkyrimRelease.SkyrimSE);\n\nConsole.WriteLine($\"The mod {mod.ModKey} has masters:\");\nforeach (var master in mod.ModHeader.MasterReferences)\n{\n    Console.WriteLine($\"  {master.Master.FileName}\");\n}\n</code></pre>"},{"location":"Big-Cheat-Sheet/#look-up-a-record","title":"Look Up a Record","text":"<pre><code>ILinkCache linkCache = ...;\nvar formLink = new FormLink&lt;IFormListGetter&gt;(FormKey.Factory(\"123456:Skyrim.esm\"));\n\nif (formLink.TryResolve(linkCache, out var foundRecord))\n{\n    // Use the specific record we were looking for\n}\n</code></pre> <p> Link Caches</p> <p>Avoid Hand Writing FormKeys</p> <p>Using the FormKey Generator project is a good alternative to hand constructing FormLinks\"</p>"},{"location":"Big-Cheat-Sheet/#convert-formkey-to-formid","title":"Convert FormKey to FormID","text":"<p>=== MasterReferenceCollection     </p><pre><code>FormKey formKey = ...;\nIMasterReferenceCollection masterCollection = ...;\n\nFormID formID = masterCollection.GetFormID(formKey);\n</code></pre><p></p> <p> FormKeys</p>"},{"location":"Big-Cheat-Sheet/#convert-formkey-to-formlink","title":"Convert FormKey to FormLink","text":"<pre><code>FormKey formKey = ...;\n// NOTE: Typically want to use the \"getter\" interfaces for FormLinks\nvar npcLink = formKey.ToLink&lt;INpcGetter&gt;();\n</code></pre> <p> FormLinks</p>"},{"location":"Big-Cheat-Sheet/#check-if-formlink-is-pointing-to-a-null-record","title":"Check if FormLink is Pointing to a Null record","text":"<pre><code>Npc npc = ...;\nif (!npc.Race.IsNull)\n{\n   // ...\n}\n</code></pre> <p> FormLink Nullability</p>"},{"location":"Big-Cheat-Sheet/#convert-formlink-to-nullableformlink","title":"Convert FormLink to NullableFormLink","text":"<p>=== SetTo     </p><pre><code>IFormLinkGetter&lt;IEquipTypeGetter&gt; link = ...;\nIFormLinkNullableGetter&lt;IEquipTypeGetter&gt; nullableLink = ...;\n\nnullableLink.SetTo(link);\n</code></pre> === AsNullable     <pre><code>IFormLinkGetter&lt;IEquipTypeGetter&gt; link = ...;\n\nIFormLinkNullableGetter&lt;IEquipTypeGetter&gt; nullableLink = link.AsNullable();\n</code></pre><p></p> <p> FormLinks</p>"},{"location":"Big-Cheat-Sheet/#convert-majorrecord-to-formlink","title":"Convert MajorRecord to FormLink","text":"<pre><code>INpcGetter npcGetter = ...;\nvar npcLink = npcGetter.ToLink();\n</code></pre> Always use Getter interfaces <p>If the source major record type is not a getter interface it is recommended to take extra steps to keep the link targeting the getter interface</p> <pre><code>INpc npcSetter = ...;\nvar npcLink2 = npcSetter.ToLink&lt;INpcGetter&gt;();\n// or\nIFormLinkGetter&lt;INpcGetter&gt; npcLink3 = npcSetter.ToLink();\n</code></pre> <p> Use Getter Interfaces in FormLinks</p>"},{"location":"Big-Cheat-Sheet/#iterate-winning-overrides","title":"Iterate Winning Overrides","text":"Normal RecordMod Context <pre><code>ILoadOrder&lt;ISkyrimMod, ISkyrimModGetter&gt; loadOrder = ...;\n\nforeach (var keywordGetter in loadOrder.PriorityOrder.Keywords().WinningOverrides())\n{\n   // Process each keyword record's winning override\n}\n</code></pre> <pre><code>ILoadOrder&lt;ISkyrimMod, ISkyrimModGetter&gt; loadOrder = ...;\nILinkCache linkCache = ...;\n\nforeach (var cellContext in loadOrder.PriorityOrder.Cell().WinningContextOverrides(linkCache))\n{\n   // Process each cell record's winning override\n}\n</code></pre> <p> Winning Overrides</p>"},{"location":"Big-Cheat-Sheet/#iterate-original-definitions","title":"Iterate Original Definitions","text":"<pre><code>foreach (var keywordGetter in loadOrder.ListedOrder.Keywords().WinningOverrides())\n{\n   // Process each keyword record's original definition\n}\n</code></pre> Reasoning <p>By swapping to ListedOrder, the loop will now iterate over the original definitions of each record.  By viewing the load order \"backwards\", is sees the original mods as the winning override to return</p>"},{"location":"Big-Cheat-Sheet/#override-a-nested-record","title":"Override a Nested Record","text":"Specific CellAll Cells <pre><code>FormKey someFormKey = ...;\nILinkCache linkCache = ...;\nISkyrimMod outgoingMod = ...;\n\nvar cellContext = linkCache.ResolveContext&lt;ICell, ICellGetter&gt;(someFormKey);\nvar overrideCell = cellContext.GetOrAddAsOverride(outgoingMod);\n</code></pre> <pre><code>ILoadOrder&lt;ISkyrimMod, ISkyrimModGetter&gt; loadOrder = ...;\nFormKey someFormKey = ...;\nILinkCache linkCache = ...;\nISkyrimMod outgoingMod = ...;\n\nforeach (var cellContext in loadOrder.PriorityOrder.Cell().WinningContextOverrides(linkCache))\n{\n    var overrideCell = cellContext.GetOrAddAsOverride(outgoingMod);\n}\n</code></pre> <p> Mod Contexts</p>"},{"location":"Big-Cheat-Sheet/#overriding-generic-records","title":"Overriding Generic Records","text":"<p>When working within generic functions, you need to explicitly provide the mod setter/getter types as well as the record setter/getter types to resolve contexts.</p> <pre><code>public void ProcessRecords&lt;TMod, TModGetter, TMajor, TMajorGetter&gt;(\n    ILinkCache&lt;TMod, TModGetter&gt; linkCache,\n    TMod outgoingMod,\n    IFormLinkGetter&lt;TMajorGetter&gt; targetLink)\n    where TModGetter : IModGetter\n    where TMod : IMod, TModGetter\n    where TMajorGetter : IMajorRecordGetter\n    where TMajor : IMajorRecord, TMajorGetter\n{\n    if (targetLink.TryResolveContext&lt;TMod, TModGetter, TMajor, TMajorGetter&gt;(linkCache, out var context))\n    {\n        var overrideRecord = context.GetOrAddAsOverride(outgoingMod);\n        // Modify overrideRecord as needed\n    }\n}\n</code></pre> <p> Mod Contexts</p>"},{"location":"Big-Cheat-Sheet/#check-if-a-formlink-points-to-a-specific-record","title":"Check If A FormLink Points to a Specific Record","text":"FormKey Mapping LibraryBy FormLinkBy FormKey <pre><code>INpcGetter npc = ...;\nif (Skyrim.Race.KhajiitRace.Equals(npc.Race))\n{\n}\n</code></pre>  FormLink Mapping <pre><code>INpcGetter npc = ...;\nIFormLinkGetter&lt;INpcGetter&gt; formLink = ...;\nif (target.Equals(npc.Race))\n{\n}\n</code></pre>  FormLinks <pre><code>INpcGetter npc = ...;\nFormKey formKey = ...;\nif (formKey.Equals(npc.Race))\n{\n}\n</code></pre>  FormKeys"},{"location":"Big-Cheat-Sheet/#duplicate-a-record","title":"Duplicate a Record","text":"<p>Copy an existing record with a new FormKey</p> Same Source ModFrom Target Mod <pre><code>var dup = someRecord.Duplicate(newFormKey);\n</code></pre> Next Available FormKeySpecific FormKeyPersistence Support <p><code>cs { .cs hl_lines=\"2\" } Npc someRecord = ...; var dup = someMod.Npcs.DuplicateInAsNewRecord(someRecord);</code></p> <pre><code>FormKey desiredFormKey = ...;\nvar dup2 = someMod.Npcs.DuplicateInAsNewRecord(desiredFormKey);\n</code></pre> <pre><code>string someUniqueEditorId = ...;\nvar dup3 = someMod.Npcs.DuplicateInAsNewRecord(someUniqueEditorId);\n</code></pre> <p> FormKey Persistence</p> <p> Duplication</p>"},{"location":"Big-Cheat-Sheet/#detect-if-given-plugin-is-the-winning-override-for-a-specific-record","title":"Detect if Given Plugin is the Winning Override for a Specific Record","text":"<p>There might be several ways to accomplish this, depending on the gritty situation, but here is one route: </p><pre><code>// Use the link cache to locate the winning record, with additional context\nif (formLinkOfRecordOfInterest.TryResolveSimpleContext(someLinkCache, out var context))\n{\n    // The context's ModKey will be from the record that contained it\n    if (context.ModKey == givenPlugin.ModKey)\n    {\n        // givenPlugin was the winningmost override for the record!\n    }\n    else\n    {\n        // Some other mod is the winningmost override for this record:  context.ModKey will have which one that is\n    }\n}\n</code></pre><p></p>"},{"location":"Big-Cheat-Sheet/#find-all-major-record-types","title":"Find all Major Record Types","text":"<pre><code>foreach (var recTypes in MajorRecordTypeEnumerator.GetMajorRecordTypesFor(GameCategory.Skyrim))\n{\n    Console.WriteLine($\"Getter: {recTypes.GetterType}\");\n    Console.WriteLine($\"Setter: {recTypes.SetterType}\");\n    Console.WriteLine($\"Class: {recTypes.ClassType}\");\n}\n</code></pre>"},{"location":"Big-Cheat-Sheet/#find-all-major-record-types-for-top-level-groups","title":"Find all Major Record Types for Top Level Groups","text":"<pre><code>foreach (var recTypes in MajorRecordTypeEnumerator.GetTopLevelMajorRecordTypesFor(GameCategory.Skyrim))\n{\n    Console.WriteLine($\"Getter: {recTypes.GetterType}\");\n    Console.WriteLine($\"Setter: {recTypes.SetterType}\");\n    Console.WriteLine($\"Class: {recTypes.ClassType}\");\n}\n</code></pre>"},{"location":"Big-Cheat-Sheet/#enrich-exceptions","title":"Enrich Exceptions","text":"<pre><code>var majorRecordContext = ...;\ntry\n{\n    // Access majorRecordContext and potentially throw\n}\ncatch (Exception e)\n{\n    throw RecordException.Enrich(e, majorRecordContext);\n}\n</code></pre> <p> Exception Enrichment</p>"},{"location":"Big-Cheat-Sheet/#detect-if-placedobject-is-inside-worldspace","title":"Detect if PlacedObject is inside Worldspace","text":"<pre><code>var loadOrder = ...;\nvar linkCache = ...;\n\nforeach (var placedObjectContext in loadOrder.PriorityOrder.PlacedObject().WinningContextOverrides(linkCache))\n{\n    Console.WriteLine($\"Checking placed object: {placedObjectContext.Record}\");\n    if (placedObjectContext.TryGetParent&lt;IWorldspaceGetter&gt;(out var worldspace))\n    {\n        Console.WriteLine($\"Was in worldspace: {worldspace}\");\n    }\n}\n</code></pre> <p> Mod Context Parents</p>"},{"location":"Big-Cheat-Sheet/#call-generic-function-by-mod-type","title":"Call Generic Function by Mod Type","text":"<pre><code>public class MyClass\n{\n    public void DoSomeThings(IMod mod)\n    {\n        ModToGenericCallHelper.InvokeFromCategory(\n            this,\n            mod.GameRelease.ToCategory(),\n            typeof(MyClass).GetMethod(nameof(DoSomeThingsGeneric), BindingFlags.NonPublic | BindingFlags.Instance)!,\n            new object[] { mod });\n    }\n\n    private void DoSomeThingsGeneric&lt;TMod, TModGetter&gt;(TMod mod)\n        where TModGetter : IModGetter\n        where TMod : IMod, TModGetter, IMajorRecordContextEnumerable&lt;TMod, TModGetter&gt;\n    {\n        // Actual logic\n    }\n}\n</code></pre> <p> Common to Generic Crossover</p>"},{"location":"Contributing/","title":"Contributing","text":""},{"location":"Contributing/#contributing","title":"Contributing","text":"<p>Want to contribute?</p>"},{"location":"Contributing/#documentation","title":"Documentation","text":"<p>Mutagen's documentation itself is able to be contributed to and improved.</p> <p>The files driving the documentation are located here</p> <p>They use a system called Material For MkDocs</p>"},{"location":"Contributing/#one-off-improvements","title":"One Off Improvements","text":"<p>If there's something small like a typo or a single sentence to improve, these can often be done straight from Github's website.</p> <p></p> <p>This will open an editor and allow you to initiate a PR directly from the website with your changes.</p> <p>You can of course do the same changes and PR proposals more traditionally by forking, cloning locally, and initiating a PR from there.</p>"},{"location":"Contributing/#extensive-improvements","title":"Extensive Improvements","text":"<p>If you're making more extensive improvements, you will likely want to see the results of the changes to the documentation \"live\" so you can make sure everything is displaying as intended.</p> <p>This involves:</p> <ul> <li> <p>Downloading the documentation to your computer</p> </li> <li> <p>Installing and running MkDocs locally to see the results as you edit the documentation</p> </li> <li> <p>Committing the final results and initiating a PR</p> </li> </ul> <p>To do this, you will want to:</p>"},{"location":"Contributing/#fork-mutagen-repository","title":"Fork Mutagen Repository","text":"<p>This step makes a copy of the Mutagen repo on Github that you have ownership of and can modify and prep your changes.</p> <p></p>"},{"location":"Contributing/#download-clone","title":"Download (Clone)","text":"<p>This step downloads (clones) the fork you just made to your local computer.</p> <p>GitKraken is a good Git client to help, but there's lots of alternatives</p> <p></p>"},{"location":"Contributing/#installing-mkdocs","title":"Installing MkDocs","text":"<p>This is the documentation system Mutagen uses, so you have to install it, along with the GLightbox plugin, so it can display the docs as you edit them.</p> <p>Installing Material for MkDocs</p> <p>Installing MkDocs GLightbox</p> <p>TLDR: <code>pip install mkdocs-material mkdocs-glightbox</code> in a command line</p>"},{"location":"Contributing/#running-mkdocs","title":"Running MkDocs","text":"<p>Running <code>mkdocs serve</code> on your cloned Mutagen repository </p> <p>This step runs MkDocs and tells it to watch Mutagen's documentation and display the changes.   </p> <p>Control-Click on the \"Serving On\" address to open it in your browser and see the docs as you write them.</p> <p></p>"},{"location":"Contributing/#edit-documentation","title":"Edit Documentation","text":"<p>Use the MkDocs guide for all the neat things you can do.</p>"},{"location":"Contributing/#commit-push","title":"Commit, Push","text":"<p>This step saves your changes locally and prepares them to be uploaded and merged.</p> <p>Once committed, you can Push them up to your Fork on GitHub's servers</p> <p></p>"},{"location":"Contributing/#create-pull-request","title":"Create Pull Request","text":"<p>This step officially makes the request for the Mutagen repository to bring in the changes you made on your Fork.</p> <p>The easiest way is to click this button, which GitHub shows on your fork's <code>Pull Requests</code> tab for a short while after you push</p> <p></p> <p>After that, the Mutagen team can merge in your documentation updates!   Feel free to comment on the PR itself, or get in touch on Discord to chat about what you changed and why.</p>"},{"location":"Correctness/","title":"Correctness","text":""},{"location":"Correctness/#correctness","title":"Correctness","text":""},{"location":"Correctness/#passthrough-testing","title":"Passthrough Testing","text":"<p>Besides general unit tests for edge-case prone code section, Mutagen has a passthrough test suite that it uses to help confirm correctness.  </p>"},{"location":"Correctness/#definition","title":"Definition","text":"<p>A passthrough means that Mutagen will read in a source file into the classes it provides, and then immediately re-export.  If the two files match, then it was able to \"pass through\" Mutagen's systems without being changed unexpectedly.</p>"},{"location":"Correctness/#pre-processing","title":"Pre-Processing","text":"<p>There is a bit more that goes into a passthrough than just importing, re-exporting, and comparing, though.  For one, it is much easier to compare files match byte to byte if you're comparing the uncompressed data.  As such, there are a few pre-processing steps that happen before a passthrough test is actually executed.</p>"},{"location":"Correctness/#decompression","title":"Decompression","text":"<p>The source file is lightly processed so that all the records are in their decompressed format.</p>"},{"location":"Correctness/#float-standardization","title":"Float Standardization","text":"<p>Some float values can be stored in multiple ways.  A common one is zero, which is stored as zero by Bethesda in two different formats.  This stage standardizes floats to be the format Mutagen will export as, while leaving their actual represented values intact.</p>"},{"location":"Correctness/#subrecord-order-standardization","title":"Subrecord Order Standardization","text":"<p>Subrecords usually come in a predictable order, but they are not required to.  Bethesda in some circumstances will deviate and shuffle the subrecords to where the content overall stays the same, but the order they show up on disk is different.  This phase moves the subrecords to be in the order Mutagen would export them in.  This helps the byte to byte comparison line up better without being distracted by subrecords of differing order.</p>"},{"location":"Correctness/#strings-file-key-reindexing","title":"Strings File Key Reindexing","text":"<p>Mutagen does not retain strings file key indexes compared to the original.  This is not important information to store and persist so that it matches the input.  As such, the source file needs to be reindexed so that it matches what Mutagen will output.  This just means making the key index start at 1 and increment for every string that was exported.</p>"},{"location":"Correctness/#other-minor-inconsistencies","title":"Other Minor Inconsistencies","text":"<p>There are a few other cases of inconsistencies that need to be aligned, similar to the ones above.</p>"},{"location":"Correctness/#running","title":"Running","text":"<p>Once a preprocessed file that has been trimmed, aligned, and decompressed is ready, then the actual passthrough will be done.  Mutagen will import the original (unprocessed) file, and re-export it.  The result will be compared to the pre-processed file which then should match byte to byte.  If there is even one byte differing, the passthrough fails, and either Mutagen's code must be fixed, or if it was just a non-important inconsistency as described above, the passthrough systems will be adjusted to compensate.</p>"},{"location":"Correctness/#helper-ui","title":"Helper UI","text":"<p>There is an internal helper UI to to facilitate selecting which tests to run, as well as digesting the parallel output that results.</p> <p></p> <p></p>"},{"location":"Correctness/#more-references","title":"More References","text":"<p>More documentation to come, but in the meantime, there is some testing information in this video about Record Generation.</p>"},{"location":"Json/","title":"Json","text":""},{"location":"Json/#json","title":"Json","text":"<p>Currently, the libraries that Mutagen offers related to Json targets <code>Newtonsoft.Json</code>.  Alternatives can be added for <code>System.Text.Json</code> if there's demand.</p>"},{"location":"Json/#json-converters","title":"Json Converters","text":"<p>There are some built in converters to allow for FormKeys/FormLinks/ModKeys to be included in a Json DTO.</p> <p></p><pre><code>public class MyDto\n{\n    public FormKey MyFormKey { get; set; }\n    public IFormLinkGetter&lt;IArmorGetter&gt; MyArmorLink { get; set; } = FormLink&lt;IArmorGetter&gt;.Null;\n    public IFormLinkIdentifier MyRuntimeLink { get; set; } = FormLink&lt;IMajorRecordGetter&gt;.Null;\n    public ModKey MyModKey { get; set; }\n}\n\n// ..\n\nvar settings = new JsonSerializerSettings();\n// Convenience function to add all converters\nsettings.AddMutagenConverters();\n\nvar someDto = new MyDto()\n{\n    MyFormKey = FormKey.Factory(\"123456:MyMod.esp\"),\n    MyArmorLink = FormKey.Factory(\"000123:MyMod.esp\").ToLink&lt;IArmorGetter&gt;(),\n    MyRuntimeLink = new FormLinkInformation(FormKey.Factory(\"000456:MyMod.esp\"), typeof(IWeaponGetter)),\n    MyModKey = \"MyMod.esp\",\n};\n\nvar str = JsonConvert.SerializeObject(someDto);\nConsole.WriteLine(str);\n</code></pre> Prints <pre><code>{\n  \"MyFormKey\": \"123456:MyMod.esp\",\n  \"MyArmorLink\": \"000123:MyMod.esp\",\n  \"MyRuntimeLink\": \"000456:MyMod.esp&lt;Skyrim.Weapon&gt;\",\n  \"MyModKey \": \"MyMod.esp\"\n}\n</code></pre><p></p>"},{"location":"Strings/","title":"Strings","text":""},{"location":"Strings/#strings-files","title":"Strings Files","text":"<p>Newer Bethesda titles come with the ability for a single string record to have multiple different translations in different languages.  </p> <p>If a strings flag in the mod is turned on, then seprate <code>.strings</code> files are included as part of the mod \"package\".  This file contains an index to string mapping to alternate translations for a language.  On the mod file binary side, string record contents are replaced with an index that can be used to lookup a value in the strings files for the language desired.  </p> <p>This section deals with how Mutagen itself interacts with Strings file concepts. You can read more about strings file structures on more generic modding documentation websites.</p>"},{"location":"Strings/#within-generated-classes","title":"Within Generated Classes","text":"<p>Within its generated classes, Mutagen exposes members of type <code>TranslatedString</code>.  This class provides the embedded language as a direct string, but also acts like a dictionary when localization is enabled and there are multiple potential languages.</p> <p><code>TranslatedString</code> queries and loads data in a lazy fashion.  Strings files for any given language will not be loaded until they are asked for.   Loose strings file located for per language will be used if present, otherwise BSAs will be searched for the applicable strings language file. </p> <p>All operations are threadsafe for <code>TranslatedString</code>.</p>"},{"location":"Strings/#simple-string-access","title":"Simple String Access","text":"<p>If a mod is not localized, then strings are embedded.  You can easily get access to this string.</p> <pre><code>Npc npc = ...;\n\nSystem.Console.WriteLine($\"Name: {npc.Name}\");\nnpc.Name = \"New Name\";\n</code></pre>"},{"location":"Strings/#default-language","title":"Default Language","text":"<p>When localization is turned on, then the simple string accesses the \"default language\", which is English, normally.   You can set the default language via a static field: </p><pre><code>Npc npc = ...;\n\nTranslatedString.DefaultLanguage = Language.French;\n\nSystem.Console.WriteLine($\"French name: {npc.Name}\");\nnpc.Name = \"Lutin\";\n</code></pre><p></p> <p>Future Expansion</p> <p>The route for setting the default language may change in the future to be less static, so use with caution.</p>"},{"location":"Strings/#multi-language-support","title":"Multi-Language Support","text":"<p><code>TranslatedString</code> also acts as a language dictionary when localization is turned on, allowing access to all the alternate strings for each language. </p><pre><code>Npc npc = ...;\n\nif (npc.Name.TryLookup(Language.French, out var frenchString))\n{\n    System.Console.WriteLine($\"French name: {frenchString}\");\n}\n\nnpc.Name.Set(Language.French, \"Lutin\");\n</code></pre><p></p>"},{"location":"Strings/#direct-strings-file-access","title":"Direct Strings File Access","text":"<p>Mutagen has API for interacting with strings files and folders directly.</p>"},{"location":"Strings/#reading-single-strings-file","title":"Reading Single Strings File","text":"<p>This class lightly wraps the data from a single strings file, indexing the available string keys but doing no parsing on the strings themselves.  The raw string byte data is cached internally for easy random access.  Strings are parsed from the raw data on lookup, and the results not cached. All operations on <code>StringsLookupOverlay</code> are threadsafe.</p> <pre><code>uint key = 1234;\n\nvar stringsOverlay = new StringsLookupOverlay(pathToStringsFile);\nif (stringsOverlay.TryLookup(key, out var containedString))\n{\n    System.Console.WriteLine($\"{pathToStringsFile} contained {key}: {containedString}\");\n}\n</code></pre>"},{"location":"Strings/#reading-strings-folder","title":"Reading Strings Folder","text":"<p>This class overlays on top an entire data folder, allowing lazy access to all strings files within, both loose and inside BSA files.  Internal StringLookupOverlays will be created and cached when required to serve a query.  Loose strings files for a query will have priority, followed by the first applicable strings files found in the BSAs.  All operations on <code>StringsFolderLookupOverlay</code> are threadsafe.</p> <pre><code>ModKey modKey = ...;\nuint key = 1234;\nLanguage language = Language.English;\nStringsSource source = StringsSource.DL;\n\nvar stringsFolderOverlay = StringsFolderLookupOverlay.TypicalFactory(pathToDataFolder);\nif (stringsFolderOverlay.TryLookup(source, language, modKey, key, out var containedString))\n{\n    System.Console.WriteLine($\"{source} {language} contained {key}: {containedString}\");\n}\n</code></pre>"},{"location":"Strings/#writing-a-strings-file","title":"Writing a Strings File","text":"<p>A class for exporting strings of various languages into the appropriate strings files.  This currently only supports export into Loose Files, not into a packed BSA.  A <code>StringsWriter</code> can be loaded with strings, and then exports to disk when disposed. </p><pre><code>ModKey modKey = ...;\nStringsSource source = StringsSource.DL;\nTranslatedString myStr = new TranslatedString();\nmyStr.String = \"Goblin\";\nmyStr.Set(Language.French, \"Lutin\");\n\nusing (var stringsWriter = new StringsWriter(modKey, pathToStringsFolder))\n{\n    uint key = stringsWriter.Register(myStr, source);\n    System.Console.WriteLine($\"{myStr} was registered into the strings files for {source} under key: {key}.\");\n}\n</code></pre><p></p>"},{"location":"Strings/#exporting-mods-with-localization","title":"Exporting Mods with Localization","text":"<p>When exporting a mod, you can control whether strings are localized (written to separate <code>.strings</code> files) or embedded directly in the mod file.</p>"},{"location":"Strings/#localization-flag","title":"Localization Flag","text":"<p>The localization behavior is controlled by the <code>Localization</code> flag in the mod header: </p><pre><code>SkyrimMod mod = ...;\n\n// Enable localization - strings will be written to separate .strings files\nmod.ModHeader.Flags = mod.ModHeader.Flags.SetTo(SkyrimModHeader.HeaderFlag.Localized, true);\n\n// Disable localization - strings will be embedded in the mod file\nmod.ModHeader.Flags = mod.ModHeader.Flags.SetTo(SkyrimModHeader.HeaderFlag.Localized, false);\n</code></pre><p></p>"},{"location":"Strings/#localized-export-localization-on","title":"Localized Export (Localization On)","text":"<p>When the <code>Localized</code> flag is set, Mutagen will: - Write each language to separate <code>.strings</code> files (e.g., <code>MyMod_English.STRINGS</code>, <code>MyMod_French.STRINGS</code>) - Replace string content in the mod file with numeric indices that reference the strings files - Export all languages that have been set on <code>TranslatedString</code> objects</p> <pre><code>SkyrimMod mod = ...;\nmod.ModHeader.Flags = mod.ModHeader.Flags.SetTo(SkyrimModHeader.HeaderFlag.Localized, true);\n\nNpc npc = mod.Npcs.AddNew();\nnpc.Name = new TranslatedString(\"Goblin\");\nnpc.Name.Set(Language.French, \"Lutin\");\nnpc.Name.Set(Language.Spanish, \"Duende\");\n\nawait mod.BeginWrite\n    .ToPath(modPath)\n    .WithDefaultLoadOrder()\n    .WriteAsync();\n\n// This will create separate strings files:\n// - MyMod_English.STRINGS (contains \"Goblin\")\n// - MyMod_French.STRINGS (contains \"Lutin\")\n// - MyMod_Spanish.STRINGS (contains \"Duende\")\n</code></pre>"},{"location":"Strings/#embedded-export-localization-off","title":"Embedded Export (Localization Off)","text":"<p>When the <code>Localized</code> flag is not set, Mutagen will: - Embed the default language's string values directly in the mod file - Not generate any <code>.strings</code> files - Ignore all non-default language translations</p> <pre><code>SkyrimMod mod = ...;\nmod.ModHeader.Flags = mod.ModHeader.Flags.SetTo(SkyrimModHeader.HeaderFlag.Localized, false);\n\nNpc npc = mod.Npcs.AddNew();\nnpc.Name = new TranslatedString(\"Goblin\");\nnpc.Name.Set(Language.French, \"Lutin\");  // This will be ignored during export\n\nawait mod.BeginWrite\n    .ToPath(modPath)\n    .WithDefaultLoadOrder()\n    .WriteAsync();\n\n// The mod file will contain \"Goblin\" embedded directly\n// French translation will not be exported\n</code></pre>"},{"location":"Strings/#setting-target-language-for-embedded-export","title":"Setting Target Language for Embedded Export","text":"<p>When exporting with localization disabled, you can specify which language should be used as the embedded value: </p><pre><code>await mod.BeginWrite\n    .ToPath(modPath)\n    .WithDefaultLoadOrder()\n    .WithTargetLanguage(Language.French)\n    .WriteAsync();\n\n// This will embed the French translation values instead of the default language\n</code></pre><p></p>"},{"location":"Strings/#custom-stringswriter","title":"Custom StringsWriter","text":"<p>For advanced scenarios, you can provide a custom <code>StringsWriter</code> to control the strings export process: </p><pre><code>using var stringsWriter = new StringsWriter(mod.ModKey, stringsOutputFolder);\n\nawait mod.BeginWrite\n    .ToPath(modPath)\n    .WithDefaultLoadOrder()\n    .WithStringsWriter(stringsWriter)\n    .WriteAsync();\n</code></pre><p></p>"},{"location":"best-practices/Accessing-Known-Records/","title":"Accessing Known Records","text":""},{"location":"best-practices/Accessing-Known-Records/#accessing-known-records","title":"Accessing Known Records","text":""},{"location":"best-practices/Accessing-Known-Records/#recommended-patterns","title":"Recommended Patterns","text":"<p>Often, especially for base master files like <code>Skyrim.esm</code>, there are specific records that you want to look up.</p> <p>The recommended strategy is to use the FormKeys library, which lets you refer to records by EditorID, while still using FormKeys under the hood: </p><pre><code>var env = ...; // Some environment, like Synthesis, or Mutagen's GameEnvironment\n\nif (Skyrim.Race.ArgonianRace.TryResolve(env.LinkCache, out var race))\n{\n    Console.WriteLine($\"Found the race record\");\n}\n</code></pre><p></p> <p>The following sections will outline the alternatives and reasoning for the recommended best practices.</p>"},{"location":"best-practices/Accessing-Known-Records/#desire-to-access-known-records","title":"Desire To Access Known Records","text":""},{"location":"best-practices/Accessing-Known-Records/#by-formkey","title":"By FormKey","text":"<p>For example, if you wanted to look up the Argonian Race record, you might do the following: </p><pre><code>var env = ...; // Some environment, like Synthesis, or Mutagen's GameEnvironment\n\nvar formKey = FormKey.Factory(\"123456:Skyrim.esm\");\n\nif (env.LinkCache.TryResolve&lt;IRaceGetter&gt;(formKey, out var race))\n{\n    Console.WriteLine($\"Found the race record\");\n}\n</code></pre><p></p> <p>First, a FormKey is created pointing to the known record for the Argonian race in Skyrim.esm.   Then the link cache is asked to resolve the winning override for the record.  This will retrieve the winning override.</p> <p>However, there's a few annoyances:</p> <ul> <li>Neither the dev nor future readers know the FormID for records offhand, and so must always look them up.</li> <li>The only indication that <code>123456</code> points to the argonian race is to look it up and check, or hope the variable is named something intelligent (like <code>argonianRaceFormKey</code>)</li> <li>Potential for typos.  What if it was actually <code>123457</code> and got mis-copied?</li> </ul>"},{"location":"best-practices/Accessing-Known-Records/#editorid","title":"EditorID","text":"<p>EditorIDs are a common alternative for looking up records, as they are human readable.</p> <pre><code>var env = ...; // Some environment, like Synthesis, or Mutagen's GameEnvironment\n\nif (env.LinkCache.TryResolve&lt;IRaceGetter&gt;(\"ArgonianRace\", out var race))\n{\n    Console.WriteLine($\"Found the race record\");\n}\n</code></pre> <p>However, they are not recommended for general use, for the reasons outlined here.</p>"},{"location":"best-practices/Accessing-Known-Records/#neither-is-ideal","title":"Neither is Ideal","text":"<p>Neither direct FormKeys or EditorIDs are ideal for looking up known records.  This is why the recommended pattern is to use the FormLinks library to bridge the gap and get the best of both worlds</p>"},{"location":"best-practices/Enrich-Exceptions/","title":"Enriching Exceptions","text":""},{"location":"best-practices/Enrich-Exceptions/#exception-enrichment","title":"Exception Enrichment","text":"<p>Mutagen's code is written in a lightweight way that means its exceptions are not fully filled out with all the extra information that might be interesting.   Often, an exception will just print the very specific field that failed, but not include other important details such as:</p> <ul> <li>FormKey of the record it was from</li> <li>ModKey of the mod it was from</li> </ul> <p>It is recommended that you wrap access code in a try/catch that enriches the exception with that extra information. </p>"},{"location":"best-practices/Enrich-Exceptions/#recordexception-enrichment","title":"RecordException Enrichment","text":"<p>This enriches an exception relative to a major record's information</p> <pre><code>foreach (var npc in state.LoadOrder.PriorityOrder.Npc().WinningOverrides())\n{\n    try\n    {\n        var overrideNpc = state.PatchMod.Npcs.GetOrAddAsOverride(npc);\n        overrideNpc.Height *= 1.3f;\n    }\n    catch (Exception e)\n    {\n        throw RecordException.Enrich(e, npc);\n    }\n}\n</code></pre> <p>This will make the exception include:</p> <ul> <li>EditorID</li> <li>RecordType (NPC_)</li> <li>FormKey</li> </ul>"},{"location":"best-practices/Enrich-Exceptions/#modkey-inclusion","title":"ModKey Inclusion","text":"<p>The above code will -NOT- include <code>ModKey</code>.  The ModKey that the record override originated from cannot be inferred automatically and so must be passed in.   The above call has a <code>modKey</code> parameter that you can pass this information to if you have it.</p> <p>More than likely, though, the best way to do this is to use ModContexts, which contain the information about what Mod the record originated from. </p><pre><code>foreach (var npcContext in state.LoadOrder.PriorityOrder.Npc().WinningContextOverrides())\n{\n    try\n    {\n        var overrideNpc = npcContext.GetOrAddAsOverride(state.PatchMod);\n        overrideNpc.Height *= 1.3f;\n    }\n    catch (Exception e)\n    {\n        throw RecordException.Enrich(e, npcContext);\n    }\n}\n</code></pre><p></p>"},{"location":"best-practices/Enrich-Exceptions/#subrecord-exception","title":"Subrecord Exception","text":"<p>This is an even more specialized version of RecordException that also includes the Subrecord type.  Typically this is just used by the Mutagen engine itself, and not applicable to user code.</p>"},{"location":"best-practices/Enumerable-Laziness/","title":"Enumerable Laziness","text":""},{"location":"best-practices/Enumerable-Laziness/#enumerable-laziness","title":"Enumerable Laziness","text":""},{"location":"best-practices/Enumerable-Laziness/#setup","title":"Setup","text":"<p>One common pitfall related to Enumerable/LINQ usage.  Take this basic Synthesis patcher example: </p><pre><code>var weaponsWithDamageMoreThanTen = \n    // Loop over all winning override weapons in the load order\n    state.LoadOrder.PriorityOrder.Weapon().WinningOverrides()\n    // Only want ones with damage above 10\n    .Where(x =&gt;\n    {\n        if (x.BasicStats == null) return false;\n        return x.BasicStats.Damage &gt; 10;\n    });\n\n// Print!\nConsole.WriteLine(\"Weapons with damage more than 10:\");\nforeach (var weaponGetter in weaponsWithDamageMoreThanTen)\n{\n    Console.WriteLine(weaponGetter.ToString());\n}\n</code></pre> This works as expected, printing lots of weapons to the console.<p></p>"},{"location":"best-practices/Enumerable-Laziness/#problem","title":"Problem","text":""},{"location":"best-practices/Enumerable-Laziness/#whats-the-problem","title":"What's the problem?","text":"<p>The variable <code>weaponsWithDamageMoreThanTen</code> is a deferred Linq statement.  Sometimes can also be called a \"naked\" or \"lazy\" Linq statement.</p>"},{"location":"best-practices/Enumerable-Laziness/#what-does-this-mean","title":"What does this mean?","text":"<p>This means <code>weaponsWithDamageMoreThanTen</code> does not contain all the weapons with damage more than 10.  Rather, it is instructions for HOW to iterate the load order to get weapons with damage more than 10.</p> <p>It is a set of instructions, not the actual data itself.</p>"},{"location":"best-practices/Enumerable-Laziness/#why-does-this-matter","title":"Why does this matter?","text":"<p>It matters because multiple usages of these instructions means multiple executions of the instructions to get the results.</p> <p>Consider this: </p><pre><code>// Print!  One usage\nConsole.WriteLine(\"Weapons with damage more than 10:\");\nforeach (var weaponGetter in weaponsWithDamageMoreThanTen)\n{\n    Console.WriteLine(weaponGetter.ToString());\n}\n\n// Do some work and add to the outgoing patch.  Two usage\nforeach (var weaponGetter in weaponsWithDamageMoreThanTen)\n{\n    // Put in outgoing patch\n    var weapon = state.PatchMod.Weapons.GetOrAddAsOverride(weaponGetter);\n    // Cut the damage in half\n    weapon.BasicStats!.Damage /= 2;\n}\n</code></pre><p></p> <p>This will work and produce results.  However, it will take 2x the time as it could.</p> <p>The print logic will execute the instructions provided by <code>weaponsWithDamageMoreThanTen</code>.  It will go to disk, read the Weapon GRUP data, parse the GRUP data into hundreds of Weapon records, iterate all those objects through your 10 damage filter, and then print to the console.</p> <p>The 2nd loop will then run.  It will go to disk, read the Weapon GRUP data, parse the GRUP data into hundreds of Weapon records, iterate all those objects through your 10 damage filter, and then add half the damage and put it into the outgoing patch.</p> <p>Notice this logic read from the disk and parsed the weapons TWICE.  This is because <code>weaponsWithDamageMoreThanTen</code> contains instructions for HOW to retrieve the weapons.  So each usage of those instructions DOES that work again.</p> <p>This concept where each usage does the work again can get catastrophically slow depending on what you're doing.</p>"},{"location":"best-practices/Enumerable-Laziness/#solution","title":"Solution","text":"<p>Linq is powerful and useful, but with power comes responsibility. </p>"},{"location":"best-practices/Enumerable-Laziness/#small-metaphor","title":"Small Metaphor","text":"<p>A naked Linq statement is like a set of instructions.</p> <p>Which would be more efficient?</p> <p><code>Using instructions for how to make an airplane, and using them to construct a new airplane for every flight.</code></p> <p>Or </p> <p><code>Using instructions for how to make an airplane once ahead of time, and reusing that airplane for many flights.</code></p> <p>Obviously making one airplane and reusing it is the better option.</p> <p>Having instructions for how to make an airplane isn't a bad thing to have, but choosing when to execute those instructions is important.</p>"},{"location":"best-practices/Enumerable-Laziness/#the-fix","title":"The Fix","text":"<p>The fix is just to execute those instructions ahead of time once, so that downstream usages don't rerun the logic each time.  This can be done very simply: </p><pre><code>var weaponsWithDamageMoreThanTen = \n    // Loop over all winning override weapons in the load order\n    state.LoadOrder.PriorityOrder.Weapon().WinningOverrides()\n    // Only want ones with damage above 10\n    .Where(x =&gt;\n    {\n        if (x.BasicStats == null) return false;\n        return x.BasicStats.Damage &gt; 10;\n    })\n    // Tell the above instructions to run immediately\n    // and put themselves into an array\n    .ToArray();\n</code></pre><p></p> <p>That's it.  Now all the usages downstream will loop over the contents of the array, rather than rerunning the instructions for themselves.</p> <p>This is the equivalent of using the airplane instructions once to make a plane, and now it can be reused by everyone downstream.</p>"},{"location":"best-practices/Enumerable-Laziness/#why-is-linq-deferredlazy","title":"Why is Linq Deferred/Lazy?","text":"<p>It is important to understand why Linq statements are lazy in the first place?  Why have this dangerous behavior at all?</p> <p>The laziness of a Linq enumerable is actually very powerful, as it allows us to short circuit work that is not needed.</p> <p>Consider this: </p><pre><code>var npcs = state.LoadOrder.PriorityOrder.Npc().WinningOverrides();\n\nforeach (var npc in npcs)\n{\n    if (npc.Name.Contains(\"Goblin\"))\n    {\n        Console.WriteLine(\"Our game has a Goblin\");\n        break;\n    }\n}\n</code></pre><p></p> <p>This logic will parse Npc records on disk until it finds a Goblin.  It will then print and stop working.</p> <p>The laziness of the Linq statement means that we only execute the instructions UNTIL we find a goblin.  If the first Npc record we saw was a Goblin, the program will have only parsed one Npc record.  This would be VERY fast, then.</p> <p>Compare to this: </p><pre><code>var npcs = state.LoadOrder.PriorityOrder.Npc().WinningOverrides()\n    .ToArray();\n\nforeach (var npc in npcs)\n{\n    if (npc.Name.Contains(\"Goblin\"))\n    {\n        Console.WriteLine(\"Our game has a Goblin\");\n        break;\n    }\n}\n</code></pre> We've added that ToArray() to turn the instructions into their results up front, storing them in an array.  In this case, this is NOT what we want.<p></p> <p>Now, if the Goblin was the first Npc record we found, we will still parse ALL Npcs in the game: 1)  Set up instructions for how to find npcs 2)  Do instructions once, putting all npcs into an array 3)  Loop over array, stopping once we find a goblin.</p> <p>Notice that the work was done ahead of time, so we couldn't short circuit the work early if we found what we wanted.  We will do ALL the work every time, even if we're tossing 99% of the results into the trash.</p>"},{"location":"best-practices/Enumerable-Laziness/#conclusion","title":"Conclusion","text":"<p>The laziness of Linq statements is a powerful tool, but it is very dangerous if misused, and so must be understood.</p> <p>If a Linq statement is going to be reused, consider calling a <code>ToArray</code> to do the work once ahead of time.</p> <p>If the Linq statement only has one user, it's better to leave as a Deferred Linq statement, so that that one user can choose to stop processing early.</p> <p>If you're unsure, it is usually better to use the <code>ToArray</code>.  Doing unnecessary work once is a better gamble than potentially doing the same work 1000x.</p>"},{"location":"best-practices/FormLink-Nullability/","title":"FormLink Nullability","text":""},{"location":"best-practices/FormLink-Nullability/#formlink-nullability","title":"FormLink Nullability","text":""},{"location":"best-practices/FormLink-Nullability/#checking-if-formlink-is-null","title":"Checking if FormLink is Null","text":"<p>FormIDs can all point to \"no\" record by containing all zeros.  This is referred to as being null.</p> <p>However, this is NOT the same as being a null object in C#.  FormLink members on Mutagen objects are never themselves null objects.</p> <p>Improper FormLink Null Checks</p> <p></p><pre><code>if (npc.Race == null) { ... }\nif (npc.Race != null) { ... }\nif (npc.Race is null) { ... }\nif (npc.Race is not null) { ... }\n</code></pre> IDEs will warn that these expressions will \"always be true/false\".  This is because the FormLink member itself is never null, so this check is not really checking anything.<p></p> <p>This is proper API for many other members that are nullable fields.  But FormLink fields are not marked as nullable, in the C# language null object sense.</p> <p>Proper FormLink Null Checks</p> <p></p><pre><code>if (!npc.Race.IsNull) { ... }\nif (npc.Race.IsNull) { ... }\n</code></pre> This is calling a member ON FormLink called <code>IsNull</code>, which checks many various ways that a FormID can be null.  <p></p>"},{"location":"best-practices/FormLink-Nullability/#formlink-vs-formlinknullable","title":"FormLink vs FormLinkNullable","text":"<p>FormLinks are used widely as a strongly typed identifier of a record, as an alternative to FormID, EditorID, or even FormKey.</p> <p>When using them, though, there are two variants:</p> <ul> <li><code>FormLink</code></li> <li><code>FormLinkNullable</code></li> </ul>"},{"location":"best-practices/FormLink-Nullability/#which-you-should-use","title":"Which You Should Use","text":"<p>Generally, the answer is you should always use <code>FormLink</code>, rather than <code>FormLinkNullable</code>.</p> <p>Mutagen exposes <code>FormLinkNullable</code> in certain areas, but you yourself should rarely if ever decide to create a <code>FormLinkNullable</code> when writing your own code.</p>"},{"location":"best-practices/FormLink-Nullability/#what-is-formlinknullable","title":"What is FormLinkNullable","text":"<p>If you shouldn't use it, what is <code>FormLinkNullable</code> for?</p> <p>It is used by Mutagen itself to expose a very specific difference in how FormIDs can be null within a binary file on the disk.</p> <p>A FormLinkNullable can be null in two ways:</p> <p>An example of this is in Skyrim Npc's Worn Armor.   It is a <code>FormID</code> in the subrecord <code>WNAM</code>, which points to an Armor an Npc wears. Consider how this Worn Armor can be null:</p> <ul> <li><code>WNAM</code>'s value can be 0</li> <li>WNAM can be missing entirely</li> </ul> <p>And how a <code>FormLinkNullable</code>'s <code>FormKey</code> will be exposed in those differing scenarios:</p> <ul> <li>When <code>WNAM</code>s value is 0, <code>FormKey</code> will not be null, and will contain a zero ID</li> <li>When <code>WNAM</code> is missing entirely, <code>FormKey</code> member will be null</li> </ul> <p>This difference lets you detect the various ways a FormID can be null on disk.  This subtle difference is not normally important, which is why FormLink itself has an <code>IsNull</code> member, which checks for both cases, and is preferable way to check for whether a FormID is null.</p> <p>For your own code, you should -not- use <code>FormLinkNullable</code>, as the above differences are not applicable for most program logic that is not interacting with an on-disk representation directly.</p>"},{"location":"best-practices/FormLinks-Target-Getter-Interfaces/","title":"FormLinks Target Getter Interfaces","text":""},{"location":"best-practices/FormLinks-Target-Getter-Interfaces/#formlinks-target-getter-interfaces","title":"FormLinks Target Getter Interfaces","text":"<p><code>FormLinks</code> are <code>FormKeys</code> with typing information mixed in as to which record type they should associate with.  As such, they require you specify the typing you want to target. </p> <p> Scoping</p> <p>Take for example that you just wanted to target Npcs, there are still a few options:</p> <ul> <li><code>Npc</code> -&gt; The direct class</li> <li><code>INpc</code> -&gt; The setter interface</li> <li><code>INpcGetter</code> -&gt; The readonly interface</li> </ul> <p>The correct usage (99% of the time) is to always use the <code>INpcGetter</code> readonly interface.</p> <p><code>IFormLinkGetter&lt;INpcGetter&gt;</code></p> <p>Or more rarely the mutable version:</p> <p><code>FormLink&lt;INpcGetter&gt;</code></p> <p>In both, the generic is targeting the getter interface <code>INpcGetter</code>, which is the important part.</p> <p>Use Setters With Caution</p> <p>There are very limited and intentional scenarios where having a FormLink target a mutable type is desirable, but for the most part it's a pitfall trap for new users.</p>"},{"location":"best-practices/FormLinks-Target-Getter-Interfaces/#complication","title":"Complication","text":"<p>Consider a LinkCache Resolve.  A FormLink and a LinkCache are combined to look up a record with a specific FormKey and Type.  </p> <p> Resolves</p> <p>You are allowed to use any record type in a resolve query, but using a non-getter interface is often less ideal.  This is because it limits the scope that the LinkCache can match against.  This can result in a confusing failure to match where it might find the Npc with the target FormKey, but not be able to satisfy the more restrictive type. </p><pre><code>IFormLinkGetter&lt;INpc&gt; myTargetNpc = ...;\nif (myTargetNpc.TryResolve(myLinkCache, out var npc))\n{\n   // Found a INpc!\n}\n</code></pre> The <code>TryResolve</code> call wants to return an <code>INpc</code> type to you.  But if all it can find is a readonly <code>INpcGetter</code>, it cannot pretend that it's settable, and so fails to match.  This is the result of you asking the system to find an Npc that is settable, when the ones that exist are only getters.<p></p> <p>You can solve this issue by modifying the TryResolve scope: </p><pre><code>IFormLinkGetter&lt;INpc&gt; myTargetNpc = ...;\nif (myTargetNpc.TryResolve&lt;INpcGetter&gt;(myLinkCache, out var npc))\n{\n   // Found a INpcGetter!\n}\n</code></pre> But it's preferable to have just had the FormLink type target getters in the first place.<p></p>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/","title":"FormLinks vs EditorID as Identifiers","text":""},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#formlinks-vs-editorid-as-identifiers","title":"FormLinks vs EditorID as Identifiers","text":""},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#editorid-vs-formlink","title":"EditorID vs FormLink","text":"<p>When choosing how you want to look up records, or store lists of record identifiers, there's the common choice between EditorIDs and FormLinks. </p> <p>For example, let's say you want to look up Skyrim's <code>ArmorImperialCuriass</code> <code>0136D5:Skyrim.esm</code>.</p> <p>You can either do it via EditorID: </p><pre><code>// EditorIDs are strings\nstring editorId = \"ArmorImperialCuriass\";\n// Look up via EditorID in the cache\nvar foundArmorRecord = myLinkCache.Resolve&lt;IArmorGetter&gt;(editorId);\n</code></pre> or by FormLink: <pre><code>// FormLinks contain type and a FormID\nIFormLinkGetter&lt;IArmorGetter&gt; link = FormKey.Factory(\"0136D5:Skyrim.esm\");\n// Can alternatively use the FormKeys library to avoid typing the ID by hand\nlink = Skyrim.Armor.ArmorImperialCuirass;\n// Look up the FormLink against the cache\nvar foundArmorRecord = link.Resolve(myLinkCache);\n</code></pre><p></p> <p>Similarly, you can store containers of identifiers via EditorID: </p><pre><code>var armors = new HashSet&lt;string&gt;();\narmors.Add(\"ArmorImperialCuriass\");\n</code></pre> or by FormLink: <pre><code>var armors = new HashSet&lt;IFormLinkGetter&lt;IArmorGetter&gt;&gt;();\narmors.Add(Skyrim.Armor.ArmorImperialCuirass);\n</code></pre><p></p> <p>What are the reasons for choosing one over the other?  Generally FormLinks are the recommended route.  This article will go over the differences and reasons why.</p>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#editorid-upsides","title":"EditorID Upsides","text":""},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#readability-and-formlink-mapping","title":"Readability and FormLink Mapping","text":""},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#editorids-are-more-readable","title":"EditorIDs are More Readable","text":"<p>We're going to start out with the one upside that EditorIDs have: readability.</p> <p><code>ArmorImperialCuriass</code> is much more human readable and understandable compared to <code>0136D5:Skyrim.esm</code>.</p> <p>Generally, this is the reason people initially gravitate towards EditorIDs, as lots of other tooling uses EditorIDs as they are more human friendly.</p>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#formlink-mapping-brings-readability-to-formlink-based-systems","title":"FormLink Mapping Brings Readability to FormLink-Based Systems","text":"<p>Work has been done to mitigate this readability downside of FormLinks.  FormLink Mapping is a system where you can point to a mod and generate mappings so that you can reference and use FormLinks by their EditorID name.</p> <p>This allows for the best of both worlds, where the code is human readable by writing EditorIDs, while still using FormLinks under the hood for the code to use.  These systems mostly nullify the readability problem that FormKeys have.</p> <pre><code>// Left hand side is a FormLink, but right hand side is written and readable like an EditorID\nIFormLinkGetter&lt;IArmorGetter&gt; myFormLink = Skyrim.Armor.ArmorImperialCuriass;\n</code></pre>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#editorid-downsides","title":"EditorID Downsides","text":"<p>As far as code is concerned, it is much more preferable to deal with FormLinks.  Here are some reasons EditorIDs can cause some problems.</p>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#overriding-mods-can-ruin-lookups","title":"Overriding Mods Can Ruin Lookups","text":"<p>Let's say you're looking for the Armor in question <code>ArmorImperialCuirass</code>.  You can look it up by EditorID: </p><pre><code>// Looking up to find a winning Armor override with EditorID \nvar foundArmorRecord = linkCache.Resolve&lt;IArmorGetter&gt;(\"ArmorImperialCuirass\");\n</code></pre> or check if it's in a set: <pre><code>myEditorIdSet.Add(\"ArmorImperialCuirass\");\n// Checking to see if a given record is within the set, by EditorID\nmyEditorIdSet.Contains(potentialMatchingArmorRecord.EditorID);\n</code></pre><p></p> <p>Both of these operations are fragile.  You're looking up a record by its EditorID, which is a field that mods are able to override and change.  It's not often recommended for mods to do so, but they do it.  So if ModA.esp decided to change <code>ArmorImperialCuriass</code> to <code>ImperialCuriass</code>, for whatever reason, then your check will fail to find the record.</p> <p>EditorID is mutable and inconsistent.  In contrast, a FormLink/FormKey/FormID is a constant immutable aspect of a record, and so lookups via FormLink will never fail, no matter what mods change what values: </p><pre><code>// Looking up to find a winning Armor override with the given FormID\nvar foundArmorRecord = myArmorLink.Resolve(linkCache);\n\nmyFormLinkSet.Add(Skyrim.Armor.ArmorImperialCuirass);\n// Checking to see if a given record is within the set, by FormID\nmyFormLinkSet.Contains(potentialMatchingArmorRecord);\n</code></pre> These will consistently connect with the record you're looking for no matter what mods have done to them.<p></p>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#type-info-is-lost-potentially-losing-speed","title":"Type Info Is Lost, Potentially Losing Speed","text":"<p>Mutagen gets a lot of its speed by short circuiting work that is unnecessary.  One of the ways it does this is by making use of the Type of record involved.  For example, if you tell the LinkCache it is an Armor you're looking for, then it can skip parsing 99% of <code>Skyrim.esm</code>.</p> <p>EditorIDs are just strings, and so have no type information.  So when looking up a record via EditorID, you ideally want to specify the type involved: </p><pre><code>// Specifying IArmorGetter speeds up the lookup\nvar foundArmorRecord = linkCache.Resolve&lt;IArmorGetter&gt;(\"ArmorImperialCuirass\");\n\n// Forgetting to specify type leads to parsing the entire mod's contents:\nvar foundArmorRecord = linkCache.Resolve(\"ArmorImperialCuirass\");\n</code></pre><p></p> <p>FormLinks have type info built into their structure.  They are an ID + a Type.  As such, you do not need to remember to specify the type: </p><pre><code>// No need to specify type, as the FormLink we're Resolving knows its type: Armor\nvar foundArmorRecord = Skyrim.Armor.ArmorImperialCuirass.Resolve(linkCache);\n</code></pre><p></p>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#requires-decompression-losing-speed","title":"Requires Decompression, Losing Speed","text":"<p>This is due to a gritty implementation detail of how records are stored on disk.  A record's header is never compressed, while all the contents can be.  An EditorID is content that gets compressed.</p> <p>FormIDs are always in the same known location in the record header and never compressed.   So, when looking up records, a FormLink can simply look at a record to see if its a match at near instant speed.</p> <p>EditorID lookups, on the other hand, require the entire record's contents to be decompressed before it can begin looking for the EDID record to parse the string needed to see if the record is a match.</p> <p>So, by using EditorIDs as your lookup identifier, you're implicitly losing a good deal of speed by requiring the systems to do a bunch of potentially unnecessary work parsing a record you're not even interested in.</p>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#some-records-cannot-be-looked-up","title":"Some Records Cannot Be Looked Up","text":"<p>EditorIDs are not actually required.  Most of the common records people are interested in have them, but there are plenty of records that do not. </p> <p>This is more applicable for set building.  If you're compiling a <code>HashSet&lt;string&gt;</code> of EditorIDs of all records that satisfy XYZ, then some records might not be able to be put into the set. </p> <p>FormIDs are fundamental required data for a record to exist, and so are ensured to always be viable.</p>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#specialized-ui-input-systems","title":"Specialized UI Input Systems","text":"<p>The Mutagen ecosystem comes with specialized UI record pickers:</p> <p></p> <p>These allow users to search for records easily, and when a record is chosen, the FormLink in question is passed to the code.</p> <p>The system is not currently set up to bind to EditorIDs in the code backend.  As such, you'd likely have to instead use a list of raw strings.</p> <p>Theoretically the work could be done to expose it in a similar UI, but it has not been done because EditorIDs are generally less preferable to use for all the other reasons mentioned.</p>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#typos","title":"Typos","text":""},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#you-can-make-typos","title":"You Can Make Typos","text":"<p>EditorIDs are just raw strings, and so are vulnerable to typos: </p><pre><code>// Will never resolve, as we've misspelled Imperial\n// Compiler cannot give you a heads up, as it's just a raw string\nvar foundArmorRecord = linkCache.Resolve&lt;IArmorGetter&gt;(\"ArmorImprialCuirass\");\n</code></pre><p></p> <p>FormLinks would be vulnerable as well when typing in their ID, except when you're using the FormLink map systems: </p> <p>As a bonus, the IDE intellisense can suggest EditorIDs for you and autocomplete:</p> <p></p>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#your-users-can-make-typos","title":"Your Users Can Make Typos","text":"<p>Users will also have to deal with typos.  With EditorID based input, you're typically going to be exposing these via a list of strings on a UI or in a json file.  As they type in their desired records, they will be very vulnerable to making typos.  It's highly likely they don't realize and might complain to you the developer that your program is broken.  </p>"},{"location":"best-practices/FormLinks-vs-EditorID-as-Identifiers/#string-comparisons-are-slower-than-int-comparisons","title":"String Comparisons Are Slower than Int Comparisons","text":"<p>I put this last, as it's a factor, but is minor compared to the other issues.  Comparing a long string of an EditorID like \"ArmorImprialCuirass\" is slower than comparing FormLinks which use integers for comparison.   As such, there will be a slight speed penalty.  Nothing to worry about too much, but just another small negative to add to the pile.</p>"},{"location":"best-practices/ITPO-Avoidance/","title":"ITPO Avoidance","text":""},{"location":"best-practices/ITPO-Avoidance/#itpo-avoidance","title":"ITPO Avoidance","text":""},{"location":"best-practices/ITPO-Avoidance/#what-is-an-itpo","title":"What is an ITPO","text":"<p>A very typical thing that can happen during processing mods is exporting a record that doesn't have any changes compared to the original.  This is known as an ITPO (Identical to Previous Override), or sometimes ITM (Idential to Master).</p> <p>For example, this code can make some ITPOs: </p><pre><code>foreach (var weapon in loadOrder.PriorityOrder.Weapon().WinningOverrides())\n{\n   var weaponOverride = outgoingMod.Weapons.GetOrAddAsOverride(weapon);\n   weaponOverride.Weight = 0;\n}\n</code></pre> If a weapon already has a weight of zero, this will cause an ITPO, as nothing has changed.<p></p>"},{"location":"best-practices/ITPO-Avoidance/#avoiding-itpos","title":"Avoiding ITPOs","text":"<p>Typically, the best patterns avoid making ITPOs in the first place, rather than cleaning them up after they exist.</p> <p>Alternatively, we can adjust the logic to just never make an ITPO in the first place.  There are two general patterns for doing this.</p>"},{"location":"best-practices/ITPO-Avoidance/#late-getoraddasoverride","title":"Late GetOrAddAsOverride","text":"<pre><code>foreach (var weapon in loadOrder.PriorityOrder.Weapon().WinningOverrides())\n{\n   // If what we wanted to change is already as we want it, skip\n   if (weaponOverride.Weight == 0) continue;\n\n   var weaponOverride = outgoingMod.Weapons.GetOrAddAsOverride(weapon);\n   weaponOverride.Weight = 0;\n}\n</code></pre> As you can see, the call to <code>GetOrAddAsOverride</code> is delayed until we know there's a meaningful modification to do."},{"location":"best-practices/ITPO-Avoidance/#deepcopy-with-late-add","title":"DeepCopy With Late Add","text":"<pre><code>foreach (var weapon in loadOrder.PriorityOrder.Weapon().WinningOverrides())\n{\n   // Make a mutable copy, but don't add it to the mod yet\n   var weaponOverride = weapon.DeepCopy();\n\n   bool madeModification = false;\n\n   if (weaponOverride.Weight != 0)\n   {\n       weaponOverride.Weight = 0;\n       madeModification = true;\n   }\n\n   if (weaponOverride.Value != 100)\n   {\n       weaponOverride.Weight = 100;\n       madeModification = true;\n   }\n\n   // If we didn't do anything, skip\n   if (!madeModification) continue;\n\n   outgoingMod.Weapons.Set(weaponOverride);\n}\n</code></pre> <p>There are many ways to achieve the same goal.  The important takeaway is that code should first try to not make any ITPOs in the first place by only adding it to the outgoing mod once/if modifications have been made to the record.  Depending on the complexity of what you're doing, it may require different patterns than the ones outlined above.</p>"},{"location":"best-practices/ITPO-Avoidance/#late-itpo-removal","title":"Late ITPO Removal","text":"<p>While it's preferable to avoid making ITPOs in the first place, they theoretically can be removed after the fact.</p> <p>Mutagen may or may not get ITPO removal tooling in the future.  This would be powered by Equality/HashCode concepts, which already exist, but are not heavily tested for accuracy yet.  If/when ITPO removal calls do get implemented, it will mostly be for feature completeness, rather than necessity.</p>"},{"location":"best-practices/Mo2-Compatibility/","title":"Mo2 Compatibility","text":""},{"location":"best-practices/Mo2-Compatibility/#mod-organizer-2-compatibility","title":"Mod Organizer 2 Compatibility","text":"<p>This might be fixed at some point, but current versions of Mo2 don't play well with a new feature of DotNet 9 which is enabled by default.</p> <p>Fix so far has been to disable it by adding <code>&lt;CETCompat&gt;false&lt;/CETCompat&gt;</code> to the <code>.csproj</code> properties.</p>"},{"location":"best-practices/Modifying-Groups-Being-Iterated/","title":"Modifying Groups Being Iterated","text":""},{"location":"best-practices/Modifying-Groups-Being-Iterated/#modifying-groups-being-iterated","title":"Modifying Groups Being Iterated","text":""},{"location":"best-practices/Modifying-Groups-Being-Iterated/#looping-and-modifying-the-same-record-types","title":"Looping and Modifying the Same Record Types","text":"<p>Consider this: </p><pre><code>foreach (var lvln in state.LoadOrder.PriorityOrder.LeveledNpc().WinningOverrides())\n{\n    var lvlnCopy = lvln.DeepCopy();\n    lvlnCopy.EditorId += \"Copy\";\n    // Some modifications\n    state.PatchMod.LeveledNpcs.Set(lvlnCopy);\n}\n</code></pre> This code is dangerous, as it modifies the same record types it's inspecting.<p></p>"},{"location":"best-practices/Modifying-Groups-Being-Iterated/#modifying-a-collection-being-enumerated","title":"Modifying a Collection Being Enumerated","text":"<p>Consider this simpler code: </p><pre><code>var list = new List&lt;int&gt;();\nlist.Add(3);\nlist.Add(7);\nforeach (var item in list)\n{\n    // Exception on next loop\n    list.Add(item * 2);\n}\n</code></pre> This code will throw an exception.  <p></p> <p>It is because this loop is modifying the <code>list</code> it is looping. The first loop iteration it will see <code>item = 3</code>, and add <code>6</code> to the list.</p> <p>It will then try to loop to the next item, but C# will throw an exception  <code>System.InvalidOperationException: Collection was modified; enumeration operation may not execute.</code></p> <p>In C#, you are not allowed to modify a collection as it's being looped.</p>"},{"location":"best-practices/Modifying-Groups-Being-Iterated/#avoiding-the-exceptions","title":"Avoiding the Exceptions","text":"<p>There are two routes to avoiding the <code>Collection was modified</code> exception</p>"},{"location":"best-practices/Modifying-Groups-Being-Iterated/#create-a-temporary-collection","title":"Create a Temporary Collection","text":"<p>This can be as simple as: </p><pre><code>foreach (var item in list\n   // Now we're safe\n   .ToArray())\n{\n    list.Add(item * 2);\n}\n</code></pre> The reason this works is that the <code>ToArray</code> call eagerly copies all the items from <code>list</code> to a new array.  The <code>foreach</code> loop then loops over that array.  Then, when you add an item to the list, you're not actually modifying the same collection you are looping, and so it succeeds.<p></p>"},{"location":"best-practices/Modifying-Groups-Being-Iterated/#stop-looping-after-modification","title":"Stop looping after modification","text":"<p>Sometimes for certain purposes, you want to stop the logic after modifying once. </p><pre><code>foreach (var item in list)\n{\n    list.Add(item * 2);\n    break;\n}\n</code></pre> This self modification is allowed, because it is not the <code>list.Add</code> that is the problem, but rather the foreach loop trying to go to the next item right after.  So by breaking out of the loop, this code is safe.<p></p>"},{"location":"best-practices/Modifying-Groups-Being-Iterated/#applying-it-to-mutagen","title":"Applying it to Mutagen","text":"<p>Taking these same concepts back to Mutagen, if you're adding/removing/replacing records from a mod/group that you're looping, you can get the same exception.</p> <p>If you're modifying the same record types you are looping, then you can follow the same patterns described above.  Just add a <code>ToArray</code> to keep yourself from modifying the collections you are looping: </p><pre><code>foreach (var lvln in state.LoadOrder.PriorityOrder.LeveledNpc().WinningOverrides().ToArray())\n{\n    var lvlnCopy = lvln.DeepCopy();\n    lvlnCopy.EditorId += \"Copy\";\n    // Some modifications\n    state.PatchMod.LeveledNpcs.Set(lvlnCopy);\n}\n</code></pre><p></p> <p>Note that this only matters when you are Adding/Removing/Replacing a record FROM/TO a group in a mod.</p> <p>If you are just modifying fields on the records (Setting the name, for example), this is not dangerous.  In this situation, you are not actually modifying the collection itself, you're modifying a field on a record.</p>"},{"location":"best-practices/Overlays-Single-Access/","title":"Access Overlays Once","text":""},{"location":"best-practices/Overlays-Single-Access/#best-practices","title":"Best Practices","text":"<p>As noted above, the Overlay pattern has the downside that repeated access of properties means repeated parsing of the same data.  While this may sound scary at first, it shouldn't pose much of a problem in most scenarios as parsing is very quick.  Most caching solutions that attempt to \"fix\" this quality will probably be slower and come with the additional downside of bloating memory usage.</p> <p>However, this parse-per-access quality does encourage a slightly different coding pattern if you want to squeeze out the tiniest optimization.  Ideally you still want to access properties as little as possible when you can.  Here are some suggestions and tricks:</p>"},{"location":"best-practices/Overlays-Single-Access/#example-of-misuse","title":"Example of Misuse","text":"<p>Here is an example of very slight misuse (only when using an Overlay): </p><pre><code>if (npcOverlay.EditorID != null)\n{\n    System.Console.WriteLine($\"NPC's EditorID was: {npcOverlay.EditorID}\");\n}\n</code></pre><p></p> <p>Why is this bad practice?  Because <code>npcOverlay.EditorID</code> was accessed twice, and so the byte to string parsing for EditorID was executed twice.  In reality, this isn't the biggest deal as it's a small amount of data, and the parsing is extremely quick.  But we're here to talk about optimization and best practices.</p>"},{"location":"best-practices/Overlays-Single-Access/#save-to-variable","title":"Save to Variable","text":"<p>One simple way to reduce access calls when you know you're going to be doing several in a row is to just save the single access to a variable: </p><pre><code>var editorID = npcOverlay.EditorID;\nif (editorID != null)\n{\n    System.Console.WriteLine($\"NPC's EditorID was: {editorID}\");\n}\n</code></pre> This is a simple way to remove the redundant access/parse.<p></p>"},{"location":"best-practices/Overlays-Single-Access/#group-access-special-case","title":"Group Access Special Case","text":"<p>Accessing a Group on a binary overlay mod object is a special case that is even more expensive.  The mod objects are designed to open the file and read the contents from disk at the Group level.  Compared to normal records/fields which multiple accesses will just result in parsing the same memory twice, multiple accesses of the same group will result in multiple reads of the content off the disk.  This is much slower.  </p> <p>As such, Groups should receive extra care to only access them once.  As a simple example using the tip describe above: </p><pre><code>var overlayMod = ...;\n\n// Retrieve the group once\nvar npcs = overlayMod.Npcs;\n\nforeach (var thing in things)\n{\n   // Use the same variable many times\n   if (npcs.TryGetValue(thing.FormKey, out var record))\n      ...\n}\n</code></pre><p></p>"},{"location":"best-practices/Overlays-Single-Access/#pattern-matching","title":"Pattern Matching","text":"<p>It is a very common pattern that a member might not be set.  An alternate way of dealing with this is via Pattern Matching: </p><pre><code>if (npcOverlay.EditorID is string editorID)\n{\n    System.Console.WriteLine($\"NPC's EditorID was {editorID}\");\n}\n</code></pre><p></p> <p>This provides a nice if-exists-then-do pattern, where <code>EditorID</code> is only parsed once and its result exposed in a non-null <code>string</code> variable to use inside the if statement.</p> <p>If you want a more <code>var</code>-like behavior, you can also consider this pattern </p><pre><code>if (npcOverlay.EditorID is {} editorID)\n{\n    System.Console.WriteLine($\"NPC's EditorID was {editorID}\");\n}\n</code></pre><p></p> <p>You no longer need to specify the type <code>string</code>, but it's an odd looking pattern.  C# might introduce a better looking one in the future.</p>"},{"location":"best-practices/Overlays-Single-Access/#safe-navigation-operator","title":"Safe Navigation Operator","text":"<p>In C#, a call on a potentially null member can be short circuited easily by adding a Safe Navigation Operator (<code>?</code>).  This does a null check, and only calls the function or retrieves the data if it is not null.  Here's how it might be used: </p><pre><code>System.Console.WriteLine($\"NPC's EditorID was {npcOverlay.EditorID?.ToString()}\");\n</code></pre> <code>ToString()</code> is only called if EditorID is not null.  It has the upside of only accessing the property once before calling the function, and so is proper practice when calling functions on Overlay members that could be null.<p></p>"},{"location":"best-practices/Overlays-Single-Access/#null-coalescing-operator","title":"Null Coalescing Operator","text":"<p>Another common operator related to potentially null items is the Null Coalescing operator (<code>??</code>).  This checks if an item is null, and if so, returns a second value. </p><pre><code>System.Console.WriteLine($\"NPC's EditorID was {npcOverlay.EditorID ?? \"UNKNOWN\"}\");\n</code></pre> This will access and return EditorID, unless it is null, at which point \"UNKNOWN\" will be returned and printed.  It also has the upside of only accessing the property once before calling the function, and so is proper practice when accessing Overlay members that could be null.<p></p>"},{"location":"best-practices/Overlays-Single-Access/#concrete-example","title":"Concrete Example","text":"<p>It might be useful to walk through a concrete example, and some of the mechanics going on under the hood.  Consider this code: </p><pre><code>using (IOblivionModGetter mod = OblivionMod.CreateFromBinaryOverlay(pathToMod))\n{\n   foreach (var potion in mod.Potions.Records)\n   {\n      // Check if the record has an EditorID, and get it\n      if (!potion.EditorID.TryGet(out var edid)) continue;\n      // Print the result\n      System.Console.WriteLine(edid);\n   }\n}\n</code></pre> This code is intended to print each Potion's Editor ID to the console.<p></p>"},{"location":"best-practices/Overlays-Single-Access/#what-work-is-actually-done-by-this-code","title":"What work is actually done by this code?","text":"<ul> <li>A file is opened</li> <li>An overlay class that implements <code>IOblivionModGetter</code> and has a reference to the file stream is instantiated.</li> <li>Quick skip-over parsing of the file is done to locate the locations of the Groups.</li> <li>User accesses the Potion Group.</li> <li>A Group overlay object is created, and the Potion Group's raw bytes are read from the file.</li> <li>Group overlay object marks all locations of Potion records in its data.</li> <li>User loops over all Potions in the Group.</li> <li>For each loop iteration, an <code>IPotionGetter</code> overlay object is created, pointing to the memory location for that record.</li> <li>The potion overlay object marks the location of all subrecords it contains.</li> <li>The user retrieves the EditorID (once), and checks if is set.</li> <li>The EDID subrecord is parsed from the byte array as a string and returned.</li> <li>The string is printed to the console.</li> <li>After loop is over, the stream is closed.</li> </ul>"},{"location":"best-practices/Overlays-Single-Access/#what-are-some-things-that-were-not-done","title":"What are some things that were not done?","text":"<ul> <li>No Groups besides Potion were parsed. Their top level locations were noted, but no contents were processed.</li> <li>No subrecords were parsed, except EditorID (EDID).</li> <li>No object had a reference to all the Potion records, so as to keep their contents in memory.  The Group object simply has a list of locations.  The user has the only reference to any Potion record at any given moment, and as soon as they were done with it was cleaned up.</li> <li>No extra code was written by the user to help indicate they were only interested in Potions or EditorIDs.  Writing code that accessed them was the implicit indication of interest itself.</li> </ul>"},{"location":"best-practices/Read-Only/","title":"Prefer Readonly Types","text":""},{"location":"best-practices/Read-Only/#prefer-readonly-types","title":"Prefer Readonly Types","text":""},{"location":"best-practices/Read-Only/#overview","title":"Overview","text":"<p>Mutagen offers up records in several ways.  Consider dealing with an Npc, it would offer:</p> <ul> <li><code>Npc</code> class.   A class with all the fields an Npc has</li> <li><code>INpc</code> interface.   An interface with all the fields an Npc has.  The class implements this.</li> <li><code>INpcGetter</code> interface.  An interface with all the fields an Npc has, but only gettable.  Cannot be modified.</li> </ul> <p>In most example code, APIs, and projects you look at the code will mostly be dealing with <code>INpcGetter</code>, and you should too.</p> <p>The best practice is to convert from readonly interfaces to mutable version as late as possible.  This allows the systems to avoid parsing the whole record when it's not applicable.  </p> <p>To transition to a mutable object is typically done via Override Mechanics, which leans on copying the readonly object into a mutable one, which reads and parses all the fields during that process.</p>"},{"location":"best-practices/Read-Only/#reasoning","title":"Reasoning","text":"<p>Doing the bulk of your work on readonly objects has several major upsides.</p>"},{"location":"best-practices/Read-Only/#readonly-increases-speed","title":"Readonly Increases Speed","text":"<p>A lot of Mutagen's speed comes from short circuiting unnecessary work.  A big way it does this is by exposing readonly records in a highly specialized fashion that are very lightweight and fast.   But one of their downsides is they are read only.</p> <pre><code>foreach (var readonlyNpc in mod.Npcs)\n{\n    // Readonly phase\n    // Skip npc if health offset greater than 100\n    if (readonlyNpc.Configuration.HealthOffset &lt; 100) continue;\n\n    // Mutable phase\n    var npc = outgoingMod.Npcs.GetOrAddAsOverride(readonlyNpc);\n    // Set all lower health offsets to be at least 100\n    npc.Configuration.HealthOffset = 100;\n}\n</code></pre> <p>For 99% of Npcs, we will just want to check if the HealthOffset is less than 100, and if so, skip.  Readonly mods are able to ONLY parse the data related to HealthOffset, and thus for 99% of the Npcs can skip 99% of the parsing work.</p> <p>As soon as you want to modify something, you have to first convert it to a settable version of the record.  This means reading ALL the data within that record to fill out each field one by one.  This is often a waste of time, and so should be done as late as possible after all filtering and investigation code has run on readonly objects.</p>"},{"location":"best-practices/Read-Only/#helps-avoid-malformed-mod-issues","title":"Helps Avoid Malformed Mod Issues","text":"<p>If a mod has a single malformed record, this can cause parsing issues.  By using readonly mods, you will avoid interacting with this object entirely if it's not of interest to your program.   For example, if there's a malformed NavMesh object in a mod, but your program is only interested in Weapons, then you'll avoid the problem record entirely.</p> <p>However, if your code was interested in that specific malformed field of that NavMesh, then of course the core issue will still need to be dealt with, either by notifying the mod author, upgrading Mutagen code to handle it better, etc.</p>"},{"location":"best-practices/Read-Only/#adds-clearer-intention-to-modifications","title":"Adds Clearer Intention to Modifications","text":""},{"location":"best-practices/Read-Only/#a-fully-mutable-ecosystem-has-easy-pitfalls","title":"A Fully Mutable Ecosystem Has Easy Pitfalls","text":"<p>Let's pretend for a moment that all records were mutable within the entire ecosystem.  This can easily lead to some very subtle bug prone situations.</p> <pre><code>// Retrieve an Npc from Skyrim.esm\n// Making use of the Mutagen.Bethesda.FormKeys.Skyrim helper library\n// Note that in this pretend example, the environment is providing setter interfaces\nINpc orthorn = env.LoadOrder[\"Skyrim.esm\"].Npcs[Skyrim.Npc.Orthorn];\n\n// Modify speed to be x2\northorn.Speed *= 2;\n\n// Add to our outgoing patch\noutgoingPatch.Npcs.Add(orthorn);\n</code></pre> <p>The above logic has some unexpected and probably undesirable side effects.  We not only overrode Orthorn to have more Speed in our outgoing patch, we also modified the original record as it existed within the <code>Skyrim.esm</code> mod object!   In fact, it's the same Npc class instance shared by both mods!  Changing the values in one changes the values in all, as both mods are pointing to the same object.  If future code is to iterate Skyrim's records, it would see that Orthorn is faster there, too, rather than the record having the original speed Skyrim.esm defined.  </p> <p>Skyrim.esm should not be so easily modified.  We wanted to modify Orthorn as it was defined in our outgoing patch.  Skyrim.esm should be more or less immutable unless we take explicit intentional steps to do so.</p>"},{"location":"best-practices/Read-Only/#initially-immutable-environment-encourages-clearer-intentions","title":"Initially Immutable Environment Encourages Clearer Intentions","text":"<p>Take the same situation, but in the actual ecosystem that provides getter interfaces by default: </p><pre><code>// Retrieve an Npc from Skyrim.esm\n// Making use of the Mutagen.Bethesda.FormKeys.Skyrim helper library\n// Note that the actual ecosystems provide only a Getter interface here\nINpcGetter orthornGetter = env.LoadOrder[\"Skyrim.esm\"].Npcs[Skyrim.Npc.Orthorn];\n\n// We want to modify, and so we have to indicate which mod wants to contain that modification\nvar orthornSetter = outgoingPatch.Npcs.GetOrAddAsOverride(orthornGetter);\n\n// Modify speed to be x2\northornSetter.Speed *= 2;\n</code></pre><p></p> <p>This is better in a few ways:</p> <ul> <li>As part of the modification process, we are required to indicate which mod is going to \"house\" those modifications</li> <li>The object instance we are modifying only exists in our outgoing patch, rather than many mods</li> <li>The original Skyrim.esm definition is left intact.  In fact, it cannot possibly be modified as the entire mod object is readonly fundamentally.</li> </ul>"},{"location":"best-practices/Reuse-Translation-Masks/","title":"Reuse Translation Masks","text":""},{"location":"best-practices/Reuse-Translation-Masks/#reuse-translation-masks","title":"Reuse Translation Masks","text":"<p>[[Translation Masks]] are a powerful toolset that give you fine-grained control over things like a Copy or Equality check.</p> <p>They typically look like this: </p><pre><code>var bookCopy = book.DeepCopy(new Book.TranslationMask(defaultOn: true)\n{\n    PickUpSound = false,\n    PutDownSound = false,\n});\n</code></pre> This code snippet would copy a book, but skip <code>PickUpSound</code> and <code>PutDownSound</code> and leave them on their default values.<p></p> <p>However, code like the ones above are typically done in loops: </p><pre><code>foreach (var book in books)\n{\n    var bookCopy = book.DeepCopy(new Book.TranslationMask(defaultOn: true)\n    {\n        PickUpSound = false,\n        PutDownSound = false,\n    });\n}\n</code></pre> This code will work, but is slightly wasteful, as it creates a new mask per loop iteration.<p></p> <p>A TranslationMask is just instructions for what to copy, so they can be reused.  A better way would look like this: </p><pre><code>var bookCopyMask = new Book.TranslationMask(defaultOn: true)\n{\n    PickUpSound = false,\n    PutDownSound = false,\n};\nforeach (var book in books)\n{\n    var bookCopy = book.DeepCopy(bookCopyMask);\n}\n</code></pre> Now the job is a bit more optimized, as the same mask can just be reused for each book.<p></p>"},{"location":"best-practices/TryGet-Concepts/","title":"TryGet Concepts","text":""},{"location":"best-practices/TryGet-Concepts/#tryget-concepts","title":"TryGet Concepts","text":"<p>There are many concepts within Mutagen that are optional, nullable, or may not link up at runtime.</p> <p>It is good practice to code in a way that is able to handle both situations:</p> <ul> <li>The field is not null.  The lookup found its target.  Etc</li> <li>The field is null.  The lookup failed to find its target.  Etc</li> </ul> <p>To facilitate this, most API comes with <code>Try</code> alternatives.</p>"},{"location":"best-practices/TryGet-Concepts/#direct-access","title":"Direct Access","text":"<p>Let's first take a look at the non-Try route.</p> <p>This pattern assumes your lookup will succeed.  This is only safe if you checked that it existed earlier.</p>"},{"location":"best-practices/TryGet-Concepts/#mutagen-example","title":"Mutagen Example","text":"<p>An example: </p><pre><code>INpcGetter npc = ...;\n\nIRaceGetter race = npc.Race.Resolve(someLinkCache);\n</code></pre><p></p> <p>This will work in 98% of scenarios, up until some user has an odd Npc that doesn't list a Race.  Maybe it was a test Npc that isn't used anymore, so it's not a big deal, except for the fact that your code will now throw an exception.  It cannot <code>Resolve</code> the race and give you an object back, so it throws.</p>"},{"location":"best-practices/TryGet-Concepts/#generic-c-example","title":"Generic C# Example","text":"<p>This is equivalent to using the Dictionary indexer directly </p><pre><code>Dictionary&lt;int, string&gt; dict = new();\ndict[23] = \"Hello\";\n\n// I will throw\nvar str = dict[45];\n</code></pre><p></p>"},{"location":"best-practices/TryGet-Concepts/#tryget-patterns-instead","title":"TryGet Patterns Instead","text":"<p>Instead, a better pattern might be:</p>"},{"location":"best-practices/TryGet-Concepts/#mutagen-example_1","title":"Mutagen Example","text":"<pre><code>INpcGetter npc = ...;\n\nif (npc.Race.TryResolve(someLinkCache, out var race))\n{\n    System.Console.WriteLine($\"Race was {race}\");\n}\nelse\n{\n    // Did not find it.  Return? Skip?\n}\n</code></pre> <p>Often, if in a loop, the cleanest pattern is: </p><pre><code>foreach (INpcGetter npc in someCollection)\n{\n   // Look it up, otherwise go to next npc\n   if (!npc.Race.TryResolve(someLinkCache, out var race)) continue;\n\n   System.Console.WriteLine($\"Race was {race}\");\n}\n</code></pre><p></p>"},{"location":"best-practices/TryGet-Concepts/#generic-c-example_1","title":"Generic C# Example","text":"<p>For the basic C# dictionary example, this would be the equivalent of: </p><pre><code>Dictionary&lt;int, string&gt; dict = new();\ndict[23] = \"Hello\";\n\nif (dict.TryGetValue(45, out var str))\n{\n   // Found it\n}\n</code></pre><p></p>"},{"location":"best-practices/TryGet-Concepts/#summary","title":"Summary","text":"<p>It is almost always preferable to use the <code>Try</code> alternative when available.   It will force you to consider both when it finds what it was looking for, as well as the case when it does not.</p> <p>Straight \"<code>Try</code>-less\" calls should only be used when you've previously checked that the value exists.  Then you know the call is safe, and so it's proper to not need to <code>Try</code>.  This is rarely used, as the <code>Try</code> pattern both checks that it exists and gets the value in one swoop, so a followup retrieval is usually not needed.</p>"},{"location":"environment/","title":"Environment","text":""},{"location":"environment/#environment","title":"Environment","text":"<p>When writing a program that is going to interact with Bethesda mods, often you would like to interact with the entirity of a game environment.  Mutagen comes with a convenience bootstrapper object that brings all the components of a game installations environment into one place:</p> <ul> <li>A LoadOrder object with the current load order </li> <li>ReadOnly Mod objects ready for use on the load order object</li> <li>LinkCache relative to the load order</li> <li>Data folder path</li> <li>Load order file path (Plugins.txt)</li> <li>Creation Club load order file path (Skyrim.ccc)</li> </ul> <p>Synthesis</p> <p>If you're coding within a Synthesis Patcher, you should not make your own environment as described here.  Synthesis provides its own environment-like <code>IPatcherState</code> object in its Run function.</p> <p> Synthesis State Object</p>"},{"location":"environment/#simple-usage","title":"Simple Usage","text":"<pre><code>using (var env = GameEnvironment.Typical.Skyrim(SkyrimRelease.SkyrimSE))\n{\n    // Now we can get straight to work\n    Console.WriteLine($\"Data folder was found to be at: {env.DataFolderPath}\");\n    Console.WriteLine($\"Load Order has {env.LoadOrder.Count} mods\");\n\n    // Let's print the load order as an example\n    Console.WriteLine($\"Load Order:\");\n    foreach (var listing in env.LoadOrder.ListedOrder)\n    {\n        Console.WriteLine($\"  {listing}\");\n    }\n}\n// Environment is now disposed, so all contained objects are no longer accurate or valid\n</code></pre>"},{"location":"environment/#advanced-usage","title":"Advanced Usage","text":"<p>The above example just shows the basic one line environment definition to get the typical environment.  Mutagen by default will construct Game Environments relative the game installation registered by Steam.</p> <p>If you have custom requirements or want to mix in output mods, etc, be sure to check out the Environment Construction documentation.</p> <p> Advanced Game Environment Construction</p> <p> Game Locations</p>"},{"location":"environment/Environment-Construction/","title":"Environment Construction","text":""},{"location":"environment/Environment-Construction/#environment-construction","title":"Environment Construction","text":"<p>Synthesis</p> <p>If you're coding within a Synthesis Patcher, you should not make your own environment as described here.  Synthesis provides its own environment-like <code>IPatcherState</code> object in its Run function.</p> <p> Synthesis State Object</p>"},{"location":"environment/Environment-Construction/#known-game-category","title":"Known Game Category","text":"<p>The simplest way to construct an environment if you know the game you want to target is: </p><pre><code>using (var env = GameEnvironment.Typical.Skyrim(SkyrimRelease.SkyrimSE))\n{\n    // Use ISkyrimModGetter environment\n}\n</code></pre><p></p>"},{"location":"environment/Environment-Construction/#unknown-game-category","title":"Unknown Game Category","text":"<p>You can construct an environment when you don't know the target game: </p><pre><code>using (var env = GameEnvironment.Typical.Construct(someGameRelease))\n{\n    // Use IModGetter environment\n}\n</code></pre><p></p> <p>But this has the downside of not knowing the type of mod it will contain at compile time.  This means it will only expose <code>IModGetter</code> objects, which will be harder to interact with, depending on your goals</p>"},{"location":"environment/Environment-Construction/#game-environment-builder","title":"Game Environment Builder","text":"<p>Lets you fluently tweak the environment that will be built to be customized to your needs:</p> <ul> <li>Override the target Data folder</li> <li>Wanting to omit a mod</li> <li>Wanting to customize load order</li> <li>Wanting to add an output mod, and integrate it with the link cache</li> </ul> <p>These types of goals can be achieved with a builder: </p><pre><code>var outgoing = new SkyrimMod(ModKey.FromFileName(\"MyMod.esp\"), SkyrimRelease.SkyrimSE);\nusing var env = GameEnvironment.Typical.Builder&lt;ISkyrimMod, ISkyrimModGetter&gt;(GameRelease.SkyrimSE)\n    .TransformLoadOrderListings(x =&gt; x.Where(x =&gt; !x.ModKey.Name.Contains(\"SkipMe\")))\n    .WithTargetDataFolder(someCustomDataFolderPath)\n    .WithOutputMod(outgoing)\n    .Build();\n</code></pre><p></p>"},{"location":"environment/Environment-Construction/#transform-load-order","title":"Transform Load Order","text":"<p>This gives you an Enumerable of mods, and lets you filter some out, or mix some in at your discretion.</p>"},{"location":"environment/Environment-Construction/#transformloadorderlistings","title":"TransformLoadOrderListings","text":"<p>This call gives you the listings as they appear in the load order files, before the mod objects get created.  Ideally any trimming is done here, rather than after the mods have been created.</p> <p>Order between multiple <code>TransformLoadOrderListings</code> is respected.</p>"},{"location":"environment/Environment-Construction/#transformmodlistings","title":"TransformModListings","text":"<p>This call gives you the listings after they have been transformed by any <code>TransformLoadOrderListings</code> calls, and after mod objects have been created for each listing.  As such, this call can interact with the mod objects as part of its transform logic.</p> <p>Order between multiple <code>TransformModListings</code> is respected, but will always come after any <code>TransformLoadOrderListings</code> calls.</p>"},{"location":"environment/Environment-Construction/#withoutputmod","title":"WithOutputMod","text":"<p>This lets you mix in a mod that you plan on exporting content with.  You can put multiple <code>WithOutputMod</code> calls in your builder chain.</p> <p>Modifies Load Order</p> <p>Using WithOutputMod adjusts the Load Order the Game Environment will give you, as described below</p>"},{"location":"environment/Environment-Construction/#load-order-trimming","title":"Load Order Trimming","text":"<p>When using WithOutputMod, be aware that this modifies the Load Order the environment will provide you to be trimmed so that it doesn't include the outgoing mod and anything after it.   The Load Order presented by the environment represents the existing mods to consider while building the output mod, and as such, excludes the outgoing mod itself, and anything after it.</p> <p>This is to help avoid:</p> <ul> <li>\"Collection modified while looping\" errors</li> <li>Adding masters to the outgoing mod from mods after itself in the load order (not allowed)</li> </ul>"},{"location":"environment/Environment-Construction/#link-cache","title":"Link Cache","text":"<p>The Link Cache made by the environment with an output mod will include the Load Order mods PLUS the outgoing mod(s) at the end.  Lookups against the Link Cache WILL resolve objects from your outgoing mod appropriately.   Outgoing mods are registered in the Link Cache in a non-caching fashion, so edits to your outgoing mod will reflect in subsequent lookups appropriately.</p>"},{"location":"environment/Environment-Construction/#further-customization","title":"Further Customization","text":"<p>If you want to break away from the default behaviors described above, you can always make your own Load Order and Link Cache objects that contain different content the way you want them.   You can even opt to not use WithOutputMod entirely and have the Game Environment give you the whole Load Order as a baseline but customize it as you want from there.</p>"},{"location":"environment/Environment-Construction/#withtargetdatafolder","title":"WithTargetDataFolder","text":"<p>Allows you to customize what game folder the environment will be constructed against.  Useful when dealing with ad-hoc installations.</p>"},{"location":"environment/Environment-Construction/#withloadorder","title":"WithLoadOrder","text":"<p>This is a <code>TransformLoadOrderListings</code> style call that simply discards any existing load order and injects an explicitly provided one.  Will respect the ordering alongside other <code>TransformLoadOrderListings</code> phase calls.</p>"},{"location":"environment/Environment-Construction/#withutf8encoding","title":"WithUtf8Encoding","text":"<p>Convenience method to enable UTF8 encoding when reading embedded (non-localized) strings from mods. By default, Bethesda games use Windows-1252 encoding for embedded strings. Some mods (particularly non-English translations) use UTF8 instead. Enable this option when working with mods that contain UTF8-encoded strings with non-Latin characters (Russian, Japanese, Chinese, etc.).</p>"},{"location":"environment/Game-Locations/","title":"Game Locations","text":""},{"location":"environment/Game-Locations/#game-locations","title":"Game Locations","text":"<p>Use Environments When Possible</p> <p>Game location concepts are somewhat unnecessary to interact with, since usually the preferred entry point is via Environments</p> <p> Environments</p>"},{"location":"environment/Game-Locations/#sources","title":"Sources","text":"<p>Currently, Mutagen locates games via a few sources:</p> <ul> <li>Looks in the registry</li> <li>Looks in Steam systems (via GameFinder)</li> </ul> <p>GameLocation API will NOT locate ad-hoc game folders that exist randomly on your system.  It must be registered in one of the two above listed sources in order to be located automatically</p> <p>Adhoc Installations Will Not Be Located</p> <p>Installations like Wabbajack might have a game folder that is \"off the grid\".  In these situations, your tools need to offer some way for the user to define where their target data folder is, as the system will not be able to locate these unregistered folders automatically.</p> <p> Wabbajack</p>"},{"location":"environment/Game-Locations/#game-folder-vs-data-folder","title":"Game Folder vs Data Folder","text":"<p>The Game Location API uses \"Game\" and \"Data\" folder naming to represent two similar paths:</p> <ul> <li><code>Game</code> folder is the one containing the game's exe itself.  This is not where mods go, typically.</li> <li><code>Data</code> folder is usually within the <code>Game</code> folder: <code>%Game%/Data</code>.  This is where mods reside, and as such is the typical folder of interest.</li> </ul>"},{"location":"environment/Game-Locations/#api","title":"API","text":""},{"location":"environment/Game-Locations/#get__folder","title":"Get__Folder","text":"<p>You can query for a Game or Data folder</p> GetTryGet <pre><code>var dataFolder = GameLocations.Get[Game/Data]Folder(GameRelease.SkyrimSE);\n</code></pre> <pre><code>if (GameLocations.TryGet[Game/Data]Folder(GameRelease.SkyrimSE, out var dataFolder))\n{\n}\n</code></pre>"},{"location":"environment/Game-Locations/#getgamefolders","title":"GetGameFolders","text":"<p>There is an enumerable option to get all the Game folders from the various sources </p><pre><code>foreach (var location in GameLocations.GetGameFolders(GameRelease.SkyrimSE))\n{\n}\n</code></pre><p></p>"},{"location":"environment/Game-Locations/#trygetgamefolderfromregistry","title":"TryGetGameFolderFromRegistry","text":"<p>You can directly query the Registry, rather than looking at game installation paths. </p><pre><code>if (GameLocations.TryGetGameFolderFromRegistry(GameRelease.SkyrimSE, out var gameFolder))\n{\n}\n</code></pre><p></p>"},{"location":"familiar/Namespaces/","title":"Namespaces","text":""},{"location":"familiar/Namespaces/#namespaces","title":"Namespaces","text":""},{"location":"familiar/Namespaces/#what-are-namespaces","title":"What Are Namespaces","text":"<p>Namespaces are \"sections\" of code that you can opt to import so that you have access to.  They help organize things and prevent naming collisions.   </p> <p>They typically might look like: </p><pre><code>// Import the namespace\nusing Mutagen.Bethesda.Skyrim;\n\n// Now I have access to the SkyrimMod concepts\nvar skyrimMod = new SkyrimMod(\"Skyrim.esm\", SkyrimRelease.SkyrimSE);\n</code></pre><p></p>"},{"location":"familiar/Namespaces/#namespaces-intellisense-and-compiling","title":"Namespaces, Intellisense, and Compiling","text":"<p>By default, Visual Studio will only show autocomplete for the concepts that exist within the namespaces you have imported.  </p> <p>If you have an empty file and start typing <code>SkyrimMod</code>, it will not autocomplete.  If you type the whole thing out manually, it'll be underlined red saying it does not know what it is.  This is because the namespace is not imported, and so it's not showing you SkyrimMod as an option to use.</p>"},{"location":"familiar/Namespaces/#adding-a-namespace","title":"Adding a Namespace","text":"<p>Often you want to add a namespace so that the compiler knows about it, and Intellisense shows it in autocomplete.</p>"},{"location":"familiar/Namespaces/#add-the-namespace-import-yourself","title":"Add the Namespace Import Yourself","text":"<p>You can write it out yourself by adding it to the top of your file: </p><pre><code>using Mutagen.Bethesda.Skyrim;\n\nvar skyrimMod = new SkyrimMod(\"Skyrim.esm\", SkyrimRelease.SkyrimSE);\n</code></pre><p></p> <p>This has the downside that you need to know what the namespace that you're interested in is</p>"},{"location":"familiar/Namespaces/#let-the-ide-add-the-namespace","title":"Let the IDE add the Namespace","text":"<p>Alternatively, if you know the thing you would like to use, you can write it out, and have the IDE find out what namespace needs to be imported for you.</p> <p>For example, you could type out <code>SkyrimMod</code>, and when it highlights red, do the Visual Studio keybind for suggest fixes (Ctrl + .) and it will suggest adding <code>Mutagen.Bethesda.Skyrim</code> to your namespaces.  Select that option, and the IDE will go ahead and do that.</p> <p>This still has the downside that you need to know what type you are interested in using and type it out by hand.  In our case that was <code>SkyrimMod</code>.  This is vulnerable to typos where the IDE wont be able to locate the namespace if it's misspelled, etc.</p>"},{"location":"familiar/Namespaces/#show-types-from-other-namespaces-in-intellisense","title":"Show Types From Other Namespaces in Intellisense","text":"<p>The final option is to allow Intellisense to show in its autocomplete ALL types that exist, not just the ones from namespaces you have imported.   This is often super nice, as you can then just start typing in <code>SkyrimMod</code> and it will show it as an autocomplete option.  If you choose to autocomplete it, it will automatically add the necessary namespace, too.</p> <p>This is by far the easiest usability, but of course comes with the downside of having a more \"clogged\" Intellisense since it is always showing all the types in existence.   Usually, though, this is not too much of a problem, as the IDE is able to narrow things down and suggest items pretty intelligently.</p> <p>To turn this on, you need to go into your <code>Visual Studio</code> options:</p> <p><code>Visual Studio -&gt; Top Bar -&gt; Tools -&gt; Options -&gt; Text Editor -&gt; C# -&gt; Intellisense -&gt; Show items from unimported namespaces</code></p> <p></p> <p><code>Rider</code> has this functionality on by default.</p>"},{"location":"familiar/Namespaces/#namespaces-help-with-collisions","title":"Namespaces Help With Collisions","text":"<p>In addition to \"scoping\" Intellisense as mentioned above, namespaces also help when you have a legitimate name collision.   Let's say you're using two libraries that both defined <code>MyClass</code>, and you want to use both of them in the same code snippet.  How do you do this? </p><pre><code>var classA = new SomeLibrary.MyClass();\nvar classB = new OtherLibrary.MyClass();\n</code></pre> The above snippet shows that you can include the namespace to help specify which <code>MyClass</code> you're referring to, and so both can be used side by side, despite the bad naming.<p></p>"},{"location":"familiar/Nullability-to-Indicate-Record-Presence/","title":"Nullability to Indicate Record Presence","text":""},{"location":"familiar/Nullability-to-Indicate-Record-Presence/#nullability-to-indicate-record-presence","title":"Nullability to Indicate Record Presence","text":""},{"location":"familiar/Nullability-to-Indicate-Record-Presence/#most-subrecords-are-optional","title":"Most Subrecords are Optional","text":"<p>Most Bethesda subrecords are optional; They can be set to a value, or not exist at all.  Mutagen uses a field's nullability to indicate which fields/subrecords are optional.   This leverages one of C#'s newer concepts of Nullable References.</p> <p>TLDR: Fields can be marked as to whether they are allowed to be null or not: </p><pre><code>string RequiredField { get; set; }\nstring? OptionalField { get; set; }\n</code></pre><p></p> <p>The <code>RequiredField</code> cannot be <code>null</code>, and always must have some value.  The <code>OptionalField</code> is allowed to be <code>null</code>.  Mutagen utilizes this distinction to communicate that <code>OptionalField</code> is considered \"unset\" if/when it is <code>null</code>.</p> <p>Going off the earlier <code>Potion</code> interface:</p> <ul> <li>FormKey cannot be null, and must always have a value.</li> <li>EditorID, Name, Model, Icon are all optional, and will be null if they are not set.</li> </ul>"},{"location":"familiar/Nullability-to-Indicate-Record-Presence/#dealing-with-nullable-fields","title":"Dealing with Nullable Fields","text":"<p>In recent C#, the compiler will error out if you're trying to access or use a value that might be null without ensuring it is not null first.  When a field is nullable, you will want to adjust your code to deal with the potential that it might not exist.</p>"},{"location":"familiar/Nullability-to-Indicate-Record-Presence/#dont-check-unless-needed","title":"Don't Check Unless Needed","text":"<p>Not all fields are nullable.  If a field's type does not end with a <code>?</code> then it cannot be null and thus does not need to be checked.</p> <p>Checking if a non-nullable field is null is unnecessary, and actually confuses the compiler in certain circumstances.  Typically the compiler will let you know when something hasn't been checked by giving you an error.  You can usually wait until it complains before worrying about writing null checks.  </p>"},{"location":"familiar/Nullability-to-Indicate-Record-Presence/#skipping-if-null","title":"Skipping if null","text":"<p>If you're within a foreach loop you can opt to skip the record if the field you're interested in is null: </p><pre><code>IObjectEffect objectEffect = ...;\nforeach (var effect in objectEffect.Effects)\n{\n    if (effect.Data == null) continue;\n    Console.WriteLine($\"Magnitude was: {effect.Data.Magnitude}\");\n}\n</code></pre><p></p>"},{"location":"familiar/Nullability-to-Indicate-Record-Presence/#using-a-fallback-value-if-null","title":"Using a fallback value if null","text":"<p>You can also use Null Conditional Operators to help specify \"fallback\" values if a field is null </p><pre><code>IObjectEffect objectEffect = ...;\nforeach (var effect in objectEffect.Effects)\n{\n    // This will be set to -1 if Data is null\n    var magnitude = effect.Data?.Magnitude ?? -1;\n    Console.WriteLine($\"Magnitude was: {magnitude}\");\n}\n</code></pre><p></p>"},{"location":"familiar/Nullability-to-Indicate-Record-Presence/#setting-the-null-field-to-have-a-value","title":"Setting the null field to have a value","text":"<p>Sometimes when you're creating a record, you might need to create the subclasses yourself on the nullable fields so that you can fill them. </p><pre><code>IObjectEffect objectEffect = ...;\nforeach (var effect in objectEffect.Effects)\n{\n    // A fancy way of setting the field to a new EffectData if it's null\n    effect.Data ??= new EffectData();\n\n    // And now we can set its Magnitude knowing it will never be null\n    effect.Data.Magnitude = 100;\n}\n</code></pre><p></p>"},{"location":"familiar/Nullability-to-Indicate-Record-Presence/#other","title":"Other","text":"<p>There are many other ways to deal with the potential of null values besides the examples given, depending on the circumstances and goals.</p>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/","title":"Oblivion Aspect Interfaces","text":""},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#oblivion-aspect-interfaces","title":"Oblivion Aspect Interfaces","text":""},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#aspect-interfaces","title":"Aspect Interfaces","text":"<p>Aspect Interfaces expose common aspects of records.  For example, <code>INamed</code> are implemented by all records that have a <code>Name</code>.</p> <p>Functions can then be written that take in <code>INamed</code>, allowing any record that has a name to be passed in.</p>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#interfaces-to-concrete-classes","title":"Interfaces to Concrete Classes","text":""},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#imodeled","title":"IModeled","text":"<ul> <li>Activator</li> <li>AlchemicalApparatus</li> <li>Ammunition</li> <li>AnimatedObject</li> <li>BodyData</li> <li>Book</li> <li>Climate</li> <li>Container</li> <li>Creature</li> <li>Door</li> <li>FacePart</li> <li>Flora</li> <li>Furniture</li> <li>Grass</li> <li>Hair</li> <li>IdleAnimation</li> <li>Ingredient</li> <li>Key</li> <li>Light</li> <li>MagicEffect</li> <li>Miscellaneous</li> <li>Npc</li> <li>Potion</li> <li>SigilStone</li> <li>SoulGem</li> <li>Static</li> <li>Tree</li> <li>Weapon</li> <li>Weather</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#inamed","title":"INamed","text":"<ul> <li>AClothing</li> <li>Activator</li> <li>AlchemicalApparatus</li> <li>Ammunition</li> <li>Armor</li> <li>Birthsign</li> <li>Book</li> <li>Cell</li> <li>Class</li> <li>Clothing</li> <li>Container</li> <li>Creature</li> <li>DialogTopic</li> <li>Door</li> <li>Enchantment</li> <li>Eye</li> <li>Faction</li> <li>Flora</li> <li>Furniture</li> <li>Hair</li> <li>Ingredient</li> <li>Key</li> <li>Light</li> <li>LocalVariable</li> <li>MagicEffect</li> <li>MapMarker</li> <li>Miscellaneous</li> <li>Npc</li> <li>Potion</li> <li>Quest</li> <li>Race</li> <li>ScriptEffect</li> <li>SigilStone</li> <li>SoulGem</li> <li>Spell</li> <li>SpellLeveled</li> <li>SpellUnleveled</li> <li>Weapon</li> <li>Worldspace</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#iweightvalue","title":"IWeightValue","text":"<ul> <li>AlchemicalApparatusData</li> <li>AmmunitionData</li> <li>ArmorData</li> <li>ClothingData</li> <li>KeyData</li> <li>LightData</li> <li>SigilStoneData</li> <li>SoulGemData</li> <li>WeaponData</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#concrete-classes-to-interfaces","title":"Concrete Classes to Interfaces","text":""},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#aclothing","title":"AClothing","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#activator","title":"Activator","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#alchemicalapparatus","title":"AlchemicalApparatus","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#alchemicalapparatusdata","title":"AlchemicalApparatusData","text":"<ul> <li>IWeightValue</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#ammunition","title":"Ammunition","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#ammunitiondata","title":"AmmunitionData","text":"<ul> <li>IWeightValue</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#animatedobject","title":"AnimatedObject","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#armor","title":"Armor","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#armordata","title":"ArmorData","text":"<ul> <li>IWeightValue</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#birthsign","title":"Birthsign","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#bodydata","title":"BodyData","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#book","title":"Book","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#cell","title":"Cell","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#class","title":"Class","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#climate","title":"Climate","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#clothing","title":"Clothing","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#clothingdata","title":"ClothingData","text":"<ul> <li>IWeightValue</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#container","title":"Container","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#creature","title":"Creature","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#dialogtopic","title":"DialogTopic","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#door","title":"Door","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#enchantment","title":"Enchantment","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#eye","title":"Eye","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#facepart","title":"FacePart","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#faction","title":"Faction","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#flora","title":"Flora","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#furniture","title":"Furniture","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#grass","title":"Grass","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#hair","title":"Hair","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#idleanimation","title":"IdleAnimation","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#ingredient","title":"Ingredient","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#key","title":"Key","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#keydata","title":"KeyData","text":"<ul> <li>IWeightValue</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#light","title":"Light","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#lightdata","title":"LightData","text":"<ul> <li>IWeightValue</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#localvariable","title":"LocalVariable","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#magiceffect","title":"MagicEffect","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#mapmarker","title":"MapMarker","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#miscellaneous","title":"Miscellaneous","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#npc","title":"Npc","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#potion","title":"Potion","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#quest","title":"Quest","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#race","title":"Race","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#scripteffect","title":"ScriptEffect","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#sigilstone","title":"SigilStone","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#sigilstonedata","title":"SigilStoneData","text":"<ul> <li>IWeightValue</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#soulgem","title":"SoulGem","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#soulgemdata","title":"SoulGemData","text":"<ul> <li>IWeightValue</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#spell","title":"Spell","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#spellleveled","title":"SpellLeveled","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#spellunleveled","title":"SpellUnleveled","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#static","title":"Static","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#tree","title":"Tree","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#weapon","title":"Weapon","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#weapondata","title":"WeaponData","text":"<ul> <li>IWeightValue</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#weather","title":"Weather","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Aspect-Interfaces/#worldspace","title":"Worldspace","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/","title":"Oblivion Link Interfaces","text":""},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/#oblivion-link-interfaces","title":"Oblivion Link Interfaces","text":""},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/#link-interfaces","title":"Link Interfaces","text":"<p>Link Interfaces are used by FormLinks to point to several record types at once.  For example, a Container record might be able to contain Armors, Weapons, Ingredients, etc.</p> <p>An interface would be defined such as 'IItem', which all Armor, Weapon, Ingredients would all implement.</p> <p>A <code>FormLink&lt;IItem&gt;</code> could then point to all those record types by pointing to the interface instead.</p>"},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/#interfaces-to-concrete-classes","title":"Interfaces to Concrete Classes","text":""},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/#iowner","title":"IOwner","text":"<ul> <li>Faction</li> <li>Npc</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/#iplaced","title":"IPlaced","text":"<ul> <li>Landscape</li> <li>PlacedCreature</li> <li>PlacedNpc</li> <li>PlacedObject</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/#concrete-classes-to-interfaces","title":"Concrete Classes to Interfaces","text":""},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/#faction","title":"Faction","text":"<ul> <li>IOwner</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/#landscape","title":"Landscape","text":"<ul> <li>IPlaced</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/#npc","title":"Npc","text":"<ul> <li>IOwner</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/#placedcreature","title":"PlacedCreature","text":"<ul> <li>IPlaced</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/#placednpc","title":"PlacedNpc","text":"<ul> <li>IPlaced</li> </ul>"},{"location":"game-specific/oblivion/Oblivion-Link-Interfaces/#placedobject","title":"PlacedObject","text":"<ul> <li>IPlaced</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/","title":"Skyrim Aspect Interfaces","text":""},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#skyrim-aspect-interfaces","title":"Skyrim Aspect Interfaces","text":""},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#aspect-interfaces","title":"Aspect Interfaces","text":"<p>Aspect Interfaces expose common aspects of records.  For example, <code>INamed</code> are implemented by all records that have a <code>Name</code>.</p> <p>Functions can then be written that take in <code>INamed</code>, allowing any record that has a name to be passed in.</p>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#interfaces-to-concrete-classes","title":"Interfaces to Concrete Classes","text":""},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#ihasicons","title":"IHasIcons","text":"<ul> <li>AlchemicalApparatus</li> <li>Ammunition</li> <li>ArmorModel</li> <li>Book</li> <li>Ingestible</li> <li>Ingredient</li> <li>Key</li> <li>Light</li> <li>LoadScreen</li> <li>MiscItem</li> <li>Perk</li> <li>RegionData</li> <li>SoulGem</li> <li>Weapon</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#ikeyworded","title":"IKeyworded","text":"<ul> <li>Activator</li> <li>Ammunition</li> <li>Armor</li> <li>Book</li> <li>Flora</li> <li>Furniture</li> <li>Ingestible</li> <li>Ingredient</li> <li>Key</li> <li>Location</li> <li>MagicEffect</li> <li>MiscItem</li> <li>Npc</li> <li>QuestAlias</li> <li>Race</li> <li>Scroll</li> <li>SoulGem</li> <li>Spell</li> <li>TalkingActivator</li> <li>Weapon</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#imodeled","title":"IModeled","text":"<ul> <li>Activator</li> <li>AddonNode</li> <li>AlchemicalApparatus</li> <li>Ammunition</li> <li>AnimatedObject</li> <li>ArmorModel</li> <li>ArtObject</li> <li>BodyData</li> <li>BodyPartData</li> <li>Book</li> <li>CameraShot</li> <li>Climate</li> <li>Container</li> <li>DestructionStage</li> <li>Door</li> <li>Explosion</li> <li>Flora</li> <li>Furniture</li> <li>Grass</li> <li>Hazard</li> <li>HeadData</li> <li>HeadPart</li> <li>IdleMarker</li> <li>Impact</li> <li>Ingestible</li> <li>Ingredient</li> <li>Key</li> <li>LeveledNpc</li> <li>Light</li> <li>MaterialObject</li> <li>MiscItem</li> <li>MoveableStatic</li> <li>Projectile</li> <li>Scroll</li> <li>SoulGem</li> <li>Static</li> <li>TalkingActivator</li> <li>Tree</li> <li>Weapon</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#inamed","title":"INamed","text":"<ul> <li>Activator</li> <li>ActorValueInformation</li> <li>AlchemicalApparatus</li> <li>AlternateTexture</li> <li>Ammunition</li> <li>APackageData</li> <li>Armor</li> <li>BodyPart</li> <li>Book</li> <li>Cell</li> <li>Class</li> <li>CollisionLayer</li> <li>ColorRecord</li> <li>Container</li> <li>DialogTopic</li> <li>Door</li> <li>Explosion</li> <li>Eyes</li> <li>Faction</li> <li>Flora</li> <li>Furniture</li> <li>Hazard</li> <li>HeadPart</li> <li>Ingestible</li> <li>Ingredient</li> <li>Key</li> <li>Light</li> <li>Location</li> <li>MagicEffect</li> <li>MapMarker</li> <li>MaterialType</li> <li>Message</li> <li>MiscItem</li> <li>MoveableStatic</li> <li>MovementType</li> <li>Npc</li> <li>ObjectEffect</li> <li>PackageDataBool</li> <li>PackageDataFloat</li> <li>PackageDataInt</li> <li>PackageDataLocation</li> <li>PackageDataObjectList</li> <li>PackageDataTarget</li> <li>PackageDataTopic</li> <li>Perk</li> <li>Phoneme</li> <li>Projectile</li> <li>Quest</li> <li>QuestAlias</li> <li>Race</li> <li>RegionMap</li> <li>SceneAction</li> <li>ScenePhase</li> <li>ScriptBoolListProperty</li> <li>ScriptBoolProperty</li> <li>ScriptEntry</li> <li>ScriptFloatListProperty</li> <li>ScriptFloatProperty</li> <li>ScriptIntListProperty</li> <li>ScriptIntProperty</li> <li>ScriptObjectListProperty</li> <li>ScriptObjectProperty</li> <li>ScriptProperty</li> <li>ScriptStringListProperty</li> <li>ScriptStringProperty</li> <li>Scroll</li> <li>Shout</li> <li>SoulGem</li> <li>SoundCategory</li> <li>Spell</li> <li>TalkingActivator</li> <li>Tree</li> <li>Water</li> <li>Weapon</li> <li>WordOfPower</li> <li>Worldspace</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#iobjectbounded","title":"IObjectBounded","text":"<ul> <li>AcousticSpace</li> <li>Activator</li> <li>AddonNode</li> <li>AlchemicalApparatus</li> <li>Ammunition</li> <li>Armor</li> <li>ArtObject</li> <li>Book</li> <li>Container</li> <li>Door</li> <li>DualCastData</li> <li>Explosion</li> <li>Flora</li> <li>Furniture</li> <li>Grass</li> <li>Hazard</li> <li>IdleMarker</li> <li>Ingestible</li> <li>Ingredient</li> <li>Key</li> <li>LeveledItem</li> <li>LeveledNpc</li> <li>LeveledSpell</li> <li>Light</li> <li>MiscItem</li> <li>MoveableStatic</li> <li>Npc</li> <li>ObjectEffect</li> <li>Projectile</li> <li>Scroll</li> <li>SoulGem</li> <li>SoundMarker</li> <li>Spell</li> <li>Static</li> <li>TalkingActivator</li> <li>TextureSet</li> <li>Tree</li> <li>Weapon</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#iweightvalue","title":"IWeightValue","text":"<ul> <li>AlchemicalApparatus</li> <li>Ammunition</li> <li>Armor</li> <li>Book</li> <li>Ingestible</li> <li>Ingredient</li> <li>Key</li> <li>Light</li> <li>MiscItem</li> <li>Scroll</li> <li>SoulGem</li> <li>WeaponBasicStats</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#keyword","title":"Keyword","text":"<ul> <li>Keyword</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#concrete-classes-to-interfaces","title":"Concrete Classes to Interfaces","text":""},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#acousticspace","title":"AcousticSpace","text":"<ul> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#activator","title":"Activator","text":"<ul> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#actorvalueinformation","title":"ActorValueInformation","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#addonnode","title":"AddonNode","text":"<ul> <li>IModeled</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#alchemicalapparatus","title":"AlchemicalApparatus","text":"<ul> <li>IHasIcons</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#alternatetexture","title":"AlternateTexture","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#ammunition","title":"Ammunition","text":"<ul> <li>IHasIcons</li> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#animatedobject","title":"AnimatedObject","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#apackagedata","title":"APackageData","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#armor","title":"Armor","text":"<ul> <li>IKeyworded</li> <li>INamed</li> <li>IObjectBounded</li> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#armormodel","title":"ArmorModel","text":"<ul> <li>IHasIcons</li> <li>IModeled</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#artobject","title":"ArtObject","text":"<ul> <li>IModeled</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#bodydata","title":"BodyData","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#bodypart","title":"BodyPart","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#bodypartdata","title":"BodyPartData","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#book","title":"Book","text":"<ul> <li>IHasIcons</li> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#camerashot","title":"CameraShot","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#cell","title":"Cell","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#class","title":"Class","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#climate","title":"Climate","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#collisionlayer","title":"CollisionLayer","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#colorrecord","title":"ColorRecord","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#container","title":"Container","text":"<ul> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#destructionstage","title":"DestructionStage","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#dialogtopic","title":"DialogTopic","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#door","title":"Door","text":"<ul> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#dualcastdata","title":"DualCastData","text":"<ul> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#explosion","title":"Explosion","text":"<ul> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#eyes","title":"Eyes","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#faction","title":"Faction","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#flora","title":"Flora","text":"<ul> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#furniture","title":"Furniture","text":"<ul> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#grass","title":"Grass","text":"<ul> <li>IModeled</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#hazard","title":"Hazard","text":"<ul> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#headdata","title":"HeadData","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#headpart","title":"HeadPart","text":"<ul> <li>IModeled</li> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#idlemarker","title":"IdleMarker","text":"<ul> <li>IModeled</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#impact","title":"Impact","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#ingestible","title":"Ingestible","text":"<ul> <li>IHasIcons</li> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#ingredient","title":"Ingredient","text":"<ul> <li>IHasIcons</li> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#key","title":"Key","text":"<ul> <li>IHasIcons</li> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#keyword_1","title":"Keyword","text":"<ul> <li>Keyword</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#leveleditem","title":"LeveledItem","text":"<ul> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#levelednpc","title":"LeveledNpc","text":"<ul> <li>IModeled</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#leveledspell","title":"LeveledSpell","text":"<ul> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#light","title":"Light","text":"<ul> <li>IHasIcons</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#loadscreen","title":"LoadScreen","text":"<ul> <li>IHasIcons</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#location","title":"Location","text":"<ul> <li>IKeyworded</li> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#magiceffect","title":"MagicEffect","text":"<ul> <li>IKeyworded</li> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#mapmarker","title":"MapMarker","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#materialobject","title":"MaterialObject","text":"<ul> <li>IModeled</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#materialtype","title":"MaterialType","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#message","title":"Message","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#miscitem","title":"MiscItem","text":"<ul> <li>IHasIcons</li> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#moveablestatic","title":"MoveableStatic","text":"<ul> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#movementtype","title":"MovementType","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#npc","title":"Npc","text":"<ul> <li>IKeyworded</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#objecteffect","title":"ObjectEffect","text":"<ul> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#packagedatabool","title":"PackageDataBool","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#packagedatafloat","title":"PackageDataFloat","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#packagedataint","title":"PackageDataInt","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#packagedatalocation","title":"PackageDataLocation","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#packagedataobjectlist","title":"PackageDataObjectList","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#packagedatatarget","title":"PackageDataTarget","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#packagedatatopic","title":"PackageDataTopic","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#perk","title":"Perk","text":"<ul> <li>IHasIcons</li> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#phoneme","title":"Phoneme","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#projectile","title":"Projectile","text":"<ul> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#quest","title":"Quest","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#questalias","title":"QuestAlias","text":"<ul> <li>IKeyworded</li> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#race","title":"Race","text":"<ul> <li>IKeyworded</li> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#regiondata","title":"RegionData","text":"<ul> <li>IHasIcons</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#regionmap","title":"RegionMap","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#sceneaction","title":"SceneAction","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scenephase","title":"ScenePhase","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptboollistproperty","title":"ScriptBoolListProperty","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptboolproperty","title":"ScriptBoolProperty","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptentry","title":"ScriptEntry","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptfloatlistproperty","title":"ScriptFloatListProperty","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptfloatproperty","title":"ScriptFloatProperty","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptintlistproperty","title":"ScriptIntListProperty","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptintproperty","title":"ScriptIntProperty","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptobjectlistproperty","title":"ScriptObjectListProperty","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptobjectproperty","title":"ScriptObjectProperty","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptproperty","title":"ScriptProperty","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptstringlistproperty","title":"ScriptStringListProperty","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scriptstringproperty","title":"ScriptStringProperty","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#scroll","title":"Scroll","text":"<ul> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#shout","title":"Shout","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#soulgem","title":"SoulGem","text":"<ul> <li>IHasIcons</li> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#soundcategory","title":"SoundCategory","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#soundmarker","title":"SoundMarker","text":"<ul> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#spell","title":"Spell","text":"<ul> <li>IKeyworded</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#static","title":"Static","text":"<ul> <li>IModeled</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#talkingactivator","title":"TalkingActivator","text":"<ul> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#textureset","title":"TextureSet","text":"<ul> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#tree","title":"Tree","text":"<ul> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#water","title":"Water","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#weapon","title":"Weapon","text":"<ul> <li>IHasIcons</li> <li>IKeyworded</li> <li>IModeled</li> <li>INamed</li> <li>IObjectBounded</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#weaponbasicstats","title":"WeaponBasicStats","text":"<ul> <li>IWeightValue</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#wordofpower","title":"WordOfPower","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Aspect-Interfaces/#worldspace","title":"Worldspace","text":"<ul> <li>INamed</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/","title":"Skyrim Link Interfaces","text":""},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#skyrim-link-interfaces","title":"Skyrim Link Interfaces","text":""},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#link-interfaces","title":"Link Interfaces","text":"<p>Link Interfaces are used by FormLinks to point to several record types at once.  For example, a Container record might be able to contain Armors, Weapons, Ingredients, etc.</p> <p>An interface would be defined such as 'IItem', which all Armor, Weapon, Ingredients would all implement.</p> <p>A <code>FormLink&lt;IItem&gt;</code> could then point to all those record types by pointing to the interface instead.</p>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#interfaces-to-concrete-classes","title":"Interfaces to Concrete Classes","text":""},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ialiasvoicetype","title":"IAliasVoiceType","text":"<ul> <li>FormList</li> <li>Npc</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#icomplexlocation","title":"IComplexLocation","text":"<ul> <li>Cell</li> <li>Worldspace</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iconstructible","title":"IConstructible","text":"<ul> <li>AlchemicalApparatus</li> <li>Ammunition</li> <li>Armor</li> <li>Book</li> <li>Ingestible</li> <li>Ingredient</li> <li>Key</li> <li>Light</li> <li>MiscItem</li> <li>Scroll</li> <li>SoulGem</li> <li>Weapon</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#idialog","title":"IDialog","text":"<ul> <li>DialogResponses</li> <li>DialogTopic</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ieffectrecord","title":"IEffectRecord","text":"<ul> <li>ObjectEffect</li> <li>Spell</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iemittance","title":"IEmittance","text":"<ul> <li>Light</li> <li>Region</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iharvesttarget","title":"IHarvestTarget","text":"<ul> <li>Ingestible</li> <li>Ingredient</li> <li>LeveledItem</li> <li>MiscItem</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iidlerelation","title":"IIdleRelation","text":"<ul> <li>ActionRecord</li> <li>IdleAnimation</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iitem","title":"IItem","text":"<ul> <li>AlchemicalApparatus</li> <li>Ammunition</li> <li>Armor</li> <li>Book</li> <li>Ingestible</li> <li>Ingredient</li> <li>Key</li> <li>LeveledItem</li> <li>Light</li> <li>MiscItem</li> <li>Scroll</li> <li>SoulGem</li> <li>Weapon</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ikeywordlinkedreference","title":"IKeywordLinkedReference","text":"<ul> <li>APlacedTrap</li> <li>Keyword</li> <li>PlacedNpc</li> <li>PlacedObject</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ilinkedreference","title":"ILinkedReference","text":"<ul> <li>APlacedTrap</li> <li>PlacedNpc</li> <li>PlacedObject</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ilocationrecord","title":"ILocationRecord","text":"<ul> <li>Location</li> <li>LocationReferenceType</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ilocationtargetable","title":"ILocationTargetable","text":"<ul> <li>Door</li> <li>PlacedNpc</li> <li>PlacedObject</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ilocklist","title":"ILockList","text":"<ul> <li>FormList</li> <li>Npc</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#inpcspawn","title":"INpcSpawn","text":"<ul> <li>LeveledNpc</li> <li>Npc</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iobjectid","title":"IObjectId","text":"<ul> <li>Activator</li> <li>Ammunition</li> <li>Armor</li> <li>Book</li> <li>Container</li> <li>Door</li> <li>Faction</li> <li>FormList</li> <li>Furniture</li> <li>IdleMarker</li> <li>Ingestible</li> <li>Key</li> <li>Light</li> <li>MiscItem</li> <li>MoveableStatic</li> <li>Npc</li> <li>Projectile</li> <li>Scroll</li> <li>Shout</li> <li>SoundMarker</li> <li>Spell</li> <li>Static</li> <li>TextureSet</li> <li>Weapon</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ioutfittarget","title":"IOutfitTarget","text":"<ul> <li>Armor</li> <li>LeveledItem</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iowner","title":"IOwner","text":"<ul> <li>Faction</li> <li>PlacedNpc</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iplaced","title":"IPlaced","text":"<ul> <li>APlaced</li> <li>APlacedTrap</li> <li>PlacedNpc</li> <li>PlacedObject</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iplacedsimple","title":"IPlacedSimple","text":"<ul> <li>PlacedNpc</li> <li>PlacedObject</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iplacedthing","title":"IPlacedThing","text":"<ul> <li>APlacedTrap</li> <li>PlacedObject</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iplacedtraptarget","title":"IPlacedTrapTarget","text":"<ul> <li>Hazard</li> <li>Projectile</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#iregiontarget","title":"IRegionTarget","text":"<ul> <li>Flora</li> <li>LandscapeTexture</li> <li>MoveableStatic</li> <li>Static</li> <li>Tree</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#irelatable","title":"IRelatable","text":"<ul> <li>Faction</li> <li>Race</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#isound","title":"ISound","text":"<ul> <li>SoundDescriptor</li> <li>SoundMarker</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ispellspawn","title":"ISpellSpawn","text":"<ul> <li>LeveledSpell</li> <li>Spell</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#concrete-classes-to-interfaces","title":"Concrete Classes to Interfaces","text":""},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#actionrecord","title":"ActionRecord","text":"<ul> <li>IIdleRelation</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#activator","title":"Activator","text":"<ul> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#alchemicalapparatus","title":"AlchemicalApparatus","text":"<ul> <li>IConstructible</li> <li>IItem</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ammunition","title":"Ammunition","text":"<ul> <li>IConstructible</li> <li>IItem</li> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#aplaced","title":"APlaced","text":"<ul> <li>IPlaced</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#aplacedtrap","title":"APlacedTrap","text":"<ul> <li>IKeywordLinkedReference</li> <li>ILinkedReference</li> <li>IPlaced</li> <li>IPlacedThing</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#armor","title":"Armor","text":"<ul> <li>IConstructible</li> <li>IItem</li> <li>IObjectId</li> <li>IOutfitTarget</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#book","title":"Book","text":"<ul> <li>IConstructible</li> <li>IItem</li> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#cell","title":"Cell","text":"<ul> <li>IComplexLocation</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#container","title":"Container","text":"<ul> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#dialogresponses","title":"DialogResponses","text":"<ul> <li>IDialog</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#dialogtopic","title":"DialogTopic","text":"<ul> <li>IDialog</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#door","title":"Door","text":"<ul> <li>ILocationTargetable</li> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#faction","title":"Faction","text":"<ul> <li>IObjectId</li> <li>IOwner</li> <li>IRelatable</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#flora","title":"Flora","text":"<ul> <li>IRegionTarget</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#formlist","title":"FormList","text":"<ul> <li>IAliasVoiceType</li> <li>ILockList</li> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#furniture","title":"Furniture","text":"<ul> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#hazard","title":"Hazard","text":"<ul> <li>IPlacedTrapTarget</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#idleanimation","title":"IdleAnimation","text":"<ul> <li>IIdleRelation</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#idlemarker","title":"IdleMarker","text":"<ul> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ingestible","title":"Ingestible","text":"<ul> <li>IConstructible</li> <li>IHarvestTarget</li> <li>IItem</li> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#ingredient","title":"Ingredient","text":"<ul> <li>IConstructible</li> <li>IHarvestTarget</li> <li>IItem</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#key","title":"Key","text":"<ul> <li>IConstructible</li> <li>IItem</li> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#keyword","title":"Keyword","text":"<ul> <li>IKeywordLinkedReference</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#landscapetexture","title":"LandscapeTexture","text":"<ul> <li>IRegionTarget</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#leveleditem","title":"LeveledItem","text":"<ul> <li>IHarvestTarget</li> <li>IItem</li> <li>IOutfitTarget</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#levelednpc","title":"LeveledNpc","text":"<ul> <li>INpcSpawn</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#leveledspell","title":"LeveledSpell","text":"<ul> <li>ISpellSpawn</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#light","title":"Light","text":"<ul> <li>IConstructible</li> <li>IEmittance</li> <li>IItem</li> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#location","title":"Location","text":"<ul> <li>ILocationRecord</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#locationreferencetype","title":"LocationReferenceType","text":"<ul> <li>ILocationRecord</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#miscitem","title":"MiscItem","text":"<ul> <li>IConstructible</li> <li>IHarvestTarget</li> <li>IItem</li> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#moveablestatic","title":"MoveableStatic","text":"<ul> <li>IObjectId</li> <li>IRegionTarget</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#npc","title":"Npc","text":"<ul> <li>IAliasVoiceType</li> <li>ILockList</li> <li>INpcSpawn</li> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#objecteffect","title":"ObjectEffect","text":"<ul> <li>IEffectRecord</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#placednpc","title":"PlacedNpc","text":"<ul> <li>IKeywordLinkedReference</li> <li>ILinkedReference</li> <li>ILocationTargetable</li> <li>IOwner</li> <li>IPlaced</li> <li>IPlacedSimple</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#placedobject","title":"PlacedObject","text":"<ul> <li>IKeywordLinkedReference</li> <li>ILinkedReference</li> <li>ILocationTargetable</li> <li>IPlaced</li> <li>IPlacedSimple</li> <li>IPlacedThing</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#projectile","title":"Projectile","text":"<ul> <li>IObjectId</li> <li>IPlacedTrapTarget</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#race","title":"Race","text":"<ul> <li>IRelatable</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#region","title":"Region","text":"<ul> <li>IEmittance</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#scroll","title":"Scroll","text":"<ul> <li>IConstructible</li> <li>IItem</li> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#shout","title":"Shout","text":"<ul> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#soulgem","title":"SoulGem","text":"<ul> <li>IConstructible</li> <li>IItem</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#sounddescriptor","title":"SoundDescriptor","text":"<ul> <li>ISound</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#soundmarker","title":"SoundMarker","text":"<ul> <li>IObjectId</li> <li>ISound</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#spell","title":"Spell","text":"<ul> <li>IEffectRecord</li> <li>IObjectId</li> <li>ISpellSpawn</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#static","title":"Static","text":"<ul> <li>IObjectId</li> <li>IRegionTarget</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#textureset","title":"TextureSet","text":"<ul> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#tree","title":"Tree","text":"<ul> <li>IRegionTarget</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#weapon","title":"Weapon","text":"<ul> <li>IConstructible</li> <li>IItem</li> <li>IObjectId</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Link-Interfaces/#worldspace","title":"Worldspace","text":"<ul> <li>IComplexLocation</li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Perks/","title":"Skyrim Perks","text":""},{"location":"game-specific/skyrim/Skyrim-Perks/#skyrim-perks","title":"Skyrim Perks","text":""},{"location":"game-specific/skyrim/Skyrim-Perks/#perk-effect-types","title":"Perk Effect Types","text":"<p>The abstract base class is <code>APerkEffect</code> which is inherited by:</p> <ul> <li><code>PerkQuestEffect</code></li> <li><code>PerkAbilityEffect</code></li> <li><code>APerkEntryPointEffect</code></li> </ul>"},{"location":"game-specific/skyrim/Skyrim-Perks/#perk-entry-point-effect-types","title":"Perk Entry Point Effect Types","text":"<p>The abstract base class is <code>APerkEntryPointEffect</code> which is inherited by:</p> <ul> <li><code>PerkModifyValue</code></li> <li><code>PerkAddRangeToValue</code></li> <li><code>PerkModifyActorValue</code></li> <li><code>PerkAbsoluteValue</code></li> <li><code>PerkAddLeveledItem</code></li> <li><code>PerkAddActivateChoice</code></li> <li><code>PerkSelectSpell</code></li> <li><code>PerkSelectText</code></li> <li><code>PerkSetText</code></li> </ul>"},{"location":"hidden/Installing-Visual-Studio/","title":"Installing Visual Studio","text":"<p>Visual Studio is the typical IDE (Integrated Development Environment) used for C#.  It is used for writing code, error checking, building, running, debugging, etc.  There are alternatives such as Rider, or VSCode, but VS will be used in this 101 tutorial.</p>"},{"location":"hidden/Installing-Visual-Studio/#downloading-visual-studio","title":"Downloading Visual Studio","text":"<p>Here is the latest link for downloading Visual Studio.  Feel free to go to Microsoft's site or Google for it as well.</p> <p>You are after the \"Visual Studio Community Edition\", which is the free version available to everyone.</p>"},{"location":"hidden/Installing-Visual-Studio/#installation-options","title":"Installation Options","text":"<p>Visual Studio can be used for a variety of things, such as Web, Game, or Mobile, or even C++ coding.  The Visual Studio Installer lets you customize and choose what modules you want to install. </p>"},{"location":"hidden/Installing-Visual-Studio/#c-desktop-development-modules","title":"C# Desktop Development Modules","text":""},{"location":"hidden/Installing-Visual-Studio/#ensure-net-standard-21-is-installed","title":"Ensure .NET Standard 2.1 is Installed","text":""},{"location":"hidden/Installing-Visual-Studio/#let-it-install-start-it-up","title":"Let It Install, Start It Up","text":"<p>Click install.  Let it download and install everything.  It may want to restart your computer.  </p> <p>At this point, your Start Menu should have <code>Visual Studio Community</code> added and you can start it up.</p>"},{"location":"hidden/Installing-Visual-Studio/#initial-setup","title":"Initial Setup","text":""},{"location":"hidden/Installing-Visual-Studio/#skip-creatingopening-a-project-for-now","title":"Skip Creating/Opening a Project For Now","text":"<p>You can create a new project now, but that will be covered in the next section.  For now just skip things so we can get to Visual Studio for initial settings adjustments.</p>"},{"location":"hidden/Installing-Visual-Studio/#dark-mode","title":"Dark Mode","text":"<p>Obviously, you'll want to switch it into Dark Mode. <code>Tools -&gt; Options -&gt; Environment -&gt; General -&gt; Color Theme -&gt; Dark</code></p>"},{"location":"hidden/Installing-Visual-Studio/#keybinds","title":"Keybinds","text":"<p>There are a few keybind schemes you can choose from.  This bootstrap guide will use <code>Visual C# 2005</code> keybinds. <code>Tools -&gt; Options -&gt; Enviornment -&gt; Keyboard -&gt; \"Apply the following...\" Top dropdown</code></p> <p>ReSharper (JetBrains) is another popular alternative.  Feel free to choose your preferred setup.</p>"},{"location":"hidden/Installing-Visual-Studio/#good-to-go","title":"Good to Go","text":"<p>At this point, you should have Visual Studio installed and ready to create your first C# project.</p>"},{"location":"hidden/New-Project-With-Mutagen/","title":"Create a New Project","text":""},{"location":"hidden/New-Project-With-Mutagen/#create-a-new-project","title":"Create a New Project","text":"<p>At this point, you should have Visual Studio installed and open.</p> <p>You will want to create a new Project to get started.  A Project is a collection of code that results in either an executable (exe), or a reusable library (dll).</p> <p>You will want to make an executable project for this 101 tutorial. - <code>File -&gt; New -&gt; Project</code> - Find and select <code>Console App (.NET Core)</code>.   Note there are alternative options such as .NET Framework; Do not select those. - Modify the location to be to your preference</p> <p>Side note:  A Solution will be made alongside your initial project.  A Solution is just a workspace where multiple projects can exist, which may or may not use and be related to each other.  This then lets you build all projects at once if you have multiple.</p>"},{"location":"hidden/New-Project-With-Mutagen/#add-mutagen-via-nuget","title":"Add Mutagen via NuGet","text":""},{"location":"hidden/New-Project-With-Mutagen/#starter-project-automatically-added","title":"Starter Project Automatically Added","text":""},{"location":"linkcache/","title":"Link Cache","text":""},{"location":"linkcache/#link-cache","title":"Link Cache","text":"<p>The LinkCache is the record lookup engine.  It is made relative to any number of mods, and does complex lookups to find records.</p> <p>It powers a lot of functionality, such as:</p> <ul> <li>Looking up records by FormKey/FormLink</li> <li>Finding the Winning Override in a Load Order</li> <li>Iterating over all versions of a record within a Load Order</li> </ul>"},{"location":"linkcache/#construction","title":"Construction","text":"<p>Every LinkCache is created relative to some mods in \"listed\" order (as opposed to priority order).  It will look up and return records relative to these mods.  </p> SingleManyLoad Order <pre><code>ISkyrimModGetter aSingleMod = ...;\nvar linkCacheConnectedToMod = aSingleMod.ToImmutableLinkCache();\n</code></pre> <pre><code>IEnumerable&lt;ISkyrimModGetter&gt; anyListOfMods = ...;\nvar linkCacheConnectedToThoseMods = anyListOfMods.ToImmutableLinkCache();\n</code></pre> <pre><code>ILoadOrderGetter&lt;ISkyrimModGetter&gt; someLoadOrder = ...;\nvar linkCacheConnectedToLoadOrder = someLoadOrder.ToImmutableLinkCache();\n</code></pre> <p> Load Order</p>"},{"location":"linkcache/#mutability","title":"Mutability","text":"<p>It can often be a costly operation to look up records.   It is preferable to cache information so that future lookups can happen faster.   Depending on whether you want to mutate the mods a Link Cache looks to, you will need to choose the correct type of Link Cache with the correct caching patterns.</p>"},{"location":"linkcache/#immutable-link-caches","title":"Immutable Link Caches","text":"<p>If you do not plan to add/remove records from the Mods, it is always recommended to use Immutable Link Caches, as they will be much more optimized.  </p> <p>No Adds or Removes</p> <p>It is not safe to add or remove records from backing mods of Immutable Link Caches.  This can corrupt a cache.</p> <p>Record Content Modification is Safe</p> <p>It is safe to modify content ON records (Name of an Npc, Items in a Container, etc)</p>"},{"location":"linkcache/#mutable-link-caches","title":"Mutable Link Caches","text":"<p>Sometimes it is desirable to have a mod on a Link Cache that you are allowed to modify.  A common use case is having an outgoing mod file that will eventually be exported.  This mod would both like to be able to be modified while also being able to resolve its content from the Link Cache.</p> <p>In these scenarios, we can create a Mutable Link Cache.  This is a combination of an Immutable Link Cache for most of the mods in a load order, PLUS a mutable component for the final mods at the end that we want to modify.  As such there are a few things to consider:</p> <ul> <li>Most of the load order still gets the speed optimizations of being immutable</li> <li>We only pay the speed price when dealing with the one (few) mutable mods at the end.</li> <li>Because of this structure, the mutable mods MUST be at the end.</li> </ul> <pre><code>// Immutable, readonly load order\nILoadOrderGetter&lt;ISkyrimModGetter&gt; readOnlyLoadOrder = ...;\n\n// A mutable mod we want to be able to change\nSkyrimMod mod = new SkyrimMod(ModKey.FromFileName(\"MyMod.esp\"), SkyrimRelease.SkyrimSE);\n\nvar linkCache = readOnlyLoadOrder.ToMutableLinkCache(mutableMods: mod);\n\n// No problems here\nvar npc = mod.Npcs.AddNew();\n</code></pre> <p>The result will be a mostly immutable Link Cache, with a mutable component at the end for <code>mod</code>.  It it safe to add/remove records from <code>mod</code>, as the Link Cache will react and continue to return accurate results even after the changes.</p> <p>Slower</p> <p>Mutable link caches are slower, so always use Immutable variants when possible</p>"},{"location":"linkcache/#resolve-target","title":"Resolve Target","text":"Target Direction Intention Winning Later mods first Locates the version of a record that the game will utilize Origin Earlier mods first Locates the initial version of the record as it was originally defined <p>By default all interactions with a Link Cache have the Resolve Target of \"Winning\".</p>"},{"location":"linkcache/#memory-usage","title":"Memory Usage","text":"<p>When using Immutable Link Caches, references to records will be kept inside the cache.  This can lead to memory growth as records are queried.</p> <p>Mutable components of Link Caches do not cache records, and so will not use memory (beyond the memory used by the mutable mod itself).</p> <p>Since the LinkCache is just an object caching records relative to a context, you can easily release this memory by tossing your LinkCache away for the Garbage Collector to pick up once you're done with it, or want to make a new fresh cache.  (Perhaps a Clear() call will be added in the future, too)</p>"},{"location":"linkcache/#identifier-only-caches","title":"Identifier Only Caches","text":"<p>In some situations like the FormKey Picker, we only care about the FormKey and EditorID of records.  Caching the entire record is a waste of memory.</p> <pre><code>var linkCache = myLoadOrder.ToImmutableLinkCache(LinkCachePreferences.OnlyIdentifiers());\n</code></pre> <p>In this mode, the Link Cache will only store the FormKey/EditorID.  As such, any call that attempts to retrieve a record will throw an exception. Only certain calls that don't retrieve a whole record will be safe to use, namely <code>TryResolveIdentifier</code> or <code>AllIdentifiers</code>.</p>"},{"location":"linkcache/ModContexts/","title":"Mod Contexts","text":""},{"location":"linkcache/ModContexts/#mod-contexts","title":"Mod Contexts","text":"<p>Mod Contexts are an opt-in advanced alternative of most LinkCache functionality.  They provide extra contextual information needed to add additional useful features.</p> <p>A <code>ModContext</code> contains:</p> <ul> <li><code>Record</code> - The record itself</li> <li><code>ModKey</code> - The <code>ModKey</code> that the associated record came from.  Not where it was originally defined and declared, but rather what mod contained the version of the record as it is. (usually the winning override mod)</li> <li><code>Parent</code> - If dealing with a \"nested\" record like <code>PlacedObject</code>, this will contain a reference to the parent record (like a <code>Cell</code>).</li> </ul>"},{"location":"linkcache/ModContexts/#retrieving-a-modcontext","title":"Retrieving a ModContext","text":"<p>Usually you will be provided a state from which ModContexts can be retrieved</p> <p> Environments</p>"},{"location":"linkcache/ModContexts/#by-looping-winningoverrides","title":"By Looping WinningOverrides","text":"Top LevelNested <pre><code>foreach (var context in environment.LoadOrder.PriorityOrder.Npc().WinningContextOverrides())\n{\n    Console.WriteLine($\"Found npc {context.Record.FormKey} {context.Record.EditorID}, which was found in mod {context.ModKey}\");\n}\n</code></pre> <pre><code>foreach (var context in environment.LoadOrder.PriorityOrder.PlacedObject().WinningContextOverrides(environment.LinkCache))\n{\n    Console.WriteLine($\"Found object {context.Record.FormKey} {context.Record.EditorID}, which was found in mod {context.ModKey}\");\n}\n</code></pre> <p>LinkCache Required</p> <p>Nested records require a LinkCache in case they need to interact with other records</p>"},{"location":"linkcache/ModContexts/#by-linkcache-resolves","title":"By LinkCache Resolves","text":"TryGetGet <pre><code>IFormLinkGetter&lt;INpcGetter&gt; myFormLink = ...;\n\nif (myFormLink.TryResolveContext&lt;ISkyrimMod, ISkyrimModGetter, INpc, INpcGetter&gt;(environment.LinkCache, out var context))\n{\n    Console.WriteLine($\"Found npc {context.Record.FormKey} {context.Record.EditorID}, which was found in mod {context.ModKey}\");\n}\n</code></pre> <pre><code>IFormLinkGetter&lt;INpcGetter&gt; myFormLink = ...;\n\nvar context = myFormLink.ResolveContext&lt;ISkyrimMod, ISkyrimModGetter, INpc, INpcGetter&gt;(environment.LinkCache);\nConsole.WriteLine($\"Found npc {context.Record.FormKey} {context.Record.EditorID}, which was found in mod {context.ModKey}\");\n</code></pre> <p>Complex Generics</p> <p>This API call requires a lot of generic information.  More on that here.</p>"},{"location":"linkcache/ModContexts/#simple-contexts","title":"Simple Contexts","text":"<p>If the generic types are too demanding and you only are interested in non-mutating operations, then you can just request \"simple\" contexts.</p> TryGetGet <pre><code>IFormLinkGetter&lt;INpcGetter&gt; myFormLink = ...;\n\nif (myFormLink.TryResolveSimpleContext(environment.LinkCache, out var context))\n{\n    Console.WriteLine($\"Found npc {context.Record.FormKey} {context.Record.EditorID}, which was found in mod {context.ModKey}\");\n}\n</code></pre> <pre><code>IFormLinkGetter&lt;INpcGetter&gt; myFormLink = ...;\n\nvar context = myFormLink.ResolveSimpleContext(environment.LinkCache);\nConsole.WriteLine($\"Found npc {context.Record.FormKey} {context.Record.EditorID}, which was found in mod {context.ModKey}\");\n</code></pre>"},{"location":"linkcache/ModContexts/#features","title":"Features","text":""},{"location":"linkcache/ModContexts/#containing-modkey","title":"Containing ModKey","text":"<p>A ModContext can give you the ModKey of the mod file that contained the record. </p> <pre><code>var modContext = ...;\n\nConsole.WriteLine($\"The mod that contained this record: {modContext.ModKey}\");\nConsole.WriteLine($\"The mod that originally defined the record: {modContext.Record.FormKey.ModKey}\");\n</code></pre> <p>ModKey Interpretation Confusion</p> <p>Be aware that the ModKey from a ModContext is the mod that contained the version of the record contained.  This is a separate concept than the ModKey that originated the record initially, which is still accessible through the FormKey</p>"},{"location":"linkcache/ModContexts/#overridding-deep-records","title":"Overridding Deep Records","text":"<p>Records like PlacedObjects are hard to override, as they are nested underneath both Worldspace and Cell records, which must also be overridden in the process.   ModContexts abstract this away so that the call is a consistent single call, no matter if it is nested or not.</p> <pre><code>var modContext = ...;\nISkyrimMod outgoingMod = ...;\n\nvar overrideRecord = modContext.GetOrAddAsOverride(outgoingMod);\n</code></pre>"},{"location":"linkcache/ModContexts/#parent-concepts","title":"Parent Concepts","text":"<p>A ModContext has a reference to the parent record in nested scenarios, such as PlacedObject parent Cell or Worldspace</p>"},{"location":"linkcache/ModContexts/#parent-lookup","title":"Parent Lookup","text":"TryGetTryGetContextIsUnderneathTryGetSimpleContext <pre><code>var modContext = ...;\n\nif (modContext.TryGetParent&lt;IWorldspaceGetter&gt;(out var worldspace))\n{\n    Console.WriteLine($\"The record was underneath a worldspace: {worldspace.FormKey}\");\n}\n</code></pre> <pre><code>var modContext = ...;\n\nif (modContext.TryGetParentContext&lt;IWorldspace, IWorldspaceGetter&gt;(out var worldspaceContext))\n{\n    Console.WriteLine($\"The record was underneath a worldspace: {worldspaceContext.Record.FormKey}\");\n}\n</code></pre> <pre><code>var modContext = ...;\n\nif (modContext.IsUnderneath&lt;IWorldspaceGetter&gt;())\n{\n    Console.WriteLine($\"The record was underneath a worldspace\");\n}\n</code></pre> <pre><code>var modContext = ...;\n\nif (modContext.TryGetParentSimpleContext&lt;IWorldspaceGetter&gt;(out var worldspaceContext))\n{\n    Console.WriteLine($\"The record was underneath a worldspace: {worldspaceContext.FormKey}\");\n}\n</code></pre> <p>Recursive</p> <p>These calls are recursive, and do not need to be the first parent to succeed.  A PlacedObject context can retrieve the parent Worldspace in one call.</p>"},{"location":"linkcache/ModContexts/#parent-direct-access","title":"Parent Direct Access","text":"<pre><code>var modContext = ...;\n\nif (modContext.Parent.Record is ICellGetter cell)\n{\n    Console.WriteLine($\"The parent record was a cell: {cell.FormKey}\");\n}\n</code></pre> <p>Typeless</p> <p>The type that the parent is expected to be is not contained, so you must query for the correct object type that you expect.   It also must be the exact type that the parent is in order to match.</p>"},{"location":"linkcache/ModContexts/#complex-call-signature","title":"Complex Call Signature","text":"<p>Mod contexts require a lot of information about the types involved:</p> <ul> <li>Mod Type</li> <li>Record Type</li> <li>Setter and Getter variants</li> </ul> <p>In some circumstances, these types can be inferred, but sometimes when this isn't the case, then all generics need to be provided.</p>"},{"location":"linkcache/Previous-Override-Iteration/","title":"Previous Override Iteration","text":""},{"location":"linkcache/Previous-Override-Iteration/#previous-override-iteration","title":"Previous Override Iteration","text":"<p>LinkCache offers an easy way to dig deeper past winning overrides into the load order and access the non-winning versions of records from previous mods.</p> <p>Some important concepts to consider when Resolving:</p> <p> Scoping Type</p> <p> Resolve Target</p>"},{"location":"linkcache/Previous-Override-Iteration/#resolveall","title":"ResolveAll","text":"<p>This call will loop over all versions of a record.  If given a ResolveTarget, it will start looping at the end given.  For example, ResolveTarget.Winning will return the winning record first, and then loop all the way to the originating version last.</p> By FormLinkBy LinkCache <pre><code>IFormLinkGetter&lt;INpcGetter&gt; myLink = ...;\nILinkCache myLinkCache = ...;\n\nforeach (var record in myLink.ResolveAll(myLinkCache))\n{\n    Console.WriteLine($\"EditorID is {record.EditorID}\");\n}\n</code></pre> <pre><code>IFormLinkGetter&lt;INpcGetter&gt; myLink = ...;\nILinkCache myLinkCache = ...;\n\nforeach (var record in myLink.ResolveAll(myLinkCache))\n{\n    Console.WriteLine($\"EditorID is {record.EditorID}\");\n}\n</code></pre> <p>Context Variants Preferred</p> <p>This call only returns the records themselves.  The context variants will be able to inform you on where the record came from</p>"},{"location":"linkcache/Previous-Override-Iteration/#resolveallcontexts","title":"ResolveAllContexts","text":"<p><code>ResolveAllContexts</code> is an alternative that returns ModContext objects instead, which have a lot more information/tooling about where a record came from.</p> <pre><code>IFormLinkGetter&lt;INpcGetter&gt; formLink = ...;\n\nforeach (var npcRecordContext in npcLink.ResolveAllContexts&lt;ISkyrimMod, ISkyrimModGetter, INpc, INpcGetter&gt;(myLinkCache))\n{\n    Console.WriteLine($\"The Npc's EditorID is {npcRecordContext.Record.EditorID} in mod {npcRecordContext.ModKey}\");\n}\n</code></pre> <p>Refer to the Mod Contexts documentation for more information about type requirements on the call</p> <p> Mod Contexts</p>"},{"location":"linkcache/Previous-Override-Iteration/#best-practices","title":"Best Practices","text":"<p>It is important to only loop over what you need.  This allows the Link Cache to only parse as deep into the Load Order as it needs.</p> <p> Enumerable Laziness</p> <pre><code>// Break out of your loops if you're done\nforeach (var npcRecord in npcLink.ResolveAll(myLinkCache))\n{\n    if (HasWhatINeed(npcRecord))\n    {\n        // Stop looping\n        break;\n    }\n}\n\n// Or only take what you're interested in\nINpcGetter[] recordWithPreviousOverride = npcLink.ResolveAll(myLinkCache)\n    // This limits the looping to two levels deep, at most\n    .Take(2)\n    // Solidifies the results into an array for reuse\n    .ToArray();\n\n// Got the winning record\nvar winningRecord = recordWithPreviousOverride[0];\nif (recordWithPreviousOverride.Length &gt; 1)\n{\n    // And it has a previous override, too\n    var previousOverride = recordWithPreviousOverride[1];\n}\n</code></pre>"},{"location":"linkcache/Record-Resolves/","title":"Record Resolves","text":""},{"location":"linkcache/Record-Resolves/#record-resolve","title":"Record Resolve","text":"<p>Record resolves are the main feature that Link Caches provide:  looking up a record relative to some mods.</p> <p>Some important concepts to consider when Resolving:</p> <p> Scoping Type</p> <p> Resolve Target</p>"},{"location":"linkcache/Record-Resolves/#tryresolve","title":"TryResolve","text":"<p><code>TryResolve</code> is the typical call for looking up records pointed to by a FormKey.  Similar to how Control-Clicking a FormID in xEdit will bring you to the record a FormID points to.  It takes a LinkCache as a parameter to the call, which will inspect the content it is attached to (whether it's a load order or a single mod) and try to locate the record that matches:</p> <ul> <li>The FormKey (FormID)</li> <li>The type specified</li> </ul> <p>If found, the record returned will be from the mod latest in the load order which is the \"winning\" override.</p> <p>Subsequent Resolves</p> <p>For Immutable caches, the results will be cached, and subsequent resolves will be almost instant</p> FormLink Entry PointLinkCache Entry PointBy EditorIDBy FormKey <pre><code>ILinkCache myLinkCache = ...;\nIFormLinkGetter&lt;INpcGetter&gt; myLink = ...;\n\nif (myLink.TryResolve(myLinkCache, out var npc))\n{\n    Console.WriteLine($\"Found the npc! {npc.EditorID}\");\n}\n</code></pre> <pre><code>ILinkCache myLinkCache = ...;\nIFormLinkGetter&lt;INpcGetter&gt; myLink = ...;\n\nif (myLinkCache.TryResolve(myLink, out var record))\n{\n    Console.WriteLine($\"Found the npc! {npc.EditorID}\");\n}\n</code></pre> <pre><code>ILinkCache myLinkCache = ...;\nstring myEditorID = ...;\n\nif (myLinkCache.TryResolve&lt;INpcGetter&gt;(myEditorId, out var npc))\n{\n    Console.WriteLine($\"Found the npc! {npc.EditorID}\");\n}\n</code></pre> <pre><code>ILinkCache myLinkCache = ...;\nmyFormKey formKey = ...;\n\nif (myLinkCache.TryResolve(myFormKey, out var record))\n{\n    Console.WriteLine($\"Found the npc! {npc.EditorID}\");\n}\n</code></pre>"},{"location":"linkcache/Record-Resolves/#tryresolveidentifier","title":"TryResolveIdentifier","text":"<p>Sometimes you are not interested in getting the whole record.   The <code>TryResolveIdentifier</code> option lets you provide a FormKey to look up the associated EditorID, and vice versa.</p> <pre><code>ILinkCache myLinkCache = ...;\n    string myEditorID = ...;\n\nif (myLinkCache.TryResolveIdentifier(myEditorId, out var associatedFormKey))\n{\n    Console.WriteLine($\"Found a record! {associatedFormKey}\");\n}\n</code></pre> <p>This is often useful to use with lightweight Link Caches, which only deal in identifiers.</p> <p> Identifier Only Caches</p>"},{"location":"linkcache/Record-Resolves/#throwing-variants","title":"Throwing Variants","text":"<p>All API described above has non-Try variants that will throw an exception if the resolve is unsuccessful.  These can be useful if you know you want to short circuit and fail if a record is missing.</p>"},{"location":"linkcache/Scoping-Type/","title":"Scoping Type","text":""},{"location":"linkcache/Scoping-Type/#scoping-type","title":"Scoping Type","text":"<p>The supplied type to calls on a Link Cache are important as they allow the systems to reduce the records that needs to be searched.  This improves both speed and memory usage.   </p> <p>For example, if you know you only want to look up an <code>Npc</code>, then scope your calls to the type <code>Npc</code> so that only <code>Npc</code> records are parsed. </p> <p>To scope a call, simply provide a type that is the most specific for your needs, which can be done in a variety of ways.</p> Scoped Implicitly By FormLinkScoped By GenericScoped By ParameterUnscoped <pre><code>ILinkCache myLinkCache = ...;\nFormLink&lt;INpcGetter&gt; myFormLink = ...;\n\nif (myLinkCache.TryResolve(myFormLink, out var targetNpc))\n{\n    // Found the Npc\n}\n</code></pre> <pre><code>ILinkCache myLinkCache = ...;\nFormKey myFormKey = ...;\n\nif (myLinkCache.TryResolve&lt;INpcGetter&gt;(myFormKey, out var targetNpc))\n{\n    // Found the Npc\n}\n</code></pre> <pre><code>ILinkCache myLinkCache = ...;\nFormKey myFormKey = ...;\n\nif (myLinkCache.TryResolve(myFormKey, typeof(INpcGetter), out var targetNpc))\n{\n    // Found the Npc\n}\n</code></pre> <p>Use Generic When Possible</p> <p>This query will run optimally thanks to the passed in type, but the returned vartiable <code>targetNpc</code> will only be <code>ISkyrimMajorRecordGetter</code>, rather than <code>INpcGetter</code>, making it hard to use without further casting.  Using the generic alternative will improve this.</p> <pre><code>ILinkCache myLinkCache = ...;\nFormKey myFormKey = ...;\n\nif (myLinkCache.TryResolve(myFormKey, out var targetNpc))\n{\n    // Found the Npc\n}\n</code></pre> <p>Not Recommended</p> <p>This type of untyped query is allowed, but should only be used as a last resort</p> <p>Best Practices</p> <p>It is recommended to use \"Getter\" interfaces when specifying scoping types</p> <p> Prefer Getters</p>"},{"location":"linkcache/Scoping-Type/#situations-to-scope","title":"Situations to Scope","text":""},{"location":"linkcache/Scoping-Type/#link-interfaces","title":"Link Interfaces","text":"<p>Link Interfaces are \"umbrella\" interfaces that can point to many record types.</p> <p> Link Interfaces</p> <p>For example, <code>IItemGetter</code> can be:</p> <ul> <li>Ammunition</li> <li>Armor</li> <li>Books</li> <li>etc</li> </ul> <p>If you know you only care about <code>Armor</code> records, you can adjust your call to tighten to that scope.</p>"},{"location":"linkcache/Scoping-Type/#formlinks-pointing-to-all-major-records","title":"FormLinks Pointing to All Major Records","text":"<p>Some FormLinks do not have a known target type, and will be presented as \"any\" major record:  <code>IFormLinkGetter&lt;ISkyrimMajorRecordGetter&gt;</code></p> <p>These calls will be just as slow as providing no type at all.  If you have any idea of the record type you are looking for, you should provide it in these situations</p>"},{"location":"linkcache/Scoping-Type/#other","title":"Other","text":"<p>Depending on your coding situation, you might be fed a \"naked\" FormKey that has no type associated.  When using these as inputs for Link Cache API, provide a scope type if there is one for your coding situation.</p>"},{"location":"loadorder/","title":"Load Order","text":""},{"location":"loadorder/#load-order","title":"Load Order","text":"<p>A Load Order represents an ordered list of items with ModKeys, where the items later in the list \"win\" and override the records from previous items.  It also acts as a dictionary style object, able to look up entries by ModKey.</p>"},{"location":"loadorder/#entries","title":"Entries","text":"<p>The <code>LoadOrder&lt;T&gt;</code> class is generic, and can contain many types of objects.  These are often objects that expose the information you would expect from a Bethesda load order.</p> <p>Use Your Own</p> <p>You can use <code>LoadOrder&lt;T&gt;</code> containers to hold other types of objects, as long as they implement <code>IModKeyed</code> and so have a <code>ModKey</code></p>"},{"location":"loadorder/#load-order-listing","title":"Load Order Listing","text":"<p>These are entries that only have information that could be provided by a typical Bethesda load order file.</p> Field Type Description ModKey ModKey The ModKey associated with the entry Enabled bool Whether the entry is to be considered enabled in the game Ghosted bool Whether the entry is \"ghosted\" and has an extra suffix causes the game to ignore it FileName string File name of the entry, with ghost suffix included, if applicable <p> ModKey</p>"},{"location":"loadorder/#mod-listing","title":"Mod Listing","text":"<p>These objects expand upon Load Order Listings by providing disk information related to the mod file itself as it exists on disk.</p> <p>Additional Fields:</p> Field Type Description ExistsOnDisk bool Whether the mod exists on disk Mod TMod (generic) Mutagen mod object (null if missing from disk) <p>These fields depend on the context in which the LoadOrder object was constructed, such as what Data folder it was relative to.</p>"},{"location":"loadorder/#interacting-with-loadorder","title":"Interacting with LoadOrder","text":"<p><code>LoadOrder</code> as a container that is acts simultaneously like a dictionary and a list.  You will find the similar accessors of both in its API.</p>"},{"location":"loadorder/#priority-vs-listed-ordering","title":"Priority vs Listed Ordering","text":"<p>While <code>LoadOrder</code> is a \"list\" object, two properties are exposed for when you want to enumerate to help clarify behavior:</p> <ul> <li>ListedOrder - Enumerates items in the order they were listed</li> <li>PriorityOrder - Enumerates the items so that highest \"winning\" priority comes first</li> </ul> Example <pre><code>foreach (var mod in loadOrder.PriorityOrder)\n{\n   // ...\n}\n</code></pre> <p>Enumeration is exposed like this just for the extra clarification and to reduce confusion of what ordering things are being iterated.  This is more clearly iterating the highest priority mods first, and will probably have <code>Skyrim.esm</code> or whatever base game file last.</p>"},{"location":"loadorder/#accessing-specific-listings","title":"Accessing Specific Listings","text":"<p><code>LoadOrder</code> has a lot accessors for checking if certain mods are on the list, and retrieving them. </p><pre><code>ModKey modKey = ...;\nILoadOrder&lt;IModListing&lt;ISkyrimModGetter&gt;&gt; loadOrder = ...;\n\nif (loadOrder.TryGetValue(modKey, out var listing))\n{\n   // Load order had that mod\n}\n\n// Also has typical contains and index access\nif (loadOrder.ContainsKey(modKey))\n{\n    listing = loadOrder[modKey];\n}\n\n// There is also int index API\nint index = loadOrder.IndexOf(modKey);\nvar obj = loadOrder.TryGetAtIndex(index);\nif (obj != null)\n{\n   // Got the listing by index\n}\n\n// And Clear/Add\nloadOrder.Clear();\nloadOrder.Add(listing);\n</code></pre><p></p>"},{"location":"loadorder/#construction","title":"Construction","text":""},{"location":"loadorder/#via-environment","title":"Via Environment","text":"<p>Typically you will not construct a Load Order object yourself.  Using a Game Environment will have a Load Order for you to use based on the game installation you point to.</p> <p> Environments</p>"},{"location":"loadorder/#create-and-fill","title":"Create and Fill","text":"<p><code>LoadOrder</code> is just a normal object that you could declare and fill yourself.</p> <pre><code>TMyObject someObj = ...;\n\nvar loadOrder = new LoadOrder&lt;TMyObject&gt;();\nloadOrder.Add(someObj);\n</code></pre>"},{"location":"loadorder/#import","title":"Import","text":"<p>If you don't want a whole environment, and just want some convenience for importing a Load Order, this exists as well.</p> SimpleData Folder OverriddenExplicit Listings <pre><code>var loadOrder = LoadOrder.Import&lt;ISkyrimModGetter&gt;(GameRelease.SkyrimSE);\n</code></pre> <pre><code>var loadOrder = LoadOrder.Import&lt;ISkyrimModGetter&gt;(dataFolderPath, GameRelease.SkyrimSE);\n</code></pre> <pre><code>var listings = new List&lt;LoadOrderListing&gt;()\n{\n   new LoadOrderListing(ModKey.FromFileName(\"Skyrim.esm\"), enabled: true)\n};\n\nvar loadOrder = LoadOrder.Import&lt;ISkyrimModGetter&gt;(listings, GameRelease.SkyrimSE);\n</code></pre> <p>Prefer Getter Generic</p> <p>The choice of specifying Getter or Setter interfaces (<code>ISkyrimMod</code> vs <code>ISkyrimModGetter</code>) is important, as that will drive the style that the mods are imported with.  If the Getter is specified, then the more optimized Binary Overlay systems will be used.  If Setter is specified, then all the import work will need to be done up front into a mutable object.</p>"},{"location":"loadorder/#writing-a-load-order","title":"Writing a Load Order","text":"<p>A <code>LoadOrder</code> can also export its contents to a file. </p><pre><code>ILoadOrderGetter&lt;IModListingGetter&gt; loadOrder = ...;\n\nLoadOrder.Write(\n   somePath, \n   GameRelease.SkyrimSE,\n   loadOrder,\n   removeImplicitMods: true);\n</code></pre><p></p>"},{"location":"loadorder/#pluginlistings-and-creationclublistings","title":"PluginListings and CreationClubListings","text":"<p>The Load Order API often abstracts away the complications that a Load Order is driven from a few sources:</p> <ul> <li>Implicit Listings (Mods that don't need to be listed, but are assumed)</li> <li>Normal Plugins File (Plugins.txt)</li> <li>Installed Creation Club Mods ([GameName].ccc)</li> </ul> <p>Logic related to each concept lives in its own class:</p> <ul> <li>Implicits.Listings</li> <li>PluginListings</li> <li>CreationClubListings</li> </ul> <p>In each you will be able to do tasks related to that specific load order source concept.</p>"},{"location":"loadorder/Winning-Overrides/","title":"Winning Override Iteration","text":""},{"location":"loadorder/Winning-Overrides/#winning-override-iteration","title":"Winning Override Iteration","text":"<p>It is very common task to retrieve the \"winning override\" version of each record on a Load Order.  Winning Overrides are the versions of each record as they exist in the mod with the highest priority, and will thus be what's used by the game when running.</p> <p>There are extension methods to streamline these operations.</p> <p>How To Override a Record</p> <p>This page outlines how to see the winning overrides in an existing load order.  If you then want to modify them further with your own override, this topic is covered more in depth here.</p> <p> Overriding Records</p>"},{"location":"loadorder/Winning-Overrides/#winning-overrides","title":"Winning Overrides","text":"By Load OrderArbitrary Mods <pre><code>LoadOrder&lt;ModListing&lt;ISkyrimModGetter&gt;&gt; loadOrder = ...;\n\nforeach (var npc in loadOrder.PriorityOrder.Npc().WinningOverrides())\n{\n   Console.WriteLine($\"Processed {npc.EditorID}\");\n}\n</code></pre> <pre><code>IEnumerable&lt;IModGetter&gt; mods = ...;\n\nforeach (var npc in mods.WinningOverrides&lt;INpcGetter&gt;())\n{\n   Console.WriteLine($\"Processed {npc.EditorID}\");\n}\n</code></pre>"},{"location":"loadorder/Winning-Overrides/#winning-context-overrides","title":"Winning Context Overrides","text":"<p>You can also iterate over Mod Context objects, which give more information and have more features that just looping the raw records.</p> <p> Mod Contexts</p> <p> Link Caches</p> By Load OrderArbitrary Mods <pre><code>LoadOrder&lt;ModListing&lt;ISkyrimModGetter&gt;&gt; loadOrder = ...;\nILinkCache linkCache = ...;\n\nforeach (var context in loadOrder.PriorityOrder.PlacedObjects().WinningContextOverrides(linkCache))\n{\n   Console.WriteLine($\"Processed {context.Record.EditorID}\");\n}\n</code></pre> <pre><code>IEnumerable&lt;ISkyrimModGetter&gt; mods = ...;\nILinkCache linkCache = ...;\n\nforeach (var context in mods.WinningOverrideContexts&lt;ISkyrimMod, ISkyrimModGetter, IPlacedObject, IPlacedObjectGetter&gt;(linkCache))\n{\n   Console.WriteLine($\"Processed {context.Record.EditorID}\");\n}\n</code></pre>"},{"location":"lowlevel/","title":"Low Level Tools","text":""},{"location":"lowlevel/#low-level-tools","title":"Low Level Tools","text":"<p>The API and tools listed in the Plugin Record Suite are intended to expose Bethesda records in an organized, strongly typed, and less error prone fashion.  However, some tasks and some users require a less safe and more direct approach to get the job done.</p> <p>This section is about some of the mechanics and tools under the hood, and are recommended for more advanced users.</p>"},{"location":"lowlevel/Binary-Streams/","title":"Binary Streams","text":""},{"location":"lowlevel/Binary-Streams/#binary-streams","title":"Binary Streams","text":""},{"location":"lowlevel/Binary-Streams/#binaryreadstream","title":"BinaryReadStream","text":"<p><code>IBinaryReadStream</code> is an interface that exposes binary extraction from a stream, with <code>BinaryReadStream</code> being a basic implementation.  The interface offers calls to read <code>int</code>, <code>short</code>, <code>uint</code>, <code>double</code>, <code>byte[]</code>, and even newer concepts such as <code>ReadOnlySpan&lt;byte&gt;</code> and <code>ReadOnlyMemorySlice&lt;byte&gt;</code>.</p>"},{"location":"lowlevel/Binary-Streams/#mutagenbinaryreadstream","title":"MutagenBinaryReadStream","text":"<p>This is just a further extension on BinaryReadStream, offering additionally:</p> <ul> <li>A Header Struct object for reference when alignment is important</li> <li>An offset member, to help calculate position relative to a source file, if the MutagenBinaryReadStream happens to be a substream on only a slice of data.</li> </ul>"},{"location":"lowlevel/Binary-Utility/","title":"Binary Utility","text":""},{"location":"lowlevel/Binary-Utility/#binary-utility","title":"Binary Utility","text":""},{"location":"lowlevel/Binary-Utility/#binarystringutility","title":"BinaryStringUtility","text":"<p>Bethesda games store their strings on disk in a single byte format, with a null terminator.  There are some convenience parsing functions inside <code>BinaryStringUtility</code> to convert these to C# strings.</p>"},{"location":"lowlevel/Binary-Utility/#tozstring","title":"ToZString","text":"<p>This function assumes the entire input span is bytes that need to be converted to a string.  There should be no null termination at the end, or it will be included in the resulting string.</p>"},{"location":"lowlevel/Binary-Utility/#processwholetozstring","title":"ProcessWholeToZString","text":"<p>This function assumes the entire input span is part of the string, and may have a null termination.  It will trim off the null termination if it exists, and return a string.  Good for typical use. </p><pre><code>var subRecordBytes = ...;\nvar subRecordFrame = meta.SubRecordFrame(someBytes.AsSpan());\nstring str = BinaryStringUtility.ProcessWholeToZString(subRecordFrame.Content);\n</code></pre><p></p>"},{"location":"lowlevel/Binary-Utility/#parseunknownlengthstring","title":"ParseUnknownLengthString","text":"<p>Sometimes you might not be able to trim your input span to a string's contents exactly.  This call will help by locating the first null byte, and retrieving the string up until that point. </p><pre><code>var bytesOfUnknownLength = ...;\nstring str = BinaryStringUtility.ParseUnknownLengthString(bytesOfUnknownLength.AsSpan());\nvar amountParsed = str.Length + 1; // +1 for the null termination that was trimmed\n</code></pre><p></p>"},{"location":"lowlevel/Binary-Utility/#subrecord-iteration-and-location","title":"SubRecord Iteration and Location","text":"<p>There are some convenience methods for iterating and locating Subrecords in a set of raw bytes in <code>UtilityTranslation</code>.  These are extension methods onto <code>HeaderConstants</code> and <code>MajorRecordFrame</code>, so they can be used directly from those objects.</p>"},{"location":"lowlevel/Binary-Utility/#enumeratesubrecords","title":"EnumerateSubrecords","text":"<p>Print some metadata for all Subrecords in a MajorRecord </p><pre><code>var meta = HeaderConstants.Skyrim;\nbyte[] majorRecordBytes = ...;\nvar majorFrame = meta.MajorRecordFrame(majorRecordBytes.AsSpan());\n\nforeach (KeyValuePair&lt;RecordType, int&gt; loc in majorFrame.EnumerateSubrecords())\n{\n    // Scope to the start of the subrecord's data, relative to the MajorRecord content\n    var subRecordSpan = majorFrame.Content.Slice(loc.Value);\n    var subHeader = meta.SubRecord(subRecordSpan);\n    System.Console.WriteLine($\"Found subrecord {loc.Key} at position {loc.Value}, with length {subHeader.ContentLength}\");\n}\n</code></pre><p></p>"},{"location":"lowlevel/Binary-Utility/#tryfindfirstsubrecord","title":"TryFindFirstSubrecord","text":"<p>This call returns the first location of a subrecord type.  Good for locating a specific subrecord </p><pre><code>if (majorFrame.TryFindFirstSubrecord(\"EDID\", out SubRecordFrame subFrame))\n{\n    System.Console.WriteLine($\"Found EDID with length {subFrame.Header.ContentLength}: \");\n    System.Console.WriteLine($\"   {BinaryStringUtility.ProcessWholeToZString(subFrame.Content)}\");\n}\n</code></pre><p></p>"},{"location":"lowlevel/Binary-Utility/#findfirstsubrecords","title":"FindFirstSubrecords","text":"<p>This call returns the first location of each subrecord type queried for.  Good for finding a set of subrecords in one pass. </p><pre><code>var finds = majorFrame.FindFirstSubrecords(\"EDID\", \"FULL\");\n// If EDID found\nif (finds[0] != -1)\n{\n    // Scope to the start of the subrecord's data, relative to the MajorRecord content\n    var subRecordSpan = majorFrame.Content.Slice(finds[0]);\n    var subFrame = meta.SubRecord(subRecordSpan);\n    System.Console.WriteLine($\"Found EDID with length {subFrame.Header.ContentLength}: \");\n    System.Console.WriteLine($\"   {BinaryStringUtility.ProcessWholeToZString(subFrame.Content)}\");\n}\n\n// If FULL found\nif (finds[1] != -1)\n{\n    // Scope to the start of the subrecord's data, relative to the MajorRecord content\n    var subRecordSpan = majorFrame.Content.Slice(finds[1]);\n    var subFrame = meta.SubRecord(subRecordSpan);\n    System.Console.WriteLine($\"Found FULL with length {subFrame.Header.ContentLength}: \");\n    System.Console.WriteLine($\"   {BinaryStringUtility.ProcessWholeToZString(subFrame.Content)}\");\n}\n</code></pre><p></p>"},{"location":"lowlevel/Binary-Utility/#compilefirstsubrecordlocations","title":"CompileFirstSubrecordLocations","text":"<p>Similar to FindFirstSubrecords, except the results are put into a <code>Dictionary&lt;RecordType, int&gt;</code> for cleaner use.  Comes at the cost of higher overhead to construct this dictionary.  Another low cost alternative is just using <code>EnumerateSubrecords</code> with a <code>switch</code> statement.</p> <pre><code>var edid = new RecordType(\"EDID\");\nvar full = new RecordType(\"FULL\");\nvar finds = majorFrame.CompileFirstSubrecordLocations(edid, full);\n\n// If EDID found\nif (finds.TryGetValue(edid, out var loc))\n{\n    // Scope to the start of the subrecord's data, relative to the MajorRecord content\n    var subRecordSpan = majorFrame.Content.Slice(loc);\n    var subFrame = meta.SubRecord(subRecordSpan);\n    System.Console.WriteLine($\"Found EDID with length {subFrame.Header.ContentLength}: \");\n    System.Console.WriteLine($\"   {BinaryStringUtility.ProcessWholeToZString(subFrame.Content)}\");\n}\n\n// If FULL found\nif (finds.TryGetValue(full, out loc))\n{\n    // Scope to the start of the subrecord's data, relative to the MajorRecord content\n    var subRecordSpan = majorFrame.Content.Slice(loc);\n    var subFrame = meta.SubRecord(subRecordSpan);\n    System.Console.WriteLine($\"Found FULL with length {subFrame.Header.ContentLength}: \");\n    System.Console.WriteLine($\"   {BinaryStringUtility.ProcessWholeToZString(subFrame.Content)}\");\n}\n</code></pre>"},{"location":"lowlevel/Binary-Utility/#recordlocator","title":"RecordLocator","text":"<p><code>RecordLocator</code> is a convenience class that processes a mod stream and returns all the locations of Groups and MajorRecords.</p> <p>It takes a few optional arguments:</p> <ul> <li>RecordInterest, to limit the search to specific <code>RecordType</code>s</li> <li>Additional Criteria lambda, to add custom filter logic</li> </ul> <pre><code>using var stream = new MutagenReadStream(pathToMod, HeaderConstants.Skyrim);\nRecordLocator.FileLocations locs = RecordLocator.FileLocations.GetFileLocations(\n    stream,\n    // Only search for NPCs\n    new RecordInterest(\"NPC_\"),\n    // That are compressed\n    additionalCriteria: (stream, recordType, recLength) =&gt;\n    {\n        var majorHeader = stream.Meta.GetMajorRecord(stream);\n        return majorHeader.IsCompressed;\n    });\n\n/// Can enumerate Group locations\nforeach (var groupLoc in locs.GrupLocations)\n{\n   System.Console.WriteLine($\"Group located at: {groupLoc}\");\n}\n\n/// Can enumerate MajorRecord locations\nforeach (KeyValuePair&lt;long, (FormID FormID, RecordType Record)&gt; recLoc in locs.ListedRecords)\n{\n   System.Console.WriteLine($\"MajorRecord located at: {recLoc.Key}, {recLoc.Value.FormID}\");\n}\n\n/// Can query a specific FormID's location\nif (locs.TryGetSection(someFormID, out RangeInt64 loc))\n{\n   stream.Position = loc.Min;\n   var header = stream.Meta.ReadMajorRecord(stream);\n   System.Console.WriteLine($\"MajorRecord type: {header.RecordType}\");\n}\n\n/// Can query what record exists at a location\nif (locs.TryGetRecord(loc: 0x1234, out (FormID FormID, RecordType Record) rec))\n{\n   System.Console.WriteLine($\"{rec.Record}: {rec.FormID}\");\n}\n\n/// Can enumerate the parent Group locations for a FormID\nforeach (var groupLoc in locs.GetContainingGroupLocations(someFormID))\n{\n   stream.Position = groupLoc;\n   var groupHeader = stream.Meta.ReadGroupHeader(stream);\n   System.Console.WriteLine($\"{someFormID} has parent group at: {groupLoc}.  Type: {groupHeader.GroupType}\");\n}\n</code></pre> <p>This class just provides a common use case of locating records.  If more fine tuned logic is needed, just fall back to using Header Struct parsing yourself with the extra logic you need.</p> <p>Note that this class uses FormID, and does not make use of the abstraction concepts found in ModKey, FormKey, FormLink</p>"},{"location":"lowlevel/Binary-Utility/#decompression","title":"Decompression","text":"<p>MajorRecords with their compression flag enabled come in a compressed format.  The byte content needs to be unzipped before it can be read.</p>"},{"location":"lowlevel/C%23-Span/","title":"C# Span","text":""},{"location":"lowlevel/C%23-Span/#c-span","title":"C# Span","text":"<p><code>Span</code>s are not a Mutagen concept, but rather a general C# concept.  However, since they are used extensively by Mutagen's parsing systems and they are a newer concept just recently added to C#, it will be covered to some extent here.</p> <p>If you are more interested in Mutagen-specific concepts, you can skip this section.</p>"},{"location":"lowlevel/C%23-Span/#spans-are-sub-sections-of-arrays","title":"Spans are Sub-Sections of Arrays","text":"<p>A <code>Span&lt;T&gt;</code> is very similar to a <code>T[]</code>.  It points to a spot in memory where T objects reside, like an array.  Consider using a typical array, however, where you wanted some logic to process just a subsection of it.  You would either have to:</p> <ul> <li>Pass the array to a function, with <code>start</code> and <code>end</code> indices of where you wanted to process.</li> <li>Make a new smaller array, and copy the data over, using that array with just the interesting data to represent a \"subsection\" of the original array.</li> </ul> <p><code>Span&lt;T&gt;</code> would be an alternate way of handling the above problem.  It lets you \"scope\" to a small subsection of an array, without actually creating a new array. </p><pre><code>byte[] originalArray = new byte[150];\n\n// This scopes to only \"contain\" 5 bytes, framing indices 10-14 of the original array\nSpan&lt;byte&gt; subSection = originalArray.AsSpan(10, 5);\n\n// This scopes in even farther, pointing to indices 2-3 of subSection,\n// which are also the indices 12-13 of the original array.\nSpan&lt;byte&gt; evenSmallerSection = subSection.Slice(2, 2);\n\n// Modify a byte in the smaller sub section, affecting the single common array at index 13\nevenSmallerSection[1] = 123;\n</code></pre><p></p> <p>Changing the value in <code>evenSmallerSection</code> will affect all others; They point to the same underlying array and space in memory.</p>"},{"location":"lowlevel/C%23-Span/#faster-substring-alternative","title":"Faster Substring Alternative","text":"<p>Trimming off or grabbing a few characters on a <code>string</code> using Substring() means allocating a whole 2nd string with mostly the same data, just some characters trimmed off.  This is a fairly wasteful operation.</p> <p><code>Span</code> concepts are great for Substring logic, as the original <code>string</code> memory can be reused while Span just points to small substrings of the original string without copies or new allocations.</p> <pre><code>string str = \"Junk Good Stuff Junk\";\nSpan&lt;char&gt; origSpan = str.AsSpan();\n\n// Equivalent to .Substring(5) to get rid of first Junk\nSpan&lt;char&gt; result = origSpan.Slice(4);\n\n// Get rid of second junk by using TrimEnd of string \"Junk\"\nresult = result.TrimEnd(\"Junk\".AsSpan());\n\n// Trim whitespace\nresult = result.Trim();\n\n// Print \"Good Stuff\"\nSystem.Console.WriteLine(result.ToString());\n\n// Note that the above call still has to call ToString(), which does allocate a new string with \"Good Stuff\".\n// But at least we avoided several new transition strings while we were processing to our end result.\n\n// Additionally, the WriteLine() API might be upgraded in C# to eventually take ReadOnlySpan&lt;char&gt; as input, too\n</code></pre>"},{"location":"lowlevel/C%23-Span/#interpreting-data-as-another-type","title":"Interpreting Data as Another Type","text":"<p>Another cool trick <code>Span</code>s can do is overlay on top of a <code>byte[]</code> a <code>Span</code> of a different type: </p><pre><code>byte[] someBytes = new byte[16];\n// Fill with some data\n\n// \"Overlay\" a uint Span on our bytes\nSpan&lt;uint&gt; uintSpan = someBytes.AsUInt32Span();\n\n// Retrieve the uint contained in bytes 4-7\nuint secondNumber = uintSpan[1];\n\n// Will loop 4 times\nfor (int i = 0 ; i &lt; uintSpan.Length ; i++) \n{\n   // Print all 4 uints\n   System.Console.WriteLine(uintSpan[i]);\n\n   // Can also set original data.  Setting bytes to FFFF\n   uintSpan[i] = uint.MaxValue;\n}\n\n// All bytes in someBytes now contain 255 / 0xFF\n</code></pre><p></p>"},{"location":"lowlevel/C%23-Span/#parsing-data-from-span","title":"Parsing Data from Span","text":"<p>Numeric primitives can be extracted from a <code>Span&lt;byte&gt;</code> fairly easily: </p><pre><code>Span&lt;byte&gt; span = ...;\n\n// Read int from span's bytes starting at index 0\nint i = BinaryPrimitives.ReadInt32LittleEndian(span);\n\n// Read short from span's bytes starting at index 7 (going to index 8)\nshort s = BinaryPrimitives.ReadInt16LittleEndian(span.Slice(7));\n</code></pre><p></p> <p>Strings (at least in the realm of Mutagen) are not as easily extracted, as <code>char</code> is 2 bytes in C#, while Bethesda binary has 1 byte chars and have null termination concepts.  There are utility functions provided by Mutagen for this, though. </p><pre><code>Span&lt;byte&gt; span = ...;\n\n// Find next null termination, convert bytes to standard C# string\nstring str = BinaryStringUtility.ProcessWholeToZString(span);\n\n// Assumes entire span is relevant string information, and will turn\n// all contained bytes into a resulting string\nstr = BinaryStringUtility.ToZString(span.Slice(11, 23));\n</code></pre><p></p>"},{"location":"lowlevel/C%23-Span/#memoryslice-alternative-for-non-stack-usage","title":"MemorySlice Alternative for Non-Stack Usage","text":"<p>One of the major downsides of <code>Span</code> is that it is a <code>ref struct</code> which can only \"live\" on the stack.  This means it cannot be a member of a class, or even be associated with async/await concepts, among other things.</p> <p>In this case, <code>MemorySlice</code> is an alternative concept (subsection of an array) that can live outside of the stack.</p>"},{"location":"lowlevel/Game-Constants/","title":"Game Constants","text":""},{"location":"lowlevel/Game-Constants/#game-constants","title":"Game Constants","text":"<p>As Bethesda games are released, headers are modified slightly.  They still have a lot in common, but certain things move or the total length changes, or something else that will misalign any common parsing code.</p> <p><code>GameConstants</code> is a class containing all the various alignment information specific to a game.  Things like:</p> <ul> <li>ModHeaderLength</li> <li>HeaderIncludedInLength</li> <li>LengthLength (amount of bytes the 'length' section is)</li> <li>Etc</li> </ul> <p><code>GameConstants</code> also has static instances of itself for each Bethesda game, so that users can look up the specific header details for a specific game.  There is also a <code>GameCategory</code> enum that can be used to query to get the constants: </p><pre><code>var oblivionHeaderData = GameConstants.Oblivion;\n// An alternate way\noblivionHeaderData = GameConstants.Get(GameCategory.Oblivion);\nvar headerLength = oblivionHeaderData.MajorConstants.HeaderLength;\n</code></pre><p></p> <p>The usefulness of this \"registry\" is that code can be written once, while referring to a header meta object to account for differences in the games.  Give the code a different meta object to refer to for the appropriate game, and all the alignment works out.</p>"},{"location":"lowlevel/Header-Structs/","title":"Header Structs","text":""},{"location":"lowlevel/Header-Structs/#header-structs","title":"Header Structs","text":"<p>Header Structs are lightweight overlays that \"lay\" on top of some bytes and offers API to retrieve the various header fields or content bytes they contain.  They are extremely cheap to create, as they do no parsing unless asked.  They are aware of any differences in data alignments from game to game, so the same systems can be applied even if alignments change slightly.</p> <p>Using Header Structs, very performant and low level parsing is possible while retaining a large degree of safety and usability.  </p> <p>Some notable features:</p> <ul> <li>Alignment is handled internally.  User can access the fields they are interested in, without needing to worry about proper offsetting.</li> <li>No parsing is done except what the user asks for.  If only one field is accessed, then most of the header data will remain unparsed, and that work skipped.</li> <li>Code written with this setup can work with any Bethesda game, as swapping out Game Constants will realign everything properly.</li> <li>No data is copied, as the structs are simply overlaid on top of the original source bytes.</li> </ul> <p>They still require a lot of knowledge of the underlying binary structures of a mod, but the system goes a long way to empower the user to do it quickly, and with minimal potential for typo or misalignment errors.</p>"},{"location":"lowlevel/Header-Structs/#example-usage","title":"Example Usage","text":"<p>The following code will print all EditorIDs of all npcs from any game type. </p><pre><code>string filePath = ...;\nGameRelease release = ...;\nvar encoding = MutagenEncodingProvider.Instance.GetEncoding(release, Language.English);\n\nusing var stream = new MutagenBinaryReadStream(filePath, release);\n\n// Skip mod header\nstream.ReadModHeaderFrame();\n\n// Keep reading group frames out of the stream\nwhile (stream.TryReadGroupFrame(out var groupFrame))\n{\n    // Check that the group contains NPCs\n    if (groupFrame.ContainedRecordType != RecordTypes.NPC_) continue;\n\n    // Loop over all major record structs in the group's content\n    foreach (var majorPin in groupFrame)\n    {\n        // Iterate and search the subrecords for EDID\n        if (majorPin.Frame.TryLocateSubrecordFrame(RecordTypes.EDID, out var subFrame))\n        {\n            // Interpret the subrecord's content as a string and print\n            System.Console.WriteLine($\"{majorFrame.FormID} =&gt; {subFrame.AsString(encoding)}\");\n        }\n    }\n\n    // We found a matching NPC group, we'll assume there's no others and break\n    break;\n}\n</code></pre><p></p> <p>This code will only do the minimal parsing necessary to locate/print the EditorIDs.  Most data will be skipped over and left unparsed.</p>"},{"location":"lowlevel/Header-Structs/#headers-frames-and-pins","title":"Headers, Frames and Pins","text":"<p>Header Structs come in a few combinations and flavors.  The above code makes use of several of them.</p>"},{"location":"lowlevel/Header-Structs/#categories","title":"Categories","text":"<p>There are Header Structs for:</p> <ul> <li>Groups</li> <li>MajorRecords</li> <li>Subrecords</li> <li>ModHeader</li> </ul> <p>These are the few different types of records we can expect to encounter in a mod file, and there is a separate struct for each, offering the specific API for its type.</p>"},{"location":"lowlevel/Header-Structs/#flavors","title":"Flavors","text":"<p>Each category also comes in a few flavors.</p>"},{"location":"lowlevel/Header-Structs/#header","title":"Header","text":"<p>This is the most basic version that has been discussed in the descriptions above.  It overlays on top of bytes and offers API to access the various aspects of the header.</p> <p>Typical accessors include:</p> <ul> <li><code>RecordType</code> that the header is (EDID, NPC_, etc)</li> <li><code>HeaderLength</code></li> <li><code>ContentLength</code></li> <li><code>TotalLength</code></li> <li>Other fields more specialized for the category (<code>MajorRecordFlags</code>, <code>FormID</code>, etc)</li> </ul> <p>All of these fields align themselves properly by bouncing off a Game Constantsobject which has all the appropriate alignment information.</p>"},{"location":"lowlevel/Header-Structs/#frame","title":"Frame","text":"<p>Frames add a single additional member <code>ReadOnlyMemorySlice&lt;byte&gt; Content { get; }</code>, and thus overlay on top of a whole record in its entirety, both the header and its content.  This struct offers a nice easy package to access anything about an entire record in one location.</p>"},{"location":"lowlevel/Header-Structs/#pin","title":"Pin","text":"<p>Pins add yet another single additional member <code>int Location { get; }</code>.  This represents the location a frame exists relative to its parent.  This facilitates parsing and operations where knowing a record's location is important.</p>"},{"location":"lowlevel/Header-Structs/#additional-functionality","title":"Additional Functionality","text":""},{"location":"lowlevel/Header-Structs/#iteration","title":"Iteration","text":"<p>Both Group and MajorRecord Frames offer iteration functionality. </p><pre><code>foreach (var subrecordPin in majorRecordFrame)\n{\n   ...\n}\n</code></pre> This allows the user to easily iterate and process contained records without needing to manually construct and align the headers themselves.<p></p>"},{"location":"lowlevel/Header-Structs/#subrecord-location","title":"Subrecord Location","text":"<p>MajorRecord Frames also have API for searching for a specific subrecord type.</p> <pre><code>var edidType = new RecordType(\"EDID\");\nif (majorRecordFrame.TryLocateSubrecordFrame(edidType, out var edidFrame))\n{\n   ...\n}\n</code></pre> <p>This allows users to easily locate a specific record they are looking for, without needing to iterate and search themselves.</p> <p>Note that it does iterate each Subrecord internally, so it is not a good solution if you are trying to process/find a large portion of Subrecords within a single Major Record.  It is more appropriate for finding one or two specific ones.  If you want to process all subrecords by type, it is recommended you iterate and switch on the type directly, or store the resulting SubrecordPins in a dictionary for later use.</p>"},{"location":"lowlevel/Header-Structs/#subrecord-frame-data-interpretation","title":"Subrecord Frame Data Interpretation","text":""},{"location":"lowlevel/Header-Structs/#primitives","title":"Primitives","text":"<p>Once a Subrecord Frame is located that you wish to retrieve data from, the content is still only offered as raw bytes (or rather, <code>ReadOnlyMemorySlice&lt;byte&gt;</code>).  There are a lot of functions to help interpret that data to the appropriate type, while confirming correctness. </p><pre><code>var subrecordFrame = ...;\nint contentAsInt = subrecordFrame.AsInt32();\n</code></pre> This code will interpret the Subrecord Frame's content as an int for you.  It will also do the additional safety check to confirm that the Subrecord's content is exactly 4 bytes.  If the content length is 3, or 5, say, then the call will throw an exception alerting you to an unexpected length.<p></p> <p>If you happen to want to extract an integer without enforcing that the content is exactly 4 bytes, then accessing the byte slice directly is the route to take. </p><pre><code>var subrecordFrame = ...;\nint contentAsInt = subrecordFrame.Content.Int32();\n</code></pre> This route will not do the check to enforce that the content length is exactly 4.  It would only throw if the content wasn't long enough to be an int at all (less than 4).<p></p>"},{"location":"lowlevel/Header-Structs/#strings","title":"Strings","text":"<p>Strings, unlike primitives, do not have a set length.  So the call to interpret a Subrecord Frame's content as a string is just for convenience, and does not add any safety mechanisms. </p><pre><code>var subrecordFrame = ...;\nstring contentAsString = subrecordFrame.AsString();\n</code></pre><p></p>"},{"location":"lowlevel/Header-Structs/#writable-structs","title":"Writable Structs","text":"<p>All the above concepts mentioned have been read-only.  Header Structs can be overlaid on top of spans, and read data from them.</p> <p>There are writable structs as well, which have both getter and setter API.  You can then read a section of data, and then make modifications which will affect the source <code>byte[]</code> at the correct indices.</p> <p>These systems are less mature, but will be expanded on in the future.</p>"},{"location":"plugins/","title":"Plugin Record Suite","text":""},{"location":"plugins/#plugin-record-suite","title":"Plugin Record Suite","text":"<p>Mutagen offers custom classes, interfaces, and functionality for each Bethesda record type. </p> <p>Here's an example of what a <code>Potion</code> record might look like:</p> ClassSetter InterfaceGetter Interface <pre><code>public class Potion : IPotion\n{\n    // Major Record Fields\n    FormKey FormKey { get; }\n    string? EditorID { get; set; }\n\n    // Spell Fields\n    string? Name { get; set; }\n    Model? Model { get; set; }\n    string? Icon { get; set; }\n    IFormLink&lt;IEquipTypeGetter&gt; EquipmentType { get; }\n\n    ...\n}\n</code></pre> <pre><code>public interface IPotion : IMajorRecord, IPotionGetter\n{\n    // Major Record Fields\n    FormKey FormKey { get; }\n    string? EditorID { get; set; }\n\n    // Spell Fields\n    string? Name { get; set; }\n    Model? Model { get; set; }\n    string? Icon { get; set; }\n    IFormLink&lt;IEquipTypeGetter&gt; EquipmentType { get; }\n\n    ...\n}\n</code></pre> <pre><code>public interface IPotionGetter : IMajorRecordGetter\n{\n    // Major Record Fields\n    FormKey FormKey { get; }\n    string? EditorID { get; }\n\n    // Spell Fields\n    string? Name { get; }\n    Model? Model { get; }\n    string? Icon { get; }\n    IFormLinkGetter&lt;IEquipTypeGetter&gt; EquipmentType { get; }\n\n    ...\n}\n</code></pre> <p>These are generated for each record and are pivotal touchstones of the entire library.  All functionality exposed will typically deal in one of these types of interfaces, depending on whether the API requires/desires readonly functionality.  </p>"},{"location":"plugins/#code-is-generated","title":"Code is Generated","text":"<p>Records and their functionality are created and maintained via a code generation library.  As such, the records feel like they are hand written, without actually needing to write them by hand.  As new functionality is added or internal optimization is improved, most of Mutagen's code is regenerated to gain all the benefits without needing to manually update the definitions for every record that exists. </p>"},{"location":"plugins/Abstract-Subclassing/","title":"Abstract Subclassing","text":"<p>Occasionally records will be classes that are abstract   </p> <p>This article will go over the concepts of Abstract Subclassing through the lens of looking at a specific example found in Skyrim Npc.   Other records have similar but different concepts.  </p> <p>Consider Skyrim's NpcConfiguration records:</p> <pre><code>public interface INpcConfigurationGetter\n{\n    // ...\n    short MagickaOffset { get; }\n    short StaminaOffset { get; }\n    // The field below is an abstract type\n    IANpcLevelGetter Level { get; }\n    // ...\n}\n</code></pre>"},{"location":"plugins/Abstract-Subclassing/#why-is-it-needed","title":"Why is it Needed?","text":"<p>Why is the <code>Level</code> field an odd abstract <code>ANpcLevel</code> object?  </p> <p>The subclassing helps encapsulate some complexity while remaining consistent and type safe.</p> <p>Consider that <code>NPC_</code>'s <code>Level</code> field is an integer normally.  But if you turn on the <code>PC Level Mult</code> flag, it suddenly acts as a float.   So how can Mutagen expose this in a type safe manner if the field can just change its type depending on a switch somewhere else?</p> <p>Mutagen exposes this by using subclassing.  <code>ANpcLevel</code> has two implementing classes:</p> Implementation Class Type NpcLevel integer PcLevelMult float <p>These two alternatives allow the same field to contain different types.</p>"},{"location":"plugins/Abstract-Subclassing/#setting-an-abstract-subclass-member","title":"Setting an Abstract Subclass Member","text":"<p>You will notice Mutagen does not expose the <code>Pc Level Mult</code> flag.   Instead, you simultaneously control both the \"mode\" that the <code>Level</code> is in, as well as <code>Level</code>'s value by choosing the appropriate subclass.  </p> Pc Level Mult Flag OFFPc Level Mult Flag ON <pre><code>INpc n = ...\n\n// Setting to straight level, with the Pc level Mult flag \"off\"\nn.Configuration.Level = new NpcLevel()\n{\n    Level = 10\n};\n</code></pre> <pre><code>INpc n = ...\n\n// Setting to Pc Level Mult flag \"on\", now with float capabilities\nn.Configuration.Level = new PcLevelMult()\n{\n    Level = 2.1234f\n};\n</code></pre> <p>Now, it's very clear when <code>Level</code> is an integer, and when it is a float.  The flag's value and <code>Level</code>'s type are \"bundled\" as one choice, depending on which subclass you make.</p>"},{"location":"plugins/Abstract-Subclassing/#reading-an-abstract-subclass-member","title":"Reading an Abstract Subclass Member","text":"<p>Reading needs to respect/consider these subclasses in the same way.  One easy way to do this is using a C# type switch: </p><pre><code>INpcGetter n = ...\nswitch (n.Configuration.Level)\n{\n    case INpcLevelGetter straightLevel:\n        System.Console.WriteLine($\"Npc level was {straightLevel.Level}\");\n        break;\n    case IPcLevelMultGetter mult:\n        System.Console.WriteLine($\"Npc level multiplier was {mult.Level}\");\n        break;\n    default:\n        System.Console.WriteLine(\"Huh?\");\n        break;\n}\n</code></pre><p></p> <p>Do Not Cast</p> <p>It is not good practice to hard cast to the desired type  </p><pre><code>INpcGetter n = ...\n\n// Bad code:\nint level = ((INpcLevelGetter)n.Configuration.Level).Level;\n</code></pre>  This will break if you are processing an Npc with the <code>PC Level Mult</code> flag on, as the subobject won't be of type <code>INpcLevelGetter</code>.<p></p>"},{"location":"plugins/Abstract-Subclassing/#summary","title":"Summary","text":"<p>Abstract Subclassing is used when a concept is complex enough to warrant the need for extra control.  It can help with:</p> <ul> <li>Exposing one field as many types</li> <li>Bundling complex configurations into one atomic decision, so that there is no potential for invalid configurations.</li> </ul> <p>In the above example, you will never accidentally deal with a <code>Level</code> that is of type <code>float</code> unless it is in <code>Pc Level Mult</code> mode, and vice versa.  That is not the biggest deal, but in many other situations the concepts/differences are more extreme.</p>"},{"location":"plugins/Abstract-Subclassing/#other-records-with-abstract-subclassing","title":"Other Records with Abstract Subclassing","text":"<p>Skyrim Npc is not the only record type that uses these concepts.  There are many other records that have the need for data structure to change depending on context, and they will use Abstract Subclassing to help expose that.</p> <p>Some other examples include: Perk Effects</p> <p>These show a more extreme example where the fields that a Perk Effect contains vary widely depending on the Perk type.  The subclassing helps only expose the applicable fields for a given effect type.</p> <p>Magic Effects</p> <p>An effect can reference many different types of records, where some effect types can point to records of type ABC, while another effect type can only point to records of type XYZ.  The subclassing again helps expose only the correct typing depending on the effect type you're dealing with.</p>"},{"location":"plugins/Abstract-Subclassing/#documentation","title":"Documentation","text":"<p>Each subclassing situation is different and is trying to solve a different complexity specific to that record.  As things mature, documentation outlining each specific structure will probably be written.</p> <p> Specific Records</p> <p>Additionally, you can investigate the subclassing alternatives yourself without documents:</p> <ul> <li>Utilize Intellisense, and follow references in the IDE to see the classes and what they contain.</li> <li> <p>Of importance:  The interfaces of these abstract classes contain comments of what options are available: </p><pre><code>/// &lt;summary&gt;\n/// Implemented by: [NpcLevel, PcLevelMult]\n/// &lt;/summary&gt;\npublic partial interface IANpcLevel\n{\n   // ...\n}\n</code></pre> This helps narrow down which types it can be so you know what to switch on and handle.<p></p> </li> <li> <p>Also, you can sometimes refer to the xmls that define the records, like the ones linked above.</p> </li> </ul>"},{"location":"plugins/AssetLink/","title":"Asset Links","text":""},{"location":"plugins/AssetLink/#asset-links","title":"Asset Links","text":"<p>An AssetLink is a strongly typed object wrapping what is normally a <code>string</code> subpath pointing to an asset.</p> <p>For example, a Skyrim Weapon's Model has a <code>File</code> member, which is the <code>MODL</code> subrecord, which contains a string relative to the <code>Data/Meshes</code> folder.   Rather than exposing this as a <code>string</code>, Mutagen exposes this as an <code>AssetLink&lt;SkyrimModelAssetType&gt;</code>.</p> <p>Enhanced FilePath</p> <p>If you're just after the path, you can still get it via an AssetLink's <code>RawPath</code> member.  But the AssetLink now comes with a bunch of additional features and convenience</p>"},{"location":"plugins/AssetLink/#members","title":"Members","text":""},{"location":"plugins/AssetLink/#rawpath","title":"RawPath","text":"<p><code>RawPath</code> is the string that is present on disk in the record itself as it appears.  This is also the field that you can set when you want to modify an AssetLink to point to a different path.</p> <p><code>AssetLink</code>s are implicitly convertible to/from <code>string</code>, which uses <code>RawPath</code> as the string to return.  This is in place to provide some backwards compatibility</p>"},{"location":"plugins/AssetLink/#datarelativepath","title":"DataRelativePath","text":"<p><code>DataRelativePath</code> is a <code>get</code> only member that does some checking/trimming of <code>RawPath</code> to try to standardize it to be relative to a game's Data folder.</p> <p>It will trim a prefixed \"Data\" folder in the path, while also ensuring the appropriate asset subfolder is present.  Some examples:</p> RawPath DataRelativePath textures/some/subpath.nif textures/some/subpath.nif data/textures/some/subpath.nif textures/some/subpath.nif some/subpath.nif textures/some/subpath.nif <p>In all examples, the <code>DataRelativePath</code> remains the same, as that is what it's attempting to do: keep it standardized to be relative the Data folder, no matter the RawPath's contents.</p>"},{"location":"plugins/AssetLink/#assettype-generic","title":"AssetType Generic","text":"<p>An <code>AssetLink</code>'s generic type is the type of asset it relates to.  </p> <p>For example, a Skyrim Model path will be of type <code>AssetLink&lt;SkyrimModelAssetType&gt;</code>, where <code>SkyrimModelAssetType</code> is a meta class containing information about Skyrim Model assets.</p> <p> AssetType</p>"},{"location":"plugins/AssetLink/#asset-type","title":"Asset Type","text":"<p>AssetTypes are constant meta objects that contain the information </p> <ul> <li><code>BaseFolder</code>, what subfolder underneath /Data/ these assests are expected to live</li> <li><code>FileExtensions</code>, what expected file extensions these types of meta files will have</li> </ul>"},{"location":"plugins/AssetLink/#asset-enumeration","title":"Asset Enumeration","text":"<p>Similar to FormLinks, a mod can enumerate AssetLinks of a desired type.   The details are slightly different, though.</p>"},{"location":"plugins/AssetLink/#typical-usage","title":"Typical Usage","text":"Specific Asset TypesAll Asset Types <pre><code>IStarfieldModGetter mod = ...;\nILinkCache linkCache = ...;\nvar assetLinkCache = linkCache.CreateImmutableAssetLinkCache();\n\nforeach (var asset in mod.EnumerateAllAssetLinks&lt;StarfieldModelAssetType&gt;(assetLinkCache))\n{\n    // Loops each asset\n}\n</code></pre> <pre><code>IStarfieldModGetter mod = ...;\nILinkCache linkCache = ...;\nvar assetLinkCache = linkCache.CreateImmutableAssetLinkCache();\n\nforeach (var asset in mod.EnumerateAllAssetLinks(assetLinkCache))\n{\n    // Loops each asset\n}\n</code></pre>"},{"location":"plugins/AssetLink/#assetlinkquery","title":"AssetLinkQuery","text":"<p>This is a flag enum with three options, letting you control what type of Assets you want to enumerate:</p> <ul> <li> <p><code>Listed</code>.  Assets explicitly listed in the records:</p> <ul> <li>Skyrim Model Path</li> </ul> </li> <li> <p><code>Inferred</code>.  Assets that can be inferred by fields that exist on the record</p> <ul> <li>Armor Addon World Model <code>_0</code> <code>_1</code> suffix assets</li> <li>Book text <code>src</code> links pointing to textures</li> </ul> </li> <li> <p><code>Resolved</code>.  Assets that can be inferred by looking at other records, and require FormLink lookups on a Link Cache.</p> <ul> <li>Dialog Topic's Voice Type paths </li> </ul> </li> </ul> <p>By combining flags, you can control what Asset categories you are interested in.  There are also convenience methods like <code>EnumerateListedAssetLinks</code> that handle the flags for you.</p>"},{"location":"plugins/AssetLink/#assetlinkcache","title":"AssetLinkCache","text":"<p><code>Resolved</code> asset enumerations require an <code>IAssetLinkCache</code>.  This is due to their complex nature requiring a lot of work to locate the same data repeatedly, a cache object helps speed up the internal logic.  Some AssetLink enumeration calls will not require AssetLinkCaches if you are not querying for Resolved assets</p> <p>Reuse Cache</p> <p>It is best to reuse the same Asset Link Cache for multiple queries, and recreate only if the wrapped LinkCache is invalidated.</p>"},{"location":"plugins/AssetLink/#construction","title":"Construction","text":"<p>An AssetLinkCache is a cache wrapper around LinkCache, to provide specific functionality for asset lookup. </p><pre><code>ILinkCache linkCache = ...;\nvar assetLinkCache = linkCache.CreateImmutableAssetLinkCache();\n</code></pre><p></p>"},{"location":"plugins/Bethesda-Format-Abstraction/","title":"Bethesda Format Abstraction","text":""},{"location":"plugins/Bethesda-Format-Abstraction/#binary-format-complexity-abstraction","title":"Binary Format Complexity Abstraction","text":"<p>Bethesda's binary format contains a lot implementation complexities that are unrelated to the actual content of the records.  A lot of times the exposure of these details are a source of confusion, and don't add much upside in the way of flexibility or power into the hands of the user.  Mutagen attempts to abstract these complexities away so that the end user is dealing with the distilled record content more directly, rather than wading through the gritty specifics that only matter in the context of their binary format on disk.</p>"},{"location":"plugins/Bethesda-Format-Abstraction/#formkeys-and-formlinks","title":"FormKeys and FormLinks","text":"<p>This topic was covered in detail in the ModKey, FormKey, FormLink section, and so will not be covered here.</p>"},{"location":"plugins/Bethesda-Format-Abstraction/#record-types","title":"Record Types","text":"<p>Most seasoned modders are familiar with the 4 character record headers. <code>EDID</code> is <code>Editor ID</code>.  <code>FULL</code> is <code>Name</code>.  <code>MODL</code> is <code>Model</code>.  </p> <p>These concepts are not exposed in Mutagen's generated classes.   Members are exposed their readable name: <code>npc.EditorID</code>, <code>npc.Name</code>, and <code>npc.Model</code></p>"},{"location":"plugins/Bethesda-Format-Abstraction/#type-safety","title":"Type Safety","text":"<p>By not using a string based lookup, there is no possibility of typos or misqueries, no need to remember the more obscure header strings, and no possibility of type mishandling.  Because everything is exposed via normal members, any typo or attempt to access a non-existent member will be caught by the compiler, instead of a failed string query at runtime.</p>"},{"location":"plugins/Bethesda-Format-Abstraction/#alternate-headers","title":"Alternate Headers","text":"<p>Some common Record Types have alternate versions to denote different fields.  A common example of this is the <code>Model</code> Record Type <code>MODL</code>, which on Armor WorldModel records is <code>MOD2</code> for males, and <code>MOD4</code>.   Mutagen deals with these alternative record types under the hood, exposing the various fields as it would normally.</p>"},{"location":"plugins/Bethesda-Format-Abstraction/#list-mechanics","title":"List Mechanics","text":""},{"location":"plugins/Bethesda-Format-Abstraction/#item-storage","title":"Item Storage","text":"<p>There are a lot of varying ways that lists are stored in the binary format:</p> <ul> <li> <p>Repeated subrecords, with their Record Header as the delimiter.  Unknown amount.   (SPLO records in Oblivion)</p> </li> <li> <p>Extra prepended subrecord /w the count of items in the list.  This can then be followed by repeated subrecords with Record Headers, or headerless raw data of known lengths.   (Keyword lists in Skyrim)</p> </li> <li> <p>A Record Header for the list itself, followed immediately by a uint count, followed by undelimited content of known length. (Skyrim Model's Alternate Textures)</p> </li> <li>Same as above, but with an extra set of bytes to denote the contained structure length</li> </ul> <p>No matter what pattern is used for a specific set of records, they are all exposed via straight up lists in the API: </p><pre><code>// Oblivion spells\nIList&lt;FormLink&lt;Spell&gt;&gt; Spells { get; set; }\n\n// A keyword list\nIList&lt;FormLink&lt;Keyword&gt;&gt; Keywords { get; set; }\n\n// A model's alternate textures\nIList&lt;AlternateTexture&gt; AlternateTextures { get; set; }\n</code></pre><p></p>"},{"location":"plugins/Bethesda-Format-Abstraction/#count-subrecords","title":"Count Subrecords","text":"<p>Some lists have a preceding extra record that contains the count of a given list.  For example <code>KSIZ</code> is the counter type for Keywords, which has a number for how many <code>KWDA</code> records are expected to follow containing keyword formIDs.   Mutagen handles these counter records internally, so you can just modify any list to contain the desired content, and the correct count will be written automatically.</p>"},{"location":"plugins/Bethesda-Format-Abstraction/#markers","title":"Markers","text":"<p>Some subrecords have specialized \"marker\" subrecords that precede them.  Sometimes they just mark the location of a section of subrecords, while other times they affect the context of the following subrecords.</p> <p>A good specific example can be found in Skyrim's <code>Race</code>'s Body Data subrecords.  A <code>Race</code> has a body data struct for males, and a body data struct for females.  These records are first \"marked\" by an empty <code>NAM0</code> record.  They are then further \"marked\" by empty <code>MNAM</code> or <code>FNAM</code> subrecords, to indicate if the following data is for males or females.  The binary might follow this pattern: </p><pre><code>NAM0: No content, just a marker\nMNAM: No content, just a marker\nINDX: Body Data content for males\nMODL: Body Data content for males\nFNAM: No content, just a marker\nINDX: Body Data content for females\nMODL: Body Data content for females\n</code></pre><p></p> <p>Mutagen abstracts the concepts of markers away from the user completely.  No concepts of markers exist in the API exposed.  A user can just directly access the data they're interested in, and if a marker-related field is set for exporting, the marker systems will be handled automatically during export internally.</p>"},{"location":"plugins/Bethesda-Format-Abstraction/#pathgrid-point-zipping","title":"PathGrid Point Zipping","text":"<p>Path grid information in records such as Oblivion's <code>Road</code> are stored in two separate subrecord lists that need to be considered together in order to get the complete structure.  The points themselves are stored in the list <code>PGRP</code>, while the information about the connections between points is stored in <code>PGRR</code>.  If you want to know what points have what connections, you need to offset your queries into the <code>PGRR</code> subrecord properly.  Each Point exposes the number of connections it has.  Then, to find the connections for Point #7, you have to offset your query into <code>PGRR</code> by 12 * the number of connections Points #1-6 had.  You then have to extract the number of connection floats appropriate for Point #7, based on the number of connections it says it has.</p> <p>Mutagen abstracts this \"zipping\" work for you and offers a simple <code>IList&lt;RoadPoint&gt; Points;</code> member on <code>Road</code>.  Each <code>RoadPoint</code> has a <code>IList&lt;P3Float&gt; Connections;</code> with all the connections related to that point.  All the complexity of the dual subrecords is hidden from the user, and they can just manipulate these lists directly in a more straightforward and familiar fashion.</p>"},{"location":"plugins/Bethesda-Format-Abstraction/#multiple-flag-consolidation","title":"Multiple Flag Consolidation","text":"<p>Some records have so many flags that they overflow above the typical 4 bytes.  Bethesda will then put a second set of flags elsewhere in the record with the overflow flag values.  One example of this happening is in Skyrim's Race record.  Mutagen merges the overflow into one Flag field exposing all of the values in one place.</p>"},{"location":"plugins/Bethesda-Format-Abstraction/#gendereditem","title":"GenderedItem","text":"<p>Bethesda records have a lot of fields that come in a Male/Female pair.  While not too much of a problem by itself, most of the complexity comes in the variety of ways that these pairs can be organized.  Sometimes the M/F data is held in dedicated <code>MNAM</code>/<code>FNAM</code> records.  Sometimes those records are prepended by a marker, as mentioned above.  Sometimes instead both are found in a single subrecord, with the data just back to back.</p> <p>Mutagen standardizes all the various cases, and exposes the male/female alternatives using a <code>GenderedItem</code> struct in the public API: </p><pre><code>public class GenderedItem&lt;T&gt;\n{\n    public T Male { get; set; }\n    public T Female { get; set; }\n}\n\n...\n\n// Using Oblivion's Race's Height as an example\nrace.Height.Male = 1.5f;\nfloat femaleHeight = race.Height.Female;\n</code></pre><p></p>"},{"location":"plugins/Bethesda-Format-Abstraction/#pseudo-enum-dictionaries","title":"Pseudo Enum Dictionaries","text":"<p>Skyrim's Race record has a hacky binary implementation for its <code>Biped Object Names</code> field.</p> <p>This field is supposed to expose the names associated with the different values of this enum: </p><pre><code>[Flags]\npublic enum BipedObjectFlag : uint\n{\n    Head = 0x0000_0001,\n    Hair = 0x0000_0002,\n    Body = 0x0000_0004,\n    ...\n    Ears = 0x0000_2000,\n    DecapitateHead = 0x0010_0000,\n    Decapitate = 0x0020_0000,\n    FX01 = 0x8000_0000,\n}\n</code></pre><p></p> <p>With this field, a user can specify different string names for the Head slot, the Hair slot, etc.  Oddly, though, this is all stored as a list, where the 3rd item would be associated with the <code>Body</code>, for example.  Additionally, to get out to the later enum values, empty list items must be inserted for each unknown flag index.</p> <pre><code>// Example binary structure\nNAME - \"Top Thing\"  // Head index\nNAME - \"Inedible Spaghetti\" // Hair index\nNAME - \"Gut Housing\" // Body index\n...\nNAME - \"Future Wings\" // Ear index\nNAME - empty // Empty index for 0x0000_4000\nNAME - empty // Empty index for 0x0000_8000\n...\nNAME - empty // Empty index for 0x0008_0000\nNAME - \"Decapitate Head\" // Decapitate Head index\n</code></pre> <p>Notice that the user needs to coordinate/know that the third index is the body index.  They also need to make sure to insert/count the proper empty indices in order to \"reach\" the later flags.  If any item is inserted/removed, all the surrounding items are now misaligned, etc.</p> <p>Mutagen wraps these List concepts internally, and exposes <code>Dictionary&lt;BipedObjectFlag, string&gt;</code> in its public API instead.  The user can get/set the dictionary in a more natural way, and the error prone list implementation will be handled for them under the hood.</p>"},{"location":"plugins/Compaction/","title":"Compaction","text":""},{"location":"plugins/Compaction/#compaction","title":"Compaction","text":"<p>Bethesda mod files come in a few compaction styles:</p> <ul> <li><code>Full</code>  This is the normal mod, allowing for IDs in the range of 0xFFFFFF</li> <li><code>Medium</code>  This is a mod that can only have IDs in the range 0xFFFF.</li> <li><code>Small</code>  (Sometimes called Light).  Can only have IDs in the range 0xFFF</li> </ul> <p>Compacting mods intelligently allows the game to load more mods overall.  These docs will not go into the gritty specifics of that.</p>"},{"location":"plugins/Compaction/#setting-small-master-flag","title":"Setting Small Master Flag","text":"<p>To create a small/light master, set the header flag on your mod:</p> <pre><code>var mod = new SkyrimMod(ModKey.FromFileName(\"MyMod.esp\"), SkyrimRelease.SkyrimSE);\nmod.ModHeader.Flags |= SkyrimModHeader.HeaderFlag.Small;\n</code></pre> <p>This creates a \"flagged ESP\" - an <code>.esp</code> file with the small master flag set in its header. The game will treat it as a light master.</p> <p>ModType vs HeaderFlag</p> <p><code>ModType.Light</code> (used in ModKey) affects the file extension (<code>.esl</code>), while <code>HeaderFlag.Small</code> sets the internal header flag. Modern practice typically uses flagged ESPs (<code>.esp</code> files with the small master flag set).</p>"},{"location":"plugins/Compaction/#compacting","title":"Compacting","text":"<p><code>ModCompaction</code> is a static class that offers the ability to compact a mod to the given acceptable range for Small/Medium/Full masters.</p> <p>This will reassign records out of range and give them new FormIDs.</p> <pre><code>IMod mod = ...;\n\nModCompaction.CompactToSmallMaster(mod);\n</code></pre> <p>This will throw if it is unable to compact for any reason.</p> <pre><code>IMod mod = ...;\n\nModCompaction.CompactToSmallMaster(mod, MasterStyle.Small);\n</code></pre> <p>This alternative will try to compact to <code>Small</code>, but will fall back to <code>Medium</code> and then <code>Full</code> if it is unable to do so.</p>"},{"location":"plugins/Compaction/#compatibility-detection","title":"Compatibility Detection","text":"<p><code>RecordCompactionCompatibilityDetection</code> provides functionality to test a mod to see if it could be compacted.</p> <p>Some examples: - <code>IsSmallMasterCompatible</code> - <code>CouldBeSmallMasterCompatible</code> - <code>GetSmallMasterRange</code> - <code>IterateAndThrowIfIncompatible</code> </p> <p>Some of these calls have <code>bool potential</code> parameters. </p> <p>This corresponds to <code>Full</code> styles, where Lower Range FormIDs are only viable if there is a master present.  By marking <code>potential</code> as true, the functions will test viability assuming that there will be masters present.</p>"},{"location":"plugins/Copy-Functionality/","title":"Copy Functionality","text":""},{"location":"plugins/Copy-Functionality/#copy-functionality","title":"Copy Functionality","text":"<p>Mutagen provides functionality for copying in data to an already existing object.</p>"},{"location":"plugins/Copy-Functionality/#deepcopy","title":"DeepCopy","text":"<p>This call will create a new object, and copy all fields.  This will be done in a \"deep\" fashion, where duplicate objects will be made for each subobject and their fields copied over as well.  No references to the original object or any subobjects from the original will exist in the object copied to.</p> <p>This separates the new object from the original object so that modifying either has no effect on the other.</p> <pre><code>IPotionGetter potionSource = ...;\nPotion potionCopy = (Potion)potionSource.DeepCopy();\n</code></pre> <p>Some things to note:</p> <ul> <li>FormKey will match the original source</li> <li>Changes to either object will not affect the other</li> <li>The new record will not be a part of any Mod or Group unless added explicity.</li> <li>The cast is required currently, but will hopefully be unnecessary eventually.</li> </ul>"},{"location":"plugins/Copy-Functionality/#deepcopyin","title":"DeepCopyIn","text":"<p>This call will copy in all fields from a second object to an already existing object.  Changes to either object will not affect the other.</p> <pre><code>IPotionGetter potionSource = ...;\nPotion potionCopy = mod.Potions.AddNew();\npotionCopy.DeepCopyIn(potionSource);\n</code></pre> <p>FormKey Will Not Be Copied</p> <p><code>FormKey</code>s are immutable, and will never be changed even with a copy in.</p>"},{"location":"plugins/Copy-Functionality/#translation-masks","title":"Translation Masks","text":"<p>As with many other translational tasks in Mutagen, Copy functionality comes with the option to provide Masks to control what will get copied.</p> <p></p><pre><code>IPotionGetter otherPotion = ...;\nvar onlyScriptsMask = new Potion.TranslationMask(defaultOn: false)\n{\n    Script = true\n};\n\npotion.DeepCopyIn(otherPotion, onlyScriptsMask);\n</code></pre> This code will replace <code>potion</code>'s script data with the values from <code>otherPotion</code>.  All other subrecords will remain untouched.<p></p>"},{"location":"plugins/Copy-Functionality/#copyinfrombinary","title":"CopyInFrom[Binary]","text":"<p>In addition to being able to copy in fields from another object via DeepCopyIn, you can also CopyIn from other serialization sources such as from a Binary file on the disk.</p> <p>This mainly only applies to Mod objects, rather than individual Major Records.  It is also less granular than other translation sources, and only lets you mask per Group type.</p> <pre><code>OblivionMod mod = ...;\nmod.CopyInFromBinary(\n    path: \"C:/SomePath/SomeMod.esp\",\n    importMask: new GroupMask(false)\n    {\n        NPCs = true\n    });\n</code></pre> <p>This code will replace the <code>mod</code> object's NPC Group's contents with the NPC contents from the file on disk.</p>"},{"location":"plugins/Create%2C-Duplicate%2C-and-Override/","title":"Create, Duplicate, and Override","text":""},{"location":"plugins/Create%2C-Duplicate%2C-and-Override/#create-duplicate-and-override","title":"Create, Duplicate, and Override","text":""},{"location":"plugins/Create%2C-Duplicate%2C-and-Override/#create-new-records","title":"Create New Records","text":"<p>New records can be constructed in a few ways.  Note that a record's FormKey is required during construction, and immutable.  If you want to change the FormKey of a record, a new one should be made.  Any desired fields can be brought over via CopyIn mechanics.</p>"},{"location":"plugins/Create%2C-Duplicate%2C-and-Override/#by-constructor","title":"By Constructor","text":"<p>Any standalone record can be made by using its constructor. </p><pre><code>FormKey formKey = ...;\nvar potion = new Potion(formKey);\n</code></pre><p></p>"},{"location":"plugins/Create%2C-Duplicate%2C-and-Override/#from-a-mods-group","title":"From a Mod's Group","text":"<p>If you have an <code>IMod</code> object that you want the record to originate from, you can easily make one from the corresponding <code>Group</code>. </p><pre><code>var potion = mod.Potions.AddNew();\n</code></pre><p></p> <p>Claims Next Available FormKey</p> <p>The new record will have the next available <code>FormKey</code> from that mod based on the metadata in its header, and automatically be added to the Group it originated from.  </p>"},{"location":"plugins/Create%2C-Duplicate%2C-and-Override/#by-duplication","title":"By Duplication","text":"<p>Duplicating a record creates a new record with a new FormKey while copying all the data from an existing source record. This differs from overriding, where the original FormKey is preserved. Duplication is useful when you want to create a new, distinct record based on an existing one.</p>"},{"location":"plugins/Create%2C-Duplicate%2C-and-Override/#key-differences-duplication-vs-override","title":"Key Differences: Duplication vs Override","text":"<ul> <li>Duplication: Assigns a new FormKey \u2192 Creates a new record</li> <li>Override: Preserves the original FormKey \u2192 Modifies an existing record</li> </ul>"},{"location":"plugins/Create%2C-Duplicate%2C-and-Override/#duplicateinasnewrecord","title":"DuplicateInAsNewRecord","text":"<p>For simple, non-nested records, use the <code>DuplicateInAsNewRecord</code> convenience method:</p> Claim Next FormIDSpecific FormKeySynced <pre><code>INpcGetter sourceNpc = ...;\nISkyrimMod myMod = ...;\n\nvar copy = myMod.Npcs.DuplicateInAsNewRecord(sourceNpc);\n</code></pre> <pre><code>INpcGetter sourceNpc = ...;\nISkyrimMod myMod = ...;\nFormKey formKey = ...;\n\nvar copy = myMod.Npcs.DuplicateInAsNewRecord(sourceNpc, formKey);\n</code></pre> <pre><code>INpcGetter sourceNpc = ...;\nISkyrimMod myMod = ...;\n\nvar copy = myMod.Npcs.DuplicateInAsNewRecord(sourceNpc, \"SomeUniqueEditorID\");\n</code></pre> <p>Extra Requirements</p> <p>If the supplied EditorID is not unique, it will throw an exception.</p> <p> FormID Allocation</p>"},{"location":"plugins/Create%2C-Duplicate%2C-and-Override/#duplicate-add-pattern","title":"Duplicate + Add Pattern","text":"<p>For complex nested records or when you need more control, use the <code>Duplicate()</code> method followed by <code>Add()</code>:</p> <pre><code>INpcGetter sourceNpc = ...;\nISkyrimMod myMod = ...;\n\n// Create a duplicate with a new FormKey\nvar npcCopy = sourceNpc.Duplicate(myMod.GetNextFormKey());\n\n// Optionally modify the duplicate\nnpcCopy.Name = \"Variant Name\";\n\n// Add it to your mod\nmyMod.Npcs.Add(npcCopy);\n</code></pre> <p>This pattern is necessary for nested records like Placed Objects or Cells where <code>DuplicateInAsNewRecord</code> is not available.</p>"},{"location":"plugins/Create%2C-Duplicate%2C-and-Override/#formlink-behavior","title":"FormLink Behavior","text":"<p>FormLinks Are Not Automatically Updated</p> <p>When you duplicate a record, any FormLinks within that record still point to their original targets. They are not automatically updated to point to the new duplicated record.</p> <p>You must manually update FormLinks if needed. See the Remapping FormLinks page for details on how to update FormLinks to point to duplicated records.</p>"},{"location":"plugins/Create%2C-Duplicate%2C-and-Override/#overriding-records","title":"Overriding Records","text":"<p>It is very common to want to modify a record that is from another mod.  This just entails making a copy of the original record and adding it to your output mod.  The fact that the FormKey doesn't originate from your output mod implicitly means that it's an override.</p>"},{"location":"plugins/Create%2C-Duplicate%2C-and-Override/#getoraddasoverride","title":"GetOrAddAsOverride","text":"<p>The quick any easy way to override a record is to utilize a Group.GetOrAddAsOverride call.  This will check if the record already exists as an override in your group, and return it if so.  Otherwise, it will copy the source record to a new object, and add it to your mod for you. </p><pre><code>INpcGetter sourceNpc = ...;\n// Retrieve or copy-and-add the record to our mod\nvar overrideRecord = myMod.Npcs.GetOrAddAsOverride(sourceNpc);\n// Modify the name to be different inside myMod\noverrideRecord.Name = \"My New Name\";\n</code></pre><p></p> <p>Call After Filters to Avoid ITPOs</p> <p>With this pattern, it is preferable to call <code>GetOrAddAsOverride</code> as late as possible, after all filtering has been done and you know you want to override and modify the record.  This avoids adding records to your mod that have no changes.</p>"},{"location":"plugins/Create%2C-Duplicate%2C-and-Override/#deep-copy-then-insert","title":"Deep Copy Then Insert","text":"<p>This pattern is an alternative to <code>GetOrAddAsOverride</code>.  It is sometimes preferable if it's hard to delay the <code>GetOrAddAsOverride</code> call, and you want more control over when a record actually gets added to the outgoing mod.</p> <pre><code>INpcGetter sourceNpc = ...;\n// Make a new mutable object that is a copy of the record to override\nvar npcCopy = sourceNpc.DeepCopy();\n\n// Modify the name\nnpcCopy.Name = \"My New Name\";\n\n// Apply some late filter logic\nif (!SomeFilter(npcCopy)) return;\n\n// Add the record as an override after the filter\noutputMod.Npcs.Add(npcCopy);\n</code></pre> <p>This strategy works well if you might change your mind and not add the copied record to the outgoing mod.  It lets you get a mutable version of the record without adding it to your outgoing mod until you are certain you want to include it.</p>"},{"location":"plugins/Create%2C-Duplicate%2C-and-Override/#nested-records","title":"Nested Records","text":"<p>Some records like Placed Objects and Cells are often nested underneath other records.  This makes it harder to follow the above patterns.  For these you will want to make use of ModContext concepts.</p> <p> Mod Contexts</p>"},{"location":"plugins/Equality-Checks/","title":"Equality Checks","text":""},{"location":"plugins/Equality-Checks/#equality-checks","title":"Equality Checks","text":"<p>Work in Progress</p> <p>Equality functionality exists, but has not been thoroughly tested.  Bugs within may exist.  Please report if you see any.</p>"},{"location":"plugins/Equality-Checks/#basic-equality","title":"Basic Equality","text":"<p>Mutagen generates Equals and Hash functions for all classes based on record content.  Normal C# equality checks can be used: </p><pre><code>bool isEqual = npc1.Equals(npc2);\nbool isEqual2 = object.Equals(npc1, npc2);\nint hash = npc1.GetHashCode();\n</code></pre><p></p>"},{"location":"plugins/Equality-Checks/#equals-mask","title":"Equals Mask","text":"<p>Mutagen generates additional helper classes called Translation Masks.  These can be used to help specify what fields a user wants to check for equality, or hash with.</p> <p> Translation Mask</p> <pre><code>// Create a mask that will only check EditorID and Name\nNpc.TranslationMask mask = new Npc.TranslationMask(defaultOn: false)\n{\n    EditorID = true,\n    Name = true,\n};\n\nbool isEqual = npc1.Equals(npc2, mask);\nint hash = npc1.GetHashCode(mask);\n</code></pre> <p>A user can also check equality and get a Mask back as the return value: </p><pre><code>var equalsMask = npc1.GetEqualsMask(npc2);\nbool isEditorIdEqual = equalsMask.EditorID;\nbool isNameEqual = equalsMask.Name;\nbool allFieldsEqual = equalsMask.AllEqual(isEqualBool =&gt; isEqualBool);\n</code></pre><p></p>"},{"location":"plugins/Exceeding-Master-Limits/","title":"Exceeding Master Limits","text":""},{"location":"plugins/Exceeding-Master-Limits/#exceeding-master-limits","title":"Exceeding Master Limits","text":""},{"location":"plugins/Exceeding-Master-Limits/#overview","title":"Overview","text":"<p>Bethesda plugins have a hard limit of 255 masters per mod file. When a mod references records from more masters than this limit allows, it cannot be saved as a single file. Mutagen's multi-mod support provides automatic splitting of a single mod object into several mod files when exported, and merging functionality when reading to work around this limitation.</p>"},{"location":"plugins/Exceeding-Master-Limits/#file-naming-convention","title":"File Naming Convention","text":"<p>When a mod is split, the files follow this naming pattern:</p> <ul> <li><code>MyMod_1.esp</code></li> <li><code>MyMod_2.esp</code></li> <li><code>MyMod_3.esp</code></li> <li>etc.</li> </ul> <p>The files are numbered consecutively starting from <code>_1</code>. When reading, Mutagen expects no gaps in the sequence.</p>"},{"location":"plugins/Exceeding-Master-Limits/#writing-with-auto-split","title":"Writing with Auto-Split","text":""},{"location":"plugins/Exceeding-Master-Limits/#using-the-builder-recommended","title":"Using the Builder (Recommended)","text":"<p>The easiest way to write a mod with automatic splitting is to use the <code>WithAutoSplit()</code> builder option:</p> <pre><code>SkyrimMod mod = ...;\n\nawait mod.BeginWrite\n    .ToPath(outputPath)\n    .WithLoadOrder(loadOrder)\n    .WithAutoSplit()\n    .WriteAsync();\n</code></pre> <p>When <code>WithAutoSplit()</code> is enabled:</p> <ol> <li>Mutagen first attempts to write the mod normally</li> <li>If a <code>TooManyMastersException</code> occurs, the mod is automatically split into multiple files</li> <li>Records are distributed across files to keep each file under the master limit</li> <li>Old split files (from previous writes with more splits) are automatically cleaned up</li> </ol> <p>Warning</p> <p>Auto-split only works with file path writes (<code>ToPath</code> or <code>IntoFolder</code>). Using <code>ToStream</code> with <code>WithAutoSplit()</code> will throw a <code>NotSupportedException</code>.</p>"},{"location":"plugins/Exceeding-Master-Limits/#reading-split-mods","title":"Reading Split Mods","text":""},{"location":"plugins/Exceeding-Master-Limits/#using-the-builder-recommended_1","title":"Using the Builder (Recommended)","text":"<p>The easiest way to read split mods is to use the <code>WithAutoSplitSupport()</code> builder option:</p> <pre><code>// Read as readonly overlay\nusing var mod = SkyrimMod.Create(SkyrimRelease.SkyrimSE)\n    .FromPath(modPath)\n    .WithAutoSplitSupport()\n    .Construct();\n\n// Read as mutable mod (deep copies the overlay)\nvar mutableMod = SkyrimMod.Create(SkyrimRelease.SkyrimSE)\n    .FromPath(modPath)\n    .WithAutoSplitSupport()\n    .Mutable()\n    .Construct();\n</code></pre> <p>When <code>WithAutoSplitSupport()</code> is enabled:</p> <ol> <li>Mutagen checks if split files exist (e.g., <code>MyMod_1.esp</code>, <code>MyMod_2.esp</code>)</li> <li>If found, automatically imports and merges them into a single unified view</li> <li>If no split files exist, falls back to normal single-file import</li> <li>For mutable imports, the merged overlay is deep-copied to a mutable mod</li> </ol> <p>Warning</p> <p>Auto-split support only works with file path reads (<code>FromPath</code>). Using <code>FromStream</code> with <code>WithAutoSplitSupport()</code> will throw a <code>NotSupportedException</code>.</p>"},{"location":"plugins/Exceeding-Master-Limits/#detecting-split-files","title":"Detecting Split Files","text":"<p>Use <code>MultiModFileAnalysis</code> to check if split files exist before reading:</p> <pre><code>using Mutagen.Bethesda.Plugins.Analysis;\n\n// Check if split files exist\nif (MultiModFileAnalysis.IsMultiModFile(modPath))\n{\n    // Get the list of split file paths\n    var splitFiles = MultiModFileAnalysis.GetSplitModFiles(modPath);\n    Console.WriteLine($\"Found {splitFiles.Count} split files\");\n}\n</code></pre> <p><code>IsMultiModFile</code> returns:</p> <ul> <li><code>true</code> if valid split files exist (at least _1 and _2)</li> <li><code>false</code> if no split files exist (single mod)</li> <li>Throws <code>SplitModException</code> if files are in an invalid state</li> </ul>"},{"location":"plugins/Exceeding-Master-Limits/#using-multimodfilereader","title":"Using MultiModFileReader","text":"<p>The <code>MultiModFileReader</code> class provides a way to read split mod files for dependency injection scenarios:</p> <pre><code>using Mutagen.Bethesda.Plugins.Analysis.DI;\n\nvar reader = new MultiModFileReader();\n\n// Read split files and get a merged overlay\nusing var mergedMod = reader.Read&lt;ISkyrimModDisposableGetter&gt;(\n    folder,           // Directory containing the split files\n    modKey,           // The base ModKey (without _1, _2 suffixes)\n    GameRelease.SkyrimSE,\n    loadOrder,        // Load order for master ordering\n    BinaryReadParameters.Default);\n\n// Use the merged mod as if it were a single file\nforeach (var npc in mergedMod.Npcs)\n{\n    // Process records from all split files\n}\n</code></pre> <p>The reader:</p> <ul> <li>Automatically detects split files matching the pattern <code>ModKey_1.ext</code>, <code>ModKey_2.ext</code>, etc.</li> <li>Validates that files are numbered consecutively</li> <li>Returns a read-only overlay that presents all split files as a single unified mod</li> <li>Throws <code>SplitModException</code> if no split files are found or only one file exists</li> </ul>"},{"location":"plugins/Exceeding-Master-Limits/#using-modfactory","title":"Using ModFactory","text":"<p><code>ModFactory</code> is useful when you need to import split mods with generic type parameters. This is common in library code or utilities that work across multiple game types.</p>"},{"location":"plugins/Exceeding-Master-Limits/#automatic-split-detection","title":"Automatic Split Detection","text":"<p>If you don't want to manually detect split files, use <code>Import_WithMultiFileDetection</code> calls. These methods automatically detect whether a mod is split and handle it appropriately:</p> <pre><code>using Mutagen.Bethesda.Plugins.Records;\n\nvar mod = ModFactory.ImportGetterWithMultiFileDetection(\n    modPath,\n    loadOrder,\n    GameRelease.SkyrimSE);\n\nvar mod = ModFactory&lt;ISkyrimModDisposableGetter&gt;.ImportGetterWithMultiFileDetection(\n    modPath,\n    loadOrder,\n    GameRelease.SkyrimSE);\n</code></pre> <p>These methods: - Use <code>MultiModFileAnalysis.IsMultiModFile()</code> to detect split files - If split files exist, call <code>ImportMultiFileGetter()</code> to merge them - If no split files exist, call the standard <code>ImportGetter()</code> for a single file</p>"},{"location":"plugins/Exceeding-Master-Limits/#manual-split-detection","title":"Manual Split Detection","text":"<p>If you know the files are split, there is a call with no detection logic:</p> <pre><code>return ModFactory&lt;TModGetter&gt;.ImportMultiFileGetter(\n    modKey,\n    splitFiles,\n    loadOrder,\n    release);\n</code></pre>"},{"location":"plugins/Exceeding-Master-Limits/#using-modimporter-di","title":"Using ModImporter (DI)","text":"<p>For dependency injection scenarios:</p> <pre><code>using Mutagen.Bethesda.Plugins.Records.DI;\n\nvar modImporter = new ModImporter(fileSystem, gameReleaseContext);\n\nvar mergedMod = modImporter.ImportMultiFile&lt;ISkyrimModDisposableGetter&gt;(\n    modKey,\n    splitFilePaths,\n    loadOrder,\n    BinaryReadParameters.Default);\n</code></pre>"},{"location":"plugins/Exceeding-Master-Limits/#important-considerations","title":"Important Considerations","text":""},{"location":"plugins/Exceeding-Master-Limits/#read-only-result","title":"Read-Only Result","text":"<p>The merged multi-mod overlay is read-only (implements <code>IModGetter</code> only). If you need to modify the data, you must copy records to a new mutable mod.</p>"},{"location":"plugins/Exceeding-Master-Limits/#resource-disposal","title":"Resource Disposal","text":"<p>The merged overlay holds references to the underlying split files. Always dispose properly:</p> <pre><code>using var mergedMod = reader.Read&lt;ISkyrimModDisposableGetter&gt;(...);\n// Use the mod\n// Disposal happens automatically at end of using block\n</code></pre>"},{"location":"plugins/Exceeding-Master-Limits/#load-order-requirements","title":"Load Order Requirements","text":"<p>Writing with auto-split requires load order information to properly order masters in the split files. Ensure you provide an accurate load order that includes all masters referenced by the mod.</p>"},{"location":"plugins/Exceeding-Master-Limits/#round-trip-support","title":"Round-Trip Support","text":"<p>Mods written with auto-split can be read back using <code>WithAutoSplitSupport()</code>, preserving all records and their data:</p> <pre><code>// Write with auto-split\nawait mod.BeginWrite\n    .ToPath(outputPath)\n    .WithLoadOrder(loadOrder)\n    .WithAutoSplit()\n    .WriteAsync();\n\n// Read back as merged overlay\nusing var roundTripped = SkyrimMod.Create(SkyrimRelease.SkyrimSE)\n    .FromPath(outputPath)\n    .WithAutoSplitSupport()\n    .Construct();\n\n// roundTripped contains all records from the original mod\n</code></pre>"},{"location":"plugins/Exceeding-Master-Limits/#limitations","title":"Limitations","text":""},{"location":"plugins/Exceeding-Master-Limits/#single-record-exceeding-master-limit","title":"Single Record Exceeding Master Limit","text":"<p>Auto-split works by distributing records across multiple files so each file stays under the 255 master limit. However, this cannot help when a single record itself references more than 255 masters.</p> <p>For example, a <code>FormList</code> that contains references to items from 300 different master files cannot be split - the record itself requires all those masters to be present. In this case, <code>TooManyMastersException</code> will be thrown even with <code>WithAutoSplit()</code> enabled.</p> <pre><code>// This will throw TooManyMastersException\nvar formList = mod.FormLists.AddNew();\nfor (uint i = 0; i &lt; 300; i++)\n{\n    var masterKey = new ModKey($\"Master_{i}\", ModType.Plugin);\n    formList.Items.Add(new FormKey(masterKey, 0x800));\n}\n\n// Auto-split cannot help here - the single FormList needs all 300 masters\nawait mod.BeginWrite\n    .ToPath(outputPath)\n    .WithLoadOrder(loadOrder)\n    .WithAutoSplit()  // Still throws TooManyMastersException\n    .WriteAsync();\n</code></pre>"},{"location":"plugins/Exceeding-Master-Limits/#error-handling","title":"Error Handling","text":""},{"location":"plugins/Exceeding-Master-Limits/#splitmodexception","title":"SplitModException","text":"<p>Thrown when:</p> <ul> <li>No split files are found for the specified ModKey (when using <code>MultiModFileReader</code>)</li> <li>Only one split file exists (expected at least 2)</li> <li>Both split files and original unsplit mod exist in the same directory</li> </ul> <pre><code>try\n{\n    var modPath = new ModPath(modKey, Path.Combine(folder, modKey.FileName));\n\n    // Check for split files - throws if invalid state\n    if (MultiModFileAnalysis.IsMultiModFile(modPath))\n    {\n        var files = MultiModFileAnalysis.GetSplitModFiles(modPath);\n    }\n}\ncatch (SplitModException ex)\n{\n    // Handle invalid split file state\n    Console.WriteLine(ex.Message);\n}\n</code></pre>"},{"location":"plugins/Exceeding-Master-Limits/#toomanymastersexception","title":"TooManyMastersException","text":"<p>When writing without <code>WithAutoSplit()</code>, this exception is thrown if the mod exceeds the master limit. Enable auto-split to handle this automatically.</p>"},{"location":"plugins/Exporting/","title":"Exporting","text":""},{"location":"plugins/Exporting/#exporting","title":"Exporting","text":""},{"location":"plugins/Exporting/#exporting_1","title":"Exporting","text":"<p>Mod objects can be exported to an esp/esm on disk</p>"},{"location":"plugins/Exporting/#builder","title":"Builder","text":"<p>The preferred route for exporting is utilizing a \"builder\": </p><pre><code>SkyrimMod mod = ...;\n\nawait mod.BeginWrite\n    .IntoFolder(folderPath)\n    .WithDefaultLoadOrder()\n    .WriteAsync();\n</code></pre><p></p> <p>The build acts as a \"wizard\", leading through the steps and options when writing.  The above will write the mod to the specified folder using the mod's ModKey.FileName for the file name, looking up the load order in the default locations (plugins.txt) for the purposes of ordering the masters properly.</p> <p>Alternatively, you can still specify the full path directly: </p><pre><code>await mod.BeginWrite\n    .ToPath(path)\n    .WithDefaultLoadOrder()\n    .WriteAsync();\n</code></pre><p></p> <p>This builder comes with lots of dials and options to customize how you want to write a mod.</p>"},{"location":"plugins/Exporting/#load-order","title":"Load Order","text":"<p><code>WithDefaultLoadOrder</code> leans on built in Mutagen systems to locate the load order.</p> <p>You can also provide it yourself with <code>WithLoadOrder</code> by passing in a list of ModKeys or similar style objects.</p> <p>Lastly, <code>WithLoadOrderFromHeaderMasters</code> lets you just use the mod objects existing header as the master ordering to refer to.  Being that the header isn't actually updated by Mutagen when modifying mod objects, this call is only useful in very specific situations.</p>"},{"location":"plugins/Exporting/#data-folder","title":"Data Folder","text":"<p>The data folder can be overridden via <code>WithDataFolder</code>, where you can specify the path explicitly.</p>"},{"location":"plugins/Exporting/#modkeysync","title":"ModKeySync","text":"<p>These builder options specify the logic to use to keep a mod's ModKey in sync with its path.  By default the system will throw an exception if the output path's name does not match the ModKey of the mod object.</p> <p><code>NoModKeySync</code> will turn this off</p> <p><code>WithModKeySync</code> lets you specify explicitly what style you want, including <code>CorrectToPath</code></p>"},{"location":"plugins/Exporting/#filesystem","title":"FileSystem","text":"<p><code>WithFileSystem</code> can be used to override the target filesystem.  By default, the normal OS filesystem will be used.</p>"},{"location":"plugins/Exporting/#masters-list-content","title":"Masters List Content","text":"<p>By default, the exporting process will loop over all records in the mod to determine the masters that need to be included in the mod's header.  </p> <p><code>NoMastersListContentCheck</code> will turn this off, and write whatever is currently in the mod header.  Note that this does not affect the order of the mods, just the content.</p>"},{"location":"plugins/Exporting/#masters-list-ordering","title":"Masters List ordering","text":"<p>By default, the load order will drive the order of the masters.  </p> <p><code>WithMastersListOrdering</code> lets you override and hand feed an alternative ordering.</p>"},{"location":"plugins/Exporting/#next-form-id","title":"Next Form ID","text":"<p>By default, all records will be iterated in order to find the next FormID available to be marked in the mod header.</p> <p><code>NoNextFormIDProcessing</code> can be called to disable this logic.</p> <p><code>WithForcedLowerFormIdRangeUsage</code> will override the behavior of whether lower range formIDs (0-0x800) should be used in the case of no records being present.</p>"},{"location":"plugins/Exporting/#formid-uniqueness","title":"FormID Uniqueness","text":"<p>By default, writing will throw if duplicate FormIDs are encountered.</p> <p><code>NoFormIDUniquenessCheck</code> will disable this check</p>"},{"location":"plugins/Exporting/#formid-null-standardization","title":"FormID Null Standardization","text":"<p>By default, all FormIDs that are null will be standardized to all zeros</p> <p><code>NoNullFormIDStandardization</code> turns this logic off.</p>"},{"location":"plugins/Exporting/#formid-compactness","title":"FormID Compactness","text":"<p>Be default, writing will check the compaction flag (Small/Medium/Full) master style and confirm that the contents are in the allowed range.</p> <p><code>NoFormIDCompactnessCheck</code> will disable this check.</p> <p><code>WithFormIDCompactnessCheck</code> will let you explicitly specify.</p>"},{"location":"plugins/Exporting/#strings","title":"Strings","text":"<p><code>WithStringsWriter</code> lets you provide a custom StringsWriter</p> <p><code>WithTargetLanguage</code> lets you set the target language (for embedded setups)</p> <p><code>WithEmbeddedEncodings</code> lets you override the encodings used</p> <p><code>WithUtf8Encoding</code> convenience method to write embedded strings using UTF8 encoding instead of the default Windows-1252. Use this when your mod contains non-Latin characters (Russian, Japanese, etc.) that need UTF8 support.</p>"},{"location":"plugins/Exporting/#lower-range-formids","title":"Lower Range FormIDs","text":"<p>Some mods and releases in certain situations allow the usage of FormIDs all the way down to ID 0.</p> <p>One requirement of this feature is that the mod has a single master.  By default, if lower IDs are used, but no master is present, then the first mod on the Load Order will be added as a placeholder.</p> <p><code>ThrowIfLowerRangeDisallowed</code> makes it throw in this situation instead.</p> <p><code>WithPlaceholderMasterIfLowerRangeDisallowed</code> lets you customize what will be used as the placeholder.</p> <p><code>NoCheckIfLowerRangeDisallowed</code> will disable the check entirely.</p>"},{"location":"plugins/Exporting/#parallel","title":"Parallel","text":"<p>Binary exporting has some parallelization potential.  By default, it will write as parallel as it can.</p> <p><code>WithParallelWriteParameters</code> lets you customize the behaviors.</p> <p><code>SingleThread</code> sets it to just use a single thread.</p>"},{"location":"plugins/Exporting/#extra-masters","title":"Extra Masters","text":"<p>Mutagen automatically determines what masters are necessary.</p> <p><code>WithExtraIncludedMasters</code> lets you add additional masters to include</p> <p><code>WithExplicitOverridingMasterList</code> lets you completely override the masters that are included.</p> <p><code>WithAllParentMasters</code> sets the logic to look at the parent mods and include their masters as well, recursively.   Requires DataFolder knowledge in order to find and read the parent mod content.</p> <p>These options only concern themselves with master content.  The order of the masters is determined via other calls.</p>"},{"location":"plugins/Exporting/#overridden-forms-list","title":"Overridden Forms List","text":"<p>Mutagen automatically populates a header's \"overridden forms\" list.</p> <p><code>WithOverriddenFormsOption</code> lets you disable/enable this logic.</p>"},{"location":"plugins/Exporting/#legacy","title":"Legacy","text":"<p>There is a more direct call <code>WriteToBinary</code> </p><pre><code>SkyrimMod mod = ...;\n\nmod.WriteToBinary(desiredFilePath);\n</code></pre> But this is not recommended, if the builder alternative is viable, as the customizations and requirements for a successful export are less easily accessed.<p></p>"},{"location":"plugins/Exporting/#typical-legacy-export","title":"Typical Legacy Export","text":"<p>The recommended call for exporting a mod passes the load order to sort with as input: </p><pre><code>SkyrimMod mod = ...;\n\nmod.WriteToBinary(\n    desiredFilePath,\n    new BinaryWriteParameters()\n    {\n        MastersListOrdering = new MastersListOrderingByLoadOrder(loadOrder)\n    });\n</code></pre><p></p> <p>This extra information helps keep the masters in proper order, as the load order information is provided for the write call to use.  </p>"},{"location":"plugins/Flags-and-Enums/","title":"Flags and Enums","text":""},{"location":"plugins/Flags-and-Enums/#flags-and-enums","title":"Flags and Enums","text":"<p>A lot of Record data is exposed via flags and enums.  All of known enum types and their options are defined explicitly for strongly typed use.</p>"},{"location":"plugins/Flags-and-Enums/#normal-enum","title":"Normal Enum","text":"<p>Certain fields have a certain subset of valid options.  These are exposed as enums, where only one choice can be made.</p> <p>For example, Oblivion's <code>Creature</code> has an enum that looks like this: </p><pre><code>public enum CreatureTypeEnum\n{\n    Creature = 0,\n    Daedra = 1,\n    Undead = 2,\n    Humanoid = 3,\n    Horse = 4,\n    Giant = 5,\n}\n</code></pre><p></p>"},{"location":"plugins/Flags-and-Enums/#setting-a-normal-enum","title":"Setting a Normal Enum","text":"<pre><code>creature.CreatureType = CreatureTypeEnum.Undead;\n</code></pre>"},{"location":"plugins/Flags-and-Enums/#switching-an-enum","title":"Switching an Enum","text":"<p>If you want to do different things depending on the value of an enum, you can do a switch</p> <pre><code>switch (creature.CreatureType)\n{\n    case CreatureType.Creature:\n        break;\n    case CreatureType.Daedra:\n        break;\n    case CreatureType.Undead:\n        break;\n    case CreatureType.Humanoid:\n        break;\n    case CreatureType.Horse:\n        break;\n    case CreatureType.Giant:\n        break;\n}\n</code></pre>"},{"location":"plugins/Flags-and-Enums/#unknown-flags","title":"Unknown Flags","text":"<p>Enums only list the values that are known and have \"nicknames\".  Sometimes mods have values for things that are \"unknown\" and don't have a name.   Rather than listing these, Mutagen opts to only list known values to keep things clean.</p> <p>You can still get at and set these values, though.  Enums in C# are backed by <code>int</code> (or other numeric primitives), and so you can write code like this: </p><pre><code>// Set an enum to an unknown value\nCreatureType e = (CreatureType)13; \n\n// Check if it's that unknown value\nif (e == (CreatureType)13)\n{\n    // Will enter this statement\n}\n</code></pre><p></p> <p>With this style API, you can still access all unknown values as needed.</p>"},{"location":"plugins/Flags-and-Enums/#flags-enum","title":"Flags Enum","text":"<p>Certain fields are allowed to have several values, and so make use of C#'s flags enum systems.</p> <p>For example, Oblivion <code>NPC</code>'s flags look like this: </p><pre><code>[Flags]\npublic enum NPCFlag\n{\n    Female = 0x000001,\n    Essential = 0x000002,\n    Respawn = 0x000008,\n    AutoCalcStats = 0x000010,\n    ...\n}\n</code></pre><p></p> <p>This enum can then be used to specify several flags on an NPC: </p><pre><code>// Mark the NPC an essential female\nnpc.Flags = NPCFlag.Female | NPCFlag.Essential;\n\n// And then add that we also want it to auto calc stats\nnpc.Flags |= NPCFlag.AutoCalcStats;\n</code></pre><p></p> <p>You can read up on C# flag enums on stack overflow for more API tricks.</p> <p>In addition to the built in C# features, Mutagen has some helper methods such as </p><pre><code>npc.Flags = npc.Flags.SetFlag(NPCFlag.AutoCalcStats, true);\n\nif (npc.Flags.HasFlag(NPCFlag.AutoCalcStats))\n{\n}\n</code></pre><p></p> <p>Info</p> <p>HasFlag and SetFlag aren't included in C# by default, but are part of the Mutagen ecosystem.</p>"},{"location":"plugins/FormKey-Allocation-and-Persistence/","title":"FormKey Allocation and Persistence","text":"<p>Experimental</p> <p>This feature has had some work put into it, but is still an experimental proof of concept</p> <p>It is common that tooling that is generating new records when creating plugins wants to keep their FormKeys consistent across several runs.  The same records should get the same FormKeys.</p> <p>There are some challenges with fulfilling this:</p> <ul> <li>How is a record detected to be the \"same\" as one from a previous run?</li> <li>Where/How do you persist the mapping information between runs?</li> </ul>"},{"location":"plugins/FormKey-Allocation-and-Persistence/#mapping-records-via-editorid","title":"Mapping Records Via EditorID","text":"<p>One of the challenges is finding a way to map records from a previous run with records from the current run, so that their FormKeys can be synced.  Mutagen does this by requiring the developer provide a unique EditorID when they want syncing to occur.</p> <p>Mutagen offers a few ways to hook into its allocation API. </p><pre><code>// No EditorID is provided at time of creation, so no syncing features invoked\nvar unsyncedNpc = mod.Npcs.AddNew();\n\n// EditorID is provided, so FormKey syncing features are active for this record\nvar syncedNpc = mod.Npcs.AddNew(\"SomeUniqueEdid\");\n\n// Some more routes\nvar syncedNpc2 = new Npc(mod, \"SomeThirdEdid\");\nvar syncedNpc3 = new Npc(mod.GetNextFormKey(\"SomeOtherEdid\"));\n</code></pre><p></p> <p>For the records where the EditorID was provided at the time of creation, syncing functionality will be applied if enabled (more on this later).</p>"},{"location":"plugins/FormKey-Allocation-and-Persistence/#keep-editorids-unique","title":"Keep EditorIDs Unique","text":"<p>With this pattern, the burden is on the developer to ensure that all records created in this fashion are supplied unique EditorIDs.  If new record is made with an EditorID that has already been used in the current \"run\", then an exception will be thrown.</p> <p>It is recommended to name the EditorIDs off the aspects that drove the record to be made in the first place:</p> <p><code>MyMod_GlassArmorNoviceShockEnchantment</code></p> <p><code>MyMod_GlassArmorMasterShockEnchantment</code></p> <p>Since each is named with a specific \"goal\" in mind, it will be less likely to collide.</p>"},{"location":"plugins/FormKey-Allocation-and-Persistence/#mixing-editorid-and-blind-allocations","title":"Mixing EditorID and Blind Allocations","text":"<p>A common question is what happens when some records are created with EditorIDs (for synchronization) while others are created without (blind allocation). Will there be collisions?</p>"},{"location":"plugins/FormKey-Allocation-and-Persistence/#how-collision-avoidance-works","title":"How Collision Avoidance Works","text":"<p>Persistent allocators (<code>TextFileFormKeyAllocator</code>, <code>TextFileSharedFormKeyAllocator</code>, <code>SQLiteFormKeyAllocator</code>) track all allocated FormIDs internally, regardless of whether they were allocated with an EditorID or not. When a blind allocation is requested, the allocator:</p> <ol> <li>Starts with the mod's <code>NextFormID</code> as a candidate</li> <li>Checks if that FormID is already in use (from the persistence file or previous allocations)</li> <li>If in use, increments and checks again until finding an unused FormID</li> <li>Returns the unused FormID</li> </ol> <p>This means blind allocations will automatically skip over any FormIDs that were previously assigned to EditorID-based records. There is no risk of a blind allocation \"stealing\" a FormKey that the allocator had reserved for a specific EditorID.</p>"},{"location":"plugins/FormKey-Allocation-and-Persistence/#example-scenario","title":"Example Scenario","text":"<p>Consider this workflow: </p><pre><code>// Run 1: Create records with EditorIDs\nvar npc1 = mod.Npcs.AddNew(\"MyMod_ImportantNpc\");  // Gets FormID 0x800\nvar npc2 = mod.Npcs.AddNew(\"MyMod_AnotherNpc\");    // Gets FormID 0x801\n// Allocator persists: \"MyMod_ImportantNpc\" -&gt; 0x800, \"MyMod_AnotherNpc\" -&gt; 0x801\n\n// Run 2: Mix of EditorID and blind allocations\nvar npc1 = mod.Npcs.AddNew(\"MyMod_ImportantNpc\");  // Returns 0x800 (from persistence)\nvar tempNpc = mod.Npcs.AddNew();                    // Gets 0x802 (skips 0x800, 0x801)\nvar npc2 = mod.Npcs.AddNew(\"MyMod_AnotherNpc\");    // Returns 0x801 (from persistence)\nvar anotherTemp = mod.Npcs.AddNew();                // Gets 0x803\n</code></pre><p></p> <p>The blind allocations never interfere with the EditorID-mapped FormKeys, even if they're requested in a different order than the original run.</p>"},{"location":"plugins/FormKey-Allocation-and-Persistence/#simpleformkeyallocator-caveat","title":"SimpleFormKeyAllocator Caveat","text":"<p>Note that <code>SimpleFormKeyAllocator</code> (the default non-persistent allocator) does not provide this collision avoidance. It simply increments the mod's <code>NextFormID</code> sequentially. If you need to mix EditorID and blind allocations safely across runs, use one of the persistent allocators.</p>"},{"location":"plugins/FormKey-Allocation-and-Persistence/#persistence-and-allocation","title":"Persistence and Allocation","text":"<p>The other half that needs to be considered is where the mapping information is stored, and how that data gets imported/used to fulfill the allocation requests described above.</p>"},{"location":"plugins/FormKey-Allocation-and-Persistence/#setting-a-mods-allocator","title":"Setting a Mod's Allocator","text":"<p>Every mod can have its FormKey allocator set, which is the logic that hands out new FormKeys to records.  This where a FormKey syncing allocator can be injected with whatever behavior we wish.</p> <p></p><pre><code>var mod = new SkyrimMod(...);\nvar allocator = new TextFileFormKeyAllocator(mod, pathToFile);\nmod.SetAllocator(allocator);\n</code></pre> This would set the mod to sync its FormKeys to a text file at the given path.<p></p>"},{"location":"plugins/FormKey-Allocation-and-Persistence/#text-file-allocators","title":"Text File Allocators","text":"<p>These alloctors save their data into a text file with the following format: </p><pre><code>TheEditorIdToSyncAgainst\n123456\n[...Repeat...]\n</code></pre><p></p> <p>One thing of note is that it saves just the FormID, without the mod indices.  The ModKey to be associated with is not persisted in the file itself.</p>"},{"location":"plugins/FormKey-Allocation-and-Persistence/#textfileformkeyallocator","title":"TextFileFormKeyAllocator","text":"<p>This a simplistic 1:1 allocator from a single mod to a single file.  As such, the ModKey of the mod is combined with the FormID retrieved from the file to get the actual FormKey for use.</p> <pre><code>var mod = new SkyrimMod(...);\nvar allocator = new TextFileFormKeyAllocator(mod, pathToFile);\nmod.SetAllocator(allocator);\n</code></pre>"},{"location":"plugins/FormKey-Allocation-and-Persistence/#textfilesharedformkeyallocator","title":"TextFileSharedFormKeyAllocator","text":"<p>This is a more advanced allocator for when several separate sources need to coordinate together to avoid FormKey collisions.  A prime example is a Synthesis patcher run, where several separate programs will run, and all need to avoid allocating FormKeys that another has used.</p> <pre><code>var mod = new SkyrimMod(...);\nvar allocator = new TextFileSharedFormKeyAllocator(mod, pathToFolder, \"MyProgramName\");\nmod.SetAllocator(allocator);\n</code></pre> <p>This will save to a folder, instead, with a file within under \"MyProgramName\" that has this specific programs sync information.  However, the system will examine other files within that folder so that those FormKeys can be avoided when allocating fresh new FormKeys.</p>"},{"location":"plugins/FormKey-Allocation-and-Persistence/#sqlite","title":"Sqlite","text":"<p>There is also the beginnings of a Sqlite backed persistence system within <code>Mutagen.Bethesda.Sqlite</code>.  It needs to be optimized before it will be a viable choice.</p>"},{"location":"plugins/FormKey-Allocation-and-Persistence/#saving-allocation-state","title":"Saving Allocation State","text":"<p>Allocators are created separately from a mod, even if they are assigned to a mod and tightly associated with it.  As such, allocators are themselves in charge of persisting their state once allocations have been made.  Typically this is done via disposal mechanics:</p> <pre><code>var mod = new SkyrimMod(...);\n// This API pattern will dispose the allocator when its variable goes out of scope\nusing var allocator = new TextFileFormKeyAllocator(mod, pathToFile);\nmod.SetAllocator(allocator);\n\n// Or\nvar mod2 = new SkyrimMod(...);\nusing (var allocator2 = new TextFileFormKeyAllocator(mod, pathToFile))\n{\n    mod2.SetAllocator(allocator2);\n    // Do work on mod\n} // Allocator exports results to disk here\n\n// Or\nvar mod3 = new SkyrimMod(...);\nvar allocator3 = new TextFileFormKeyAllocator(mod, pathToFile)\nmod3.SetAllocator(allocator3);\n\n// Do work on mod\n// Manually dispose or persist allocator when done\nallocator3.Commit(); // Or Dispose\n</code></pre>"},{"location":"plugins/Importing/","title":"Importing","text":""},{"location":"plugins/Importing/#importing","title":"Importing","text":"<p>All Mods are generated with the ability to create themselves from their binary plugin format (esp/esm/esl).</p>"},{"location":"plugins/Importing/#read-only","title":"Read Only","text":"<p>By default, mods are readonly.  This comes with a lot of speed and memory usage upsides.  Only fields that are accessed get parsed, which saves a lot of time and work.</p> <pre><code>using var mod = OblivionMod.Create(OblivionRelease.Oblivion)\n    .FromPath(pathToMod)\n    .Construct();\n// Code accessing the mod\n</code></pre> <p>Preferred</p> <p>Use readonly when possible, up until you want to mutate records.</p> <p> Mutation Patterns</p>"},{"location":"plugins/Importing/#no-up-front-work","title":"No Up Front Work","text":"<p>With readonly objects, a mod object is returned almost immediately for use after having done almost no parsing.  As the user accesses members of the <code>Mod</code>, the parsing is done on demand for only the members accessed.</p>"},{"location":"plugins/Importing/#no-persistent-references-to-records-or-memory","title":"No Persistent References to Records or Memory","text":"<p>Readonly systems keep no internal references to any record objects.  This means that when a user is done working with something and discards it, the GC is allowed to immediately clean it up.</p>"},{"location":"plugins/Importing/#requires-an-open-stream","title":"Requires an Open Stream","text":"<p>Readonly objects keep reference to an open stream internally, so they can read when accessed.</p> <p>Disposable</p> <p>Binary Overlay objects implement <code>IDisposable</code>.  Putting them in <code>using</code> statements to close when appropriate is good practice.</p>"},{"location":"plugins/Importing/#best-practices","title":"Best Practices","text":"<p>Avoid Repeated Access</p> <p>The Overlay pattern has the downside that repeated access of properties means repeated parsing of the same data.</p> <p> Overlay Best Practices</p>"},{"location":"plugins/Importing/#mutable","title":"Mutable","text":"<p>A normal C# object can be created containing all of a mod's data.  This is generally be reserved for when constructing or modifying records for output.</p> <pre><code>using var mod = OblivionMod.Create(OblivionRelease.Oblivion)\n    .FromPath(pathToMod)\n    .Mutable()\n    .Construct();\n</code></pre> <p>The only difference is we add <code>Mutable()</code>, which returns a mutable variant of the mod object, which is fulfilled in a completely different way. The entire mod will have been loaded into memory via classes created to store all the various fields and records.   You can then begin to interact with the mod object.</p> <p>Heavier Load</p> <p>This route spends more time and memory loading in everything up front, even the data you will not be interacting with.</p> <p>If you don't need to modify the mod, consider instead:</p> <p> Read Only Mod Importing</p>"},{"location":"plugins/Importing/#flexible-game-target","title":"Flexible Game Target","text":"<p>In more complex setups, often the game type is not known at compile time.</p> UntypedGeneric <pre><code>using var readOnlyInputMod = ModFactory.ImportGetter(pathToMod, release);\nvar mutableMod = ModFactory.ImportSetter(pathToMod, release);\n</code></pre> <pre><code>var mod = ModFactory&lt;TMod&gt;.Importer(ModKey.FromFileName(\"MyMod.esp\"), release);\n</code></pre> <p>Dispose Appropriately</p> <p>Binary overlays are disposable, as they can keep streams open as they are accessed.  Make sure to utilize <code>using</code> statements to dispose of them appropriately.</p>"},{"location":"plugins/Importing/#builder-pattern","title":"Builder Pattern","text":"<p>All mod importing in Mutagen uses a fluent builder pattern that allows you to customize the import process. The builder pattern starts with <code>Create()</code> and ends with <code>Construct()</code>, with various configuration methods in between.</p>"},{"location":"plugins/Importing/#basic-structure","title":"Basic Structure","text":"<pre><code>var mod = OblivionMod.Create(OblivionRelease.Oblivion)  // Start builder\n    .FromPath(pathToMod)                                 // Specify source\n    .Construct();                                        // Execute import\n</code></pre> <p>The builder pattern is designed to guide you through the import process with a progressive API that requires certain decisions at specific points.</p>"},{"location":"plugins/Importing/#source-selection","title":"Source Selection","text":"<p>The first required step is to specify where to load the mod from.</p>"},{"location":"plugins/Importing/#frompath","title":"FromPath","text":"<p>Loads a mod from a file path. This is the most common approach.</p> <pre><code>var mod = SkyrimMod.Create(SkyrimRelease.SkyrimSE)\n    .FromPath(new ModPath(modKey, pathToModFile))\n    .Construct();\n</code></pre>"},{"location":"plugins/Importing/#fromstream","title":"FromStream","text":"<p>Loads a mod from an open stream. The stream must remain open for the lifetime of the overlay.</p> <pre><code>using var stream = File.OpenRead(pathToModFile);\nvar mod = SkyrimMod.Create(SkyrimRelease.SkyrimSE)\n    .FromStream(stream, modKey)\n    .Construct();\n</code></pre> <p>Stream Lifetime</p> <p>For readonly imports, the stream must remain open as data is read on-demand. For mutable imports, the stream can be closed after <code>Construct()</code> completes.</p>"},{"location":"plugins/Importing/#fromstreamfactory","title":"FromStreamFactory","text":"<p>Loads a mod using a stream factory that creates new streams on demand. Useful for readonly imports that need multiple concurrent streams.</p> <pre><code>var mod = SkyrimMod.Create(SkyrimRelease.SkyrimSE)\n    .FromStreamFactory(() =&gt; File.OpenRead(pathToModFile), modKey)\n    .Construct();\n</code></pre> <p>Stream Factory Requirements</p> <p>The factory must return a new stream each time it is called. Returning the same stream instance will cause errors.</p>"},{"location":"plugins/Importing/#data-folder","title":"Data Folder","text":""},{"location":"plugins/Importing/#withdatafolder","title":"WithDataFolder","text":"<p>Specifies the data folder location for loading master files.</p> <pre><code>var mod = SkyrimMod.Create(SkyrimRelease.SkyrimSE)\n    .FromPath(modPath)\n    .WithLoadOrder(masterKey1, masterKey2)\n    .WithDataFolder(dataFolderPath)\n    .Construct();\n</code></pre>"},{"location":"plugins/Importing/#withdefaultdatafolder","title":"WithDefaultDataFolder","text":"<p>Uses the game's installed data folder location automatically.</p> <pre><code>var mod = SkyrimMod.Create(SkyrimRelease.SkyrimSE)\n    .FromPath(modPath)\n    .WithDefaultDataFolder()\n    .Construct();\n</code></pre>"},{"location":"plugins/Importing/#split-file-support","title":"Split File Support","text":""},{"location":"plugins/Importing/#withautosplitsupport","title":"WithAutoSplitSupport","text":"<p>Enables automatic detection and merging of split mod files (e.g., <code>ModName_1.esp</code>, <code>ModName_2.esp</code>).</p> <pre><code>var mod = SkyrimMod.Create(SkyrimRelease.SkyrimSE)\n    .FromPath(modPath)\n    .WithAutoSplitSupport()\n    .Construct();\n</code></pre> <p>Path Only</p> <p>Auto-split support only works with <code>FromPath</code>. Using <code>FromStream</code> with this option will throw an exception.</p> <p> More on Split Files</p>"},{"location":"plugins/Importing/#load-order-configuration","title":"Load Order Configuration","text":"<p>For most games and situations, load order is not required for reading mods. Load order information is only necessary in these specific cases:</p> <ul> <li>Starfield - Required for proper FormID resolution with separated masters  See Starfield section</li> <li>ExtraData Usage - Suggested if your code will interact with ExtraData  ExtraData documentation</li> </ul> <p>For all other situations, you can safely omit load order configuration.</p>"},{"location":"plugins/Importing/#withloadorder-modkeys","title":"WithLoadOrder (ModKeys)","text":"<p>Provides a list of ModKeys to load from the data folder.</p> <pre><code>var mod = SkyrimMod.Create(SkyrimRelease.SkyrimSE)\n    .FromPath(modPath)\n    .WithLoadOrder(masterKey1, masterKey2)\n    .WithDataFolder(dataFolderPath)\n    .Construct();\n</code></pre>"},{"location":"plugins/Importing/#withdefaultloadorder","title":"WithDefaultLoadOrder","text":"<p>Uses the game's default load order from the installed game location.</p> <pre><code>var mod = SkyrimMod.Create(SkyrimRelease.SkyrimSE)\n    .FromPath(modPath)\n    .WithDefaultLoadOrder()\n    .Construct();\n</code></pre>"},{"location":"plugins/Importing/#withloadorderfromheadermasters","title":"WithLoadOrderFromHeaderMasters","text":"<p>Reads the master list from the mod header and loads those specific mods.</p> <pre><code>var mod = SkyrimMod.Create(SkyrimRelease.SkyrimSE)\n    .FromPath(modPath)\n    .WithLoadOrderFromHeaderMasters()\n    .WithDataFolder(dataFolderPath)\n    .Construct();\n</code></pre>"},{"location":"plugins/Importing/#withlinkcache","title":"WithLinkCache","text":"<p>Provides an existing LinkCache instead of constructing one from a load order.</p> <pre><code>var linkCache = mods.ToImmutableLinkCache();\n\nvar mod = SkyrimMod.Create(SkyrimRelease.SkyrimSE)\n    .FromPath(modPath)\n    .WithLinkCache(linkCache)\n    .Construct();\n</code></pre> <p>Mutual Exclusivity</p> <p><code>WithLinkCache</code> and <code>WithLoadOrder</code> methods are mutually exclusive. Use one or the other, not both.</p>"},{"location":"plugins/Importing/#withnoloadorder","title":"WithNoLoadOrder","text":"<p>Skips load order processing entirely. Use with caution.</p> <pre><code>var mod = SkyrimMod.Create(SkyrimRelease.SkyrimSE)\n    .FromPath(modPath)\n    .WithNoLoadOrder()\n    .Construct();\n</code></pre> <p>Potential Corruption</p> <p>For Starfield and other separated master games, using <code>WithNoLoadOrder</code> can cause data corruption if the mod references light or medium masters.</p>"},{"location":"plugins/Importing/#string-configuration","title":"String Configuration","text":"<p>Control how strings and translations are handled during import.</p>"},{"location":"plugins/Importing/#withstringsfolder","title":"WithStringsFolder","text":"<p>Overrides the default strings folder location.</p> <pre><code>var mod = SkyrimMod.Create(SkyrimRelease.SkyrimSE)\n    .FromPath(modPath)\n    .WithStringsFolder(customStringsFolder)\n    .Construct();\n</code></pre>"},{"location":"plugins/Importing/#withtargetlanguage","title":"WithTargetLanguage","text":"<p>Sets the target language for TranslatedString fields.</p> <pre><code>var mod = SkyrimMod.Create(SkyrimRelease.SkyrimSE)\n    .FromPath(modPath)\n    .WithTargetLanguage(Language.French)\n    .Construct();\n</code></pre>"},{"location":"plugins/Importing/#withencoding","title":"WithEncoding","text":"<p>Overrides the encoding provider used for string parsing.</p> <pre><code>var mod = SkyrimMod.Create(SkyrimRelease.SkyrimSE)\n    .FromPath(modPath)\n    .WithEncoding(customEncodingProvider)\n    .Construct();\n</code></pre>"},{"location":"plugins/Importing/#performance-options","title":"Performance Options","text":""},{"location":"plugins/Importing/#parallel-processing","title":"Parallel Processing","text":"<p>Enables or disables parallel processing during import. Enabled by default for mutable imports.</p> <pre><code>// Enable parallel processing\nvar mod = SkyrimMod.Create(SkyrimRelease.SkyrimSE)\n    .FromPath(modPath)\n    .Mutable()\n    .Parallel(true)\n    .Construct();\n\n// Disable parallel processing\nvar mod = SkyrimMod.Create(SkyrimRelease.SkyrimSE)\n    .FromPath(modPath)\n    .Mutable()\n    .SingleThread()\n    .Construct();\n</code></pre>"},{"location":"plugins/Importing/#mutable-specific-options","title":"Mutable-Specific Options","text":"<p>These options are only available when using <code>.Mutable()</code>.</p>"},{"location":"plugins/Importing/#withgroupmask","title":"WithGroupMask","text":"<p>Limits which record types are imported, reducing memory usage and load time.</p> <pre><code>var mod = OblivionMod.Create(OblivionRelease.Oblivion)\n    .FromPath(pathToMod)\n    .Mutable()\n    .WithGroupMask(new GroupMask()\n    {\n        Potions = true,\n        NPCs = true,\n    })\n    .Construct();\n</code></pre> <p>Generally Unused</p> <p>Generally this feature is unused, as Binary Overlays handle the situation of selectively accessing data much better.</p>"},{"location":"plugins/Importing/#witherrormask","title":"WithErrorMask","text":"<p>Adds error tracking to help debug issues during import.</p> <pre><code>var errorMask = new ErrorMaskBuilder();\nvar mod = SkyrimMod.Create(SkyrimRelease.SkyrimSE)\n    .FromPath(modPath)\n    .Mutable()\n    .WithErrorMask(errorMask)\n    .Construct();\n\n// Check for errors\nif (errorMask.Overall != null)\n{\n    Console.WriteLine(errorMask.Overall.ToString());\n}\n</code></pre>"},{"location":"plugins/Importing/#error-handling","title":"Error Handling","text":""},{"location":"plugins/Importing/#throwifunknownsubrecord","title":"ThrowIfUnknownSubrecord","text":"<p>Controls whether unknown subrecords cause exceptions.</p> <pre><code>var mod = SkyrimMod.Create(SkyrimRelease.SkyrimSE)\n    .FromPath(modPath)\n    .ThrowIfUnknownSubrecord(true)\n    .Construct();\n</code></pre>"},{"location":"plugins/Importing/#advanced-options","title":"Advanced Options","text":""},{"location":"plugins/Importing/#withfilesystem","title":"WithFileSystem","text":"<p>Provides a custom file system implementation for testing or virtualization.</p> <pre><code>var mod = SkyrimMod.Create(SkyrimRelease.SkyrimSE)\n    .FromPath(modPath)\n    .WithFileSystem(customFileSystem)\n    .Construct();\n</code></pre>"},{"location":"plugins/Importing/#starfield-and-separated-master-games","title":"Starfield and Separated Master Games","text":"<p>Starfield and other games with separated master load orders require special handling for light and medium masters.</p>"},{"location":"plugins/Importing/#withknownmasters","title":"WithKnownMasters","text":"<p>Provides master style information without requiring the files to be present in the data folder.</p> <pre><code>var knownMaster = new KeyedMasterStyle(masterKey, MasterStyle.Medium);\n\nvar mod = StarfieldMod.Create(StarfieldRelease.Starfield)\n    .FromPath(modPath)\n    .WithKnownMasters(knownMaster)\n    .WithNoLoadOrder()\n    .Construct();\n</code></pre> <p>This is useful when you have master information but the actual master files aren't available in the data folder.</p>"},{"location":"plugins/Importing/#separated-load-order-requirements","title":"Separated Load Order Requirements","text":"<p>For Starfield, you must provide either:</p> <ol> <li> <p>A load order with mod objects (contains master style info):    </p><pre><code>var mod = StarfieldMod.Create(StarfieldRelease.Starfield)\n    .FromPath(modPath)\n    .WithLoadOrder(masterMod1, masterMod2)\n    .Construct();\n</code></pre><p></p> </li> <li> <p>A load order with ModKeys and a data folder (to read master style from files):    </p><pre><code>var mod = StarfieldMod.Create(StarfieldRelease.Starfield)\n    .FromPath(modPath)\n    .WithLoadOrder(masterKey1, masterKey2)\n    .WithDataFolder(dataFolderPath)\n    .Construct();\n</code></pre><p></p> </li> <li> <p>Known masters with no load order (for controlled scenarios):    </p><pre><code>var mod = StarfieldMod.Create(StarfieldRelease.Starfield)\n    .FromPath(modPath)\n    .WithKnownMasters(knownMaster1, knownMaster2)\n    .WithNoLoadOrder()\n    .Construct();\n</code></pre><p></p> </li> </ol> <p>Required for Starfield</p> <p>Failing to provide proper master information for Starfield mods will result in corrupted FormID resolution when the mod references light or medium masters.</p>"},{"location":"plugins/Importing/#group-masks","title":"Group Masks","text":"<p>Often, users are not interested in all records that a mod contains.  Group Masks are an optional parameter that allows you to specify which record types you are interested in importing. </p><pre><code>using var mod = OblivionMod.Create(OblivionRelease.Oblivion)\n    .FromPath(pathToMod)\n    .Mutable()\n    .WithGroupMask(new GroupMask()\n    {\n        Potions = true,\n        NPCs = true,\n    })\n    .Construct();\n</code></pre> This import call will only process and import Potions and NPCs.<p></p> <p>Generally Unused</p> <p>Generally this feature is unused, as Binary Overlays handle the situation of selectively accessing data much better.</p>"},{"location":"plugins/Interfaces/","title":"Interfaces (Aspect/Link/Getters)","text":""},{"location":"plugins/Interfaces/#interfaces","title":"Interfaces","text":"<p>Mutagen exposes a few categories of interfaces:</p> <ul> <li>Getters and Setters (Immutable vs Mutable)</li> <li>Aspect (Expose aspects common to many records)</li> <li>Link (Enables FormLinks to point to an umbrella of record types)</li> </ul>"},{"location":"plugins/Interfaces/#getters-and-setters","title":"Getters and Setters","text":"<p>Each autogenerated class also gets accompanying Getter/Setter interfaces</p> <pre><code>public class Potion : IPotion\n{\n    public int Value { get; set; }\n    public float Weight { get; set; }\n    public string Name { get; set; }\n}\n\npublic interface IPotionGetter\n{\n    int Value { get; }\n    float Weight { get; }\n    string Name { get; }\n}\n\npublic interface IPotion : IPotionGetter\n{\n    int Value { get; set; }\n    float Weight { get; set; }\n    string Name { get; set; }\n}\n</code></pre> <p>These are created mainly to expose objects in a readonly manner when appropriate. The Getter interfaces, specifically, are heavily used when reading data from a mod on-disk.</p>"},{"location":"plugins/Interfaces/#aspect-interfaces","title":"Aspect Interfaces","text":"<p>Aspect Interfaces expose common fields that are shared among many records.  They are used to help write code that is more generic and can process more than just a single record type.</p>"},{"location":"plugins/Interfaces/#problem-to-solve","title":"Problem to Solve","text":"<pre><code>public static void PrintName(Armor armor)\n{\n   System.Console.WriteLine($\"Found {armor.GetType()} with name: {armor.Name}\");\n}\n</code></pre> This works great!  For armors only. What if you wanted this function to work on any record that had <code>Name</code>?  What type do you specify as the parameter? <p>This is where Aspect Interfaces come to the rescue. An interface is defined: </p><pre><code>public interface INamed\n{\n    string Name { get; set; }\n}\n</code></pre> This is an interface that any record that contains a <code>Name</code> can implement.  Now we can tweak our <code>PrintName</code> function to apply to any of these records, no matter what they are. <pre><code>public static void PrintName(INamed name)\n{\n   System.Console.WriteLine($\"Found {name.GetType()} with name: {name.Name}\");\n}\n</code></pre><p></p>"},{"location":"plugins/Interfaces/#typical-usage","title":"Typical Usage","text":""},{"location":"plugins/Interfaces/#using-aspect-interfaces-as-a-parameter","title":"Using Aspect Interfaces as a Parameter","text":"<p>In the problem described above, a common use case is wanting to write a function that applies to multiple record types: </p><pre><code>public static void PrintName(INamedGetter namedRecord)\n{\n   System.Console.WriteLine($\"Found name: {namedRecord.Name}\");\n}\n</code></pre> Using the Aspect Interface <code>INamed</code>, we have written a function that can apply to any record that has a name.  Could be an Armor, Npc, Weapon, etc.<p></p>"},{"location":"plugins/Interfaces/#weaving-multiple-aspect-interfaces-using-generics","title":"Weaving Multiple Aspect Interfaces Using Generics","text":"<p>The above example using one Aspect Interface as the parameter type is great if you're only interested in a single aspect.</p> <p>What if you wanted to write a function that could process any record that had a name, and had a model?  Well, then we need to combine multiple aspects.</p> <pre><code>public static void PrintNameAndModel&lt;TRecord&gt;(TRecord record)\n    where TRecord : IMajorRecordCommon, INamed, IModeled\n{\n   System.Console.WriteLine($\"{record.FormKey} with EditorID {record.EditorID} had name: {record.Name}.\");\n   if (record.Model != null)\n   {\n       System.Console.WriteLine($\"   Model file: {record.Model.File}\");\n   }\n}\n</code></pre> <p>This function uses C# Generics to specify that <code>TRecord</code> should be any record that is a Major Record, is named, and has a model.</p> <p>Now this function can directly access those aspects of records that are passed in.  Additionally, this function will automatically only accept records that have all these aspects.  A <code>Footstep</code> record, for example, which isn't named and doesn't have a model, would not be allowed to be passed to this function: C# would give a compiler error.</p>"},{"location":"plugins/Interfaces/#evolution","title":"Evolution","text":"<p>The list of Aspect Interfaces is an evolution.  Many more Aspect Interfaces could be created to expose fields that are common to many records.  </p> <p>Additionally, Aspect Interfaces can be made to apply to cross-game records.  These of course will be more limited, as concepts that are shared across different games are less than those shared within the same game.</p> <p>New Interfaces</p> <p>If you see an Aspect Interface that would be nice to add, please create an issue and ask for it to be added!  Over time, the list of Aspect Interfaces will be more and more complete.</p>"},{"location":"plugins/Interfaces/#link-interfaces","title":"Link Interfaces","text":"<p>Link Interfaces have a different goal.  They act more as markers, rather than a vehicle to expose common fields.</p>"},{"location":"plugins/Interfaces/#problem-to-solve_1","title":"Problem to Solve","text":"<p>Mutagen's FormLinks can specify a record type that the FormKey they represent is allowed to match against.  It provides type safety to FormID/FormKey concepts.</p> <p>What happens when a FormLink should be able to point to multiple record types?  A container object can contain many different record types:  Armor, Weapons, etc.</p> <p>This is where Link Interfaces come into play.   A LinkInterface <code>IItem</code> is defined: </p><pre><code>public interface IItem\n{\n}\n</code></pre> Notice it doesn't have any fields.  It is just a marker that Armor, Weapons, etc can implement. Now FormLink can target that interface instead: <code>FormLink&lt;IItemGetter&gt;</code>.  This link can now point to any of those records that are marked with <code>IItem</code><p></p>"},{"location":"plugins/Interfaces/#typical-usage_1","title":"Typical Usage","text":""},{"location":"plugins/Interfaces/#knowing-types-allowed-into-a-formlink","title":"Knowing Types Allowed into a FormLink","text":"<p>Typical interaction with Link Interfaces are when users try to assign a record to a FormLink, and the compiler tells them it's not allowed.  They offer type safety, and block users from messing up and assigning a <code>Potion</code> to an Npc's <code>Race</code> field.</p> <p>However, you may want to know what types are allowed when you see a <code>FormLink&lt;IConstructibleGetter&gt;</code>.  There are two ways to get at this information:</p>"},{"location":"plugins/Interfaces/#visual-studio-intellisense","title":"Visual Studio Intellisense","text":"<p>Visual Studio offers a lot of tooling to be able to investigate classes/interfaces. Here is an example of <code>F12</code> being used to investigate <code>IConstructibleGetter</code> and see the comments on which objects implement it:</p> <p></p>"},{"location":"plugins/Interfaces/#evolution_1","title":"Evolution","text":"<p>New Link Interfaces are rarely defined.  These are usually known ahead of time and new ones aren't added.</p> <p>However, over time they can/could take on more of an Aspect Interface role, where common fields that are shared by all records implementing a Link Interface could be listed.  This would be Link Interfaces becoming more than just a simple marker, and becoming their own Aspect Interfaces of sorts.   </p> <p>Field Exposure</p> <p>If there are some fields common to all records of a Link Interface that you think should be exposed, please make an issue!</p>"},{"location":"plugins/Interfaces/#list-of-interfaces","title":"List of Interfaces","text":"<p>Mutagen autogenerates some documentation on what Aspect/Link interfaces exist, and what implements what.</p> <p> List of Interfaces</p>"},{"location":"plugins/ModKey%2C%20FormKey%2C%20FormLink/","title":"ModKey, FormKey, FormLink","text":"<p>This article covers three fundamental identifiers:</p> <ul> <li>ModKey (a unique identifier for a mod)</li> <li>FormKey (FormID)</li> <li>FormLink (Typing added to a FormKey)</li> </ul>"},{"location":"plugins/ModKey%2C%20FormKey%2C%20FormLink/#modkey","title":"ModKey","text":"<p><code>ModKey</code>s represent a unique identifier for a mod, as an alternative to a raw string.</p> Field Type Description Skyrim.esm Example Name string Mod's name (without '.esp' or '.esm) \"Skyrim\" Type enum Whether it is a master, plugin, or light master ModType.Master"},{"location":"plugins/ModKey%2C%20FormKey%2C%20FormLink/#construction","title":"Construction","text":"TryFromFileNameFromFileNameNew <pre><code>if (ModKey.TryFromFileName(\"Skyrim.esm\", out var modKey))\n{\n   // If conversion successful.\n}\nelse\n{\n   // An unsuccessful conversion.\n   // Might occur if there was an extension typo, like \"Skyrim.esz\"\n}\n</code></pre> <pre><code>var modKey = ModKey.FromFileName(\"Skyrim.esm\");\n</code></pre> <p>This would throw an exception if string could not be converted</p> <pre><code>var modKey = new ModKey(\"Skyrim\", ModType.Plugin);\n</code></pre>"},{"location":"plugins/ModKey%2C%20FormKey%2C%20FormLink/#formkey","title":"FormKey","text":"<p>A <code>FormKey</code> represents a unique identifier for a record. They are Mutagen's interpretation of a <code>FormID</code>.</p> Field Type Description Skyrim Iron Sword example ModKey ModKey The ModKey associated with the FormKey \"Skyrim.esm\" ID uint A record's FormID (without master indices) 0x012EB7 <p>Mod indices are ignored in the uint, as this information is stored in the ModKey</p> <p>String Representation</p> <p>An example FormKey string might be <code>123456:Skyrim.esm</code></p> <p>The numbers are the last 6 digits of a FormID (with no mod index), followed by the string name of the mod that originally defined it</p>"},{"location":"plugins/ModKey%2C%20FormKey%2C%20FormLink/#construction_1","title":"Construction","text":"TryFactoryFactoryConstructor <pre><code>if (FormKey.TryFactory(\"123456:Oblivion.esm\", out var formKey))\n{\n   // If conversion successful\n}\n</code></pre> <pre><code>formKey = FormKey.Factory(\"123456:Skyrim.esm\");\n</code></pre> <p>This would throw an exception if string could not be converted</p> <pre><code>var modKey = ModKey.FromFileName(\"Skyrim.esm\");\nvar formKey = new FormKey(modKey, 0x123456);\n</code></pre>"},{"location":"plugins/ModKey%2C%20FormKey%2C%20FormLink/#why-formkeys-instead-of-formids","title":"Why FormKeys instead of FormIDs?","text":""},{"location":"plugins/ModKey%2C%20FormKey%2C%20FormLink/#avoid-master-mismatch-bugs","title":"Avoid Master Mismatch Bugs","text":"<p><code>FormID</code> concepts are a staple of Bethesda modding, but they can be the source of some confusion and bugs.  </p> <p>Warning</p> <p>A <code>FormID</code>'s master index bits are relative to the mod/loadorder that contains them.  A <code>FormID</code> contained in one mod can point to a completely different record if used to query into a different mod.  A user has to \"realign\" the master indices of a FormID to match the mod or context that they want to query into.</p> <p>Mutagen abstracts away some of the complexity of <code>FormID</code>s by exposing <code>FormKey</code> objects instead.  There are no Master Indices, but rather a string of the mod's name they originate from.  This means a <code>FormKey</code> can never be misinterpreted to point to the wrong record, no matter what context it is used in.</p>"},{"location":"plugins/ModKey%2C%20FormKey%2C%20FormLink/#remove-the-255-mod-limit","title":"Remove the 255 Mod Limit","text":"<p>As there is no Mod index stored as a byte within a <code>FormKey</code>, there is no 255 master limit within Mutagen when a program is running.  Mods can contain records from &gt;255 number of masters, and <code>LoadOrders</code> can contain &gt;255 mods.</p> <p>Limit Still Exists on Disk</p> <p>The limit is still enforced when exporting to Binary.  When transposed to disk, there is no way around the 255 limit.</p>"},{"location":"plugins/ModKey%2C%20FormKey%2C%20FormLink/#formlink","title":"FormLink","text":"<p>A <code>FormLink&lt;T&gt;</code> is generic, where T is a Major Record type.</p> Field Type Description Skyrim Iron Sword example FormKey FormKey The FormKey associated with the FormLink \"012EB7:Skyrim.esm\" Type Type A Major Record type IWeaponGetter <p>A <code>FormLink</code> adds type safety to the concept of a <code>FormKey</code>.  Consider an NPC's <code>Race</code> member, which is of type: <code>FormLink&lt;IRaceGetter&gt;</code>.  This link is not allowed to point to or link against any record that is not a <code>Race</code>.  It is hard to accidentally set a <code>FormLink&lt;IRaceGetter&gt;</code> link to point to an <code>IPotionGetter</code> record, as attempting to do so would typically result in a compiler error.</p> <p>Best Practices</p> <p>It is recommended to use \"Getter\" interfaces when specifying generic types</p> <p> Prefer Getters</p>"},{"location":"plugins/ModKey%2C%20FormKey%2C%20FormLink/#resolves","title":"Resolves","text":"<p>FormLinks can be combined with LinkCaches to easily look up a record. </p> <pre><code>IFormLinkGetter&lt;IItemGetter&gt; someItemLink = ...;\n\nif (someItemLink.TryResolve(myLinkCache, out var itemRecord))\n{\n   // The FormKey associated with the FormLink was found\n   // and was of the type associated with the link (IItemRecord)\n   Console.WriteLine($\"Was able to find the item record object: {itemRecord}\");\n}\n</code></pre> <p> Record Lookups</p>"},{"location":"plugins/ModKey%2C%20FormKey%2C%20FormLink/#setto","title":"SetTo","text":"<p>Generated records will have FormLinks that point to records.  You can change the record they point to by modifying the FormLink</p> FormKeyRecord <pre><code>Npc npc = ...;\nFormKey formKey = ...;\n\nnpc.WornArmor.SetTo(formKey);\n</code></pre> <pre><code>Npc npc = ...;\nArmor armor = ...;\n\nnpc.WornArmor.SetTo(armor);\n</code></pre> <p>Things that don't make sense will be blocked by the compiler</p> <pre><code>Npc npc = ...;\nIngredient ingredient = ...;\n\n// An ingredient cannot be a worn armor\nnpc.WornArmor.SetTo(ingredient); // Compiler error\n</code></pre>"},{"location":"plugins/ModKey%2C%20FormKey%2C%20FormLink/#construction_2","title":"Construction","text":"<p>Most FormLinks come as part of generated record objects, but you can also create your own. Note that usually FormLinks work best when they point to getter interfaces, rather than setters.</p> ConstructorImplicit OperatorHelper Functions <pre><code>FormKey formKey = ...;\nIArmorGetter armor = ...;\n\n// With FormKey\nvar link1 = new FormLink&lt;IArmorGetter&gt;(formKey);\n\n// With Record\nvar link2 = new FormLink&lt;IArmorGetter&gt;(armor);\n</code></pre> <pre><code>FormKey formKey = ...;\nIArmorGetter armor = ...;\nFormLink&lt;IArmorGetter&gt; myLink;\n\n// Implictly assign with FormKey\nlink = formKey;\n\n// Implictly assign with Record\nlink = armor;\n</code></pre> <pre><code>FormKey formKey = ...;\nIArmorGetter armor = ...;\n\n// By FormKey\nvar myOtherLink = myArmorKey.AsLink&lt;IArmorGetter&gt;();\n\n// By Record\nvar myOtherLink2 = armor.AsLink();\n</code></pre> <p>Best Practices</p> <p>It is recommended to use \"Getter\" interfaces when specifying scoping types</p> <p> Prefer Getters</p>"},{"location":"plugins/New-Mods/","title":"New Mods","text":""},{"location":"plugins/New-Mods/#new-mods","title":"New Mods","text":"<p>How to make a new mod object from scratch without a file</p>"},{"location":"plugins/New-Mods/#known-game","title":"Known Game","text":"<p>If you know the game you will be working with at compile time, this is the typical way to create a new mod:</p> <pre><code>var newMod = new SkyrimMod(ModKey.FromFileName(\"MyMod.esp\"), SkyrimRelease.SkyrimSE);\n</code></pre>"},{"location":"plugins/New-Mods/#unknown-game","title":"Unknown Game","text":"<p>In more complex setups, often the game type is not known at compile time</p> UntypedGeneric <pre><code>var newMod = ModFactory.Activator(ModKey.FromFileName(\"MyMod.esp\"), release);\n</code></pre> <pre><code>var newMod = ModFactory&lt;TMod&gt;.Activator(ModKey.FromFileName(\"MyMod.esp\"), release);\n</code></pre>"},{"location":"plugins/Printing/","title":"Printing","text":"<p>There are a few options for turning a Mutagen object into a `string``.</p>"},{"location":"plugins/Printing/#tostring","title":"ToString","text":"<p>If you call <code>ToString()</code> on a Mutagen object, you will typically not see any content within the string.  You will usually get just the class name, or some short but informative identifying string, such as Major Records returning their FormKey:</p> <p><code>Skyrim.Npc 123456:Skyrim.esm</code></p>"},{"location":"plugins/Printing/#print","title":"Print","text":"<p>All Mutagen objects implement <code>IPrintable</code>, which exposes a <code>Print()</code> method.   Calling this will do a more verbose printing of the content.</p> <pre><code>var str = npc.Print();\n</code></pre>"},{"location":"plugins/Printing/#structuredstringbuilder","title":"StructuredStringBuilder","text":"<p>If you are printing multiple objects, or have more complex needs, you might consider utilizing the <code>StructuredStringBuilder</code>.  This is a more advanced <code>StringBuilder</code> with some extra functionality.</p> <pre><code>StructuredStringBuilder sb = ...;\nsb.AppendLine(\"The NPC had the content:\");\n\nnpc.Print(sb);\n\nvar str = sb.ToString();\n</code></pre>"},{"location":"plugins/Remapping-FormLinks/","title":"Remapping FormLinks","text":""},{"location":"plugins/Remapping-FormLinks/#remapping-formlinks","title":"Remapping FormLinks","text":"<p>When working with duplicated records, overridden records, or reorganizing your mod, you may need to update FormLinks to point to different records. Mutagen provides several tools for remapping FormLinks.</p>"},{"location":"plugins/Remapping-FormLinks/#single-link-updates","title":"Single Link Updates","text":"<p>For updating individual FormLinks, use the <code>SetTo()</code> method:</p> <pre><code>var duplicatedNpc = sourceNpc.Duplicate(myMod.GetNextFormKey());\n\n// Update a specific FormLink to point to the new record\nsomeOtherRecord.NpcLink.SetTo(duplicatedNpc);\n</code></pre> <p>This is useful when you know exactly which links need to be updated.</p>"},{"location":"plugins/Remapping-FormLinks/#batch-remapping","title":"Batch Remapping","text":"<p>For updating multiple FormLinks across many records, use the <code>RemapLinks()</code> method:</p> <pre><code>var oldFormKey = sourceNpc.FormKey;\nvar duplicatedNpc = sourceNpc.Duplicate(myMod.GetNextFormKey());\n\n// Create a mapping of old FormKeys to new FormKeys\nvar mapping = new Dictionary&lt;FormKey, FormKey&gt;\n{\n    { oldFormKey, duplicatedNpc.FormKey }\n};\n\n// Remap all FormLinks in the mod that match the mapping\nmyMod.RemapLinks(mapping);\n</code></pre> <p>The <code>RemapLinks()</code> method will:</p> <ul> <li>Traverse all records in the mod</li> <li>Find all FormLinks that reference any of the old FormKeys in the mapping</li> <li>Update those FormLinks to point to the corresponding new FormKeys</li> </ul>"},{"location":"plugins/Translation-Masks/","title":"Translation Masks","text":""},{"location":"plugins/Translation-Masks/#translation-masks","title":"Translation Masks","text":"<p>Several functionalities such as Equality, DeepCopy, and a few others have support for a concept called Translation Masks.  These allow for customization of what members are involved in those operations.</p>"},{"location":"plugins/Translation-Masks/#deepcopyin","title":"DeepCopy(In)","text":"<pre><code>var mask = new Npc.TranslationMask(defaultOn: false)\n{\n    Height = true,\n    Weight = true,\n    Destructible = true,\n};\n\nnpc.DeepCopyIn(npc2, mask);\n</code></pre> <p>The above would copy in the values of the <code>Height</code>, <code>Weight</code>, and <code>Destructible</code> subobject from <code>npc2</code> into <code>npc</code>.  All other members of <code>npc</code> would be left untouched.</p> <p> Copy Functionality</p>"},{"location":"plugins/Translation-Masks/#equality","title":"Equality","text":"<p>Providing a translation mask to an Equality call will control what members are compared when determining equality.</p> <pre><code>var mask = new Npc.TranslationMask(defaultOn: false)\n{\n    Height = true,\n    Weight = true,\n};\n\nnpc.Equals(npc2, mask);\n</code></pre> <p>The above would compare equality of the Height and Weight of the two Npcs.  All other members would not be considered.</p> <p> Equality</p> <p>Work in Progress</p> <p>Equality functionality exists, but has not been thoroughly tested.  Bugs within may exist.  Please report if you see any.</p>"},{"location":"plugins/Translation-Masks/#translation-mask-construction","title":"Translation Mask Construction","text":"<p>The above examples are very simple mask constructions.  They can get more complex when there are subobjects and/or lists involved.</p>"},{"location":"plugins/Translation-Masks/#defaulton-parameter","title":"defaultOn Parameter","text":"<p>When creating a mask, you can either give it <code>defaultOn: true</code> where all the fields will be marked <code>true</code> by default, and then you can selectively mark fields false as desired.  Inversely, you can give it <code>defaultOn: false</code> where all the fields will be marked <code>false</code> by default, and you'll need to turn specific fields <code>true</code> as needed.</p> Copy Only One FieldCopy All But One Field <pre><code>// Only copy Height\nvar mask = new Npc.TranslationMask(defaultOn: false)\n{\n    Height = true,\n};\n</code></pre> <pre><code>// Copy everything BUT Height\nvar mask = new Npc.TranslationMask(defaultOn: true)\n{\n    Height = false,\n};\n</code></pre>"},{"location":"plugins/Translation-Masks/#subobjects","title":"Subobjects","text":"<p>When a record has subobjects, the subobject field is itself a Translation mask letting you set members within that subobject </p><pre><code>// Copy destructible subobject, but not its Stages field\nvar mask = new Npc.TranslationMask(defaultOn: true)\n{\n    Destructible = new Destructible.TranslationMask(true)\n    {\n        Stages = false\n    }\n};\n</code></pre><p></p>"},{"location":"plugins/Translation-Masks/#implicit-bool-conversion-shorthand","title":"Implicit Bool Conversion Shorthand","text":"<p>When dealing with subobjects, the above API can get a bit verbose.  For the basic situations of inclusion/exclusion, Translation Masks are implicitly convertible from <code>bool</code>s.  So you can do something like this:</p> <pre><code>rec.DeepCopy(new Npc.TranslationMask(defaultOn: false)\n{\n    // Boolean converts to a translation mask for you\n    Destructible = true\n    // Equivalent to\n    // Destructible = new Destructible.TranslationMask(true)\n});\n</code></pre> <p>This would copy over everything but the <code>Destructible</code> member, but is much easier to write</p>"},{"location":"plugins/Translation-Masks/#onoverall-parameter","title":"onOverall Parameter","text":"<p>This one has a lot more nuance.  It relates to behavior for a nullable subobject, and gives the user more control as to how those are handled.</p> <p>It does not have any effect if it is the top level mask.   It only has an effect if it's a submask used within another mask.</p> <p>To help demonstrate its usage, let's take Skyrim Npc as a case study.  It has a simplified interface of: </p><pre><code>public interface INpc\n{\n    // A name\n    string? Name { get; set; }\n    // A nullable subobject\n    Destructible? Destructible { get; set; }\n    // Other fields\n}\n</code></pre><p></p> <p>Consider this: </p><pre><code>rec.DeepCopy(new Npc.TranslationMask(true)\n{\n    Name = false,\n    // Implicit:\n    // Destructible = null\n});\n</code></pre> This is an easy way to specify that you want all fields copied except the name.  Destructible's submask object will be left null, but in this case, that means we want to copy it.  (we shouldn't have to define Destructible's subobject in order to bring it over)<p></p> <p>Okay, but what about the case when we want to omit Destructible, then?  There's some confusion when you try to do this with nullable subobjects.  Does a false mean:</p> <ul> <li>Destructible should not be considered at all during equality</li> <li>All fields on the destructible mask should be false. Those are two slightly different things.</li> </ul> <p>The bool <code>onOverall</code> gives us the extra control to specify exactly what we want.</p> <p></p><pre><code>// This will skip Destructible from being considered during the copy altogether\nrec.DeepCopy(new Npc.TranslationMask(true)\n{\n    Name = false,\n    Destructible = new Destructible.TranslationMask(onOverall: false)\n});\n</code></pre> So whatever value the <code>rec.Destructible</code> had before, it will still have, as it will be not touched or considered at all.<p></p> <p>This is in contrast to this: </p><pre><code>rec.DeepCopy(new Npc.TranslationMask(true)\n{\n    Name = false,\n    Destructible = new Destructible.TranslationMask(\n        defaultOn: false, \n        // optional, but shown for clarity\n        onOverall: true)\n    {\n        Stages = true\n    }\n});\n</code></pre> This setup has <code>onOverall</code> of true, and so the mask will be applied and considered during the copy. <code>defaultOn</code> is false, and so by default it would only copy over the <code>Stages</code> member of Destructible, as well as respecting the nullability.  If the source Npc had a null Destructible, the the target will get a null Destructible.<p></p> <p>In summary: <code>onOverall = false</code> is what we'd set if we did not want it to have any effects, and wanted <code>Destructible</code> to not be considered whatsoever. <code>onOverall = true</code> (default), is what we'd set if we wanted the mask to be applied, in which case <code>defaultOn</code> and any field settings would take effect during the application.</p>"},{"location":"plugins/Translation-Masks/#best-practices","title":"Best Practices","text":""},{"location":"plugins/Translation-Masks/#create-once-use-many","title":"Create Once, Use Many","text":"<p>Usually you do not need to create a translation mask per call.  Rather, you can make the desired mask once ahead of time and reuse it for each equality call.</p>"},{"location":"plugins/other-utility/","title":"Other Utility","text":""},{"location":"plugins/other-utility/#associated-files-locator","title":"Associated Files Locator","text":"<p>Mod files will often have several associated files in addition to a plugin (esm/esp) file:</p> <ul> <li>Strings Files</li> <li>Archive Files</li> </ul> <p>This utility functionality locates all files that are associated with a given mod</p> StaticDependency Injection <pre><code>foreach (var file in PluginUtilityIO.GetAssociatedFiles(pathToMod))\n{\n\n}\n</code></pre> <pre><code>IAssociatedFilesLocator filesLocator = ...;\n\nforeach (var file in filesLocator.GetAssociatedFiles(pathToMod))\n{\n\n}\n</code></pre> <p>An optional <code>AssociatedModFileCategory</code> parameter lets you specify which types to look for, in case you want to only look for a few:</p> <ul> <li>Plugin</li> <li>RawStrings</li> <li>Archives</li> </ul> <p>Code to only look for the plugin and raw strings (excluding archives):</p> StaticDependency Injection <pre><code>foreach (var file in PluginUtilityIO.GetAssociatedFiles(\n   pathToMod, \n   AssociatedModFileCategory.Plugin | AssociatedModFileCategory.RawStrings))\n{\n\n}\n</code></pre> <pre><code>IAssociatedFilesLocator filesLocator = ...;\n\nforeach (var file in filesLocator.GetAssociatedFiles(\n   pathToMod, \n   AssociatedModFileCategory.Plugin | AssociatedModFileCategory.RawStrings))\n{\n\n}\n</code></pre>"},{"location":"plugins/other-utility/#mod-files-mover","title":"Mod Files Mover","text":"<p>When moving a mod file to overwrite an old mod file, this can typically work with a simple line. </p><pre><code>File.Move(originalPath, newPath, overwrite: true);\n</code></pre><p></p> <p>But for mods, this only works if it's a simple mod with a single file.  With mods that have localization or archive files have several associated files, this gets more complex.</p> <p>This call will move a mod along with all its associated files to the new location.  Additionally, it will clean up old files no longer used by the overwritten version of the mod.  </p> <p>For example, if you are overwriting a non-localized version of a mod onto a localized version, then the raw strings from the old setup will be removed.</p> StaticDependency Injection <pre><code>foreach (var file in PluginUtilityIO.GetAssociatedFiles(\n   pathToMod, \n   AssociatedModFileCategory.Plugin | AssociatedModFileCategory.RawStrings,\n   overwrite: true))\n{\n\n}\n</code></pre> <pre><code>IAssociatedFilesLocator filesLocator = ...;\n\nforeach (var file in filesLocator.GetAssociatedFiles(\n   pathToMod, \n   AssociatedModFileCategory.Plugin | AssociatedModFileCategory.RawStrings,\n   overwrite: true))\n{\n\n}\n</code></pre> <p>Deleted Files</p> <p>This function deletes files, so be sure you're calling it appropriately and have any backups desired</p>"},{"location":"plugins/other-utility/#common-to-generic-crossover","title":"Common to Generic Crossover","text":"<p>Often you'll be dealing with code in a generic setup where you aren't sure what game you'll be targeting.  Often one route to deal with this is to define generics: </p><pre><code>public void MyFunction&lt;TMod, TModGetter&gt;(TMod mod)\n    where TModGetter : IModGetter\n    where TMod : IMod, TModGetter, IMajorRecordContextEnumerable&lt;TMod, TModGetter&gt;\n{\n    // Do something\n}\n</code></pre><p></p> <p>This is often a great route to allow the caller to know what type they want to interact with, and let them decide. However, at some point higher up in your code, adding generics becomes burdensome, or the API cannot offer generics for one reason or the other.</p> <p>What happens when we have a call that is not generic, but wants to call one that is? </p><pre><code>public class MyClass\n{\n    public void DoSomeThings(IMod mod)\n    {\n        // What do we put here?\n        DoSomeThingsGeneric&lt;???, ???&gt;(mod);\n    }\n\n    private void DoSomeThingsGeneric&lt;TMod, TModGetter&gt;(TMod mod)\n        where TModGetter : IModGetter\n        where TMod : IMod, TModGetter, IMajorRecordContextEnumerable&lt;TMod, TModGetter&gt;\n    {\n        // Actual logic\n    }\n}\n</code></pre><p></p> <p>The answer is that we would use C# reflection to make the first function call the 2nd.  However, this is fairly gritty code that is easy to get wrong.</p> <p>Mutagen offers <code>ModToGenericCallHelper</code> to help with this.  Take the above example again: </p><pre><code>public class MyClass\n{\n    public void DoSomeThings(IMod mod)\n    {\n        // Mutagen helper class\n        ModToGenericCallHelper.InvokeFromCategory(\n            // Pass in the object that has the generic function we want to call\n            this,\n            // What category is this related to?  The mod knows its own category, here.\n            mod.GameRelease.ToCategory(),\n            // This is a bit of C# reflection to locate the method we want to call\n            // In our case, it's in a class called MyClass, the function is called DoSomeThingsGeneric,\n            // which is private and non-static\n            typeof(MyClass).GetMethod(nameof(DoSomeThingsGeneric), BindingFlags.NonPublic | BindingFlags.Instance)!,\n            // What parameter to pass to DoSomeThingsGeneric.  Might have more depending on the call you designed\n            new object[] { mod });\n    }\n\n    private void DoSomeThingsGeneric&lt;TMod, TModGetter&gt;(TMod mod)\n        where TModGetter : IModGetter\n        where TMod : IMod, TModGetter, IMajorRecordContextEnumerable&lt;TMod, TModGetter&gt;\n    {\n        // Actual logic\n    }\n}\n</code></pre><p></p> <p>Optimization</p> <p>To optimize the above call a bit more, we could do the GetMethod call once ahead of time (in MyClass' constructor) and store the MethodInfo for re-use every time DoSomeThings got called, as it does not change per call</p> <p>This helper abstracts away the complexityof locating what types <code>&lt;TMod, TModGetter&gt;</code> are, and wiring those up.</p>"},{"location":"plugins/specific/","title":"Specific Records","text":""},{"location":"plugins/specific/#specific-records","title":"Specific Records","text":""},{"location":"plugins/specific/#typical-api","title":"Typical API","text":"<p>Mutagen generates thousands of classes and fields for all the records that exist within the Bethesda plugin files.  Documentation cannot be written for every class and field, as it would become too verbose.</p> <p>Most data exists as fields on objects very similar to the structures found in common tools like xEdit.  The can be discovered and accessed in a straightforward manner with some familiarity with IDE intellisense.</p>"},{"location":"plugins/specific/#specific-documentation","title":"Specific Documentation","text":"<p>The Specific Records section is about the abnormal record structures that inspire special documentation to cover specific concepts that might complicate things.</p> <p>Not Exhaustive</p> <p>The current documents can always be expanded.  If you would like one to be outlined, feel free to open an issue to request</p> <p>Some related documentation about some deviation patterns that might be encountered:</p> <p> Abstract Subclassing</p> <p> Bethesda Format Abstractions</p> <p> ExtraData (Container Item Ownership)</p> <p> Globals and GameSettings</p>"},{"location":"plugins/specific/ExtraData/","title":"ExtraData","text":""},{"location":"plugins/specific/ExtraData/#extradata-container-item-ownership","title":"ExtraData (Container Item Ownership)","text":"<p>ExtraData is a subrecord found on Container entries that stores ownership and condition information for items. The ownership data indicates who owns an item and under what conditions it can be taken.</p> <p>The complexity comes from the fact that the binary format doesn't explicitly specify the owner type - it must be determined by looking up the FormKey in a LinkCache to see what record type it points to. This creates special handling requirements when reading mods without a complete load order.</p>"},{"location":"plugins/specific/ExtraData/#owner-types","title":"Owner Types","text":"<p>ExtraData uses abstract subclassing to represent different owner types:</p> <ul> <li><code>NpcOwner</code> - When the owner is an NPC record<ul> <li><code>Npc</code> - FormLink to the owning NPC</li> <li><code>Global</code> - Optional FormLink to a Global variable</li> </ul> </li> <li><code>FactionOwner</code> - When the owner is a Faction record<ul> <li><code>Faction</code> - FormLink to the owning Faction</li> <li><code>RequiredRank</code> - Minimum faction rank required</li> </ul> </li> <li><code>UntypedOwner</code> - Fallback when the owner type cannot be determined<ul> <li><code>OwnerData</code> - FormLink to any major record (the owner)</li> <li><code>VariableData</code> - FormLink to any major record (additional data)</li> </ul> </li> </ul>"},{"location":"plugins/specific/ExtraData/#construction","title":"Construction","text":"<p>When creating ExtraData, you should know the owner type and use the appropriate subclass:</p> NPC OwnerFaction Owner <pre><code>var container = mod.Containers.AddNew(\"MyContainer\");\nvar entry = new ContainerEntry\n{\n    Item = new ContainerItem\n    {\n        Item = myItem.AsLink(),\n        Count = 5\n    },\n    Data = new ExtraData\n    {\n        Owner = new NpcOwner\n        {\n            Npc = myNpc.AsLink(),\n            Global = FormLink&lt;IGlobalGetter&gt;.Null\n        },\n        ItemCondition = 100f\n    }\n};\ncontainer.Items.Add(entry);\n</code></pre> <pre><code>var container = mod.Containers.AddNew(\"MyContainer\");\nvar entry = new ContainerEntry\n{\n    Item = new ContainerItem\n    {\n        Item = myItem.AsLink(),\n        Count = 5\n    },\n    Data = new ExtraData\n    {\n        Owner = new FactionOwner\n        {\n            Faction = myFaction.AsLink(),\n            RequiredRank = 2\n        },\n        ItemCondition = 100f\n    }\n};\ncontainer.Items.Add(entry);\n</code></pre>"},{"location":"plugins/specific/ExtraData/#reading","title":"Reading","text":"<p>ExtraData presents a unique challenge: the binary format doesn't specify the owner type, so Mutagen must look up the FormKey in other mod files to determine whether it points to an NPC or Faction record. This means ExtraData is one of the only records that requires a load order for full functionality.</p> <p>Mutagen tries its best to determine correct owner type (<code>NpcOwner</code> or <code>FactionOwner</code>). However, it can only do so when the owner record is within the same mod as the ExtraData record being inspected.  Otherwise it requires a load order at time of creation to locate it.  When no load order is available, Mutagen falls back to <code>UntypedOwner</code> to preserve the data.</p> <p>Reading ExtraData uses a switch statement to handle all three possible owner types:</p> <pre><code>using var env = GameEnvironment.Typical.Builder&lt;ISkyrimMod, ISkyrimModGetter&gt;(GameRelease.SkyrimSE)\n    .WithLoadOrder(loadOrderFilePath)\n    .Build();\n\nforeach (var container in env.LoadOrder.PriorityOrder.Container().WinningOverrides())\n{\n    foreach (var entry in container.Items)\n    {\n        if (entry.Data?.Owner == null) continue;\n\n        switch (entry.Data.Owner)\n        {\n            case NpcOwner npcOwner:\n                Console.WriteLine($\"NPC Owner: {npcOwner.Npc.FormKey}\");\n                if (!npcOwner.Global.IsNull)\n                {\n                    Console.WriteLine($\"  Global condition: {npcOwner.Global.FormKey}\");\n                }\n                break;\n\n            case FactionOwner factionOwner:\n                Console.WriteLine($\"Faction Owner: {factionOwner.Faction.FormKey}\");\n                Console.WriteLine($\"  Required rank: {factionOwner.RequiredRank}\");\n                break;\n\n            case UntypedOwner untypedOwner:\n                Console.WriteLine($\"Unknown owner type: {untypedOwner.OwnerData.FormKey}\");\n                break;\n        }\n    }\n}\n</code></pre> <p>UntypedOwner Without Load Order</p> <p>If you read a mod without providing a load order, and the owner references a record from another mod, you'll receive an <code>UntypedOwner</code> instead of the specific type. The FormKey data is still available in <code>OwnerData</code> and <code>VariableData</code> fields, but you won't know whether it's an NPC or Faction without looking it up in a LinkCache.</p>"},{"location":"plugins/specific/Globals-And-GameSettings/","title":"Globals and GameSettings","text":"<p>The Global and Gamesetting records contain many different types of data while each having their own unique rules of communicating what type of data they contain.  For example, <code>Global</code> records have a special subrecord <code>FNAM</code> with a single char <code>i</code>, <code>f</code>, <code>s</code> to symbolize the float field it contains should be interpreted as an <code>int</code>, <code>float</code>, or <code>short</code>.  <code>GameSetting</code> on the other hand prepends a character to its EditorID to communicate what type of data is stored in its <code>DATA</code> subrecord.</p> <p>This complexity is abstracted away by Mutagen by offering strongly typed subclasses for Globals and Gamesettings.  <code>GlobalInt</code>, <code>GlobalFloat</code>, <code>GameSettingInt</code>, <code>GameSettingString</code>, <code>GameSettingBool</code>, etc.  These subclasses expose a strongly typed member of the correct type to the user while internally handling the most of the details.</p> <p> Abstract Subclassing</p>"},{"location":"plugins/specific/Globals-And-GameSettings/#construction","title":"Construction","text":"ConstructorAddNew <pre><code>mod.Globals.Add(\n    new GlobalInt(mod.GetNextFormKey())\n    {\n        EditorID = \"MyIntGlobal\",\n        Data = 1234\n    });\n\nmod.GameSettings.Add(\n    new GameSettingFloat(mod.GetNextFormKey())\n    {\n        EditorID = \"MyFloatGameSetting\",\n        Data = 1234.5f\n    });\n</code></pre> <pre><code>ISkyrimMod mod = ...;\n\nvar global = mod.Globals.AddNewInt(\"MyIntGlobal\");\nglobal.Data = 1234;\n\nvar gameSetting = mod.GameSettings.AddNewFloat(\"MyFloatGameSetting\");\nglobal.Data = 1234f;\n</code></pre> <p>Editor ID Processed Automatically</p> <p>For GameSettings, the EditorID stores the type data as its first character.  Any EditorID you set will automatically be processed to have the correct starting character.  As such, all GameSettings should have their EditorIDs set.</p>"},{"location":"plugins/specific/Globals-And-GameSettings/#reading","title":"Reading","text":"<p>Reading Globals/GameSettings consists of checking/casting the records to their correct subtype as per Abstract Subclass patterns.  One easy way to do this is to use a switch: </p><pre><code>foreach (GameSetting setting in mod.GameSettings.Records)\n{\n   switch (setting)\n   {\n       case GameSettingString stringSetting:\n           System.Console.WriteLine($\"Found a string setting: {stringSetting.EditorID}\");\n           System.Console.WriteLine($\"   Value: {stringSetting.Data}\");\n           break;\n       case GameSettingBool boolSetting:\n           System.Console.WriteLine($\"Found a bool setting: {stringSetting.EditorID}\");\n           System.Console.WriteLine($\"   Value: {(stringSetting.Data ? \"ON!\" : \"OFF!\")}\");\n           break;\n   }\n}\n</code></pre><p></p>"},{"location":"wpf/","title":"WPF Library","text":""},{"location":"wpf/#wpf-library","title":"WPF Library","text":"<p>If you are making a C# WPF UI application with Mutagen, you can import <code>Mutagen.Bethesda.WPF</code> to get some tooling related to Bethesda specific content.</p> <ul> <li>Controls for Bethesda specific concepts, such as FormKeyPickers, LoadOrder displays, etc</li> <li>Reflection powered settings editor</li> <li>ValueConverters for binding things like Visibility to whether a FormKey can be looked up</li> </ul> <p>The Mutagen repository has a Test Display WPF app, which flexes a lot of these controls, and can be a good tutorial for how to use them.</p> <p>Explore the right hand side bar for more specifics on the features provided by Mutagen's WPF library</p>"},{"location":"wpf/#formkey-pickers","title":"FormKey Pickers","text":""},{"location":"wpf/#modkey-pickers","title":"ModKey Pickers","text":""},{"location":"wpf/#reflection-powered-settings","title":"Reflection Powered Settings","text":""},{"location":"wpf/Adding-Required-Resources/","title":"Adding Required Resources","text":""},{"location":"wpf/Adding-Required-Resources/#adding-required-resources","title":"Adding Required Resources","text":"<p><code>Mutagen.WPF</code> is built with style-less controls.  This means the controls are just logic, and you can add your own look exactly how you want it.</p> <p>Typically though a default look is provided, and <code>Mutagen.WPF</code> does this as well.  It is built on top of MahApps, and other reusable libraries.  </p>"},{"location":"wpf/Adding-Required-Resources/#global-import","title":"Global Import","text":"<p>To import these resources/looks, the easiest way is to modify the <code>App.xaml</code> file that comes with every WPF project: </p><pre><code>&lt;Application ...&gt;\n    &lt;Application.Resources&gt;\n        &lt;ResourceDictionary&gt;\n            &lt;ResourceDictionary.MergedDictionaries&gt;\n                &lt;!--  MahApps.Metro resource dictionaries.  --&gt;\n                &lt;ResourceDictionary Source=\"pack://application:,,,/MahApps.Metro;component/Styles/Controls.xaml\" /&gt;\n                &lt;ResourceDictionary Source=\"pack://application:,,,/MahApps.Metro;component/Styles/Fonts.xaml\" /&gt;\n                &lt;ResourceDictionary Source=\"pack://application:,,,/MahApps.Metro;component/Styles/Controls.Buttons.xaml\" /&gt;\n\n                &lt;!--  Purple Accent and AppTheme setting  --&gt;\n                &lt;ResourceDictionary Source=\"pack://application:,,,/MahApps.Metro;component/Styles/Themes/Dark.Purple.xaml\" /&gt;\n\n                &lt;!--  Noggog.WPF Theming  --&gt;\n                &lt;ResourceDictionary Source=\"pack://application:,,,/Noggog.WPF;component/Everything.xaml\" /&gt;\n\n                &lt;!--  Mutagen Specific Theming  --&gt;\n                &lt;ResourceDictionary Source=\"pack://application:,,,/Mutagen.Bethesda.WPF;component/Everything.xaml\" /&gt;\n\n            &lt;/ResourceDictionary.MergedDictionaries&gt;\n        &lt;/ResourceDictionary&gt;\n    &lt;/Application.Resources&gt;\n&lt;/Application&gt;\n</code></pre><p></p>"},{"location":"wpf/Adding-Required-Resources/#non-global-import","title":"Non-Global Import","text":"<p>You can also add the above ResourceDictionary to specific controls in your WPF app, if you don't want to import/apply them globally to everything.</p>"},{"location":"wpf/Adding-Required-Resources/#work-in-progress","title":"Work In Progress","text":"<p>These patterns may be adjusted over time, as they don't allow for the easiest customization of color theming and such.  As better patterns for exposing more control are discovered, these suggestions might change.</p>"},{"location":"wpf/FormKey-Picker/","title":"FormKey Picker","text":""},{"location":"wpf/FormKey-Picker/#formkey-picker","title":"FormKey Picker","text":"<p>The FormKey Picker helps users select record(s) by typing in:</p> <ul> <li>EditorIDs</li> <li>FormKeys</li> <li>FormIDs (Mod indices relative to current load order)</li> </ul> <p>The picker can reference a LinkCache to do lookups to help display and locate records that actually exist in the user's active load order.</p> <p>They can also be scoped to only allow or search for specific record types, if desired.</p> <p>Make sure you've added the Required Resources, or the controls will not have any display.</p> <p>The Mutagen Test Display app utilizes the FormKey pickers, and provides a good example of how to use them from within a WPF app.</p>"},{"location":"wpf/FormKey-Picker/#formkey-picker_1","title":"FormKey Picker","text":"<p>This is a picker to select a single FormKey.</p> <p></p>"},{"location":"wpf/FormKey-Picker/#view-side","title":"View Side","text":"<pre><code>&lt;UserControl\n    ...\n    xmlns:plugins=\"clr-namespace:Mutagen.Bethesda.WPF.Plugins;assembly=Mutagen.Bethesda.WPF\" &gt;\n    &lt;plugins:FormKeyPicker \n        FormKey=\"{Binding MyFormKey}\"\n        LinkCache=\"{Binding MyLinkCache}\"\n        ScopedTypes=\"{Binding MyDesiredTypes}\" /&gt;\n&lt;/UserControl&gt;\n</code></pre>"},{"location":"wpf/FormKey-Picker/#viewmodel-side","title":"ViewModel Side","text":"<pre><code>// Some mechanics shown here are from `ReactiveUI`, or `Noggog.WPF`\npublic class MyViewModel : ViewModel\n{\n    [Reactive]\n    public FormKey MyFormKey { get; set; }\n\n    public ILinkCache MyLinkCache { get; }\n\n    public IEnumerable&lt;Type&gt; MyDesiredTypes { get; }\n\n    public MyViewModel()\n    {\n        // Create a GameEnvironment, to get a LinkCache connected to the current users' setup\n        var env = GameEnvironment.Typical.Skyrim(\n            SkyrimRelease.SkyrimSE, \n            // By passing in this preference, we only cache FormKey/EditorID info, keeping memory usage down\n            LinkCachePreferences.OnlyIdentifiers());\n\n        // When the ViewModel is destroyed, clean up the environment object.  Good practice\n        env.DisposeWith(this);\n\n        // Set the ViewModel's LinkCache to the one given by the environment\n        LinkCache = env.LinkCache;\n\n        // We only care about Armor records\n        ScopedTypes = typeof(IArmorGetter).AsEnumerable();\n\n        // User can now set the FormKey member, and the viewmodel can see the results\n    }\n}\n</code></pre>"},{"location":"wpf/FormKey-Picker/#formkey-multipicker","title":"FormKey Multipicker","text":"<p>This is a picker to select any number of FormKeys.</p> <p></p>"},{"location":"wpf/FormKey-Picker/#view-side_1","title":"View Side","text":"<pre><code>&lt;UserControl\n    ...\n    xmlns:plugins=\"clr-namespace:Mutagen.Bethesda.WPF.Plugins;assembly=Mutagen.Bethesda.WPF\" &gt;\n    &lt;plugins:FormKeyMultiPicker\n        FormKeys=\"{Binding MyFormKeys}\"\n        LinkCache=\"{Binding MyLinkCache}\"\n        ScopedTypes=\"{Binding MyDesiredTypes}\" /&gt;\n&lt;/UserControl&gt;\n</code></pre>"},{"location":"wpf/FormKey-Picker/#viewmodel-side_1","title":"ViewModel Side","text":"<pre><code>// Some mechanics shown here are from `ReactiveUI`, or `Noggog.WPF`\npublic class MyViewModel : ViewModel\n{\n    // FormKeyItemViewModel provided by Mutagen.WPF\n    public ObservableCollection&lt;FormKeyItemViewModel&gt; MyFormKeys { get; } = new();\n\n    public ILinkCache MyLinkCache { get; }\n\n    public IEnumerable&lt;Type&gt; MyDesiredTypes { get; }\n\n    public MyViewModel()\n    {\n        // Create a GameEnvironment, to get a LinkCache connected to the current users' setup\n        var env = GameEnvironment.Typical.Skyrim(\n            SkyrimRelease.SkyrimSE, \n            // By passing in this preference, we only cache FormKey/EditorID info, keeping memory usage down\n            LinkCachePreferences.OnlyIdentifiers());\n\n        // When the ViewModel is destroyed, clean up the environment object.  Good practice\n        env.DisposeWith(this);\n\n        // Set the ViewModel's LinkCache to the one given by the environment\n        LinkCache = env.LinkCache;\n\n        // We only care about Armor records\n        ScopedTypes = typeof(IArmorGetter).AsEnumerable();\n\n        // User can now fill FormKeys collection, and the viewmodel can see the results\n    }\n}\n</code></pre>"},{"location":"wpf/ModKey-Picker/","title":"ModKey Picker","text":""},{"location":"wpf/ModKey-Picker/#modkey-picker","title":"ModKey Picker","text":"<p>The ModKey Picker helps users select mod(s) by typing in their names.</p> <p>The picker can reference certain objects to know what mods actually exist on a user's active load order:</p> <ul> <li>A Load Order object</li> <li>Any enumerable of type <code>ModKey</code> or <code>IModListingGetter</code></li> <li>An <code>IObservable&lt;IChangeSet&lt;T&gt;&gt;</code> of type <code>ModKey</code> or <code>IModListingGetter</code>. (Reactive Extension concepts)</li> </ul> <p>Make sure you've added the Required Resources, or the controls will not have any display.</p> <p>The Mutagen Test Display app utilizes the ModKey pickers, and provides a good example of how to use them from within a WPF app.</p>"},{"location":"wpf/ModKey-Picker/#single-picker","title":"Single Picker","text":"<p>This is a picker to select a single ModKey.</p> <p></p>"},{"location":"wpf/ModKey-Picker/#view-side","title":"View Side","text":"<pre><code>&lt;UserControl\n    ...\n    xmlns:plugins=\"clr-namespace:Mutagen.Bethesda.WPF.Plugins;assembly=Mutagen.Bethesda.WPF\" &gt;\n    &lt;plugins:ModKeyPicker \n        ModKey=\"{Binding MyModKey}\"\n        SearchableMods=\"{Binding MyAvailableMods}\" /&gt;\n&lt;/UserControl&gt;\n</code></pre>"},{"location":"wpf/ModKey-Picker/#viewmodel-side","title":"ViewModel Side","text":"<pre><code>// Some mechanics shown here are from `ReactiveUI`, or `Noggog.WPF`\npublic class MyViewModel : ViewModel\n{\n    [Reactive]\n    public ModKey MyModKey { get; set; }\n\n    public object MyAvailableMods { get; }\n\n    public MyViewModel()\n    {\n        // Create a GameEnvironment, to get a LoadOrder connected to the current users' setup\n        var env = GameEnvironment.Typical.Skyrim(\n            SkyrimRelease.SkyrimSE, \n            // By passing in this preference, we only cache FormKey/EditorID info, keeping memory usage down\n            LinkCachePreferences.OnlyIdentifiers());\n\n        // When the ViewModel is destroyed, clean up the environment object.  Good practice\n        env.DisposeWith(this);\n\n        // Set the ViewModel's available mods to the LoadOrder given by the environment\n        MyAvailableMods = env.LoadOrder;\n\n        // User can now set the ModKey member, and the viewmodel can see the results\n    }\n}\n</code></pre>"},{"location":"wpf/ModKey-Picker/#modkey-multipicker","title":"ModKey Multipicker","text":"<p>This is a picker to select any number of ModKeys.</p> <p></p>"},{"location":"wpf/ModKey-Picker/#view-side_1","title":"View Side","text":"<pre><code>&lt;UserControl\n    ...\n    xmlns:plugins=\"clr-namespace:Mutagen.Bethesda.WPF.Plugins;assembly=Mutagen.Bethesda.WPF\" &gt;\n    &lt;plugins:ModKeyMultiPicker\n        ModKeys=\"{Binding MyModKeys}\"\n        SearchableMods=\"{Binding MyAvailableMods}\" /&gt;\n&lt;/UserControl&gt;\n</code></pre>"},{"location":"wpf/ModKey-Picker/#viewmodel-side_1","title":"ViewModel Side","text":"<pre><code>// Some mechanics shown here are from `ReactiveUI`, or `Noggog.WPF`\npublic class MyViewModel : ViewModel\n{\n    // ModKeyItemViewModel provided by Mutagen.WPF\n    public ObservableCollection&lt;ModKeyItemViewModel&gt; MyModKeys { get; } = new();\n\n    public object MyAvailableMods { get; }\n\n    public MyViewModel()\n    {\n        // Create a GameEnvironment, to get a LoadOrder connected to the current users' setup\n        var env = GameEnvironment.Typical.Skyrim(\n            SkyrimRelease.SkyrimSE, \n            // By passing in this preference, we only cache FormKey/EditorID info, keeping memory usage down\n            LinkCachePreferences.OnlyIdentifiers());\n\n        // When the ViewModel is destroyed, clean up the environment object.  Good practice\n        env.DisposeWith(this);\n\n        // Set the ViewModel's available mods to the LoadOrder given by the environment\n        MyAvailableMods = env.LinkCache;\n\n        // User can now set the MyModKeys member, and the viewmodel can see the results\n    }\n}\n</code></pre>"},{"location":"wpf/Reflection-Powered-Settings/","title":"Reflection Powered Settings","text":""},{"location":"wpf/Reflection-Powered-Settings/#reflection-powered-settings","title":"Reflection Powered Settings","text":"<p>This is a control that is able to attach to any DTO (Data Transfer Object) style class and generate a UI for each of the fields.  This is very good for getting a basic settings editor up and running with minimal WPF experience.</p> <p>Originally it was part of Synthesis to provide UI controls for patcher settings, but has been moved up to Mutagen's libraries for more general use.</p>"},{"location":"wpf/Reflection-Powered-Settings/#overview","title":"Overview","text":"<p>Let's take an example DTO class </p><pre><code>public class TestSettings\n{\n    public bool MyBool;\n    public string MyString = string.Empty;\n    public FormKey MyFormKey;\n    public IFormLinkGetter&lt;IArmorGetter&gt; MyArmor = FormLink&lt;IArmorGetter&gt;.Null;\n}\n</code></pre><p></p> <p>We can supply that definition to this control, and get a UI immediately:</p> <p></p> <p>As such, it is an easy way to get a decent UI for any class, and is very helpful if:</p> <ul> <li>You aren't used to WPF and just want to get something up and running</li> <li>If you don't know ahead of time what fields will exist (Synthesis patchers being a prime example)</li> </ul>"},{"location":"wpf/Reflection-Powered-Settings/#nesting","title":"Nesting","text":"<p>The reflection systems allow nested classes, and utilize them to create \"sections\".</p> <p>Take this modified setup for example: </p><pre><code>public class TestSettings\n{\n    public bool MyBool;\n    public string MyString = string.Empty;\n    public FormKey MyFormKey;\n    public IFormLinkGetter&lt;IArmorGetter&gt; MyArmor = FormLink&lt;IArmorGetter&gt;.Null;\n    public SubSettings SubSetting = new();\n}\n\npublic class TopLevelSettings\n{\n    public TestSettings SectionOne = new();\n    public TestSettings SectionTwo = new();\n}\n\npublic class SubSettings\n{\n    public bool SubSetting;\n}\n</code></pre><p></p> <p>This would yield the following display:</p> <p></p>"},{"location":"wpf/Reflection-Powered-Settings/#attributes","title":"Attributes","text":"<p>Since the internal systems are constructing a view for you based on the contents of your class, you have reduced control over what is displayed, where, and how.</p> <p>The system provides some Attributes to help give back some of this control.  They all live within the namespace <code>Mutagen.Bethesda.WPF.Reflection.Attributes</code></p> <p>NOTE:  The naming of these attributes differs slightly from the names Synthesis uses for its autogenerated setting systems</p>"},{"location":"wpf/Reflection-Powered-Settings/#ignore","title":"Ignore","text":"<p>A marker attribute that will make a specific field not display</p> <pre><code>[Ignore]\npublic bool MyIgnoredBool { get; set; }\n</code></pre>"},{"location":"wpf/Reflection-Powered-Settings/#tooltip","title":"Tooltip","text":"<p>Sets the tooltip to display</p> <pre><code>[Tooltip(\"I am a setting with a lot of detail to consider\")\npublic bool SomeComplexSetting { get; set; }\n</code></pre>"},{"location":"wpf/Reflection-Powered-Settings/#settingname","title":"SettingName","text":"<p>Will set explicitly what text to display as the name for the field</p> <pre><code>[SettingName(\"Please Display This Text\")\npublic bool SomeDerpyName { get; set; }\n</code></pre>"},{"location":"wpf/Reflection-Powered-Settings/#jsondiskname","title":"JsonDiskName","text":"<p>An attribute to change what text key is used when persisting/loading from json</p> <pre><code>[JsonDiskName(\"some-setting\")\npublic bool SomeSetting { get; set; }\n</code></pre>"},{"location":"wpf/Reflection-Powered-Settings/#maintainorder","title":"MaintainOrder","text":"<p>Unfortunately, C# cannot properly guarantee order of fields when utilizing reflection.  This attribute is a marker that helps maintain desired ordering.</p> <pre><code>[MaintainOrder]\npublic bool FirstSetting { get; set; }\n\n[MaintainOrder]\npublic bool SecondSetting { get; set; }\n</code></pre>"},{"location":"wpf/Reflection-Powered-Settings/#objectnamemember","title":"ObjectNameMember","text":"<p>This attribute applies to the settings class itself, and defines the object type naming to show when nested classes are involved.</p> <pre><code>[ObjectNameMember(nameof(TestSettings.MyString))]\npublic class TestSettings\n{\n    // Will now drive the text displayed when in a nested scenario\n    public string MyString = string.Empty;\n}\n</code></pre> <p>Now <code>MyString</code> drives the display in the top navigation bar</p> <p></p>"},{"location":"wpf/Reflection-Powered-Settings/#formlinkpickercustomization","title":"FormLinkPickerCustomization","text":"<p>Allows you to list explicitly the types that should be allowed in the picker.  It loses generic type safety, so only preferable if there is not already a LinkInterface or AspectInterface that describes the several types you want to target.</p> <pre><code>[FormLinkPickerCustomization(typeof(IArmorGetter), typeof(IWeaponGetter))]\npublic IFormLinkGetter ArmorsAndWeapons { get; set; } = FormLinkInformation.Null;\n</code></pre>"},{"location":"wpf/Reflection-Powered-Settings/#allowed-field-types","title":"Allowed Field Types","text":"<ul> <li><code>bool</code></li> <li><code>string</code></li> <li>Integers (signed and unsigned)</li> <li><code>float</code></li> <li><code>double</code></li> <li><code>decimal</code></li> <li>Enums</li> <li><code>ModKey</code></li> <li><code>FormKey</code></li> <li>FormLinks</li> <li>Other classes with appropriate fields</li> <li>Lists/Arrays/HashSets/IEnumerables (of the above types)</li> <li>Dictionaries, in certain scenarios:</li> <li>Key is an enum</li> <li>Key is a <code>string</code></li> </ul>"},{"location":"wpf/Reflection-Powered-Settings/#implementing-within-a-ui-yourself","title":"Implementing Within a UI Yourself","text":"<p>Note that Synthesis users do not need to worry about any of this, as it is handled for them.  But if you're making a UI of your own, and want to lean on the autogenerated setting systems, this would be how to do it.</p>"},{"location":"wpf/Reflection-Powered-Settings/#view-side","title":"View Side","text":"<pre><code>&lt;UserControl\n    ...\n    xmlns:refl=\"clr-namespace:Mutagen.Bethesda.WPF.Reflection;assembly=Mutagen.Bethesda.WPF\" &gt;\n    &lt;refl:AutogeneratedSettingView DataContext=\"{Binding MyReflectionViewModel}\" /&gt;\n&lt;/UserControl&gt;\n</code></pre>"},{"location":"wpf/Reflection-Powered-Settings/#viewmodel-side","title":"ViewModel Side","text":"<pre><code>// Some mechanics shown here are from `ReactiveUI`, or `Noggog.WPF`\npublic class MyViewModel : ViewModel\n{\n    public ReflectionSettingsVM MyReflectionViewModel { get; }\n\n    public MyViewModel()\n    {\n        // Create a GameEnvironment\n        var env = GameEnvironment.Typical.Skyrim(\n            SkyrimRelease.SkyrimSE, \n            // By passing in this preference, we only cache FormKey/EditorID info, keeping memory usage down\n            LinkCachePreferences.OnlyIdentifiers());\n\n        // When the ViewModel is destroyed, clean up the environment object.  Good practice\n        env.DisposeWith(this);\n\n        // Create a prototype instance of the class we want it to display\n        var defaultSettings = new TestSettings()\n        {\n            // Can specify some default settings we want to appear\n            MyBool = true\n        };\n\n        MyReflectionViewModel = new ReflectionSettingsVM(\n            ReflectionSettingsParameters.CreateFrom(\n                // Give it the class we want to display\n                defaultSettings,\n                // Can give it a live load order, or just some raw listings\n                env.LoadOrder.Select(x =&gt; new ModListingVM(x.Value, env.DataFolderPath.Path)),\n                // Give it the link cache, for lookups if needed\n                env.LinkCache));\n\n        // Reflection display systems will now take over and display the appropriate fields\n    }\n\n    // Function save the current state of the reflection display to a json file\n    public void SaveToDisk(string somePath)\n    {\n        var jsonObj = new JObject();\n        MyReflectionViewModel.ObjVM.Persist(jsonObj);\n        File.WriteAllText(somePath, jsonObj.ToString());\n    }\n\n    // More functionality to access data from the reflection view will be added\n}\n</code></pre>"}]}