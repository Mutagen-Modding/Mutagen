/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Autogenerated by Loqui.  Do not manually change.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*/
#region Usings
using Loqui;
using Loqui.Interfaces;
using Loqui.Internal;
using Mutagen.Bethesda.Binary;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Binary.Headers;
using Mutagen.Bethesda.Plugins.Binary.Overlay;
using Mutagen.Bethesda.Plugins.Binary.Streams;
using Mutagen.Bethesda.Plugins.Binary.Translations;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Exceptions;
using Mutagen.Bethesda.Plugins.Internals;
using Mutagen.Bethesda.Plugins.Meta;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Plugins.Records.Internals;
using Mutagen.Bethesda.Plugins.Records.Mapping;
using Mutagen.Bethesda.Starfield;
using Mutagen.Bethesda.Starfield.Internals;
using Mutagen.Bethesda.Translations.Binary;
using Noggog;
using Noggog.StructuredStrings;
using Noggog.StructuredStrings.CSharp;
using RecordTypeInts = Mutagen.Bethesda.Starfield.Internals.RecordTypeInts;
using RecordTypes = Mutagen.Bethesda.Starfield.Internals.RecordTypes;
using System.Buffers.Binary;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Reactive.Disposables;
using System.Reactive.Linq;
#endregion

#nullable enable
namespace Mutagen.Bethesda.Starfield
{
    #region Class
    public partial class AnimationSceneItem :
        IAnimationSceneItem,
        IEquatable<IAnimationSceneItemGetter>,
        ILoquiObjectSetter<AnimationSceneItem>
    {
        #region Ctor
        public AnimationSceneItem()
        {
            CustomCtor();
        }
        partial void CustomCtor();
        #endregion

        #region NpcAnimation
        private readonly IFormLinkNullable<IIdleAnimationGetter> _NpcAnimation = new FormLinkNullable<IIdleAnimationGetter>();
        public IFormLinkNullable<IIdleAnimationGetter> NpcAnimation
        {
            get => _NpcAnimation;
            set => _NpcAnimation.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IIdleAnimationGetter> IAnimationSceneItemGetter.NpcAnimation => this.NpcAnimation;
        #endregion
        #region STRV
        public String? STRV { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        String? IAnimationSceneItemGetter.STRV => this.STRV;
        #endregion
        #region VCLR
        private readonly IFormLink<IKeywordGetter> _VCLR = new FormLink<IKeywordGetter>();
        public IFormLink<IKeywordGetter> VCLR
        {
            get => _VCLR;
            set => _VCLR.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IKeywordGetter> IAnimationSceneItemGetter.VCLR => this.VCLR;
        #endregion
        #region FLMV
        private readonly IFormLink<IKeywordGetter> _FLMV = new FormLink<IKeywordGetter>();
        public IFormLink<IKeywordGetter> FLMV
        {
            get => _FLMV;
            set => _FLMV.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IKeywordGetter> IAnimationSceneItemGetter.FLMV => this.FLMV;
        #endregion
        #region FLAV
        private readonly IFormLink<IKeywordGetter> _FLAV = new FormLink<IKeywordGetter>();
        public IFormLink<IKeywordGetter> FLAV
        {
            get => _FLAV;
            set => _FLAV.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IKeywordGetter> IAnimationSceneItemGetter.FLAV => this.FLAV;
        #endregion
        #region QUAL
        public Boolean QUAL { get; set; } = default(Boolean);
        #endregion
        #region SPOR
        public Boolean SPOR { get; set; } = default(Boolean);
        #endregion
        #region OCOR
        public Boolean OCOR { get; set; } = default(Boolean);
        #endregion
        #region SOFT
        public Boolean SOFT { get; set; } = default(Boolean);
        #endregion
        #region DOFT
        public Boolean DOFT { get; set; } = default(Boolean);
        #endregion
        #region LVCR
        public Single LVCR { get; set; } = default(Single);
        #endregion
        #region Conditions
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private ExtendedList<Condition> _Conditions = new ExtendedList<Condition>();
        public ExtendedList<Condition> Conditions
        {
            get => this._Conditions;
            init => this._Conditions = value;
        }
        #region Interface Members
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IReadOnlyList<IConditionGetter> IAnimationSceneItemGetter.Conditions => _Conditions;
        #endregion

        #endregion
        #region ATAC
        private readonly IFormLink<IActionRecordGetter> _ATAC = new FormLink<IActionRecordGetter>();
        public IFormLink<IActionRecordGetter> ATAC
        {
            get => _ATAC;
            set => _ATAC.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IActionRecordGetter> IAnimationSceneItemGetter.ATAC => this.ATAC;
        #endregion
        #region PLRL
        public Boolean PLRL { get; set; } = default(Boolean);
        #endregion
        #region SHRT
        public Boolean SHRT { get; set; } = default(Boolean);
        #endregion
        #region DTGT
        public Int32? DTGT { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Int32? IAnimationSceneItemGetter.DTGT => this.DTGT;
        #endregion
        #region DPLT
        public Boolean DPLT { get; set; } = default(Boolean);
        #endregion
        #region ACEP
        public Boolean ACEP { get; set; } = default(Boolean);
        #endregion

        #region To String

        public void Print(
            StructuredStringBuilder sb,
            string? name = null)
        {
            AnimationSceneItemMixIn.Print(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is not IAnimationSceneItemGetter rhs) return false;
            return ((AnimationSceneItemCommon)((IAnimationSceneItemGetter)this).CommonInstance()!).Equals(this, rhs, equalsMask: null);
        }

        public bool Equals(IAnimationSceneItemGetter? obj)
        {
            return ((AnimationSceneItemCommon)((IAnimationSceneItemGetter)this).CommonInstance()!).Equals(this, obj, equalsMask: null);
        }

        public override int GetHashCode() => ((AnimationSceneItemCommon)((IAnimationSceneItemGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        #region Mask
        public class Mask<TItem> :
            IEquatable<Mask<TItem>>,
            IMask<TItem>
        {
            #region Ctors
            public Mask(TItem initialValue)
            {
                this.NpcAnimation = initialValue;
                this.STRV = initialValue;
                this.VCLR = initialValue;
                this.FLMV = initialValue;
                this.FLAV = initialValue;
                this.QUAL = initialValue;
                this.SPOR = initialValue;
                this.OCOR = initialValue;
                this.SOFT = initialValue;
                this.DOFT = initialValue;
                this.LVCR = initialValue;
                this.Conditions = new MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, Condition.Mask<TItem>?>>?>(initialValue, Enumerable.Empty<MaskItemIndexed<TItem, Condition.Mask<TItem>?>>());
                this.ATAC = initialValue;
                this.PLRL = initialValue;
                this.SHRT = initialValue;
                this.DTGT = initialValue;
                this.DPLT = initialValue;
                this.ACEP = initialValue;
            }

            public Mask(
                TItem NpcAnimation,
                TItem STRV,
                TItem VCLR,
                TItem FLMV,
                TItem FLAV,
                TItem QUAL,
                TItem SPOR,
                TItem OCOR,
                TItem SOFT,
                TItem DOFT,
                TItem LVCR,
                TItem Conditions,
                TItem ATAC,
                TItem PLRL,
                TItem SHRT,
                TItem DTGT,
                TItem DPLT,
                TItem ACEP)
            {
                this.NpcAnimation = NpcAnimation;
                this.STRV = STRV;
                this.VCLR = VCLR;
                this.FLMV = FLMV;
                this.FLAV = FLAV;
                this.QUAL = QUAL;
                this.SPOR = SPOR;
                this.OCOR = OCOR;
                this.SOFT = SOFT;
                this.DOFT = DOFT;
                this.LVCR = LVCR;
                this.Conditions = new MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, Condition.Mask<TItem>?>>?>(Conditions, Enumerable.Empty<MaskItemIndexed<TItem, Condition.Mask<TItem>?>>());
                this.ATAC = ATAC;
                this.PLRL = PLRL;
                this.SHRT = SHRT;
                this.DTGT = DTGT;
                this.DPLT = DPLT;
                this.ACEP = ACEP;
            }

            #pragma warning disable CS8618
            protected Mask()
            {
            }
            #pragma warning restore CS8618

            #endregion

            #region Members
            public TItem NpcAnimation;
            public TItem STRV;
            public TItem VCLR;
            public TItem FLMV;
            public TItem FLAV;
            public TItem QUAL;
            public TItem SPOR;
            public TItem OCOR;
            public TItem SOFT;
            public TItem DOFT;
            public TItem LVCR;
            public MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, Condition.Mask<TItem>?>>?>? Conditions;
            public TItem ATAC;
            public TItem PLRL;
            public TItem SHRT;
            public TItem DTGT;
            public TItem DPLT;
            public TItem ACEP;
            #endregion

            #region Equals
            public override bool Equals(object? obj)
            {
                if (!(obj is Mask<TItem> rhs)) return false;
                return Equals(rhs);
            }

            public bool Equals(Mask<TItem>? rhs)
            {
                if (rhs == null) return false;
                if (!object.Equals(this.NpcAnimation, rhs.NpcAnimation)) return false;
                if (!object.Equals(this.STRV, rhs.STRV)) return false;
                if (!object.Equals(this.VCLR, rhs.VCLR)) return false;
                if (!object.Equals(this.FLMV, rhs.FLMV)) return false;
                if (!object.Equals(this.FLAV, rhs.FLAV)) return false;
                if (!object.Equals(this.QUAL, rhs.QUAL)) return false;
                if (!object.Equals(this.SPOR, rhs.SPOR)) return false;
                if (!object.Equals(this.OCOR, rhs.OCOR)) return false;
                if (!object.Equals(this.SOFT, rhs.SOFT)) return false;
                if (!object.Equals(this.DOFT, rhs.DOFT)) return false;
                if (!object.Equals(this.LVCR, rhs.LVCR)) return false;
                if (!object.Equals(this.Conditions, rhs.Conditions)) return false;
                if (!object.Equals(this.ATAC, rhs.ATAC)) return false;
                if (!object.Equals(this.PLRL, rhs.PLRL)) return false;
                if (!object.Equals(this.SHRT, rhs.SHRT)) return false;
                if (!object.Equals(this.DTGT, rhs.DTGT)) return false;
                if (!object.Equals(this.DPLT, rhs.DPLT)) return false;
                if (!object.Equals(this.ACEP, rhs.ACEP)) return false;
                return true;
            }
            public override int GetHashCode()
            {
                var hash = new HashCode();
                hash.Add(this.NpcAnimation);
                hash.Add(this.STRV);
                hash.Add(this.VCLR);
                hash.Add(this.FLMV);
                hash.Add(this.FLAV);
                hash.Add(this.QUAL);
                hash.Add(this.SPOR);
                hash.Add(this.OCOR);
                hash.Add(this.SOFT);
                hash.Add(this.DOFT);
                hash.Add(this.LVCR);
                hash.Add(this.Conditions);
                hash.Add(this.ATAC);
                hash.Add(this.PLRL);
                hash.Add(this.SHRT);
                hash.Add(this.DTGT);
                hash.Add(this.DPLT);
                hash.Add(this.ACEP);
                return hash.ToHashCode();
            }

            #endregion

            #region All
            public bool All(Func<TItem, bool> eval)
            {
                if (!eval(this.NpcAnimation)) return false;
                if (!eval(this.STRV)) return false;
                if (!eval(this.VCLR)) return false;
                if (!eval(this.FLMV)) return false;
                if (!eval(this.FLAV)) return false;
                if (!eval(this.QUAL)) return false;
                if (!eval(this.SPOR)) return false;
                if (!eval(this.OCOR)) return false;
                if (!eval(this.SOFT)) return false;
                if (!eval(this.DOFT)) return false;
                if (!eval(this.LVCR)) return false;
                if (this.Conditions != null)
                {
                    if (!eval(this.Conditions.Overall)) return false;
                    if (this.Conditions.Specific != null)
                    {
                        foreach (var item in this.Conditions.Specific)
                        {
                            if (!eval(item.Overall)) return false;
                            if (item.Specific != null && !item.Specific.All(eval)) return false;
                        }
                    }
                }
                if (!eval(this.ATAC)) return false;
                if (!eval(this.PLRL)) return false;
                if (!eval(this.SHRT)) return false;
                if (!eval(this.DTGT)) return false;
                if (!eval(this.DPLT)) return false;
                if (!eval(this.ACEP)) return false;
                return true;
            }
            #endregion

            #region Any
            public bool Any(Func<TItem, bool> eval)
            {
                if (eval(this.NpcAnimation)) return true;
                if (eval(this.STRV)) return true;
                if (eval(this.VCLR)) return true;
                if (eval(this.FLMV)) return true;
                if (eval(this.FLAV)) return true;
                if (eval(this.QUAL)) return true;
                if (eval(this.SPOR)) return true;
                if (eval(this.OCOR)) return true;
                if (eval(this.SOFT)) return true;
                if (eval(this.DOFT)) return true;
                if (eval(this.LVCR)) return true;
                if (this.Conditions != null)
                {
                    if (eval(this.Conditions.Overall)) return true;
                    if (this.Conditions.Specific != null)
                    {
                        foreach (var item in this.Conditions.Specific)
                        {
                            if (!eval(item.Overall)) return false;
                            if (item.Specific != null && !item.Specific.All(eval)) return false;
                        }
                    }
                }
                if (eval(this.ATAC)) return true;
                if (eval(this.PLRL)) return true;
                if (eval(this.SHRT)) return true;
                if (eval(this.DTGT)) return true;
                if (eval(this.DPLT)) return true;
                if (eval(this.ACEP)) return true;
                return false;
            }
            #endregion

            #region Translate
            public Mask<R> Translate<R>(Func<TItem, R> eval)
            {
                var ret = new AnimationSceneItem.Mask<R>();
                this.Translate_InternalFill(ret, eval);
                return ret;
            }

            protected void Translate_InternalFill<R>(Mask<R> obj, Func<TItem, R> eval)
            {
                obj.NpcAnimation = eval(this.NpcAnimation);
                obj.STRV = eval(this.STRV);
                obj.VCLR = eval(this.VCLR);
                obj.FLMV = eval(this.FLMV);
                obj.FLAV = eval(this.FLAV);
                obj.QUAL = eval(this.QUAL);
                obj.SPOR = eval(this.SPOR);
                obj.OCOR = eval(this.OCOR);
                obj.SOFT = eval(this.SOFT);
                obj.DOFT = eval(this.DOFT);
                obj.LVCR = eval(this.LVCR);
                if (Conditions != null)
                {
                    obj.Conditions = new MaskItem<R, IEnumerable<MaskItemIndexed<R, Condition.Mask<R>?>>?>(eval(this.Conditions.Overall), Enumerable.Empty<MaskItemIndexed<R, Condition.Mask<R>?>>());
                    if (Conditions.Specific != null)
                    {
                        var l = new List<MaskItemIndexed<R, Condition.Mask<R>?>>();
                        obj.Conditions.Specific = l;
                        foreach (var item in Conditions.Specific)
                        {
                            MaskItemIndexed<R, Condition.Mask<R>?>? mask = item == null ? null : new MaskItemIndexed<R, Condition.Mask<R>?>(item.Index, eval(item.Overall), item.Specific?.Translate(eval));
                            if (mask == null) continue;
                            l.Add(mask);
                        }
                    }
                }
                obj.ATAC = eval(this.ATAC);
                obj.PLRL = eval(this.PLRL);
                obj.SHRT = eval(this.SHRT);
                obj.DTGT = eval(this.DTGT);
                obj.DPLT = eval(this.DPLT);
                obj.ACEP = eval(this.ACEP);
            }
            #endregion

            #region To String
            public override string ToString() => this.Print();

            public string Print(AnimationSceneItem.Mask<bool>? printMask = null)
            {
                var sb = new StructuredStringBuilder();
                Print(sb, printMask);
                return sb.ToString();
            }

            public void Print(StructuredStringBuilder sb, AnimationSceneItem.Mask<bool>? printMask = null)
            {
                sb.AppendLine($"{nameof(AnimationSceneItem.Mask<TItem>)} =>");
                using (sb.Brace())
                {
                    if (printMask?.NpcAnimation ?? true)
                    {
                        sb.AppendItem(NpcAnimation, "NpcAnimation");
                    }
                    if (printMask?.STRV ?? true)
                    {
                        sb.AppendItem(STRV, "STRV");
                    }
                    if (printMask?.VCLR ?? true)
                    {
                        sb.AppendItem(VCLR, "VCLR");
                    }
                    if (printMask?.FLMV ?? true)
                    {
                        sb.AppendItem(FLMV, "FLMV");
                    }
                    if (printMask?.FLAV ?? true)
                    {
                        sb.AppendItem(FLAV, "FLAV");
                    }
                    if (printMask?.QUAL ?? true)
                    {
                        sb.AppendItem(QUAL, "QUAL");
                    }
                    if (printMask?.SPOR ?? true)
                    {
                        sb.AppendItem(SPOR, "SPOR");
                    }
                    if (printMask?.OCOR ?? true)
                    {
                        sb.AppendItem(OCOR, "OCOR");
                    }
                    if (printMask?.SOFT ?? true)
                    {
                        sb.AppendItem(SOFT, "SOFT");
                    }
                    if (printMask?.DOFT ?? true)
                    {
                        sb.AppendItem(DOFT, "DOFT");
                    }
                    if (printMask?.LVCR ?? true)
                    {
                        sb.AppendItem(LVCR, "LVCR");
                    }
                    if ((printMask?.Conditions?.Overall ?? true)
                        && Conditions is {} ConditionsItem)
                    {
                        sb.AppendLine("Conditions =>");
                        using (sb.Brace())
                        {
                            sb.AppendItem(ConditionsItem.Overall);
                            if (ConditionsItem.Specific != null)
                            {
                                foreach (var subItem in ConditionsItem.Specific)
                                {
                                    using (sb.Brace())
                                    {
                                        subItem?.Print(sb);
                                    }
                                }
                            }
                        }
                    }
                    if (printMask?.ATAC ?? true)
                    {
                        sb.AppendItem(ATAC, "ATAC");
                    }
                    if (printMask?.PLRL ?? true)
                    {
                        sb.AppendItem(PLRL, "PLRL");
                    }
                    if (printMask?.SHRT ?? true)
                    {
                        sb.AppendItem(SHRT, "SHRT");
                    }
                    if (printMask?.DTGT ?? true)
                    {
                        sb.AppendItem(DTGT, "DTGT");
                    }
                    if (printMask?.DPLT ?? true)
                    {
                        sb.AppendItem(DPLT, "DPLT");
                    }
                    if (printMask?.ACEP ?? true)
                    {
                        sb.AppendItem(ACEP, "ACEP");
                    }
                }
            }
            #endregion

        }

        public class ErrorMask :
            IErrorMask,
            IErrorMask<ErrorMask>
        {
            #region Members
            public Exception? Overall { get; set; }
            private List<string>? _warnings;
            public List<string> Warnings
            {
                get
                {
                    if (_warnings == null)
                    {
                        _warnings = new List<string>();
                    }
                    return _warnings;
                }
            }
            public Exception? NpcAnimation;
            public Exception? STRV;
            public Exception? VCLR;
            public Exception? FLMV;
            public Exception? FLAV;
            public Exception? QUAL;
            public Exception? SPOR;
            public Exception? OCOR;
            public Exception? SOFT;
            public Exception? DOFT;
            public Exception? LVCR;
            public MaskItem<Exception?, IEnumerable<MaskItem<Exception?, Condition.ErrorMask?>>?>? Conditions;
            public Exception? ATAC;
            public Exception? PLRL;
            public Exception? SHRT;
            public Exception? DTGT;
            public Exception? DPLT;
            public Exception? ACEP;
            #endregion

            #region IErrorMask
            public object? GetNthMask(int index)
            {
                AnimationSceneItem_FieldIndex enu = (AnimationSceneItem_FieldIndex)index;
                switch (enu)
                {
                    case AnimationSceneItem_FieldIndex.NpcAnimation:
                        return NpcAnimation;
                    case AnimationSceneItem_FieldIndex.STRV:
                        return STRV;
                    case AnimationSceneItem_FieldIndex.VCLR:
                        return VCLR;
                    case AnimationSceneItem_FieldIndex.FLMV:
                        return FLMV;
                    case AnimationSceneItem_FieldIndex.FLAV:
                        return FLAV;
                    case AnimationSceneItem_FieldIndex.QUAL:
                        return QUAL;
                    case AnimationSceneItem_FieldIndex.SPOR:
                        return SPOR;
                    case AnimationSceneItem_FieldIndex.OCOR:
                        return OCOR;
                    case AnimationSceneItem_FieldIndex.SOFT:
                        return SOFT;
                    case AnimationSceneItem_FieldIndex.DOFT:
                        return DOFT;
                    case AnimationSceneItem_FieldIndex.LVCR:
                        return LVCR;
                    case AnimationSceneItem_FieldIndex.Conditions:
                        return Conditions;
                    case AnimationSceneItem_FieldIndex.ATAC:
                        return ATAC;
                    case AnimationSceneItem_FieldIndex.PLRL:
                        return PLRL;
                    case AnimationSceneItem_FieldIndex.SHRT:
                        return SHRT;
                    case AnimationSceneItem_FieldIndex.DTGT:
                        return DTGT;
                    case AnimationSceneItem_FieldIndex.DPLT:
                        return DPLT;
                    case AnimationSceneItem_FieldIndex.ACEP:
                        return ACEP;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthException(int index, Exception ex)
            {
                AnimationSceneItem_FieldIndex enu = (AnimationSceneItem_FieldIndex)index;
                switch (enu)
                {
                    case AnimationSceneItem_FieldIndex.NpcAnimation:
                        this.NpcAnimation = ex;
                        break;
                    case AnimationSceneItem_FieldIndex.STRV:
                        this.STRV = ex;
                        break;
                    case AnimationSceneItem_FieldIndex.VCLR:
                        this.VCLR = ex;
                        break;
                    case AnimationSceneItem_FieldIndex.FLMV:
                        this.FLMV = ex;
                        break;
                    case AnimationSceneItem_FieldIndex.FLAV:
                        this.FLAV = ex;
                        break;
                    case AnimationSceneItem_FieldIndex.QUAL:
                        this.QUAL = ex;
                        break;
                    case AnimationSceneItem_FieldIndex.SPOR:
                        this.SPOR = ex;
                        break;
                    case AnimationSceneItem_FieldIndex.OCOR:
                        this.OCOR = ex;
                        break;
                    case AnimationSceneItem_FieldIndex.SOFT:
                        this.SOFT = ex;
                        break;
                    case AnimationSceneItem_FieldIndex.DOFT:
                        this.DOFT = ex;
                        break;
                    case AnimationSceneItem_FieldIndex.LVCR:
                        this.LVCR = ex;
                        break;
                    case AnimationSceneItem_FieldIndex.Conditions:
                        this.Conditions = new MaskItem<Exception?, IEnumerable<MaskItem<Exception?, Condition.ErrorMask?>>?>(ex, null);
                        break;
                    case AnimationSceneItem_FieldIndex.ATAC:
                        this.ATAC = ex;
                        break;
                    case AnimationSceneItem_FieldIndex.PLRL:
                        this.PLRL = ex;
                        break;
                    case AnimationSceneItem_FieldIndex.SHRT:
                        this.SHRT = ex;
                        break;
                    case AnimationSceneItem_FieldIndex.DTGT:
                        this.DTGT = ex;
                        break;
                    case AnimationSceneItem_FieldIndex.DPLT:
                        this.DPLT = ex;
                        break;
                    case AnimationSceneItem_FieldIndex.ACEP:
                        this.ACEP = ex;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthMask(int index, object obj)
            {
                AnimationSceneItem_FieldIndex enu = (AnimationSceneItem_FieldIndex)index;
                switch (enu)
                {
                    case AnimationSceneItem_FieldIndex.NpcAnimation:
                        this.NpcAnimation = (Exception?)obj;
                        break;
                    case AnimationSceneItem_FieldIndex.STRV:
                        this.STRV = (Exception?)obj;
                        break;
                    case AnimationSceneItem_FieldIndex.VCLR:
                        this.VCLR = (Exception?)obj;
                        break;
                    case AnimationSceneItem_FieldIndex.FLMV:
                        this.FLMV = (Exception?)obj;
                        break;
                    case AnimationSceneItem_FieldIndex.FLAV:
                        this.FLAV = (Exception?)obj;
                        break;
                    case AnimationSceneItem_FieldIndex.QUAL:
                        this.QUAL = (Exception?)obj;
                        break;
                    case AnimationSceneItem_FieldIndex.SPOR:
                        this.SPOR = (Exception?)obj;
                        break;
                    case AnimationSceneItem_FieldIndex.OCOR:
                        this.OCOR = (Exception?)obj;
                        break;
                    case AnimationSceneItem_FieldIndex.SOFT:
                        this.SOFT = (Exception?)obj;
                        break;
                    case AnimationSceneItem_FieldIndex.DOFT:
                        this.DOFT = (Exception?)obj;
                        break;
                    case AnimationSceneItem_FieldIndex.LVCR:
                        this.LVCR = (Exception?)obj;
                        break;
                    case AnimationSceneItem_FieldIndex.Conditions:
                        this.Conditions = (MaskItem<Exception?, IEnumerable<MaskItem<Exception?, Condition.ErrorMask?>>?>)obj;
                        break;
                    case AnimationSceneItem_FieldIndex.ATAC:
                        this.ATAC = (Exception?)obj;
                        break;
                    case AnimationSceneItem_FieldIndex.PLRL:
                        this.PLRL = (Exception?)obj;
                        break;
                    case AnimationSceneItem_FieldIndex.SHRT:
                        this.SHRT = (Exception?)obj;
                        break;
                    case AnimationSceneItem_FieldIndex.DTGT:
                        this.DTGT = (Exception?)obj;
                        break;
                    case AnimationSceneItem_FieldIndex.DPLT:
                        this.DPLT = (Exception?)obj;
                        break;
                    case AnimationSceneItem_FieldIndex.ACEP:
                        this.ACEP = (Exception?)obj;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public bool IsInError()
            {
                if (Overall != null) return true;
                if (NpcAnimation != null) return true;
                if (STRV != null) return true;
                if (VCLR != null) return true;
                if (FLMV != null) return true;
                if (FLAV != null) return true;
                if (QUAL != null) return true;
                if (SPOR != null) return true;
                if (OCOR != null) return true;
                if (SOFT != null) return true;
                if (DOFT != null) return true;
                if (LVCR != null) return true;
                if (Conditions != null) return true;
                if (ATAC != null) return true;
                if (PLRL != null) return true;
                if (SHRT != null) return true;
                if (DTGT != null) return true;
                if (DPLT != null) return true;
                if (ACEP != null) return true;
                return false;
            }
            #endregion

            #region To String
            public override string ToString() => this.Print();

            public void Print(StructuredStringBuilder sb, string? name = null)
            {
                sb.AppendLine($"{(name ?? "ErrorMask")} =>");
                using (sb.Brace())
                {
                    if (this.Overall != null)
                    {
                        sb.AppendLine("Overall =>");
                        using (sb.Brace())
                        {
                            sb.AppendLine($"{this.Overall}");
                        }
                    }
                    PrintFillInternal(sb);
                }
            }
            protected void PrintFillInternal(StructuredStringBuilder sb)
            {
                {
                    sb.AppendItem(NpcAnimation, "NpcAnimation");
                }
                {
                    sb.AppendItem(STRV, "STRV");
                }
                {
                    sb.AppendItem(VCLR, "VCLR");
                }
                {
                    sb.AppendItem(FLMV, "FLMV");
                }
                {
                    sb.AppendItem(FLAV, "FLAV");
                }
                {
                    sb.AppendItem(QUAL, "QUAL");
                }
                {
                    sb.AppendItem(SPOR, "SPOR");
                }
                {
                    sb.AppendItem(OCOR, "OCOR");
                }
                {
                    sb.AppendItem(SOFT, "SOFT");
                }
                {
                    sb.AppendItem(DOFT, "DOFT");
                }
                {
                    sb.AppendItem(LVCR, "LVCR");
                }
                if (Conditions is {} ConditionsItem)
                {
                    sb.AppendLine("Conditions =>");
                    using (sb.Brace())
                    {
                        sb.AppendItem(ConditionsItem.Overall);
                        if (ConditionsItem.Specific != null)
                        {
                            foreach (var subItem in ConditionsItem.Specific)
                            {
                                using (sb.Brace())
                                {
                                    subItem?.Print(sb);
                                }
                            }
                        }
                    }
                }
                {
                    sb.AppendItem(ATAC, "ATAC");
                }
                {
                    sb.AppendItem(PLRL, "PLRL");
                }
                {
                    sb.AppendItem(SHRT, "SHRT");
                }
                {
                    sb.AppendItem(DTGT, "DTGT");
                }
                {
                    sb.AppendItem(DPLT, "DPLT");
                }
                {
                    sb.AppendItem(ACEP, "ACEP");
                }
            }
            #endregion

            #region Combine
            public ErrorMask Combine(ErrorMask? rhs)
            {
                if (rhs == null) return this;
                var ret = new ErrorMask();
                ret.NpcAnimation = this.NpcAnimation.Combine(rhs.NpcAnimation);
                ret.STRV = this.STRV.Combine(rhs.STRV);
                ret.VCLR = this.VCLR.Combine(rhs.VCLR);
                ret.FLMV = this.FLMV.Combine(rhs.FLMV);
                ret.FLAV = this.FLAV.Combine(rhs.FLAV);
                ret.QUAL = this.QUAL.Combine(rhs.QUAL);
                ret.SPOR = this.SPOR.Combine(rhs.SPOR);
                ret.OCOR = this.OCOR.Combine(rhs.OCOR);
                ret.SOFT = this.SOFT.Combine(rhs.SOFT);
                ret.DOFT = this.DOFT.Combine(rhs.DOFT);
                ret.LVCR = this.LVCR.Combine(rhs.LVCR);
                ret.Conditions = new MaskItem<Exception?, IEnumerable<MaskItem<Exception?, Condition.ErrorMask?>>?>(Noggog.ExceptionExt.Combine(this.Conditions?.Overall, rhs.Conditions?.Overall), Noggog.ExceptionExt.Combine(this.Conditions?.Specific, rhs.Conditions?.Specific));
                ret.ATAC = this.ATAC.Combine(rhs.ATAC);
                ret.PLRL = this.PLRL.Combine(rhs.PLRL);
                ret.SHRT = this.SHRT.Combine(rhs.SHRT);
                ret.DTGT = this.DTGT.Combine(rhs.DTGT);
                ret.DPLT = this.DPLT.Combine(rhs.DPLT);
                ret.ACEP = this.ACEP.Combine(rhs.ACEP);
                return ret;
            }
            public static ErrorMask? Combine(ErrorMask? lhs, ErrorMask? rhs)
            {
                if (lhs != null && rhs != null) return lhs.Combine(rhs);
                return lhs ?? rhs;
            }
            #endregion

            #region Factory
            public static ErrorMask Factory(ErrorMaskBuilder errorMask)
            {
                return new ErrorMask();
            }
            #endregion

        }
        public class TranslationMask : ITranslationMask
        {
            #region Members
            private TranslationCrystal? _crystal;
            public readonly bool DefaultOn;
            public bool OnOverall;
            public bool NpcAnimation;
            public bool STRV;
            public bool VCLR;
            public bool FLMV;
            public bool FLAV;
            public bool QUAL;
            public bool SPOR;
            public bool OCOR;
            public bool SOFT;
            public bool DOFT;
            public bool LVCR;
            public Condition.TranslationMask? Conditions;
            public bool ATAC;
            public bool PLRL;
            public bool SHRT;
            public bool DTGT;
            public bool DPLT;
            public bool ACEP;
            #endregion

            #region Ctors
            public TranslationMask(
                bool defaultOn,
                bool onOverall = true)
            {
                this.DefaultOn = defaultOn;
                this.OnOverall = onOverall;
                this.NpcAnimation = defaultOn;
                this.STRV = defaultOn;
                this.VCLR = defaultOn;
                this.FLMV = defaultOn;
                this.FLAV = defaultOn;
                this.QUAL = defaultOn;
                this.SPOR = defaultOn;
                this.OCOR = defaultOn;
                this.SOFT = defaultOn;
                this.DOFT = defaultOn;
                this.LVCR = defaultOn;
                this.ATAC = defaultOn;
                this.PLRL = defaultOn;
                this.SHRT = defaultOn;
                this.DTGT = defaultOn;
                this.DPLT = defaultOn;
                this.ACEP = defaultOn;
            }

            #endregion

            public TranslationCrystal GetCrystal()
            {
                if (_crystal != null) return _crystal;
                var ret = new List<(bool On, TranslationCrystal? SubCrystal)>();
                GetCrystal(ret);
                _crystal = new TranslationCrystal(ret.ToArray());
                return _crystal;
            }

            protected void GetCrystal(List<(bool On, TranslationCrystal? SubCrystal)> ret)
            {
                ret.Add((NpcAnimation, null));
                ret.Add((STRV, null));
                ret.Add((VCLR, null));
                ret.Add((FLMV, null));
                ret.Add((FLAV, null));
                ret.Add((QUAL, null));
                ret.Add((SPOR, null));
                ret.Add((OCOR, null));
                ret.Add((SOFT, null));
                ret.Add((DOFT, null));
                ret.Add((LVCR, null));
                ret.Add((Conditions == null ? DefaultOn : !Conditions.GetCrystal().CopyNothing, Conditions?.GetCrystal()));
                ret.Add((ATAC, null));
                ret.Add((PLRL, null));
                ret.Add((SHRT, null));
                ret.Add((DTGT, null));
                ret.Add((DPLT, null));
                ret.Add((ACEP, null));
            }

            public static implicit operator TranslationMask(bool defaultOn)
            {
                return new TranslationMask(defaultOn: defaultOn, onOverall: defaultOn);
            }

        }
        #endregion

        #region Mutagen
        public IEnumerable<IFormLinkGetter> EnumerateFormLinks() => AnimationSceneItemCommon.Instance.EnumerateFormLinks(this);
        public void RemapLinks(IReadOnlyDictionary<FormKey, FormKey> mapping) => AnimationSceneItemSetterCommon.Instance.RemapLinks(this, mapping);
        #endregion

        #region Binary Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => AnimationSceneItemBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((AnimationSceneItemBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }
        #region Binary Create
        public static AnimationSceneItem CreateFromBinary(
            MutagenFrame frame,
            TypedParseParams translationParams = default)
        {
            var ret = new AnimationSceneItem();
            ((AnimationSceneItemSetterCommon)((IAnimationSceneItemGetter)ret).CommonSetterInstance()!).CopyInFromBinary(
                item: ret,
                frame: frame,
                translationParams: translationParams);
            return ret;
        }

        #endregion

        public static bool TryCreateFromBinary(
            MutagenFrame frame,
            out AnimationSceneItem item,
            TypedParseParams translationParams = default)
        {
            var startPos = frame.Position;
            item = CreateFromBinary(
                frame: frame,
                translationParams: translationParams);
            return startPos != frame.Position;
        }
        #endregion

        void IPrintable.Print(StructuredStringBuilder sb, string? name) => this.Print(sb, name);

        void IClearable.Clear()
        {
            ((AnimationSceneItemSetterCommon)((IAnimationSceneItemGetter)this).CommonSetterInstance()!).Clear(this);
        }

        internal static AnimationSceneItem GetNew()
        {
            return new AnimationSceneItem();
        }

    }
    #endregion

    #region Interface
    public partial interface IAnimationSceneItem :
        IAnimationSceneItemGetter,
        IFormLinkContainer,
        ILoquiObjectSetter<IAnimationSceneItem>
    {
        new IFormLinkNullable<IIdleAnimationGetter> NpcAnimation { get; set; }
        new String? STRV { get; set; }
        new IFormLink<IKeywordGetter> VCLR { get; set; }
        new IFormLink<IKeywordGetter> FLMV { get; set; }
        new IFormLink<IKeywordGetter> FLAV { get; set; }
        new Boolean QUAL { get; set; }
        new Boolean SPOR { get; set; }
        new Boolean OCOR { get; set; }
        new Boolean SOFT { get; set; }
        new Boolean DOFT { get; set; }
        new Single LVCR { get; set; }
        new ExtendedList<Condition> Conditions { get; }
        new IFormLink<IActionRecordGetter> ATAC { get; set; }
        new Boolean PLRL { get; set; }
        new Boolean SHRT { get; set; }
        new Int32? DTGT { get; set; }
        new Boolean DPLT { get; set; }
        new Boolean ACEP { get; set; }
    }

    public partial interface IAnimationSceneItemGetter :
        ILoquiObject,
        IBinaryItem,
        IFormLinkContainerGetter,
        ILoquiObject<IAnimationSceneItemGetter>
    {
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object? CommonSetterInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonSetterTranslationInstance();
        static ILoquiRegistration StaticRegistration => AnimationSceneItem_Registration.Instance;
        IFormLinkNullableGetter<IIdleAnimationGetter> NpcAnimation { get; }
        String? STRV { get; }
        IFormLinkGetter<IKeywordGetter> VCLR { get; }
        IFormLinkGetter<IKeywordGetter> FLMV { get; }
        IFormLinkGetter<IKeywordGetter> FLAV { get; }
        Boolean QUAL { get; }
        Boolean SPOR { get; }
        Boolean OCOR { get; }
        Boolean SOFT { get; }
        Boolean DOFT { get; }
        Single LVCR { get; }
        IReadOnlyList<IConditionGetter> Conditions { get; }
        IFormLinkGetter<IActionRecordGetter> ATAC { get; }
        Boolean PLRL { get; }
        Boolean SHRT { get; }
        Int32? DTGT { get; }
        Boolean DPLT { get; }
        Boolean ACEP { get; }

    }

    #endregion

    #region Common MixIn
    public static partial class AnimationSceneItemMixIn
    {
        public static void Clear(this IAnimationSceneItem item)
        {
            ((AnimationSceneItemSetterCommon)((IAnimationSceneItemGetter)item).CommonSetterInstance()!).Clear(item: item);
        }

        public static AnimationSceneItem.Mask<bool> GetEqualsMask(
            this IAnimationSceneItemGetter item,
            IAnimationSceneItemGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            return ((AnimationSceneItemCommon)((IAnimationSceneItemGetter)item).CommonInstance()!).GetEqualsMask(
                item: item,
                rhs: rhs,
                include: include);
        }

        public static string Print(
            this IAnimationSceneItemGetter item,
            string? name = null,
            AnimationSceneItem.Mask<bool>? printMask = null)
        {
            return ((AnimationSceneItemCommon)((IAnimationSceneItemGetter)item).CommonInstance()!).Print(
                item: item,
                name: name,
                printMask: printMask);
        }

        public static void Print(
            this IAnimationSceneItemGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            AnimationSceneItem.Mask<bool>? printMask = null)
        {
            ((AnimationSceneItemCommon)((IAnimationSceneItemGetter)item).CommonInstance()!).Print(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
        }

        public static bool Equals(
            this IAnimationSceneItemGetter item,
            IAnimationSceneItemGetter rhs,
            AnimationSceneItem.TranslationMask? equalsMask = null)
        {
            return ((AnimationSceneItemCommon)((IAnimationSceneItemGetter)item).CommonInstance()!).Equals(
                lhs: item,
                rhs: rhs,
                equalsMask: equalsMask?.GetCrystal());
        }

        public static void DeepCopyIn(
            this IAnimationSceneItem lhs,
            IAnimationSceneItemGetter rhs)
        {
            ((AnimationSceneItemSetterTranslationCommon)((IAnimationSceneItemGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: default,
                deepCopy: false);
        }

        public static void DeepCopyIn(
            this IAnimationSceneItem lhs,
            IAnimationSceneItemGetter rhs,
            AnimationSceneItem.TranslationMask? copyMask = null)
        {
            ((AnimationSceneItemSetterTranslationCommon)((IAnimationSceneItemGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
        }

        public static void DeepCopyIn(
            this IAnimationSceneItem lhs,
            IAnimationSceneItemGetter rhs,
            out AnimationSceneItem.ErrorMask errorMask,
            AnimationSceneItem.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            ((AnimationSceneItemSetterTranslationCommon)((IAnimationSceneItemGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
            errorMask = AnimationSceneItem.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void DeepCopyIn(
            this IAnimationSceneItem lhs,
            IAnimationSceneItemGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            ((AnimationSceneItemSetterTranslationCommon)((IAnimationSceneItemGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: false);
        }

        public static AnimationSceneItem DeepCopy(
            this IAnimationSceneItemGetter item,
            AnimationSceneItem.TranslationMask? copyMask = null)
        {
            return ((AnimationSceneItemSetterTranslationCommon)((IAnimationSceneItemGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask);
        }

        public static AnimationSceneItem DeepCopy(
            this IAnimationSceneItemGetter item,
            out AnimationSceneItem.ErrorMask errorMask,
            AnimationSceneItem.TranslationMask? copyMask = null)
        {
            return ((AnimationSceneItemSetterTranslationCommon)((IAnimationSceneItemGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: out errorMask);
        }

        public static AnimationSceneItem DeepCopy(
            this IAnimationSceneItemGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            return ((AnimationSceneItemSetterTranslationCommon)((IAnimationSceneItemGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: errorMask);
        }

        #region Binary Translation
        public static void CopyInFromBinary(
            this IAnimationSceneItem item,
            MutagenFrame frame,
            TypedParseParams translationParams = default)
        {
            ((AnimationSceneItemSetterCommon)((IAnimationSceneItemGetter)item).CommonSetterInstance()!).CopyInFromBinary(
                item: item,
                frame: frame,
                translationParams: translationParams);
        }

        #endregion

    }
    #endregion

}

namespace Mutagen.Bethesda.Starfield
{
    #region Field Index
    internal enum AnimationSceneItem_FieldIndex
    {
        NpcAnimation = 0,
        STRV = 1,
        VCLR = 2,
        FLMV = 3,
        FLAV = 4,
        QUAL = 5,
        SPOR = 6,
        OCOR = 7,
        SOFT = 8,
        DOFT = 9,
        LVCR = 10,
        Conditions = 11,
        ATAC = 12,
        PLRL = 13,
        SHRT = 14,
        DTGT = 15,
        DPLT = 16,
        ACEP = 17,
    }
    #endregion

    #region Registration
    internal partial class AnimationSceneItem_Registration : ILoquiRegistration
    {
        public static readonly AnimationSceneItem_Registration Instance = new AnimationSceneItem_Registration();

        public static ProtocolKey ProtocolKey => ProtocolDefinition_Starfield.ProtocolKey;

        public const ushort AdditionalFieldCount = 18;

        public const ushort FieldCount = 18;

        public static readonly Type MaskType = typeof(AnimationSceneItem.Mask<>);

        public static readonly Type ErrorMaskType = typeof(AnimationSceneItem.ErrorMask);

        public static readonly Type ClassType = typeof(AnimationSceneItem);

        public static readonly Type GetterType = typeof(IAnimationSceneItemGetter);

        public static readonly Type? InternalGetterType = null;

        public static readonly Type SetterType = typeof(IAnimationSceneItem);

        public static readonly Type? InternalSetterType = null;

        public const string FullName = "Mutagen.Bethesda.Starfield.AnimationSceneItem";

        public const string Name = "AnimationSceneItem";

        public const string Namespace = "Mutagen.Bethesda.Starfield";

        public const byte GenericCount = 0;

        public static readonly Type? GenericRegistrationType = null;

        public static RecordTriggerSpecs TriggerSpecs => _recordSpecs.Value;
        private static readonly Lazy<RecordTriggerSpecs> _recordSpecs = new Lazy<RecordTriggerSpecs>(() =>
        {
            var endTriggers = RecordCollection.Factory(RecordTypes.XNAM);
            var triggers = RecordCollection.Factory(
                RecordTypes.BNAM,
                RecordTypes.STRV,
                RecordTypes.VCLR);
            var all = RecordCollection.Factory(
                RecordTypes.BNAM,
                RecordTypes.STRV,
                RecordTypes.VCLR,
                RecordTypes.XNAM,
                RecordTypes.FLMV,
                RecordTypes.FLAV,
                RecordTypes.QUAL,
                RecordTypes.SPOR,
                RecordTypes.OCOR,
                RecordTypes.SOFT,
                RecordTypes.DOFT,
                RecordTypes.LVCR,
                RecordTypes.CTDA,
                RecordTypes.CITC,
                RecordTypes.CIS1,
                RecordTypes.CIS2,
                RecordTypes.ATAC,
                RecordTypes.PLRL,
                RecordTypes.SHRT,
                RecordTypes.DTGT,
                RecordTypes.DPLT,
                RecordTypes.ACEP);
            return new RecordTriggerSpecs(
                allRecordTypes: all,
                triggeringRecordTypes: triggers,
                endRecordTypes: endTriggers);
        });
        public static readonly Type BinaryWriteTranslation = typeof(AnimationSceneItemBinaryWriteTranslation);
        #region Interface
        ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;
        ushort ILoquiRegistration.FieldCount => FieldCount;
        ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;
        Type ILoquiRegistration.MaskType => MaskType;
        Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;
        Type ILoquiRegistration.ClassType => ClassType;
        Type ILoquiRegistration.SetterType => SetterType;
        Type? ILoquiRegistration.InternalSetterType => InternalSetterType;
        Type ILoquiRegistration.GetterType => GetterType;
        Type? ILoquiRegistration.InternalGetterType => InternalGetterType;
        string ILoquiRegistration.FullName => FullName;
        string ILoquiRegistration.Name => Name;
        string ILoquiRegistration.Namespace => Namespace;
        byte ILoquiRegistration.GenericCount => GenericCount;
        Type? ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;
        ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsLoqui(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsSingleton(ushort index) => throw new NotImplementedException();
        string ILoquiRegistration.GetNthName(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsNthDerivative(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsProtected(ushort index) => throw new NotImplementedException();
        Type ILoquiRegistration.GetNthType(ushort index) => throw new NotImplementedException();
        #endregion

    }
    #endregion

    #region Common
    internal partial class AnimationSceneItemSetterCommon
    {
        public static readonly AnimationSceneItemSetterCommon Instance = new AnimationSceneItemSetterCommon();

        partial void ClearPartial();
        
        public void Clear(IAnimationSceneItem item)
        {
            ClearPartial();
            item.NpcAnimation.Clear();
            item.STRV = default;
            item.VCLR.Clear();
            item.FLMV.Clear();
            item.FLAV.Clear();
            item.QUAL = default(Boolean);
            item.SPOR = default(Boolean);
            item.OCOR = default(Boolean);
            item.SOFT = default(Boolean);
            item.DOFT = default(Boolean);
            item.LVCR = default(Single);
            item.Conditions.Clear();
            item.ATAC.Clear();
            item.PLRL = default(Boolean);
            item.SHRT = default(Boolean);
            item.DTGT = default;
            item.DPLT = default(Boolean);
            item.ACEP = default(Boolean);
        }
        
        #region Mutagen
        public void RemapLinks(IAnimationSceneItem obj, IReadOnlyDictionary<FormKey, FormKey> mapping)
        {
            obj.NpcAnimation.Relink(mapping);
            obj.VCLR.Relink(mapping);
            obj.FLMV.Relink(mapping);
            obj.FLAV.Relink(mapping);
            obj.Conditions.RemapLinks(mapping);
            obj.ATAC.Relink(mapping);
        }
        
        #endregion
        
        #region Binary Translation
        public virtual void CopyInFromBinary(
            IAnimationSceneItem item,
            MutagenFrame frame,
            TypedParseParams translationParams)
        {
            PluginUtilityTranslation.SubrecordParse(
                record: item,
                frame: frame,
                translationParams: translationParams,
                fillTyped: AnimationSceneItemBinaryCreateTranslation.FillBinaryRecordTypes);
        }
        
        #endregion
        
    }
    internal partial class AnimationSceneItemCommon
    {
        public static readonly AnimationSceneItemCommon Instance = new AnimationSceneItemCommon();

        public AnimationSceneItem.Mask<bool> GetEqualsMask(
            IAnimationSceneItemGetter item,
            IAnimationSceneItemGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            var ret = new AnimationSceneItem.Mask<bool>(false);
            ((AnimationSceneItemCommon)((IAnimationSceneItemGetter)item).CommonInstance()!).FillEqualsMask(
                item: item,
                rhs: rhs,
                ret: ret,
                include: include);
            return ret;
        }
        
        public void FillEqualsMask(
            IAnimationSceneItemGetter item,
            IAnimationSceneItemGetter rhs,
            AnimationSceneItem.Mask<bool> ret,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            ret.NpcAnimation = item.NpcAnimation.Equals(rhs.NpcAnimation);
            ret.STRV = string.Equals(item.STRV, rhs.STRV);
            ret.VCLR = item.VCLR.Equals(rhs.VCLR);
            ret.FLMV = item.FLMV.Equals(rhs.FLMV);
            ret.FLAV = item.FLAV.Equals(rhs.FLAV);
            ret.QUAL = item.QUAL == rhs.QUAL;
            ret.SPOR = item.SPOR == rhs.SPOR;
            ret.OCOR = item.OCOR == rhs.OCOR;
            ret.SOFT = item.SOFT == rhs.SOFT;
            ret.DOFT = item.DOFT == rhs.DOFT;
            ret.LVCR = item.LVCR.EqualsWithin(rhs.LVCR);
            ret.Conditions = item.Conditions.CollectionEqualsHelper(
                rhs.Conditions,
                (loqLhs, loqRhs) => loqLhs.GetEqualsMask(loqRhs, include),
                include);
            ret.ATAC = item.ATAC.Equals(rhs.ATAC);
            ret.PLRL = item.PLRL == rhs.PLRL;
            ret.SHRT = item.SHRT == rhs.SHRT;
            ret.DTGT = item.DTGT == rhs.DTGT;
            ret.DPLT = item.DPLT == rhs.DPLT;
            ret.ACEP = item.ACEP == rhs.ACEP;
        }
        
        public string Print(
            IAnimationSceneItemGetter item,
            string? name = null,
            AnimationSceneItem.Mask<bool>? printMask = null)
        {
            var sb = new StructuredStringBuilder();
            Print(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
            return sb.ToString();
        }
        
        public void Print(
            IAnimationSceneItemGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            AnimationSceneItem.Mask<bool>? printMask = null)
        {
            if (name == null)
            {
                sb.AppendLine($"AnimationSceneItem =>");
            }
            else
            {
                sb.AppendLine($"{name} (AnimationSceneItem) =>");
            }
            using (sb.Brace())
            {
                ToStringFields(
                    item: item,
                    sb: sb,
                    printMask: printMask);
            }
        }
        
        protected static void ToStringFields(
            IAnimationSceneItemGetter item,
            StructuredStringBuilder sb,
            AnimationSceneItem.Mask<bool>? printMask = null)
        {
            if (printMask?.NpcAnimation ?? true)
            {
                sb.AppendItem(item.NpcAnimation.FormKeyNullable, "NpcAnimation");
            }
            if ((printMask?.STRV ?? true)
                && item.STRV is {} STRVItem)
            {
                sb.AppendItem(STRVItem, "STRV");
            }
            if (printMask?.VCLR ?? true)
            {
                sb.AppendItem(item.VCLR.FormKey, "VCLR");
            }
            if (printMask?.FLMV ?? true)
            {
                sb.AppendItem(item.FLMV.FormKey, "FLMV");
            }
            if (printMask?.FLAV ?? true)
            {
                sb.AppendItem(item.FLAV.FormKey, "FLAV");
            }
            if (printMask?.QUAL ?? true)
            {
                sb.AppendItem(item.QUAL, "QUAL");
            }
            if (printMask?.SPOR ?? true)
            {
                sb.AppendItem(item.SPOR, "SPOR");
            }
            if (printMask?.OCOR ?? true)
            {
                sb.AppendItem(item.OCOR, "OCOR");
            }
            if (printMask?.SOFT ?? true)
            {
                sb.AppendItem(item.SOFT, "SOFT");
            }
            if (printMask?.DOFT ?? true)
            {
                sb.AppendItem(item.DOFT, "DOFT");
            }
            if (printMask?.LVCR ?? true)
            {
                sb.AppendItem(item.LVCR, "LVCR");
            }
            if (printMask?.Conditions?.Overall ?? true)
            {
                sb.AppendLine("Conditions =>");
                using (sb.Brace())
                {
                    foreach (var subItem in item.Conditions)
                    {
                        using (sb.Brace())
                        {
                            subItem?.Print(sb, "Item");
                        }
                    }
                }
            }
            if (printMask?.ATAC ?? true)
            {
                sb.AppendItem(item.ATAC.FormKey, "ATAC");
            }
            if (printMask?.PLRL ?? true)
            {
                sb.AppendItem(item.PLRL, "PLRL");
            }
            if (printMask?.SHRT ?? true)
            {
                sb.AppendItem(item.SHRT, "SHRT");
            }
            if ((printMask?.DTGT ?? true)
                && item.DTGT is {} DTGTItem)
            {
                sb.AppendItem(DTGTItem, "DTGT");
            }
            if (printMask?.DPLT ?? true)
            {
                sb.AppendItem(item.DPLT, "DPLT");
            }
            if (printMask?.ACEP ?? true)
            {
                sb.AppendItem(item.ACEP, "ACEP");
            }
        }
        
        #region Equals and Hash
        public virtual bool Equals(
            IAnimationSceneItemGetter? lhs,
            IAnimationSceneItemGetter? rhs,
            TranslationCrystal? equalsMask)
        {
            if (!EqualsMaskHelper.RefEquality(lhs, rhs, out var isEqual)) return isEqual;
            if ((equalsMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.NpcAnimation) ?? true))
            {
                if (!lhs.NpcAnimation.Equals(rhs.NpcAnimation)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.STRV) ?? true))
            {
                if (!string.Equals(lhs.STRV, rhs.STRV)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.VCLR) ?? true))
            {
                if (!lhs.VCLR.Equals(rhs.VCLR)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.FLMV) ?? true))
            {
                if (!lhs.FLMV.Equals(rhs.FLMV)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.FLAV) ?? true))
            {
                if (!lhs.FLAV.Equals(rhs.FLAV)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.QUAL) ?? true))
            {
                if (lhs.QUAL != rhs.QUAL) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.SPOR) ?? true))
            {
                if (lhs.SPOR != rhs.SPOR) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.OCOR) ?? true))
            {
                if (lhs.OCOR != rhs.OCOR) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.SOFT) ?? true))
            {
                if (lhs.SOFT != rhs.SOFT) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.DOFT) ?? true))
            {
                if (lhs.DOFT != rhs.DOFT) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.LVCR) ?? true))
            {
                if (!lhs.LVCR.EqualsWithin(rhs.LVCR)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.Conditions) ?? true))
            {
                if (!lhs.Conditions.SequenceEqual(rhs.Conditions, (l, r) => ((ConditionCommon)((IConditionGetter)l).CommonInstance()!).Equals(l, r, equalsMask?.GetSubCrystal((int)AnimationSceneItem_FieldIndex.Conditions)))) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.ATAC) ?? true))
            {
                if (!lhs.ATAC.Equals(rhs.ATAC)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.PLRL) ?? true))
            {
                if (lhs.PLRL != rhs.PLRL) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.SHRT) ?? true))
            {
                if (lhs.SHRT != rhs.SHRT) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.DTGT) ?? true))
            {
                if (lhs.DTGT != rhs.DTGT) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.DPLT) ?? true))
            {
                if (lhs.DPLT != rhs.DPLT) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.ACEP) ?? true))
            {
                if (lhs.ACEP != rhs.ACEP) return false;
            }
            return true;
        }
        
        public virtual int GetHashCode(IAnimationSceneItemGetter item)
        {
            var hash = new HashCode();
            hash.Add(item.NpcAnimation);
            if (item.STRV is {} STRVitem)
            {
                hash.Add(STRVitem);
            }
            hash.Add(item.VCLR);
            hash.Add(item.FLMV);
            hash.Add(item.FLAV);
            hash.Add(item.QUAL);
            hash.Add(item.SPOR);
            hash.Add(item.OCOR);
            hash.Add(item.SOFT);
            hash.Add(item.DOFT);
            hash.Add(item.LVCR);
            hash.Add(item.Conditions);
            hash.Add(item.ATAC);
            hash.Add(item.PLRL);
            hash.Add(item.SHRT);
            if (item.DTGT is {} DTGTitem)
            {
                hash.Add(DTGTitem);
            }
            hash.Add(item.DPLT);
            hash.Add(item.ACEP);
            return hash.ToHashCode();
        }
        
        #endregion
        
        
        public object GetNew()
        {
            return AnimationSceneItem.GetNew();
        }
        
        #region Mutagen
        public IEnumerable<IFormLinkGetter> EnumerateFormLinks(IAnimationSceneItemGetter obj)
        {
            if (FormLinkInformation.TryFactory(obj.NpcAnimation, out var NpcAnimationInfo))
            {
                yield return NpcAnimationInfo;
            }
            yield return FormLinkInformation.Factory(obj.VCLR);
            yield return FormLinkInformation.Factory(obj.FLMV);
            yield return FormLinkInformation.Factory(obj.FLAV);
            foreach (var item in obj.Conditions.SelectMany(f => f.EnumerateFormLinks()))
            {
                yield return FormLinkInformation.Factory(item);
            }
            yield return FormLinkInformation.Factory(obj.ATAC);
            yield break;
        }
        
        #endregion
        
    }
    internal partial class AnimationSceneItemSetterTranslationCommon
    {
        public static readonly AnimationSceneItemSetterTranslationCommon Instance = new AnimationSceneItemSetterTranslationCommon();

        #region DeepCopyIn
        public void DeepCopyIn(
            IAnimationSceneItem item,
            IAnimationSceneItemGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            if ((copyMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.NpcAnimation) ?? true))
            {
                item.NpcAnimation.SetTo(rhs.NpcAnimation.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.STRV) ?? true))
            {
                item.STRV = rhs.STRV;
            }
            if ((copyMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.VCLR) ?? true))
            {
                item.VCLR.SetTo(rhs.VCLR.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.FLMV) ?? true))
            {
                item.FLMV.SetTo(rhs.FLMV.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.FLAV) ?? true))
            {
                item.FLAV.SetTo(rhs.FLAV.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.QUAL) ?? true))
            {
                item.QUAL = rhs.QUAL;
            }
            if ((copyMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.SPOR) ?? true))
            {
                item.SPOR = rhs.SPOR;
            }
            if ((copyMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.OCOR) ?? true))
            {
                item.OCOR = rhs.OCOR;
            }
            if ((copyMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.SOFT) ?? true))
            {
                item.SOFT = rhs.SOFT;
            }
            if ((copyMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.DOFT) ?? true))
            {
                item.DOFT = rhs.DOFT;
            }
            if ((copyMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.LVCR) ?? true))
            {
                item.LVCR = rhs.LVCR;
            }
            if ((copyMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.Conditions) ?? true))
            {
                errorMask?.PushIndex((int)AnimationSceneItem_FieldIndex.Conditions);
                try
                {
                    item.Conditions.SetTo(
                        rhs.Conditions
                        .Select(r =>
                        {
                            return r.DeepCopy(
                                errorMask: errorMask,
                                default(TranslationCrystal));
                        }));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.ATAC) ?? true))
            {
                item.ATAC.SetTo(rhs.ATAC.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.PLRL) ?? true))
            {
                item.PLRL = rhs.PLRL;
            }
            if ((copyMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.SHRT) ?? true))
            {
                item.SHRT = rhs.SHRT;
            }
            if ((copyMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.DTGT) ?? true))
            {
                item.DTGT = rhs.DTGT;
            }
            if ((copyMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.DPLT) ?? true))
            {
                item.DPLT = rhs.DPLT;
            }
            if ((copyMask?.GetShouldTranslate((int)AnimationSceneItem_FieldIndex.ACEP) ?? true))
            {
                item.ACEP = rhs.ACEP;
            }
            DeepCopyInCustom(
                item: item,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        partial void DeepCopyInCustom(
            IAnimationSceneItem item,
            IAnimationSceneItemGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy);
        #endregion
        
        public AnimationSceneItem DeepCopy(
            IAnimationSceneItemGetter item,
            AnimationSceneItem.TranslationMask? copyMask = null)
        {
            AnimationSceneItem ret = (AnimationSceneItem)((AnimationSceneItemCommon)((IAnimationSceneItemGetter)item).CommonInstance()!).GetNew();
            ((AnimationSceneItemSetterTranslationCommon)((IAnimationSceneItemGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: null,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            return ret;
        }
        
        public AnimationSceneItem DeepCopy(
            IAnimationSceneItemGetter item,
            out AnimationSceneItem.ErrorMask errorMask,
            AnimationSceneItem.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            AnimationSceneItem ret = (AnimationSceneItem)((AnimationSceneItemCommon)((IAnimationSceneItemGetter)item).CommonInstance()!).GetNew();
            ((AnimationSceneItemSetterTranslationCommon)((IAnimationSceneItemGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                ret,
                item,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            errorMask = AnimationSceneItem.ErrorMask.Factory(errorMaskBuilder);
            return ret;
        }
        
        public AnimationSceneItem DeepCopy(
            IAnimationSceneItemGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            AnimationSceneItem ret = (AnimationSceneItem)((AnimationSceneItemCommon)((IAnimationSceneItemGetter)item).CommonInstance()!).GetNew();
            ((AnimationSceneItemSetterTranslationCommon)((IAnimationSceneItemGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: true);
            return ret;
        }
        
    }
    #endregion

}

namespace Mutagen.Bethesda.Starfield
{
    public partial class AnimationSceneItem
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => AnimationSceneItem_Registration.Instance;
        public static ILoquiRegistration StaticRegistration => AnimationSceneItem_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => AnimationSceneItemCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterInstance()
        {
            return AnimationSceneItemSetterCommon.Instance;
        }
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => AnimationSceneItemSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IAnimationSceneItemGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object IAnimationSceneItemGetter.CommonSetterInstance() => this.CommonSetterInstance();
        [DebuggerStepThrough]
        object IAnimationSceneItemGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

    }
}

#region Modules
#region Binary Translation
namespace Mutagen.Bethesda.Starfield
{
    public partial class AnimationSceneItemBinaryWriteTranslation : IBinaryWriteTranslator
    {
        public static readonly AnimationSceneItemBinaryWriteTranslation Instance = new();

        public static void WriteRecordTypes(
            IAnimationSceneItemGetter item,
            MutagenWriter writer,
            TypedWriteParams translationParams)
        {
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.NpcAnimation,
                header: translationParams.ConvertToCustom(RecordTypes.BNAM));
            StringBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.STRV,
                header: translationParams.ConvertToCustom(RecordTypes.STRV),
                binaryType: StringBinaryType.NullTerminate);
            FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.VCLR,
                header: translationParams.ConvertToCustom(RecordTypes.VCLR));
            FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.FLMV,
                header: translationParams.ConvertToCustom(RecordTypes.FLMV));
            FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.FLAV,
                header: translationParams.ConvertToCustom(RecordTypes.FLAV));
            BooleanBinaryTranslation<MutagenFrame>.Instance.WriteAsMarker(
                writer: writer,
                item: item.QUAL,
                header: translationParams.ConvertToCustom(RecordTypes.QUAL));
            BooleanBinaryTranslation<MutagenFrame>.Instance.WriteAsMarker(
                writer: writer,
                item: item.SPOR,
                header: translationParams.ConvertToCustom(RecordTypes.SPOR));
            BooleanBinaryTranslation<MutagenFrame>.Instance.WriteAsMarker(
                writer: writer,
                item: item.OCOR,
                header: translationParams.ConvertToCustom(RecordTypes.OCOR));
            BooleanBinaryTranslation<MutagenFrame>.Instance.WriteAsMarker(
                writer: writer,
                item: item.SOFT,
                header: translationParams.ConvertToCustom(RecordTypes.SOFT));
            BooleanBinaryTranslation<MutagenFrame>.Instance.WriteAsMarker(
                writer: writer,
                item: item.DOFT,
                header: translationParams.ConvertToCustom(RecordTypes.DOFT));
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                writer: writer,
                item: item.LVCR,
                header: translationParams.ConvertToCustom(RecordTypes.LVCR));
            Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<IConditionGetter>.Instance.Write(
                writer: writer,
                items: item.Conditions,
                transl: (MutagenWriter subWriter, IConditionGetter subItem, TypedWriteParams conv) =>
                {
                    var Item = subItem;
                    ((ConditionBinaryWriteTranslation)((IBinaryItem)Item).BinaryWriteTranslator).Write(
                        item: Item,
                        writer: subWriter,
                        translationParams: conv);
                });
            FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.ATAC,
                header: translationParams.ConvertToCustom(RecordTypes.ATAC));
            BooleanBinaryTranslation<MutagenFrame>.Instance.WriteAsMarker(
                writer: writer,
                item: item.PLRL,
                header: translationParams.ConvertToCustom(RecordTypes.PLRL));
            BooleanBinaryTranslation<MutagenFrame>.Instance.WriteAsMarker(
                writer: writer,
                item: item.SHRT,
                header: translationParams.ConvertToCustom(RecordTypes.SHRT));
            Int32BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.DTGT,
                header: translationParams.ConvertToCustom(RecordTypes.DTGT));
            BooleanBinaryTranslation<MutagenFrame>.Instance.WriteAsMarker(
                writer: writer,
                item: item.DPLT,
                header: translationParams.ConvertToCustom(RecordTypes.DPLT));
            BooleanBinaryTranslation<MutagenFrame>.Instance.WriteAsMarker(
                writer: writer,
                item: item.ACEP,
                header: translationParams.ConvertToCustom(RecordTypes.ACEP));
        }

        public void Write(
            MutagenWriter writer,
            IAnimationSceneItemGetter item,
            TypedWriteParams translationParams)
        {
            WriteRecordTypes(
                item: item,
                writer: writer,
                translationParams: translationParams);
            using (HeaderExport.Subrecord(writer, RecordTypes.XNAM)) { } // End Marker
        }

        public void Write(
            MutagenWriter writer,
            object item,
            TypedWriteParams translationParams = default)
        {
            Write(
                item: (IAnimationSceneItemGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

    }

    internal partial class AnimationSceneItemBinaryCreateTranslation
    {
        public static readonly AnimationSceneItemBinaryCreateTranslation Instance = new AnimationSceneItemBinaryCreateTranslation();

        public static ParseResult FillBinaryRecordTypes(
            IAnimationSceneItem item,
            MutagenFrame frame,
            PreviousParse lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            RecordType nextRecordType,
            int contentLength,
            TypedParseParams translationParams = default)
        {
            nextRecordType = translationParams.ConvertToStandard(nextRecordType);
            switch (nextRecordType.TypeInt)
            {
                case RecordTypeInts.BNAM:
                {
                    if (lastParsed.ShortCircuit((int)AnimationSceneItem_FieldIndex.NpcAnimation, translationParams)) return ParseResult.Stop;
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.NpcAnimation.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)AnimationSceneItem_FieldIndex.NpcAnimation;
                }
                case RecordTypeInts.STRV:
                {
                    if (lastParsed.ShortCircuit((int)AnimationSceneItem_FieldIndex.STRV, translationParams)) return ParseResult.Stop;
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.STRV = StringBinaryTranslation.Instance.Parse(
                        reader: frame.SpawnWithLength(contentLength),
                        stringBinaryType: StringBinaryType.NullTerminate,
                        parseWhole: true);
                    return (int)AnimationSceneItem_FieldIndex.STRV;
                }
                case RecordTypeInts.VCLR:
                {
                    if (lastParsed.ShortCircuit((int)AnimationSceneItem_FieldIndex.VCLR, translationParams)) return ParseResult.Stop;
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.VCLR.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)AnimationSceneItem_FieldIndex.VCLR;
                }
                case RecordTypeInts.FLMV:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.FLMV.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)AnimationSceneItem_FieldIndex.FLMV;
                }
                case RecordTypeInts.FLAV:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.FLAV.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)AnimationSceneItem_FieldIndex.FLAV;
                }
                case RecordTypeInts.QUAL:
                {
                    item.QUAL = true;
                    return (int)AnimationSceneItem_FieldIndex.QUAL;
                }
                case RecordTypeInts.SPOR:
                {
                    item.SPOR = true;
                    return (int)AnimationSceneItem_FieldIndex.SPOR;
                }
                case RecordTypeInts.OCOR:
                {
                    item.OCOR = true;
                    return (int)AnimationSceneItem_FieldIndex.OCOR;
                }
                case RecordTypeInts.SOFT:
                {
                    item.SOFT = true;
                    return (int)AnimationSceneItem_FieldIndex.SOFT;
                }
                case RecordTypeInts.DOFT:
                {
                    item.DOFT = true;
                    return (int)AnimationSceneItem_FieldIndex.DOFT;
                }
                case RecordTypeInts.LVCR:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.LVCR = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)AnimationSceneItem_FieldIndex.LVCR;
                }
                case RecordTypeInts.CTDA:
                {
                    item.Conditions.SetTo(
                        Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<Condition>.Instance.Parse(
                            reader: frame,
                            triggeringRecord: Condition_Registration.TriggerSpecs,
                            translationParams: translationParams,
                            transl: Condition.TryCreateFromBinary));
                    return (int)AnimationSceneItem_FieldIndex.Conditions;
                }
                case RecordTypeInts.ATAC:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.ATAC.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)AnimationSceneItem_FieldIndex.ATAC;
                }
                case RecordTypeInts.PLRL:
                {
                    item.PLRL = true;
                    return (int)AnimationSceneItem_FieldIndex.PLRL;
                }
                case RecordTypeInts.SHRT:
                {
                    item.SHRT = true;
                    return (int)AnimationSceneItem_FieldIndex.SHRT;
                }
                case RecordTypeInts.DTGT:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.DTGT = frame.ReadInt32();
                    return (int)AnimationSceneItem_FieldIndex.DTGT;
                }
                case RecordTypeInts.DPLT:
                {
                    item.DPLT = true;
                    return (int)AnimationSceneItem_FieldIndex.DPLT;
                }
                case RecordTypeInts.ACEP:
                {
                    item.ACEP = true;
                    return (int)AnimationSceneItem_FieldIndex.ACEP;
                }
                case RecordTypeInts.XNAM: // End Marker
                {
                    frame.ReadSubrecord();
                    return ParseResult.Stop;
                }
                default:
                    return ParseResult.Stop;
            }
        }

    }

}
namespace Mutagen.Bethesda.Starfield
{
    #region Binary Write Mixins
    public static class AnimationSceneItemBinaryTranslationMixIn
    {
        public static void WriteToBinary(
            this IAnimationSceneItemGetter item,
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((AnimationSceneItemBinaryWriteTranslation)item.BinaryWriteTranslator).Write(
                item: item,
                writer: writer,
                translationParams: translationParams);
        }

    }
    #endregion


}
namespace Mutagen.Bethesda.Starfield
{
    internal partial class AnimationSceneItemBinaryOverlay :
        PluginBinaryOverlay,
        IAnimationSceneItemGetter
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => AnimationSceneItem_Registration.Instance;
        public static ILoquiRegistration StaticRegistration => AnimationSceneItem_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => AnimationSceneItemCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => AnimationSceneItemSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IAnimationSceneItemGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object? IAnimationSceneItemGetter.CommonSetterInstance() => null;
        [DebuggerStepThrough]
        object IAnimationSceneItemGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

        void IPrintable.Print(StructuredStringBuilder sb, string? name) => this.Print(sb, name);

        public IEnumerable<IFormLinkGetter> EnumerateFormLinks() => AnimationSceneItemCommon.Instance.EnumerateFormLinks(this);
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => AnimationSceneItemBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((AnimationSceneItemBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }

        #region NpcAnimation
        private int? _NpcAnimationLocation;
        public IFormLinkNullableGetter<IIdleAnimationGetter> NpcAnimation => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IIdleAnimationGetter>(_package, _recordData, _NpcAnimationLocation);
        #endregion
        #region STRV
        private int? _STRVLocation;
        public String? STRV => _STRVLocation.HasValue ? BinaryStringUtility.ProcessWholeToZString(HeaderTranslation.ExtractSubrecordMemory(_recordData, _STRVLocation.Value, _package.MetaData.Constants), encoding: _package.MetaData.Encodings.NonTranslated) : default(string?);
        #endregion
        #region VCLR
        private int? _VCLRLocation;
        public IFormLinkGetter<IKeywordGetter> VCLR => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IKeywordGetter>(_package, _recordData, _VCLRLocation);
        #endregion
        #region FLMV
        private int? _FLMVLocation;
        public IFormLinkGetter<IKeywordGetter> FLMV => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IKeywordGetter>(_package, _recordData, _FLMVLocation);
        #endregion
        #region FLAV
        private int? _FLAVLocation;
        public IFormLinkGetter<IKeywordGetter> FLAV => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IKeywordGetter>(_package, _recordData, _FLAVLocation);
        #endregion
        #region QUAL
        private int? _QUALLocation;
        public Boolean QUAL => _QUALLocation.HasValue ? true : default(Boolean);
        #endregion
        #region SPOR
        private int? _SPORLocation;
        public Boolean SPOR => _SPORLocation.HasValue ? true : default(Boolean);
        #endregion
        #region OCOR
        private int? _OCORLocation;
        public Boolean OCOR => _OCORLocation.HasValue ? true : default(Boolean);
        #endregion
        #region SOFT
        private int? _SOFTLocation;
        public Boolean SOFT => _SOFTLocation.HasValue ? true : default(Boolean);
        #endregion
        #region DOFT
        private int? _DOFTLocation;
        public Boolean DOFT => _DOFTLocation.HasValue ? true : default(Boolean);
        #endregion
        #region LVCR
        private int? _LVCRLocation;
        public Single LVCR => _LVCRLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_recordData, _LVCRLocation.Value, _package.MetaData.Constants).Float() : default(Single);
        #endregion
        public IReadOnlyList<IConditionGetter> Conditions { get; private set; } = Array.Empty<IConditionGetter>();
        #region ATAC
        private int? _ATACLocation;
        public IFormLinkGetter<IActionRecordGetter> ATAC => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IActionRecordGetter>(_package, _recordData, _ATACLocation);
        #endregion
        #region PLRL
        private int? _PLRLLocation;
        public Boolean PLRL => _PLRLLocation.HasValue ? true : default(Boolean);
        #endregion
        #region SHRT
        private int? _SHRTLocation;
        public Boolean SHRT => _SHRTLocation.HasValue ? true : default(Boolean);
        #endregion
        #region DTGT
        private int? _DTGTLocation;
        public Int32? DTGT => _DTGTLocation.HasValue ? BinaryPrimitives.ReadInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_recordData, _DTGTLocation.Value, _package.MetaData.Constants)) : default(Int32?);
        #endregion
        #region DPLT
        private int? _DPLTLocation;
        public Boolean DPLT => _DPLTLocation.HasValue ? true : default(Boolean);
        #endregion
        #region ACEP
        private int? _ACEPLocation;
        public Boolean ACEP => _ACEPLocation.HasValue ? true : default(Boolean);
        #endregion
        partial void CustomFactoryEnd(
            OverlayStream stream,
            int finalPos,
            int offset);

        partial void CustomCtor();
        protected AnimationSceneItemBinaryOverlay(
            MemoryPair memoryPair,
            BinaryOverlayFactoryPackage package)
            : base(
                memoryPair: memoryPair,
                package: package)
        {
            this.CustomCtor();
        }

        public static IAnimationSceneItemGetter AnimationSceneItemFactory(
            OverlayStream stream,
            BinaryOverlayFactoryPackage package,
            TypedParseParams translationParams = default)
        {
            stream = ExtractTypelessSubrecordRecordMemory(
                stream: stream,
                meta: package.MetaData.Constants,
                translationParams: translationParams,
                memoryPair: out var memoryPair,
                offset: out var offset,
                finalPos: out var finalPos);
            var ret = new AnimationSceneItemBinaryOverlay(
                memoryPair: memoryPair,
                package: package);
            ret.FillTypelessSubrecordTypes(
                stream: stream,
                finalPos: stream.Length,
                offset: offset,
                translationParams: translationParams,
                fill: ret.FillRecordType);
            return ret;
        }

        public static IAnimationSceneItemGetter AnimationSceneItemFactory(
            ReadOnlyMemorySlice<byte> slice,
            BinaryOverlayFactoryPackage package,
            TypedParseParams translationParams = default)
        {
            return AnimationSceneItemFactory(
                stream: new OverlayStream(slice, package),
                package: package,
                translationParams: translationParams);
        }

        public ParseResult FillRecordType(
            OverlayStream stream,
            int finalPos,
            int offset,
            RecordType type,
            PreviousParse lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            TypedParseParams translationParams = default)
        {
            type = translationParams.ConvertToStandard(type);
            switch (type.TypeInt)
            {
                case RecordTypeInts.BNAM:
                {
                    if (lastParsed.ShortCircuit((int)AnimationSceneItem_FieldIndex.NpcAnimation, translationParams)) return ParseResult.Stop;
                    _NpcAnimationLocation = (stream.Position - offset);
                    return (int)AnimationSceneItem_FieldIndex.NpcAnimation;
                }
                case RecordTypeInts.STRV:
                {
                    if (lastParsed.ShortCircuit((int)AnimationSceneItem_FieldIndex.STRV, translationParams)) return ParseResult.Stop;
                    _STRVLocation = (stream.Position - offset);
                    return (int)AnimationSceneItem_FieldIndex.STRV;
                }
                case RecordTypeInts.VCLR:
                {
                    if (lastParsed.ShortCircuit((int)AnimationSceneItem_FieldIndex.VCLR, translationParams)) return ParseResult.Stop;
                    _VCLRLocation = (stream.Position - offset);
                    return (int)AnimationSceneItem_FieldIndex.VCLR;
                }
                case RecordTypeInts.FLMV:
                {
                    _FLMVLocation = (stream.Position - offset);
                    return (int)AnimationSceneItem_FieldIndex.FLMV;
                }
                case RecordTypeInts.FLAV:
                {
                    _FLAVLocation = (stream.Position - offset);
                    return (int)AnimationSceneItem_FieldIndex.FLAV;
                }
                case RecordTypeInts.QUAL:
                {
                    _QUALLocation = (stream.Position - offset);
                    return (int)AnimationSceneItem_FieldIndex.QUAL;
                }
                case RecordTypeInts.SPOR:
                {
                    _SPORLocation = (stream.Position - offset);
                    return (int)AnimationSceneItem_FieldIndex.SPOR;
                }
                case RecordTypeInts.OCOR:
                {
                    _OCORLocation = (stream.Position - offset);
                    return (int)AnimationSceneItem_FieldIndex.OCOR;
                }
                case RecordTypeInts.SOFT:
                {
                    _SOFTLocation = (stream.Position - offset);
                    return (int)AnimationSceneItem_FieldIndex.SOFT;
                }
                case RecordTypeInts.DOFT:
                {
                    _DOFTLocation = (stream.Position - offset);
                    return (int)AnimationSceneItem_FieldIndex.DOFT;
                }
                case RecordTypeInts.LVCR:
                {
                    _LVCRLocation = (stream.Position - offset);
                    return (int)AnimationSceneItem_FieldIndex.LVCR;
                }
                case RecordTypeInts.CTDA:
                {
                    this.Conditions = BinaryOverlayList.FactoryByArray<IConditionGetter>(
                        mem: stream.RemainingMemory,
                        package: _package,
                        translationParams: translationParams,
                        getter: (s, p, recConv) => ConditionBinaryOverlay.ConditionFactory(new OverlayStream(s, p), p, recConv),
                        locs: ParseRecordLocations(
                            stream: stream,
                            trigger: Condition_Registration.TriggerSpecs,
                            triggersAlwaysAreNewRecords: true,
                            constants: _package.MetaData.Constants.SubConstants,
                            skipHeader: false));
                    return (int)AnimationSceneItem_FieldIndex.Conditions;
                }
                case RecordTypeInts.ATAC:
                {
                    _ATACLocation = (stream.Position - offset);
                    return (int)AnimationSceneItem_FieldIndex.ATAC;
                }
                case RecordTypeInts.PLRL:
                {
                    _PLRLLocation = (stream.Position - offset);
                    return (int)AnimationSceneItem_FieldIndex.PLRL;
                }
                case RecordTypeInts.SHRT:
                {
                    _SHRTLocation = (stream.Position - offset);
                    return (int)AnimationSceneItem_FieldIndex.SHRT;
                }
                case RecordTypeInts.DTGT:
                {
                    _DTGTLocation = (stream.Position - offset);
                    return (int)AnimationSceneItem_FieldIndex.DTGT;
                }
                case RecordTypeInts.DPLT:
                {
                    _DPLTLocation = (stream.Position - offset);
                    return (int)AnimationSceneItem_FieldIndex.DPLT;
                }
                case RecordTypeInts.ACEP:
                {
                    _ACEPLocation = (stream.Position - offset);
                    return (int)AnimationSceneItem_FieldIndex.ACEP;
                }
                case RecordTypeInts.XNAM: // End Marker
                {
                    stream.ReadSubrecord();
                    return ParseResult.Stop;
                }
                default:
                    return ParseResult.Stop;
            }
        }
        #region To String

        public void Print(
            StructuredStringBuilder sb,
            string? name = null)
        {
            AnimationSceneItemMixIn.Print(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is not IAnimationSceneItemGetter rhs) return false;
            return ((AnimationSceneItemCommon)((IAnimationSceneItemGetter)this).CommonInstance()!).Equals(this, rhs, equalsMask: null);
        }

        public bool Equals(IAnimationSceneItemGetter? obj)
        {
            return ((AnimationSceneItemCommon)((IAnimationSceneItemGetter)this).CommonInstance()!).Equals(this, obj, equalsMask: null);
        }

        public override int GetHashCode() => ((AnimationSceneItemCommon)((IAnimationSceneItemGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

    }

}
#endregion

#endregion

