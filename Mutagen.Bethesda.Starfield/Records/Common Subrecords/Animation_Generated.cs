/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Autogenerated by Loqui.  Do not manually change.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*/
#region Usings
using Loqui;
using Loqui.Interfaces;
using Loqui.Internal;
using Mutagen.Bethesda.Binary;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Binary.Headers;
using Mutagen.Bethesda.Plugins.Binary.Overlay;
using Mutagen.Bethesda.Plugins.Binary.Streams;
using Mutagen.Bethesda.Plugins.Binary.Translations;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Exceptions;
using Mutagen.Bethesda.Plugins.Internals;
using Mutagen.Bethesda.Plugins.Meta;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Plugins.Records.Internals;
using Mutagen.Bethesda.Plugins.Records.Mapping;
using Mutagen.Bethesda.Starfield;
using Mutagen.Bethesda.Starfield.Internals;
using Mutagen.Bethesda.Translations.Binary;
using Noggog;
using Noggog.StructuredStrings;
using Noggog.StructuredStrings.CSharp;
using RecordTypeInts = Mutagen.Bethesda.Starfield.Internals.RecordTypeInts;
using RecordTypes = Mutagen.Bethesda.Starfield.Internals.RecordTypes;
using System.Buffers.Binary;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Reactive.Disposables;
using System.Reactive.Linq;
#endregion

#nullable enable
namespace Mutagen.Bethesda.Starfield
{
    #region Class
    public partial class Animation :
        IAnimation,
        IEquatable<IAnimationGetter>,
        ILoquiObjectSetter<Animation>
    {
        #region Ctor
        public Animation()
        {
            CustomCtor();
        }
        partial void CustomCtor();
        #endregion

        #region NpcAnimation
        private readonly IFormLink<IIdleAnimationGetter> _NpcAnimation = new FormLink<IIdleAnimationGetter>();
        public IFormLink<IIdleAnimationGetter> NpcAnimation
        {
            get => _NpcAnimation;
            set => _NpcAnimation.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IIdleAnimationGetter> IAnimationGetter.NpcAnimation => this.NpcAnimation;
        #endregion
        #region Subgraph
        public String? Subgraph { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        String? IAnimationGetter.Subgraph => this.Subgraph;
        #endregion
        #region BodyArchetype
        private readonly IFormLinkNullable<IKeywordGetter> _BodyArchetype = new FormLinkNullable<IKeywordGetter>();
        public IFormLinkNullable<IKeywordGetter> BodyArchetype
        {
            get => _BodyArchetype;
            set => _BodyArchetype.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IKeywordGetter> IAnimationGetter.BodyArchetype => this.BodyArchetype;
        #endregion
        #region FaceArchetype
        private readonly IFormLinkNullable<IKeywordGetter> _FaceArchetype = new FormLinkNullable<IKeywordGetter>();
        public IFormLinkNullable<IKeywordGetter> FaceArchetype
        {
            get => _FaceArchetype;
            set => _FaceArchetype.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IKeywordGetter> IAnimationGetter.FaceArchetype => this.FaceArchetype;
        #endregion
        #region Flavor
        private readonly IFormLinkNullable<IKeywordGetter> _Flavor = new FormLinkNullable<IKeywordGetter>();
        public IFormLinkNullable<IKeywordGetter> Flavor
        {
            get => _Flavor;
            set => _Flavor.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IKeywordGetter> IAnimationGetter.Flavor => this.Flavor;
        #endregion
        #region UseDialogueAnimation
        public Boolean UseDialogueAnimation { get; set; } = default(Boolean);
        #endregion
        #region UseAnimationBodyArchetype
        public Boolean UseAnimationBodyArchetype { get; set; } = default(Boolean);
        #endregion
        #region HasAnimationFaceArchetype
        public Boolean HasAnimationFaceArchetype { get; set; } = default(Boolean);
        #endregion
        #region AnimationCompleteEndsPhase
        public Boolean AnimationCompleteEndsPhase { get; set; } = default(Boolean);
        #endregion
        #region AnimationOnlyMovement
        public Boolean AnimationOnlyMovement { get; set; } = default(Boolean);
        #endregion
        #region UseFlavorAnimation
        public Boolean UseFlavorAnimation { get; set; } = default(Boolean);
        #endregion
        #region DelayStartTimeAction
        public Single? DelayStartTimeAction { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? IAnimationGetter.DelayStartTimeAction => this.DelayStartTimeAction;
        #endregion
        #region Conditions
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private ExtendedList<Condition> _Conditions = new ExtendedList<Condition>();
        public ExtendedList<Condition> Conditions
        {
            get => this._Conditions;
            init => this._Conditions = value;
        }
        #region Interface Members
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IReadOnlyList<IConditionGetter> IAnimationGetter.Conditions => _Conditions;
        #endregion

        #endregion
        #region Action
        private readonly IFormLinkNullable<IActionRecordGetter> _Action = new FormLinkNullable<IActionRecordGetter>();
        public IFormLinkNullable<IActionRecordGetter> Action
        {
            get => _Action;
            set => _Action.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IActionRecordGetter> IAnimationGetter.Action => this.Action;
        #endregion
        #region UseActorAnimationAction
        public Boolean UseActorAnimationAction { get; set; } = default(Boolean);
        #endregion
        #region AnimationHoldEvent
        public Boolean AnimationHoldEvent { get; set; } = default(Boolean);
        #endregion
        #region DTGT
        public Int32? DTGT { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Int32? IAnimationGetter.DTGT => this.DTGT;
        #endregion
        #region ACEP
        public Boolean ACEP { get; set; } = default(Boolean);
        #endregion

        #region To String

        public void Print(
            StructuredStringBuilder sb,
            string? name = null)
        {
            AnimationMixIn.Print(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is not IAnimationGetter rhs) return false;
            return ((AnimationCommon)((IAnimationGetter)this).CommonInstance()!).Equals(this, rhs, equalsMask: null);
        }

        public bool Equals(IAnimationGetter? obj)
        {
            return ((AnimationCommon)((IAnimationGetter)this).CommonInstance()!).Equals(this, obj, equalsMask: null);
        }

        public override int GetHashCode() => ((AnimationCommon)((IAnimationGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        #region Mask
        public class Mask<TItem> :
            IEquatable<Mask<TItem>>,
            IMask<TItem>
        {
            #region Ctors
            public Mask(TItem initialValue)
            {
                this.NpcAnimation = initialValue;
                this.Subgraph = initialValue;
                this.BodyArchetype = initialValue;
                this.FaceArchetype = initialValue;
                this.Flavor = initialValue;
                this.UseDialogueAnimation = initialValue;
                this.UseAnimationBodyArchetype = initialValue;
                this.HasAnimationFaceArchetype = initialValue;
                this.AnimationCompleteEndsPhase = initialValue;
                this.AnimationOnlyMovement = initialValue;
                this.UseFlavorAnimation = initialValue;
                this.DelayStartTimeAction = initialValue;
                this.Conditions = new MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, Condition.Mask<TItem>?>>?>(initialValue, Enumerable.Empty<MaskItemIndexed<TItem, Condition.Mask<TItem>?>>());
                this.Action = initialValue;
                this.UseActorAnimationAction = initialValue;
                this.AnimationHoldEvent = initialValue;
                this.DTGT = initialValue;
                this.ACEP = initialValue;
            }

            public Mask(
                TItem NpcAnimation,
                TItem Subgraph,
                TItem BodyArchetype,
                TItem FaceArchetype,
                TItem Flavor,
                TItem UseDialogueAnimation,
                TItem UseAnimationBodyArchetype,
                TItem HasAnimationFaceArchetype,
                TItem AnimationCompleteEndsPhase,
                TItem AnimationOnlyMovement,
                TItem UseFlavorAnimation,
                TItem DelayStartTimeAction,
                TItem Conditions,
                TItem Action,
                TItem UseActorAnimationAction,
                TItem AnimationHoldEvent,
                TItem DTGT,
                TItem ACEP)
            {
                this.NpcAnimation = NpcAnimation;
                this.Subgraph = Subgraph;
                this.BodyArchetype = BodyArchetype;
                this.FaceArchetype = FaceArchetype;
                this.Flavor = Flavor;
                this.UseDialogueAnimation = UseDialogueAnimation;
                this.UseAnimationBodyArchetype = UseAnimationBodyArchetype;
                this.HasAnimationFaceArchetype = HasAnimationFaceArchetype;
                this.AnimationCompleteEndsPhase = AnimationCompleteEndsPhase;
                this.AnimationOnlyMovement = AnimationOnlyMovement;
                this.UseFlavorAnimation = UseFlavorAnimation;
                this.DelayStartTimeAction = DelayStartTimeAction;
                this.Conditions = new MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, Condition.Mask<TItem>?>>?>(Conditions, Enumerable.Empty<MaskItemIndexed<TItem, Condition.Mask<TItem>?>>());
                this.Action = Action;
                this.UseActorAnimationAction = UseActorAnimationAction;
                this.AnimationHoldEvent = AnimationHoldEvent;
                this.DTGT = DTGT;
                this.ACEP = ACEP;
            }

            #pragma warning disable CS8618
            protected Mask()
            {
            }
            #pragma warning restore CS8618

            #endregion

            #region Members
            public TItem NpcAnimation;
            public TItem Subgraph;
            public TItem BodyArchetype;
            public TItem FaceArchetype;
            public TItem Flavor;
            public TItem UseDialogueAnimation;
            public TItem UseAnimationBodyArchetype;
            public TItem HasAnimationFaceArchetype;
            public TItem AnimationCompleteEndsPhase;
            public TItem AnimationOnlyMovement;
            public TItem UseFlavorAnimation;
            public TItem DelayStartTimeAction;
            public MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, Condition.Mask<TItem>?>>?>? Conditions;
            public TItem Action;
            public TItem UseActorAnimationAction;
            public TItem AnimationHoldEvent;
            public TItem DTGT;
            public TItem ACEP;
            #endregion

            #region Equals
            public override bool Equals(object? obj)
            {
                if (!(obj is Mask<TItem> rhs)) return false;
                return Equals(rhs);
            }

            public bool Equals(Mask<TItem>? rhs)
            {
                if (rhs == null) return false;
                if (!object.Equals(this.NpcAnimation, rhs.NpcAnimation)) return false;
                if (!object.Equals(this.Subgraph, rhs.Subgraph)) return false;
                if (!object.Equals(this.BodyArchetype, rhs.BodyArchetype)) return false;
                if (!object.Equals(this.FaceArchetype, rhs.FaceArchetype)) return false;
                if (!object.Equals(this.Flavor, rhs.Flavor)) return false;
                if (!object.Equals(this.UseDialogueAnimation, rhs.UseDialogueAnimation)) return false;
                if (!object.Equals(this.UseAnimationBodyArchetype, rhs.UseAnimationBodyArchetype)) return false;
                if (!object.Equals(this.HasAnimationFaceArchetype, rhs.HasAnimationFaceArchetype)) return false;
                if (!object.Equals(this.AnimationCompleteEndsPhase, rhs.AnimationCompleteEndsPhase)) return false;
                if (!object.Equals(this.AnimationOnlyMovement, rhs.AnimationOnlyMovement)) return false;
                if (!object.Equals(this.UseFlavorAnimation, rhs.UseFlavorAnimation)) return false;
                if (!object.Equals(this.DelayStartTimeAction, rhs.DelayStartTimeAction)) return false;
                if (!object.Equals(this.Conditions, rhs.Conditions)) return false;
                if (!object.Equals(this.Action, rhs.Action)) return false;
                if (!object.Equals(this.UseActorAnimationAction, rhs.UseActorAnimationAction)) return false;
                if (!object.Equals(this.AnimationHoldEvent, rhs.AnimationHoldEvent)) return false;
                if (!object.Equals(this.DTGT, rhs.DTGT)) return false;
                if (!object.Equals(this.ACEP, rhs.ACEP)) return false;
                return true;
            }
            public override int GetHashCode()
            {
                var hash = new HashCode();
                hash.Add(this.NpcAnimation);
                hash.Add(this.Subgraph);
                hash.Add(this.BodyArchetype);
                hash.Add(this.FaceArchetype);
                hash.Add(this.Flavor);
                hash.Add(this.UseDialogueAnimation);
                hash.Add(this.UseAnimationBodyArchetype);
                hash.Add(this.HasAnimationFaceArchetype);
                hash.Add(this.AnimationCompleteEndsPhase);
                hash.Add(this.AnimationOnlyMovement);
                hash.Add(this.UseFlavorAnimation);
                hash.Add(this.DelayStartTimeAction);
                hash.Add(this.Conditions);
                hash.Add(this.Action);
                hash.Add(this.UseActorAnimationAction);
                hash.Add(this.AnimationHoldEvent);
                hash.Add(this.DTGT);
                hash.Add(this.ACEP);
                return hash.ToHashCode();
            }

            #endregion

            #region All
            public bool All(Func<TItem, bool> eval)
            {
                if (!eval(this.NpcAnimation)) return false;
                if (!eval(this.Subgraph)) return false;
                if (!eval(this.BodyArchetype)) return false;
                if (!eval(this.FaceArchetype)) return false;
                if (!eval(this.Flavor)) return false;
                if (!eval(this.UseDialogueAnimation)) return false;
                if (!eval(this.UseAnimationBodyArchetype)) return false;
                if (!eval(this.HasAnimationFaceArchetype)) return false;
                if (!eval(this.AnimationCompleteEndsPhase)) return false;
                if (!eval(this.AnimationOnlyMovement)) return false;
                if (!eval(this.UseFlavorAnimation)) return false;
                if (!eval(this.DelayStartTimeAction)) return false;
                if (this.Conditions != null)
                {
                    if (!eval(this.Conditions.Overall)) return false;
                    if (this.Conditions.Specific != null)
                    {
                        foreach (var item in this.Conditions.Specific)
                        {
                            if (!eval(item.Overall)) return false;
                            if (item.Specific != null && !item.Specific.All(eval)) return false;
                        }
                    }
                }
                if (!eval(this.Action)) return false;
                if (!eval(this.UseActorAnimationAction)) return false;
                if (!eval(this.AnimationHoldEvent)) return false;
                if (!eval(this.DTGT)) return false;
                if (!eval(this.ACEP)) return false;
                return true;
            }
            #endregion

            #region Any
            public bool Any(Func<TItem, bool> eval)
            {
                if (eval(this.NpcAnimation)) return true;
                if (eval(this.Subgraph)) return true;
                if (eval(this.BodyArchetype)) return true;
                if (eval(this.FaceArchetype)) return true;
                if (eval(this.Flavor)) return true;
                if (eval(this.UseDialogueAnimation)) return true;
                if (eval(this.UseAnimationBodyArchetype)) return true;
                if (eval(this.HasAnimationFaceArchetype)) return true;
                if (eval(this.AnimationCompleteEndsPhase)) return true;
                if (eval(this.AnimationOnlyMovement)) return true;
                if (eval(this.UseFlavorAnimation)) return true;
                if (eval(this.DelayStartTimeAction)) return true;
                if (this.Conditions != null)
                {
                    if (eval(this.Conditions.Overall)) return true;
                    if (this.Conditions.Specific != null)
                    {
                        foreach (var item in this.Conditions.Specific)
                        {
                            if (!eval(item.Overall)) return false;
                            if (item.Specific != null && !item.Specific.All(eval)) return false;
                        }
                    }
                }
                if (eval(this.Action)) return true;
                if (eval(this.UseActorAnimationAction)) return true;
                if (eval(this.AnimationHoldEvent)) return true;
                if (eval(this.DTGT)) return true;
                if (eval(this.ACEP)) return true;
                return false;
            }
            #endregion

            #region Translate
            public Mask<R> Translate<R>(Func<TItem, R> eval)
            {
                var ret = new Animation.Mask<R>();
                this.Translate_InternalFill(ret, eval);
                return ret;
            }

            protected void Translate_InternalFill<R>(Mask<R> obj, Func<TItem, R> eval)
            {
                obj.NpcAnimation = eval(this.NpcAnimation);
                obj.Subgraph = eval(this.Subgraph);
                obj.BodyArchetype = eval(this.BodyArchetype);
                obj.FaceArchetype = eval(this.FaceArchetype);
                obj.Flavor = eval(this.Flavor);
                obj.UseDialogueAnimation = eval(this.UseDialogueAnimation);
                obj.UseAnimationBodyArchetype = eval(this.UseAnimationBodyArchetype);
                obj.HasAnimationFaceArchetype = eval(this.HasAnimationFaceArchetype);
                obj.AnimationCompleteEndsPhase = eval(this.AnimationCompleteEndsPhase);
                obj.AnimationOnlyMovement = eval(this.AnimationOnlyMovement);
                obj.UseFlavorAnimation = eval(this.UseFlavorAnimation);
                obj.DelayStartTimeAction = eval(this.DelayStartTimeAction);
                if (Conditions != null)
                {
                    obj.Conditions = new MaskItem<R, IEnumerable<MaskItemIndexed<R, Condition.Mask<R>?>>?>(eval(this.Conditions.Overall), Enumerable.Empty<MaskItemIndexed<R, Condition.Mask<R>?>>());
                    if (Conditions.Specific != null)
                    {
                        var l = new List<MaskItemIndexed<R, Condition.Mask<R>?>>();
                        obj.Conditions.Specific = l;
                        foreach (var item in Conditions.Specific)
                        {
                            MaskItemIndexed<R, Condition.Mask<R>?>? mask = item == null ? null : new MaskItemIndexed<R, Condition.Mask<R>?>(item.Index, eval(item.Overall), item.Specific?.Translate(eval));
                            if (mask == null) continue;
                            l.Add(mask);
                        }
                    }
                }
                obj.Action = eval(this.Action);
                obj.UseActorAnimationAction = eval(this.UseActorAnimationAction);
                obj.AnimationHoldEvent = eval(this.AnimationHoldEvent);
                obj.DTGT = eval(this.DTGT);
                obj.ACEP = eval(this.ACEP);
            }
            #endregion

            #region To String
            public override string ToString() => this.Print();

            public string Print(Animation.Mask<bool>? printMask = null)
            {
                var sb = new StructuredStringBuilder();
                Print(sb, printMask);
                return sb.ToString();
            }

            public void Print(StructuredStringBuilder sb, Animation.Mask<bool>? printMask = null)
            {
                sb.AppendLine($"{nameof(Animation.Mask<TItem>)} =>");
                using (sb.Brace())
                {
                    if (printMask?.NpcAnimation ?? true)
                    {
                        sb.AppendItem(NpcAnimation, "NpcAnimation");
                    }
                    if (printMask?.Subgraph ?? true)
                    {
                        sb.AppendItem(Subgraph, "Subgraph");
                    }
                    if (printMask?.BodyArchetype ?? true)
                    {
                        sb.AppendItem(BodyArchetype, "BodyArchetype");
                    }
                    if (printMask?.FaceArchetype ?? true)
                    {
                        sb.AppendItem(FaceArchetype, "FaceArchetype");
                    }
                    if (printMask?.Flavor ?? true)
                    {
                        sb.AppendItem(Flavor, "Flavor");
                    }
                    if (printMask?.UseDialogueAnimation ?? true)
                    {
                        sb.AppendItem(UseDialogueAnimation, "UseDialogueAnimation");
                    }
                    if (printMask?.UseAnimationBodyArchetype ?? true)
                    {
                        sb.AppendItem(UseAnimationBodyArchetype, "UseAnimationBodyArchetype");
                    }
                    if (printMask?.HasAnimationFaceArchetype ?? true)
                    {
                        sb.AppendItem(HasAnimationFaceArchetype, "HasAnimationFaceArchetype");
                    }
                    if (printMask?.AnimationCompleteEndsPhase ?? true)
                    {
                        sb.AppendItem(AnimationCompleteEndsPhase, "AnimationCompleteEndsPhase");
                    }
                    if (printMask?.AnimationOnlyMovement ?? true)
                    {
                        sb.AppendItem(AnimationOnlyMovement, "AnimationOnlyMovement");
                    }
                    if (printMask?.UseFlavorAnimation ?? true)
                    {
                        sb.AppendItem(UseFlavorAnimation, "UseFlavorAnimation");
                    }
                    if (printMask?.DelayStartTimeAction ?? true)
                    {
                        sb.AppendItem(DelayStartTimeAction, "DelayStartTimeAction");
                    }
                    if ((printMask?.Conditions?.Overall ?? true)
                        && Conditions is {} ConditionsItem)
                    {
                        sb.AppendLine("Conditions =>");
                        using (sb.Brace())
                        {
                            sb.AppendItem(ConditionsItem.Overall);
                            if (ConditionsItem.Specific != null)
                            {
                                foreach (var subItem in ConditionsItem.Specific)
                                {
                                    using (sb.Brace())
                                    {
                                        subItem?.Print(sb);
                                    }
                                }
                            }
                        }
                    }
                    if (printMask?.Action ?? true)
                    {
                        sb.AppendItem(Action, "Action");
                    }
                    if (printMask?.UseActorAnimationAction ?? true)
                    {
                        sb.AppendItem(UseActorAnimationAction, "UseActorAnimationAction");
                    }
                    if (printMask?.AnimationHoldEvent ?? true)
                    {
                        sb.AppendItem(AnimationHoldEvent, "AnimationHoldEvent");
                    }
                    if (printMask?.DTGT ?? true)
                    {
                        sb.AppendItem(DTGT, "DTGT");
                    }
                    if (printMask?.ACEP ?? true)
                    {
                        sb.AppendItem(ACEP, "ACEP");
                    }
                }
            }
            #endregion

        }

        public class ErrorMask :
            IErrorMask,
            IErrorMask<ErrorMask>
        {
            #region Members
            public Exception? Overall { get; set; }
            private List<string>? _warnings;
            public List<string> Warnings
            {
                get
                {
                    if (_warnings == null)
                    {
                        _warnings = new List<string>();
                    }
                    return _warnings;
                }
            }
            public Exception? NpcAnimation;
            public Exception? Subgraph;
            public Exception? BodyArchetype;
            public Exception? FaceArchetype;
            public Exception? Flavor;
            public Exception? UseDialogueAnimation;
            public Exception? UseAnimationBodyArchetype;
            public Exception? HasAnimationFaceArchetype;
            public Exception? AnimationCompleteEndsPhase;
            public Exception? AnimationOnlyMovement;
            public Exception? UseFlavorAnimation;
            public Exception? DelayStartTimeAction;
            public MaskItem<Exception?, IEnumerable<MaskItem<Exception?, Condition.ErrorMask?>>?>? Conditions;
            public Exception? Action;
            public Exception? UseActorAnimationAction;
            public Exception? AnimationHoldEvent;
            public Exception? DTGT;
            public Exception? ACEP;
            #endregion

            #region IErrorMask
            public object? GetNthMask(int index)
            {
                Animation_FieldIndex enu = (Animation_FieldIndex)index;
                switch (enu)
                {
                    case Animation_FieldIndex.NpcAnimation:
                        return NpcAnimation;
                    case Animation_FieldIndex.Subgraph:
                        return Subgraph;
                    case Animation_FieldIndex.BodyArchetype:
                        return BodyArchetype;
                    case Animation_FieldIndex.FaceArchetype:
                        return FaceArchetype;
                    case Animation_FieldIndex.Flavor:
                        return Flavor;
                    case Animation_FieldIndex.UseDialogueAnimation:
                        return UseDialogueAnimation;
                    case Animation_FieldIndex.UseAnimationBodyArchetype:
                        return UseAnimationBodyArchetype;
                    case Animation_FieldIndex.HasAnimationFaceArchetype:
                        return HasAnimationFaceArchetype;
                    case Animation_FieldIndex.AnimationCompleteEndsPhase:
                        return AnimationCompleteEndsPhase;
                    case Animation_FieldIndex.AnimationOnlyMovement:
                        return AnimationOnlyMovement;
                    case Animation_FieldIndex.UseFlavorAnimation:
                        return UseFlavorAnimation;
                    case Animation_FieldIndex.DelayStartTimeAction:
                        return DelayStartTimeAction;
                    case Animation_FieldIndex.Conditions:
                        return Conditions;
                    case Animation_FieldIndex.Action:
                        return Action;
                    case Animation_FieldIndex.UseActorAnimationAction:
                        return UseActorAnimationAction;
                    case Animation_FieldIndex.AnimationHoldEvent:
                        return AnimationHoldEvent;
                    case Animation_FieldIndex.DTGT:
                        return DTGT;
                    case Animation_FieldIndex.ACEP:
                        return ACEP;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthException(int index, Exception ex)
            {
                Animation_FieldIndex enu = (Animation_FieldIndex)index;
                switch (enu)
                {
                    case Animation_FieldIndex.NpcAnimation:
                        this.NpcAnimation = ex;
                        break;
                    case Animation_FieldIndex.Subgraph:
                        this.Subgraph = ex;
                        break;
                    case Animation_FieldIndex.BodyArchetype:
                        this.BodyArchetype = ex;
                        break;
                    case Animation_FieldIndex.FaceArchetype:
                        this.FaceArchetype = ex;
                        break;
                    case Animation_FieldIndex.Flavor:
                        this.Flavor = ex;
                        break;
                    case Animation_FieldIndex.UseDialogueAnimation:
                        this.UseDialogueAnimation = ex;
                        break;
                    case Animation_FieldIndex.UseAnimationBodyArchetype:
                        this.UseAnimationBodyArchetype = ex;
                        break;
                    case Animation_FieldIndex.HasAnimationFaceArchetype:
                        this.HasAnimationFaceArchetype = ex;
                        break;
                    case Animation_FieldIndex.AnimationCompleteEndsPhase:
                        this.AnimationCompleteEndsPhase = ex;
                        break;
                    case Animation_FieldIndex.AnimationOnlyMovement:
                        this.AnimationOnlyMovement = ex;
                        break;
                    case Animation_FieldIndex.UseFlavorAnimation:
                        this.UseFlavorAnimation = ex;
                        break;
                    case Animation_FieldIndex.DelayStartTimeAction:
                        this.DelayStartTimeAction = ex;
                        break;
                    case Animation_FieldIndex.Conditions:
                        this.Conditions = new MaskItem<Exception?, IEnumerable<MaskItem<Exception?, Condition.ErrorMask?>>?>(ex, null);
                        break;
                    case Animation_FieldIndex.Action:
                        this.Action = ex;
                        break;
                    case Animation_FieldIndex.UseActorAnimationAction:
                        this.UseActorAnimationAction = ex;
                        break;
                    case Animation_FieldIndex.AnimationHoldEvent:
                        this.AnimationHoldEvent = ex;
                        break;
                    case Animation_FieldIndex.DTGT:
                        this.DTGT = ex;
                        break;
                    case Animation_FieldIndex.ACEP:
                        this.ACEP = ex;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthMask(int index, object obj)
            {
                Animation_FieldIndex enu = (Animation_FieldIndex)index;
                switch (enu)
                {
                    case Animation_FieldIndex.NpcAnimation:
                        this.NpcAnimation = (Exception?)obj;
                        break;
                    case Animation_FieldIndex.Subgraph:
                        this.Subgraph = (Exception?)obj;
                        break;
                    case Animation_FieldIndex.BodyArchetype:
                        this.BodyArchetype = (Exception?)obj;
                        break;
                    case Animation_FieldIndex.FaceArchetype:
                        this.FaceArchetype = (Exception?)obj;
                        break;
                    case Animation_FieldIndex.Flavor:
                        this.Flavor = (Exception?)obj;
                        break;
                    case Animation_FieldIndex.UseDialogueAnimation:
                        this.UseDialogueAnimation = (Exception?)obj;
                        break;
                    case Animation_FieldIndex.UseAnimationBodyArchetype:
                        this.UseAnimationBodyArchetype = (Exception?)obj;
                        break;
                    case Animation_FieldIndex.HasAnimationFaceArchetype:
                        this.HasAnimationFaceArchetype = (Exception?)obj;
                        break;
                    case Animation_FieldIndex.AnimationCompleteEndsPhase:
                        this.AnimationCompleteEndsPhase = (Exception?)obj;
                        break;
                    case Animation_FieldIndex.AnimationOnlyMovement:
                        this.AnimationOnlyMovement = (Exception?)obj;
                        break;
                    case Animation_FieldIndex.UseFlavorAnimation:
                        this.UseFlavorAnimation = (Exception?)obj;
                        break;
                    case Animation_FieldIndex.DelayStartTimeAction:
                        this.DelayStartTimeAction = (Exception?)obj;
                        break;
                    case Animation_FieldIndex.Conditions:
                        this.Conditions = (MaskItem<Exception?, IEnumerable<MaskItem<Exception?, Condition.ErrorMask?>>?>)obj;
                        break;
                    case Animation_FieldIndex.Action:
                        this.Action = (Exception?)obj;
                        break;
                    case Animation_FieldIndex.UseActorAnimationAction:
                        this.UseActorAnimationAction = (Exception?)obj;
                        break;
                    case Animation_FieldIndex.AnimationHoldEvent:
                        this.AnimationHoldEvent = (Exception?)obj;
                        break;
                    case Animation_FieldIndex.DTGT:
                        this.DTGT = (Exception?)obj;
                        break;
                    case Animation_FieldIndex.ACEP:
                        this.ACEP = (Exception?)obj;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public bool IsInError()
            {
                if (Overall != null) return true;
                if (NpcAnimation != null) return true;
                if (Subgraph != null) return true;
                if (BodyArchetype != null) return true;
                if (FaceArchetype != null) return true;
                if (Flavor != null) return true;
                if (UseDialogueAnimation != null) return true;
                if (UseAnimationBodyArchetype != null) return true;
                if (HasAnimationFaceArchetype != null) return true;
                if (AnimationCompleteEndsPhase != null) return true;
                if (AnimationOnlyMovement != null) return true;
                if (UseFlavorAnimation != null) return true;
                if (DelayStartTimeAction != null) return true;
                if (Conditions != null) return true;
                if (Action != null) return true;
                if (UseActorAnimationAction != null) return true;
                if (AnimationHoldEvent != null) return true;
                if (DTGT != null) return true;
                if (ACEP != null) return true;
                return false;
            }
            #endregion

            #region To String
            public override string ToString() => this.Print();

            public void Print(StructuredStringBuilder sb, string? name = null)
            {
                sb.AppendLine($"{(name ?? "ErrorMask")} =>");
                using (sb.Brace())
                {
                    if (this.Overall != null)
                    {
                        sb.AppendLine("Overall =>");
                        using (sb.Brace())
                        {
                            sb.AppendLine($"{this.Overall}");
                        }
                    }
                    PrintFillInternal(sb);
                }
            }
            protected void PrintFillInternal(StructuredStringBuilder sb)
            {
                {
                    sb.AppendItem(NpcAnimation, "NpcAnimation");
                }
                {
                    sb.AppendItem(Subgraph, "Subgraph");
                }
                {
                    sb.AppendItem(BodyArchetype, "BodyArchetype");
                }
                {
                    sb.AppendItem(FaceArchetype, "FaceArchetype");
                }
                {
                    sb.AppendItem(Flavor, "Flavor");
                }
                {
                    sb.AppendItem(UseDialogueAnimation, "UseDialogueAnimation");
                }
                {
                    sb.AppendItem(UseAnimationBodyArchetype, "UseAnimationBodyArchetype");
                }
                {
                    sb.AppendItem(HasAnimationFaceArchetype, "HasAnimationFaceArchetype");
                }
                {
                    sb.AppendItem(AnimationCompleteEndsPhase, "AnimationCompleteEndsPhase");
                }
                {
                    sb.AppendItem(AnimationOnlyMovement, "AnimationOnlyMovement");
                }
                {
                    sb.AppendItem(UseFlavorAnimation, "UseFlavorAnimation");
                }
                {
                    sb.AppendItem(DelayStartTimeAction, "DelayStartTimeAction");
                }
                if (Conditions is {} ConditionsItem)
                {
                    sb.AppendLine("Conditions =>");
                    using (sb.Brace())
                    {
                        sb.AppendItem(ConditionsItem.Overall);
                        if (ConditionsItem.Specific != null)
                        {
                            foreach (var subItem in ConditionsItem.Specific)
                            {
                                using (sb.Brace())
                                {
                                    subItem?.Print(sb);
                                }
                            }
                        }
                    }
                }
                {
                    sb.AppendItem(Action, "Action");
                }
                {
                    sb.AppendItem(UseActorAnimationAction, "UseActorAnimationAction");
                }
                {
                    sb.AppendItem(AnimationHoldEvent, "AnimationHoldEvent");
                }
                {
                    sb.AppendItem(DTGT, "DTGT");
                }
                {
                    sb.AppendItem(ACEP, "ACEP");
                }
            }
            #endregion

            #region Combine
            public ErrorMask Combine(ErrorMask? rhs)
            {
                if (rhs == null) return this;
                var ret = new ErrorMask();
                ret.NpcAnimation = this.NpcAnimation.Combine(rhs.NpcAnimation);
                ret.Subgraph = this.Subgraph.Combine(rhs.Subgraph);
                ret.BodyArchetype = this.BodyArchetype.Combine(rhs.BodyArchetype);
                ret.FaceArchetype = this.FaceArchetype.Combine(rhs.FaceArchetype);
                ret.Flavor = this.Flavor.Combine(rhs.Flavor);
                ret.UseDialogueAnimation = this.UseDialogueAnimation.Combine(rhs.UseDialogueAnimation);
                ret.UseAnimationBodyArchetype = this.UseAnimationBodyArchetype.Combine(rhs.UseAnimationBodyArchetype);
                ret.HasAnimationFaceArchetype = this.HasAnimationFaceArchetype.Combine(rhs.HasAnimationFaceArchetype);
                ret.AnimationCompleteEndsPhase = this.AnimationCompleteEndsPhase.Combine(rhs.AnimationCompleteEndsPhase);
                ret.AnimationOnlyMovement = this.AnimationOnlyMovement.Combine(rhs.AnimationOnlyMovement);
                ret.UseFlavorAnimation = this.UseFlavorAnimation.Combine(rhs.UseFlavorAnimation);
                ret.DelayStartTimeAction = this.DelayStartTimeAction.Combine(rhs.DelayStartTimeAction);
                ret.Conditions = new MaskItem<Exception?, IEnumerable<MaskItem<Exception?, Condition.ErrorMask?>>?>(Noggog.ExceptionExt.Combine(this.Conditions?.Overall, rhs.Conditions?.Overall), Noggog.ExceptionExt.Combine(this.Conditions?.Specific, rhs.Conditions?.Specific));
                ret.Action = this.Action.Combine(rhs.Action);
                ret.UseActorAnimationAction = this.UseActorAnimationAction.Combine(rhs.UseActorAnimationAction);
                ret.AnimationHoldEvent = this.AnimationHoldEvent.Combine(rhs.AnimationHoldEvent);
                ret.DTGT = this.DTGT.Combine(rhs.DTGT);
                ret.ACEP = this.ACEP.Combine(rhs.ACEP);
                return ret;
            }
            public static ErrorMask? Combine(ErrorMask? lhs, ErrorMask? rhs)
            {
                if (lhs != null && rhs != null) return lhs.Combine(rhs);
                return lhs ?? rhs;
            }
            #endregion

            #region Factory
            public static ErrorMask Factory(ErrorMaskBuilder errorMask)
            {
                return new ErrorMask();
            }
            #endregion

        }
        public class TranslationMask : ITranslationMask
        {
            #region Members
            private TranslationCrystal? _crystal;
            public readonly bool DefaultOn;
            public bool OnOverall;
            public bool NpcAnimation;
            public bool Subgraph;
            public bool BodyArchetype;
            public bool FaceArchetype;
            public bool Flavor;
            public bool UseDialogueAnimation;
            public bool UseAnimationBodyArchetype;
            public bool HasAnimationFaceArchetype;
            public bool AnimationCompleteEndsPhase;
            public bool AnimationOnlyMovement;
            public bool UseFlavorAnimation;
            public bool DelayStartTimeAction;
            public Condition.TranslationMask? Conditions;
            public bool Action;
            public bool UseActorAnimationAction;
            public bool AnimationHoldEvent;
            public bool DTGT;
            public bool ACEP;
            #endregion

            #region Ctors
            public TranslationMask(
                bool defaultOn,
                bool onOverall = true)
            {
                this.DefaultOn = defaultOn;
                this.OnOverall = onOverall;
                this.NpcAnimation = defaultOn;
                this.Subgraph = defaultOn;
                this.BodyArchetype = defaultOn;
                this.FaceArchetype = defaultOn;
                this.Flavor = defaultOn;
                this.UseDialogueAnimation = defaultOn;
                this.UseAnimationBodyArchetype = defaultOn;
                this.HasAnimationFaceArchetype = defaultOn;
                this.AnimationCompleteEndsPhase = defaultOn;
                this.AnimationOnlyMovement = defaultOn;
                this.UseFlavorAnimation = defaultOn;
                this.DelayStartTimeAction = defaultOn;
                this.Action = defaultOn;
                this.UseActorAnimationAction = defaultOn;
                this.AnimationHoldEvent = defaultOn;
                this.DTGT = defaultOn;
                this.ACEP = defaultOn;
            }

            #endregion

            public TranslationCrystal GetCrystal()
            {
                if (_crystal != null) return _crystal;
                var ret = new List<(bool On, TranslationCrystal? SubCrystal)>();
                GetCrystal(ret);
                _crystal = new TranslationCrystal(ret.ToArray());
                return _crystal;
            }

            protected void GetCrystal(List<(bool On, TranslationCrystal? SubCrystal)> ret)
            {
                ret.Add((NpcAnimation, null));
                ret.Add((Subgraph, null));
                ret.Add((BodyArchetype, null));
                ret.Add((FaceArchetype, null));
                ret.Add((Flavor, null));
                ret.Add((UseDialogueAnimation, null));
                ret.Add((UseAnimationBodyArchetype, null));
                ret.Add((HasAnimationFaceArchetype, null));
                ret.Add((AnimationCompleteEndsPhase, null));
                ret.Add((AnimationOnlyMovement, null));
                ret.Add((UseFlavorAnimation, null));
                ret.Add((DelayStartTimeAction, null));
                ret.Add((Conditions == null ? DefaultOn : !Conditions.GetCrystal().CopyNothing, Conditions?.GetCrystal()));
                ret.Add((Action, null));
                ret.Add((UseActorAnimationAction, null));
                ret.Add((AnimationHoldEvent, null));
                ret.Add((DTGT, null));
                ret.Add((ACEP, null));
            }

            public static implicit operator TranslationMask(bool defaultOn)
            {
                return new TranslationMask(defaultOn: defaultOn, onOverall: defaultOn);
            }

        }
        #endregion

        #region Mutagen
        public IEnumerable<IFormLinkGetter> EnumerateFormLinks() => AnimationCommon.Instance.EnumerateFormLinks(this);
        public void RemapLinks(IReadOnlyDictionary<FormKey, FormKey> mapping) => AnimationSetterCommon.Instance.RemapLinks(this, mapping);
        #endregion

        #region Binary Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => AnimationBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((AnimationBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }
        #region Binary Create
        public static Animation CreateFromBinary(
            MutagenFrame frame,
            TypedParseParams translationParams = default)
        {
            var ret = new Animation();
            ((AnimationSetterCommon)((IAnimationGetter)ret).CommonSetterInstance()!).CopyInFromBinary(
                item: ret,
                frame: frame,
                translationParams: translationParams);
            return ret;
        }

        #endregion

        public static bool TryCreateFromBinary(
            MutagenFrame frame,
            out Animation item,
            TypedParseParams translationParams = default)
        {
            var startPos = frame.Position;
            item = CreateFromBinary(
                frame: frame,
                translationParams: translationParams);
            return startPos != frame.Position;
        }
        #endregion

        void IPrintable.Print(StructuredStringBuilder sb, string? name) => this.Print(sb, name);

        void IClearable.Clear()
        {
            ((AnimationSetterCommon)((IAnimationGetter)this).CommonSetterInstance()!).Clear(this);
        }

        internal static Animation GetNew()
        {
            return new Animation();
        }

    }
    #endregion

    #region Interface
    public partial interface IAnimation :
        IAnimationGetter,
        IFormLinkContainer,
        ILoquiObjectSetter<IAnimation>
    {
        new IFormLink<IIdleAnimationGetter> NpcAnimation { get; set; }
        new String? Subgraph { get; set; }
        new IFormLinkNullable<IKeywordGetter> BodyArchetype { get; set; }
        new IFormLinkNullable<IKeywordGetter> FaceArchetype { get; set; }
        new IFormLinkNullable<IKeywordGetter> Flavor { get; set; }
        new Boolean UseDialogueAnimation { get; set; }
        new Boolean UseAnimationBodyArchetype { get; set; }
        new Boolean HasAnimationFaceArchetype { get; set; }
        new Boolean AnimationCompleteEndsPhase { get; set; }
        new Boolean AnimationOnlyMovement { get; set; }
        new Boolean UseFlavorAnimation { get; set; }
        new Single? DelayStartTimeAction { get; set; }
        new ExtendedList<Condition> Conditions { get; }
        new IFormLinkNullable<IActionRecordGetter> Action { get; set; }
        new Boolean UseActorAnimationAction { get; set; }
        new Boolean AnimationHoldEvent { get; set; }
        new Int32? DTGT { get; set; }
        new Boolean ACEP { get; set; }
    }

    public partial interface IAnimationGetter :
        ILoquiObject,
        IBinaryItem,
        IFormLinkContainerGetter,
        ILoquiObject<IAnimationGetter>
    {
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object? CommonSetterInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonSetterTranslationInstance();
        static ILoquiRegistration StaticRegistration => Animation_Registration.Instance;
        IFormLinkGetter<IIdleAnimationGetter> NpcAnimation { get; }
        String? Subgraph { get; }
        IFormLinkNullableGetter<IKeywordGetter> BodyArchetype { get; }
        IFormLinkNullableGetter<IKeywordGetter> FaceArchetype { get; }
        IFormLinkNullableGetter<IKeywordGetter> Flavor { get; }
        Boolean UseDialogueAnimation { get; }
        Boolean UseAnimationBodyArchetype { get; }
        Boolean HasAnimationFaceArchetype { get; }
        Boolean AnimationCompleteEndsPhase { get; }
        Boolean AnimationOnlyMovement { get; }
        Boolean UseFlavorAnimation { get; }
        Single? DelayStartTimeAction { get; }
        IReadOnlyList<IConditionGetter> Conditions { get; }
        IFormLinkNullableGetter<IActionRecordGetter> Action { get; }
        Boolean UseActorAnimationAction { get; }
        Boolean AnimationHoldEvent { get; }
        Int32? DTGT { get; }
        Boolean ACEP { get; }

    }

    #endregion

    #region Common MixIn
    public static partial class AnimationMixIn
    {
        public static void Clear(this IAnimation item)
        {
            ((AnimationSetterCommon)((IAnimationGetter)item).CommonSetterInstance()!).Clear(item: item);
        }

        public static Animation.Mask<bool> GetEqualsMask(
            this IAnimationGetter item,
            IAnimationGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            return ((AnimationCommon)((IAnimationGetter)item).CommonInstance()!).GetEqualsMask(
                item: item,
                rhs: rhs,
                include: include);
        }

        public static string Print(
            this IAnimationGetter item,
            string? name = null,
            Animation.Mask<bool>? printMask = null)
        {
            return ((AnimationCommon)((IAnimationGetter)item).CommonInstance()!).Print(
                item: item,
                name: name,
                printMask: printMask);
        }

        public static void Print(
            this IAnimationGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            Animation.Mask<bool>? printMask = null)
        {
            ((AnimationCommon)((IAnimationGetter)item).CommonInstance()!).Print(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
        }

        public static bool Equals(
            this IAnimationGetter item,
            IAnimationGetter rhs,
            Animation.TranslationMask? equalsMask = null)
        {
            return ((AnimationCommon)((IAnimationGetter)item).CommonInstance()!).Equals(
                lhs: item,
                rhs: rhs,
                equalsMask: equalsMask?.GetCrystal());
        }

        public static void DeepCopyIn(
            this IAnimation lhs,
            IAnimationGetter rhs)
        {
            ((AnimationSetterTranslationCommon)((IAnimationGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: default,
                deepCopy: false);
        }

        public static void DeepCopyIn(
            this IAnimation lhs,
            IAnimationGetter rhs,
            Animation.TranslationMask? copyMask = null)
        {
            ((AnimationSetterTranslationCommon)((IAnimationGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
        }

        public static void DeepCopyIn(
            this IAnimation lhs,
            IAnimationGetter rhs,
            out Animation.ErrorMask errorMask,
            Animation.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            ((AnimationSetterTranslationCommon)((IAnimationGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
            errorMask = Animation.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void DeepCopyIn(
            this IAnimation lhs,
            IAnimationGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            ((AnimationSetterTranslationCommon)((IAnimationGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: false);
        }

        public static Animation DeepCopy(
            this IAnimationGetter item,
            Animation.TranslationMask? copyMask = null)
        {
            return ((AnimationSetterTranslationCommon)((IAnimationGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask);
        }

        public static Animation DeepCopy(
            this IAnimationGetter item,
            out Animation.ErrorMask errorMask,
            Animation.TranslationMask? copyMask = null)
        {
            return ((AnimationSetterTranslationCommon)((IAnimationGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: out errorMask);
        }

        public static Animation DeepCopy(
            this IAnimationGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            return ((AnimationSetterTranslationCommon)((IAnimationGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: errorMask);
        }

        #region Binary Translation
        public static void CopyInFromBinary(
            this IAnimation item,
            MutagenFrame frame,
            TypedParseParams translationParams = default)
        {
            ((AnimationSetterCommon)((IAnimationGetter)item).CommonSetterInstance()!).CopyInFromBinary(
                item: item,
                frame: frame,
                translationParams: translationParams);
        }

        #endregion

    }
    #endregion

}

namespace Mutagen.Bethesda.Starfield
{
    #region Field Index
    internal enum Animation_FieldIndex
    {
        NpcAnimation = 0,
        Subgraph = 1,
        BodyArchetype = 2,
        FaceArchetype = 3,
        Flavor = 4,
        UseDialogueAnimation = 5,
        UseAnimationBodyArchetype = 6,
        HasAnimationFaceArchetype = 7,
        AnimationCompleteEndsPhase = 8,
        AnimationOnlyMovement = 9,
        UseFlavorAnimation = 10,
        DelayStartTimeAction = 11,
        Conditions = 12,
        Action = 13,
        UseActorAnimationAction = 14,
        AnimationHoldEvent = 15,
        DTGT = 16,
        ACEP = 17,
    }
    #endregion

    #region Registration
    internal partial class Animation_Registration : ILoquiRegistration
    {
        public static readonly Animation_Registration Instance = new Animation_Registration();

        public static ProtocolKey ProtocolKey => ProtocolDefinition_Starfield.ProtocolKey;

        public const ushort AdditionalFieldCount = 18;

        public const ushort FieldCount = 18;

        public static readonly Type MaskType = typeof(Animation.Mask<>);

        public static readonly Type ErrorMaskType = typeof(Animation.ErrorMask);

        public static readonly Type ClassType = typeof(Animation);

        public static readonly Type GetterType = typeof(IAnimationGetter);

        public static readonly Type? InternalGetterType = null;

        public static readonly Type SetterType = typeof(IAnimation);

        public static readonly Type? InternalSetterType = null;

        public const string FullName = "Mutagen.Bethesda.Starfield.Animation";

        public const string Name = "Animation";

        public const string Namespace = "Mutagen.Bethesda.Starfield";

        public const byte GenericCount = 0;

        public static readonly Type? GenericRegistrationType = null;

        public static readonly RecordType TriggeringRecordType = RecordTypes.BNAM;
        public static RecordTriggerSpecs TriggerSpecs => _recordSpecs.Value;
        private static readonly Lazy<RecordTriggerSpecs> _recordSpecs = new Lazy<RecordTriggerSpecs>(() =>
        {
            var endTriggers = RecordCollection.Factory(RecordTypes.XNAM);
            var triggers = RecordCollection.Factory(RecordTypes.BNAM);
            var all = RecordCollection.Factory(
                RecordTypes.BNAM,
                RecordTypes.XNAM,
                RecordTypes.STRV,
                RecordTypes.VCLR,
                RecordTypes.FLMV,
                RecordTypes.FLAV,
                RecordTypes.QUAL,
                RecordTypes.DOFT,
                RecordTypes.SOFT,
                RecordTypes.DPLT,
                RecordTypes.SPOR,
                RecordTypes.OCOR,
                RecordTypes.LVCR,
                RecordTypes.CTDA,
                RecordTypes.CITC,
                RecordTypes.CIS1,
                RecordTypes.CIS2,
                RecordTypes.ATAC,
                RecordTypes.SHRT,
                RecordTypes.PLRL,
                RecordTypes.DTGT,
                RecordTypes.ACEP);
            return new RecordTriggerSpecs(
                allRecordTypes: all,
                triggeringRecordTypes: triggers,
                endRecordTypes: endTriggers);
        });
        public static readonly Type BinaryWriteTranslation = typeof(AnimationBinaryWriteTranslation);
        #region Interface
        ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;
        ushort ILoquiRegistration.FieldCount => FieldCount;
        ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;
        Type ILoquiRegistration.MaskType => MaskType;
        Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;
        Type ILoquiRegistration.ClassType => ClassType;
        Type ILoquiRegistration.SetterType => SetterType;
        Type? ILoquiRegistration.InternalSetterType => InternalSetterType;
        Type ILoquiRegistration.GetterType => GetterType;
        Type? ILoquiRegistration.InternalGetterType => InternalGetterType;
        string ILoquiRegistration.FullName => FullName;
        string ILoquiRegistration.Name => Name;
        string ILoquiRegistration.Namespace => Namespace;
        byte ILoquiRegistration.GenericCount => GenericCount;
        Type? ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;
        ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsLoqui(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsSingleton(ushort index) => throw new NotImplementedException();
        string ILoquiRegistration.GetNthName(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsNthDerivative(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsProtected(ushort index) => throw new NotImplementedException();
        Type ILoquiRegistration.GetNthType(ushort index) => throw new NotImplementedException();
        #endregion

    }
    #endregion

    #region Common
    internal partial class AnimationSetterCommon
    {
        public static readonly AnimationSetterCommon Instance = new AnimationSetterCommon();

        partial void ClearPartial();
        
        public void Clear(IAnimation item)
        {
            ClearPartial();
            item.NpcAnimation.Clear();
            item.Subgraph = default;
            item.BodyArchetype.Clear();
            item.FaceArchetype.Clear();
            item.Flavor.Clear();
            item.UseDialogueAnimation = default(Boolean);
            item.UseAnimationBodyArchetype = default(Boolean);
            item.HasAnimationFaceArchetype = default(Boolean);
            item.AnimationCompleteEndsPhase = default(Boolean);
            item.AnimationOnlyMovement = default(Boolean);
            item.UseFlavorAnimation = default(Boolean);
            item.DelayStartTimeAction = default;
            item.Conditions.Clear();
            item.Action.Clear();
            item.UseActorAnimationAction = default(Boolean);
            item.AnimationHoldEvent = default(Boolean);
            item.DTGT = default;
            item.ACEP = default(Boolean);
        }
        
        #region Mutagen
        public void RemapLinks(IAnimation obj, IReadOnlyDictionary<FormKey, FormKey> mapping)
        {
            obj.NpcAnimation.Relink(mapping);
            obj.BodyArchetype.Relink(mapping);
            obj.FaceArchetype.Relink(mapping);
            obj.Flavor.Relink(mapping);
            obj.Conditions.RemapLinks(mapping);
            obj.Action.Relink(mapping);
        }
        
        #endregion
        
        #region Binary Translation
        public virtual void CopyInFromBinary(
            IAnimation item,
            MutagenFrame frame,
            TypedParseParams translationParams)
        {
            PluginUtilityTranslation.SubrecordParse(
                record: item,
                frame: frame,
                translationParams: translationParams,
                fillTyped: AnimationBinaryCreateTranslation.FillBinaryRecordTypes);
        }
        
        #endregion
        
    }
    internal partial class AnimationCommon
    {
        public static readonly AnimationCommon Instance = new AnimationCommon();

        public Animation.Mask<bool> GetEqualsMask(
            IAnimationGetter item,
            IAnimationGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            var ret = new Animation.Mask<bool>(false);
            ((AnimationCommon)((IAnimationGetter)item).CommonInstance()!).FillEqualsMask(
                item: item,
                rhs: rhs,
                ret: ret,
                include: include);
            return ret;
        }
        
        public void FillEqualsMask(
            IAnimationGetter item,
            IAnimationGetter rhs,
            Animation.Mask<bool> ret,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            ret.NpcAnimation = item.NpcAnimation.Equals(rhs.NpcAnimation);
            ret.Subgraph = string.Equals(item.Subgraph, rhs.Subgraph);
            ret.BodyArchetype = item.BodyArchetype.Equals(rhs.BodyArchetype);
            ret.FaceArchetype = item.FaceArchetype.Equals(rhs.FaceArchetype);
            ret.Flavor = item.Flavor.Equals(rhs.Flavor);
            ret.UseDialogueAnimation = item.UseDialogueAnimation == rhs.UseDialogueAnimation;
            ret.UseAnimationBodyArchetype = item.UseAnimationBodyArchetype == rhs.UseAnimationBodyArchetype;
            ret.HasAnimationFaceArchetype = item.HasAnimationFaceArchetype == rhs.HasAnimationFaceArchetype;
            ret.AnimationCompleteEndsPhase = item.AnimationCompleteEndsPhase == rhs.AnimationCompleteEndsPhase;
            ret.AnimationOnlyMovement = item.AnimationOnlyMovement == rhs.AnimationOnlyMovement;
            ret.UseFlavorAnimation = item.UseFlavorAnimation == rhs.UseFlavorAnimation;
            ret.DelayStartTimeAction = item.DelayStartTimeAction.EqualsWithin(rhs.DelayStartTimeAction);
            ret.Conditions = item.Conditions.CollectionEqualsHelper(
                rhs.Conditions,
                (loqLhs, loqRhs) => loqLhs.GetEqualsMask(loqRhs, include),
                include);
            ret.Action = item.Action.Equals(rhs.Action);
            ret.UseActorAnimationAction = item.UseActorAnimationAction == rhs.UseActorAnimationAction;
            ret.AnimationHoldEvent = item.AnimationHoldEvent == rhs.AnimationHoldEvent;
            ret.DTGT = item.DTGT == rhs.DTGT;
            ret.ACEP = item.ACEP == rhs.ACEP;
        }
        
        public string Print(
            IAnimationGetter item,
            string? name = null,
            Animation.Mask<bool>? printMask = null)
        {
            var sb = new StructuredStringBuilder();
            Print(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
            return sb.ToString();
        }
        
        public void Print(
            IAnimationGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            Animation.Mask<bool>? printMask = null)
        {
            if (name == null)
            {
                sb.AppendLine($"Animation =>");
            }
            else
            {
                sb.AppendLine($"{name} (Animation) =>");
            }
            using (sb.Brace())
            {
                ToStringFields(
                    item: item,
                    sb: sb,
                    printMask: printMask);
            }
        }
        
        protected static void ToStringFields(
            IAnimationGetter item,
            StructuredStringBuilder sb,
            Animation.Mask<bool>? printMask = null)
        {
            if (printMask?.NpcAnimation ?? true)
            {
                sb.AppendItem(item.NpcAnimation.FormKey, "NpcAnimation");
            }
            if ((printMask?.Subgraph ?? true)
                && item.Subgraph is {} SubgraphItem)
            {
                sb.AppendItem(SubgraphItem, "Subgraph");
            }
            if (printMask?.BodyArchetype ?? true)
            {
                sb.AppendItem(item.BodyArchetype.FormKeyNullable, "BodyArchetype");
            }
            if (printMask?.FaceArchetype ?? true)
            {
                sb.AppendItem(item.FaceArchetype.FormKeyNullable, "FaceArchetype");
            }
            if (printMask?.Flavor ?? true)
            {
                sb.AppendItem(item.Flavor.FormKeyNullable, "Flavor");
            }
            if (printMask?.UseDialogueAnimation ?? true)
            {
                sb.AppendItem(item.UseDialogueAnimation, "UseDialogueAnimation");
            }
            if (printMask?.UseAnimationBodyArchetype ?? true)
            {
                sb.AppendItem(item.UseAnimationBodyArchetype, "UseAnimationBodyArchetype");
            }
            if (printMask?.HasAnimationFaceArchetype ?? true)
            {
                sb.AppendItem(item.HasAnimationFaceArchetype, "HasAnimationFaceArchetype");
            }
            if (printMask?.AnimationCompleteEndsPhase ?? true)
            {
                sb.AppendItem(item.AnimationCompleteEndsPhase, "AnimationCompleteEndsPhase");
            }
            if (printMask?.AnimationOnlyMovement ?? true)
            {
                sb.AppendItem(item.AnimationOnlyMovement, "AnimationOnlyMovement");
            }
            if (printMask?.UseFlavorAnimation ?? true)
            {
                sb.AppendItem(item.UseFlavorAnimation, "UseFlavorAnimation");
            }
            if ((printMask?.DelayStartTimeAction ?? true)
                && item.DelayStartTimeAction is {} DelayStartTimeActionItem)
            {
                sb.AppendItem(DelayStartTimeActionItem, "DelayStartTimeAction");
            }
            if (printMask?.Conditions?.Overall ?? true)
            {
                sb.AppendLine("Conditions =>");
                using (sb.Brace())
                {
                    foreach (var subItem in item.Conditions)
                    {
                        using (sb.Brace())
                        {
                            subItem?.Print(sb, "Item");
                        }
                    }
                }
            }
            if (printMask?.Action ?? true)
            {
                sb.AppendItem(item.Action.FormKeyNullable, "Action");
            }
            if (printMask?.UseActorAnimationAction ?? true)
            {
                sb.AppendItem(item.UseActorAnimationAction, "UseActorAnimationAction");
            }
            if (printMask?.AnimationHoldEvent ?? true)
            {
                sb.AppendItem(item.AnimationHoldEvent, "AnimationHoldEvent");
            }
            if ((printMask?.DTGT ?? true)
                && item.DTGT is {} DTGTItem)
            {
                sb.AppendItem(DTGTItem, "DTGT");
            }
            if (printMask?.ACEP ?? true)
            {
                sb.AppendItem(item.ACEP, "ACEP");
            }
        }
        
        #region Equals and Hash
        public virtual bool Equals(
            IAnimationGetter? lhs,
            IAnimationGetter? rhs,
            TranslationCrystal? equalsMask)
        {
            if (!EqualsMaskHelper.RefEquality(lhs, rhs, out var isEqual)) return isEqual;
            if ((equalsMask?.GetShouldTranslate((int)Animation_FieldIndex.NpcAnimation) ?? true))
            {
                if (!lhs.NpcAnimation.Equals(rhs.NpcAnimation)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Animation_FieldIndex.Subgraph) ?? true))
            {
                if (!string.Equals(lhs.Subgraph, rhs.Subgraph)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Animation_FieldIndex.BodyArchetype) ?? true))
            {
                if (!lhs.BodyArchetype.Equals(rhs.BodyArchetype)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Animation_FieldIndex.FaceArchetype) ?? true))
            {
                if (!lhs.FaceArchetype.Equals(rhs.FaceArchetype)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Animation_FieldIndex.Flavor) ?? true))
            {
                if (!lhs.Flavor.Equals(rhs.Flavor)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Animation_FieldIndex.UseDialogueAnimation) ?? true))
            {
                if (lhs.UseDialogueAnimation != rhs.UseDialogueAnimation) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Animation_FieldIndex.UseAnimationBodyArchetype) ?? true))
            {
                if (lhs.UseAnimationBodyArchetype != rhs.UseAnimationBodyArchetype) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Animation_FieldIndex.HasAnimationFaceArchetype) ?? true))
            {
                if (lhs.HasAnimationFaceArchetype != rhs.HasAnimationFaceArchetype) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Animation_FieldIndex.AnimationCompleteEndsPhase) ?? true))
            {
                if (lhs.AnimationCompleteEndsPhase != rhs.AnimationCompleteEndsPhase) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Animation_FieldIndex.AnimationOnlyMovement) ?? true))
            {
                if (lhs.AnimationOnlyMovement != rhs.AnimationOnlyMovement) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Animation_FieldIndex.UseFlavorAnimation) ?? true))
            {
                if (lhs.UseFlavorAnimation != rhs.UseFlavorAnimation) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Animation_FieldIndex.DelayStartTimeAction) ?? true))
            {
                if (!lhs.DelayStartTimeAction.EqualsWithin(rhs.DelayStartTimeAction)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Animation_FieldIndex.Conditions) ?? true))
            {
                if (!lhs.Conditions.SequenceEqual(rhs.Conditions, (l, r) => ((ConditionCommon)((IConditionGetter)l).CommonInstance()!).Equals(l, r, equalsMask?.GetSubCrystal((int)Animation_FieldIndex.Conditions)))) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Animation_FieldIndex.Action) ?? true))
            {
                if (!lhs.Action.Equals(rhs.Action)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Animation_FieldIndex.UseActorAnimationAction) ?? true))
            {
                if (lhs.UseActorAnimationAction != rhs.UseActorAnimationAction) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Animation_FieldIndex.AnimationHoldEvent) ?? true))
            {
                if (lhs.AnimationHoldEvent != rhs.AnimationHoldEvent) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Animation_FieldIndex.DTGT) ?? true))
            {
                if (lhs.DTGT != rhs.DTGT) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Animation_FieldIndex.ACEP) ?? true))
            {
                if (lhs.ACEP != rhs.ACEP) return false;
            }
            return true;
        }
        
        public virtual int GetHashCode(IAnimationGetter item)
        {
            var hash = new HashCode();
            hash.Add(item.NpcAnimation);
            if (item.Subgraph is {} Subgraphitem)
            {
                hash.Add(Subgraphitem);
            }
            hash.Add(item.BodyArchetype);
            hash.Add(item.FaceArchetype);
            hash.Add(item.Flavor);
            hash.Add(item.UseDialogueAnimation);
            hash.Add(item.UseAnimationBodyArchetype);
            hash.Add(item.HasAnimationFaceArchetype);
            hash.Add(item.AnimationCompleteEndsPhase);
            hash.Add(item.AnimationOnlyMovement);
            hash.Add(item.UseFlavorAnimation);
            if (item.DelayStartTimeAction is {} DelayStartTimeActionitem)
            {
                hash.Add(DelayStartTimeActionitem);
            }
            hash.Add(item.Conditions);
            hash.Add(item.Action);
            hash.Add(item.UseActorAnimationAction);
            hash.Add(item.AnimationHoldEvent);
            if (item.DTGT is {} DTGTitem)
            {
                hash.Add(DTGTitem);
            }
            hash.Add(item.ACEP);
            return hash.ToHashCode();
        }
        
        #endregion
        
        
        public object GetNew()
        {
            return Animation.GetNew();
        }
        
        #region Mutagen
        public IEnumerable<IFormLinkGetter> EnumerateFormLinks(IAnimationGetter obj)
        {
            yield return FormLinkInformation.Factory(obj.NpcAnimation);
            if (FormLinkInformation.TryFactory(obj.BodyArchetype, out var BodyArchetypeInfo))
            {
                yield return BodyArchetypeInfo;
            }
            if (FormLinkInformation.TryFactory(obj.FaceArchetype, out var FaceArchetypeInfo))
            {
                yield return FaceArchetypeInfo;
            }
            if (FormLinkInformation.TryFactory(obj.Flavor, out var FlavorInfo))
            {
                yield return FlavorInfo;
            }
            foreach (var item in obj.Conditions.SelectMany(f => f.EnumerateFormLinks()))
            {
                yield return FormLinkInformation.Factory(item);
            }
            if (FormLinkInformation.TryFactory(obj.Action, out var ActionInfo))
            {
                yield return ActionInfo;
            }
            yield break;
        }
        
        #endregion
        
    }
    internal partial class AnimationSetterTranslationCommon
    {
        public static readonly AnimationSetterTranslationCommon Instance = new AnimationSetterTranslationCommon();

        #region DeepCopyIn
        public void DeepCopyIn(
            IAnimation item,
            IAnimationGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            if ((copyMask?.GetShouldTranslate((int)Animation_FieldIndex.NpcAnimation) ?? true))
            {
                item.NpcAnimation.SetTo(rhs.NpcAnimation.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)Animation_FieldIndex.Subgraph) ?? true))
            {
                item.Subgraph = rhs.Subgraph;
            }
            if ((copyMask?.GetShouldTranslate((int)Animation_FieldIndex.BodyArchetype) ?? true))
            {
                item.BodyArchetype.SetTo(rhs.BodyArchetype.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)Animation_FieldIndex.FaceArchetype) ?? true))
            {
                item.FaceArchetype.SetTo(rhs.FaceArchetype.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)Animation_FieldIndex.Flavor) ?? true))
            {
                item.Flavor.SetTo(rhs.Flavor.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)Animation_FieldIndex.UseDialogueAnimation) ?? true))
            {
                item.UseDialogueAnimation = rhs.UseDialogueAnimation;
            }
            if ((copyMask?.GetShouldTranslate((int)Animation_FieldIndex.UseAnimationBodyArchetype) ?? true))
            {
                item.UseAnimationBodyArchetype = rhs.UseAnimationBodyArchetype;
            }
            if ((copyMask?.GetShouldTranslate((int)Animation_FieldIndex.HasAnimationFaceArchetype) ?? true))
            {
                item.HasAnimationFaceArchetype = rhs.HasAnimationFaceArchetype;
            }
            if ((copyMask?.GetShouldTranslate((int)Animation_FieldIndex.AnimationCompleteEndsPhase) ?? true))
            {
                item.AnimationCompleteEndsPhase = rhs.AnimationCompleteEndsPhase;
            }
            if ((copyMask?.GetShouldTranslate((int)Animation_FieldIndex.AnimationOnlyMovement) ?? true))
            {
                item.AnimationOnlyMovement = rhs.AnimationOnlyMovement;
            }
            if ((copyMask?.GetShouldTranslate((int)Animation_FieldIndex.UseFlavorAnimation) ?? true))
            {
                item.UseFlavorAnimation = rhs.UseFlavorAnimation;
            }
            if ((copyMask?.GetShouldTranslate((int)Animation_FieldIndex.DelayStartTimeAction) ?? true))
            {
                item.DelayStartTimeAction = rhs.DelayStartTimeAction;
            }
            if ((copyMask?.GetShouldTranslate((int)Animation_FieldIndex.Conditions) ?? true))
            {
                errorMask?.PushIndex((int)Animation_FieldIndex.Conditions);
                try
                {
                    item.Conditions.SetTo(
                        rhs.Conditions
                        .Select(r =>
                        {
                            return r.DeepCopy(
                                errorMask: errorMask,
                                default(TranslationCrystal));
                        }));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Animation_FieldIndex.Action) ?? true))
            {
                item.Action.SetTo(rhs.Action.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)Animation_FieldIndex.UseActorAnimationAction) ?? true))
            {
                item.UseActorAnimationAction = rhs.UseActorAnimationAction;
            }
            if ((copyMask?.GetShouldTranslate((int)Animation_FieldIndex.AnimationHoldEvent) ?? true))
            {
                item.AnimationHoldEvent = rhs.AnimationHoldEvent;
            }
            if ((copyMask?.GetShouldTranslate((int)Animation_FieldIndex.DTGT) ?? true))
            {
                item.DTGT = rhs.DTGT;
            }
            if ((copyMask?.GetShouldTranslate((int)Animation_FieldIndex.ACEP) ?? true))
            {
                item.ACEP = rhs.ACEP;
            }
            DeepCopyInCustom(
                item: item,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        partial void DeepCopyInCustom(
            IAnimation item,
            IAnimationGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy);
        #endregion
        
        public Animation DeepCopy(
            IAnimationGetter item,
            Animation.TranslationMask? copyMask = null)
        {
            Animation ret = (Animation)((AnimationCommon)((IAnimationGetter)item).CommonInstance()!).GetNew();
            ((AnimationSetterTranslationCommon)((IAnimationGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: null,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            return ret;
        }
        
        public Animation DeepCopy(
            IAnimationGetter item,
            out Animation.ErrorMask errorMask,
            Animation.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            Animation ret = (Animation)((AnimationCommon)((IAnimationGetter)item).CommonInstance()!).GetNew();
            ((AnimationSetterTranslationCommon)((IAnimationGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                ret,
                item,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            errorMask = Animation.ErrorMask.Factory(errorMaskBuilder);
            return ret;
        }
        
        public Animation DeepCopy(
            IAnimationGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            Animation ret = (Animation)((AnimationCommon)((IAnimationGetter)item).CommonInstance()!).GetNew();
            ((AnimationSetterTranslationCommon)((IAnimationGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: true);
            return ret;
        }
        
    }
    #endregion

}

namespace Mutagen.Bethesda.Starfield
{
    public partial class Animation
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => Animation_Registration.Instance;
        public static ILoquiRegistration StaticRegistration => Animation_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => AnimationCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterInstance()
        {
            return AnimationSetterCommon.Instance;
        }
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => AnimationSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IAnimationGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object IAnimationGetter.CommonSetterInstance() => this.CommonSetterInstance();
        [DebuggerStepThrough]
        object IAnimationGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

    }
}

#region Modules
#region Binary Translation
namespace Mutagen.Bethesda.Starfield
{
    public partial class AnimationBinaryWriteTranslation : IBinaryWriteTranslator
    {
        public static readonly AnimationBinaryWriteTranslation Instance = new();

        public static void WriteRecordTypes(
            IAnimationGetter item,
            MutagenWriter writer,
            TypedWriteParams translationParams)
        {
            FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.NpcAnimation,
                header: translationParams.ConvertToCustom(RecordTypes.BNAM));
            StringBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.Subgraph,
                header: translationParams.ConvertToCustom(RecordTypes.STRV),
                binaryType: StringBinaryType.NullTerminate);
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.BodyArchetype,
                header: translationParams.ConvertToCustom(RecordTypes.VCLR));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.FaceArchetype,
                header: translationParams.ConvertToCustom(RecordTypes.FLMV));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.Flavor,
                header: translationParams.ConvertToCustom(RecordTypes.FLAV));
            BooleanBinaryTranslation<MutagenFrame>.Instance.WriteAsMarker(
                writer: writer,
                item: item.UseDialogueAnimation,
                header: translationParams.ConvertToCustom(RecordTypes.QUAL));
            BooleanBinaryTranslation<MutagenFrame>.Instance.WriteAsMarker(
                writer: writer,
                item: item.UseAnimationBodyArchetype,
                header: translationParams.ConvertToCustom(RecordTypes.DOFT));
            BooleanBinaryTranslation<MutagenFrame>.Instance.WriteAsMarker(
                writer: writer,
                item: item.HasAnimationFaceArchetype,
                header: translationParams.ConvertToCustom(RecordTypes.SOFT));
            BooleanBinaryTranslation<MutagenFrame>.Instance.WriteAsMarker(
                writer: writer,
                item: item.AnimationCompleteEndsPhase,
                header: translationParams.ConvertToCustom(RecordTypes.DPLT));
            BooleanBinaryTranslation<MutagenFrame>.Instance.WriteAsMarker(
                writer: writer,
                item: item.AnimationOnlyMovement,
                header: translationParams.ConvertToCustom(RecordTypes.SPOR));
            BooleanBinaryTranslation<MutagenFrame>.Instance.WriteAsMarker(
                writer: writer,
                item: item.UseFlavorAnimation,
                header: translationParams.ConvertToCustom(RecordTypes.OCOR));
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.DelayStartTimeAction,
                header: translationParams.ConvertToCustom(RecordTypes.LVCR));
            Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<IConditionGetter>.Instance.Write(
                writer: writer,
                items: item.Conditions,
                transl: (MutagenWriter subWriter, IConditionGetter subItem, TypedWriteParams conv) =>
                {
                    var Item = subItem;
                    ((ConditionBinaryWriteTranslation)((IBinaryItem)Item).BinaryWriteTranslator).Write(
                        item: Item,
                        writer: subWriter,
                        translationParams: conv);
                });
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.Action,
                header: translationParams.ConvertToCustom(RecordTypes.ATAC));
            BooleanBinaryTranslation<MutagenFrame>.Instance.WriteAsMarker(
                writer: writer,
                item: item.UseActorAnimationAction,
                header: translationParams.ConvertToCustom(RecordTypes.SHRT));
            BooleanBinaryTranslation<MutagenFrame>.Instance.WriteAsMarker(
                writer: writer,
                item: item.AnimationHoldEvent,
                header: translationParams.ConvertToCustom(RecordTypes.PLRL));
            Int32BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.DTGT,
                header: translationParams.ConvertToCustom(RecordTypes.DTGT));
            BooleanBinaryTranslation<MutagenFrame>.Instance.WriteAsMarker(
                writer: writer,
                item: item.ACEP,
                header: translationParams.ConvertToCustom(RecordTypes.ACEP));
        }

        public void Write(
            MutagenWriter writer,
            IAnimationGetter item,
            TypedWriteParams translationParams)
        {
            WriteRecordTypes(
                item: item,
                writer: writer,
                translationParams: translationParams);
            using (HeaderExport.Subrecord(writer, RecordTypes.XNAM)) { } // End Marker
        }

        public void Write(
            MutagenWriter writer,
            object item,
            TypedWriteParams translationParams = default)
        {
            Write(
                item: (IAnimationGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

    }

    internal partial class AnimationBinaryCreateTranslation
    {
        public static readonly AnimationBinaryCreateTranslation Instance = new AnimationBinaryCreateTranslation();

        public static ParseResult FillBinaryRecordTypes(
            IAnimation item,
            MutagenFrame frame,
            PreviousParse lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            RecordType nextRecordType,
            int contentLength,
            TypedParseParams translationParams = default)
        {
            nextRecordType = translationParams.ConvertToStandard(nextRecordType);
            switch (nextRecordType.TypeInt)
            {
                case RecordTypeInts.BNAM:
                {
                    if (lastParsed.ShortCircuit((int)Animation_FieldIndex.NpcAnimation, translationParams)) return ParseResult.Stop;
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.NpcAnimation.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)Animation_FieldIndex.NpcAnimation;
                }
                case RecordTypeInts.STRV:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Subgraph = StringBinaryTranslation.Instance.Parse(
                        reader: frame.SpawnWithLength(contentLength),
                        stringBinaryType: StringBinaryType.NullTerminate,
                        parseWhole: true);
                    return (int)Animation_FieldIndex.Subgraph;
                }
                case RecordTypeInts.VCLR:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.BodyArchetype.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)Animation_FieldIndex.BodyArchetype;
                }
                case RecordTypeInts.FLMV:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.FaceArchetype.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)Animation_FieldIndex.FaceArchetype;
                }
                case RecordTypeInts.FLAV:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Flavor.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)Animation_FieldIndex.Flavor;
                }
                case RecordTypeInts.QUAL:
                {
                    item.UseDialogueAnimation = true;
                    return (int)Animation_FieldIndex.UseDialogueAnimation;
                }
                case RecordTypeInts.DOFT:
                {
                    item.UseAnimationBodyArchetype = true;
                    return (int)Animation_FieldIndex.UseAnimationBodyArchetype;
                }
                case RecordTypeInts.SOFT:
                {
                    item.HasAnimationFaceArchetype = true;
                    return (int)Animation_FieldIndex.HasAnimationFaceArchetype;
                }
                case RecordTypeInts.DPLT:
                {
                    item.AnimationCompleteEndsPhase = true;
                    return (int)Animation_FieldIndex.AnimationCompleteEndsPhase;
                }
                case RecordTypeInts.SPOR:
                {
                    item.AnimationOnlyMovement = true;
                    return (int)Animation_FieldIndex.AnimationOnlyMovement;
                }
                case RecordTypeInts.OCOR:
                {
                    item.UseFlavorAnimation = true;
                    return (int)Animation_FieldIndex.UseFlavorAnimation;
                }
                case RecordTypeInts.LVCR:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.DelayStartTimeAction = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)Animation_FieldIndex.DelayStartTimeAction;
                }
                case RecordTypeInts.CTDA:
                {
                    item.Conditions.SetTo(
                        Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<Condition>.Instance.Parse(
                            reader: frame,
                            triggeringRecord: Condition_Registration.TriggerSpecs,
                            translationParams: translationParams,
                            transl: Condition.TryCreateFromBinary));
                    return (int)Animation_FieldIndex.Conditions;
                }
                case RecordTypeInts.ATAC:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Action.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)Animation_FieldIndex.Action;
                }
                case RecordTypeInts.SHRT:
                {
                    item.UseActorAnimationAction = true;
                    return (int)Animation_FieldIndex.UseActorAnimationAction;
                }
                case RecordTypeInts.PLRL:
                {
                    item.AnimationHoldEvent = true;
                    return (int)Animation_FieldIndex.AnimationHoldEvent;
                }
                case RecordTypeInts.DTGT:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.DTGT = frame.ReadInt32();
                    return (int)Animation_FieldIndex.DTGT;
                }
                case RecordTypeInts.ACEP:
                {
                    item.ACEP = true;
                    return (int)Animation_FieldIndex.ACEP;
                }
                case RecordTypeInts.XNAM: // End Marker
                {
                    frame.ReadSubrecord();
                    return ParseResult.Stop;
                }
                default:
                    return ParseResult.Stop;
            }
        }

    }

}
namespace Mutagen.Bethesda.Starfield
{
    #region Binary Write Mixins
    public static class AnimationBinaryTranslationMixIn
    {
        public static void WriteToBinary(
            this IAnimationGetter item,
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((AnimationBinaryWriteTranslation)item.BinaryWriteTranslator).Write(
                item: item,
                writer: writer,
                translationParams: translationParams);
        }

    }
    #endregion


}
namespace Mutagen.Bethesda.Starfield
{
    internal partial class AnimationBinaryOverlay :
        PluginBinaryOverlay,
        IAnimationGetter
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => Animation_Registration.Instance;
        public static ILoquiRegistration StaticRegistration => Animation_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => AnimationCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => AnimationSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IAnimationGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object? IAnimationGetter.CommonSetterInstance() => null;
        [DebuggerStepThrough]
        object IAnimationGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

        void IPrintable.Print(StructuredStringBuilder sb, string? name) => this.Print(sb, name);

        public IEnumerable<IFormLinkGetter> EnumerateFormLinks() => AnimationCommon.Instance.EnumerateFormLinks(this);
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => AnimationBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((AnimationBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }

        #region NpcAnimation
        private int? _NpcAnimationLocation;
        public IFormLinkGetter<IIdleAnimationGetter> NpcAnimation => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IIdleAnimationGetter>(_package, _recordData, _NpcAnimationLocation);
        #endregion
        #region Subgraph
        private int? _SubgraphLocation;
        public String? Subgraph => _SubgraphLocation.HasValue ? BinaryStringUtility.ProcessWholeToZString(HeaderTranslation.ExtractSubrecordMemory(_recordData, _SubgraphLocation.Value, _package.MetaData.Constants), encoding: _package.MetaData.Encodings.NonTranslated) : default(string?);
        #endregion
        #region BodyArchetype
        private int? _BodyArchetypeLocation;
        public IFormLinkNullableGetter<IKeywordGetter> BodyArchetype => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IKeywordGetter>(_package, _recordData, _BodyArchetypeLocation);
        #endregion
        #region FaceArchetype
        private int? _FaceArchetypeLocation;
        public IFormLinkNullableGetter<IKeywordGetter> FaceArchetype => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IKeywordGetter>(_package, _recordData, _FaceArchetypeLocation);
        #endregion
        #region Flavor
        private int? _FlavorLocation;
        public IFormLinkNullableGetter<IKeywordGetter> Flavor => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IKeywordGetter>(_package, _recordData, _FlavorLocation);
        #endregion
        #region UseDialogueAnimation
        private int? _UseDialogueAnimationLocation;
        public Boolean UseDialogueAnimation => _UseDialogueAnimationLocation.HasValue ? true : default(Boolean);
        #endregion
        #region UseAnimationBodyArchetype
        private int? _UseAnimationBodyArchetypeLocation;
        public Boolean UseAnimationBodyArchetype => _UseAnimationBodyArchetypeLocation.HasValue ? true : default(Boolean);
        #endregion
        #region HasAnimationFaceArchetype
        private int? _HasAnimationFaceArchetypeLocation;
        public Boolean HasAnimationFaceArchetype => _HasAnimationFaceArchetypeLocation.HasValue ? true : default(Boolean);
        #endregion
        #region AnimationCompleteEndsPhase
        private int? _AnimationCompleteEndsPhaseLocation;
        public Boolean AnimationCompleteEndsPhase => _AnimationCompleteEndsPhaseLocation.HasValue ? true : default(Boolean);
        #endregion
        #region AnimationOnlyMovement
        private int? _AnimationOnlyMovementLocation;
        public Boolean AnimationOnlyMovement => _AnimationOnlyMovementLocation.HasValue ? true : default(Boolean);
        #endregion
        #region UseFlavorAnimation
        private int? _UseFlavorAnimationLocation;
        public Boolean UseFlavorAnimation => _UseFlavorAnimationLocation.HasValue ? true : default(Boolean);
        #endregion
        #region DelayStartTimeAction
        private int? _DelayStartTimeActionLocation;
        public Single? DelayStartTimeAction => _DelayStartTimeActionLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_recordData, _DelayStartTimeActionLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        public IReadOnlyList<IConditionGetter> Conditions { get; private set; } = Array.Empty<IConditionGetter>();
        #region Action
        private int? _ActionLocation;
        public IFormLinkNullableGetter<IActionRecordGetter> Action => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IActionRecordGetter>(_package, _recordData, _ActionLocation);
        #endregion
        #region UseActorAnimationAction
        private int? _UseActorAnimationActionLocation;
        public Boolean UseActorAnimationAction => _UseActorAnimationActionLocation.HasValue ? true : default(Boolean);
        #endregion
        #region AnimationHoldEvent
        private int? _AnimationHoldEventLocation;
        public Boolean AnimationHoldEvent => _AnimationHoldEventLocation.HasValue ? true : default(Boolean);
        #endregion
        #region DTGT
        private int? _DTGTLocation;
        public Int32? DTGT => _DTGTLocation.HasValue ? BinaryPrimitives.ReadInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_recordData, _DTGTLocation.Value, _package.MetaData.Constants)) : default(Int32?);
        #endregion
        #region ACEP
        private int? _ACEPLocation;
        public Boolean ACEP => _ACEPLocation.HasValue ? true : default(Boolean);
        #endregion
        partial void CustomFactoryEnd(
            OverlayStream stream,
            int finalPos,
            int offset);

        partial void CustomCtor();
        protected AnimationBinaryOverlay(
            MemoryPair memoryPair,
            BinaryOverlayFactoryPackage package)
            : base(
                memoryPair: memoryPair,
                package: package)
        {
            this.CustomCtor();
        }

        public static IAnimationGetter AnimationFactory(
            OverlayStream stream,
            BinaryOverlayFactoryPackage package,
            TypedParseParams translationParams = default)
        {
            stream = ExtractTypelessSubrecordRecordMemory(
                stream: stream,
                meta: package.MetaData.Constants,
                translationParams: translationParams,
                memoryPair: out var memoryPair,
                offset: out var offset,
                finalPos: out var finalPos);
            var ret = new AnimationBinaryOverlay(
                memoryPair: memoryPair,
                package: package);
            ret.FillTypelessSubrecordTypes(
                stream: stream,
                finalPos: stream.Length,
                offset: offset,
                translationParams: translationParams,
                fill: ret.FillRecordType);
            return ret;
        }

        public static IAnimationGetter AnimationFactory(
            ReadOnlyMemorySlice<byte> slice,
            BinaryOverlayFactoryPackage package,
            TypedParseParams translationParams = default)
        {
            return AnimationFactory(
                stream: new OverlayStream(slice, package),
                package: package,
                translationParams: translationParams);
        }

        public ParseResult FillRecordType(
            OverlayStream stream,
            int finalPos,
            int offset,
            RecordType type,
            PreviousParse lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            TypedParseParams translationParams = default)
        {
            type = translationParams.ConvertToStandard(type);
            switch (type.TypeInt)
            {
                case RecordTypeInts.BNAM:
                {
                    if (lastParsed.ShortCircuit((int)Animation_FieldIndex.NpcAnimation, translationParams)) return ParseResult.Stop;
                    _NpcAnimationLocation = (stream.Position - offset);
                    return (int)Animation_FieldIndex.NpcAnimation;
                }
                case RecordTypeInts.STRV:
                {
                    _SubgraphLocation = (stream.Position - offset);
                    return (int)Animation_FieldIndex.Subgraph;
                }
                case RecordTypeInts.VCLR:
                {
                    _BodyArchetypeLocation = (stream.Position - offset);
                    return (int)Animation_FieldIndex.BodyArchetype;
                }
                case RecordTypeInts.FLMV:
                {
                    _FaceArchetypeLocation = (stream.Position - offset);
                    return (int)Animation_FieldIndex.FaceArchetype;
                }
                case RecordTypeInts.FLAV:
                {
                    _FlavorLocation = (stream.Position - offset);
                    return (int)Animation_FieldIndex.Flavor;
                }
                case RecordTypeInts.QUAL:
                {
                    _UseDialogueAnimationLocation = (stream.Position - offset);
                    return (int)Animation_FieldIndex.UseDialogueAnimation;
                }
                case RecordTypeInts.DOFT:
                {
                    _UseAnimationBodyArchetypeLocation = (stream.Position - offset);
                    return (int)Animation_FieldIndex.UseAnimationBodyArchetype;
                }
                case RecordTypeInts.SOFT:
                {
                    _HasAnimationFaceArchetypeLocation = (stream.Position - offset);
                    return (int)Animation_FieldIndex.HasAnimationFaceArchetype;
                }
                case RecordTypeInts.DPLT:
                {
                    _AnimationCompleteEndsPhaseLocation = (stream.Position - offset);
                    return (int)Animation_FieldIndex.AnimationCompleteEndsPhase;
                }
                case RecordTypeInts.SPOR:
                {
                    _AnimationOnlyMovementLocation = (stream.Position - offset);
                    return (int)Animation_FieldIndex.AnimationOnlyMovement;
                }
                case RecordTypeInts.OCOR:
                {
                    _UseFlavorAnimationLocation = (stream.Position - offset);
                    return (int)Animation_FieldIndex.UseFlavorAnimation;
                }
                case RecordTypeInts.LVCR:
                {
                    _DelayStartTimeActionLocation = (stream.Position - offset);
                    return (int)Animation_FieldIndex.DelayStartTimeAction;
                }
                case RecordTypeInts.CTDA:
                {
                    this.Conditions = BinaryOverlayList.FactoryByArray<IConditionGetter>(
                        mem: stream.RemainingMemory,
                        package: _package,
                        translationParams: translationParams,
                        getter: (s, p, recConv) => ConditionBinaryOverlay.ConditionFactory(new OverlayStream(s, p), p, recConv),
                        locs: ParseRecordLocations(
                            stream: stream,
                            trigger: Condition_Registration.TriggerSpecs,
                            triggersAlwaysAreNewRecords: true,
                            constants: _package.MetaData.Constants.SubConstants,
                            skipHeader: false));
                    return (int)Animation_FieldIndex.Conditions;
                }
                case RecordTypeInts.ATAC:
                {
                    _ActionLocation = (stream.Position - offset);
                    return (int)Animation_FieldIndex.Action;
                }
                case RecordTypeInts.SHRT:
                {
                    _UseActorAnimationActionLocation = (stream.Position - offset);
                    return (int)Animation_FieldIndex.UseActorAnimationAction;
                }
                case RecordTypeInts.PLRL:
                {
                    _AnimationHoldEventLocation = (stream.Position - offset);
                    return (int)Animation_FieldIndex.AnimationHoldEvent;
                }
                case RecordTypeInts.DTGT:
                {
                    _DTGTLocation = (stream.Position - offset);
                    return (int)Animation_FieldIndex.DTGT;
                }
                case RecordTypeInts.ACEP:
                {
                    _ACEPLocation = (stream.Position - offset);
                    return (int)Animation_FieldIndex.ACEP;
                }
                case RecordTypeInts.XNAM: // End Marker
                {
                    stream.ReadSubrecord();
                    return ParseResult.Stop;
                }
                default:
                    return ParseResult.Stop;
            }
        }
        #region To String

        public void Print(
            StructuredStringBuilder sb,
            string? name = null)
        {
            AnimationMixIn.Print(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is not IAnimationGetter rhs) return false;
            return ((AnimationCommon)((IAnimationGetter)this).CommonInstance()!).Equals(this, rhs, equalsMask: null);
        }

        public bool Equals(IAnimationGetter? obj)
        {
            return ((AnimationCommon)((IAnimationGetter)this).CommonInstance()!).Equals(this, obj, equalsMask: null);
        }

        public override int GetHashCode() => ((AnimationCommon)((IAnimationGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

    }

}
#endregion

#endregion

