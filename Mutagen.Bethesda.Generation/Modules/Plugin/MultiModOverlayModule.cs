using Loqui.Generation;
using Mutagen.Bethesda.Plugins.Meta;
using Noggog;
using Noggog.IO;
using Noggog.StructuredStrings;
using Noggog.StructuredStrings.CSharp;
using ObjectType = Mutagen.Bethesda.Plugins.Meta.ObjectType;

namespace Mutagen.Bethesda.Generation.Modules.Plugin;

public class MultiModOverlayModule : GenerationModule
{
    public override async Task FinalizeGeneration(ProtocolGeneration proto)
    {
        await base.FinalizeGeneration(proto);

        // Find all Mod objects in this protocol
        foreach (var obj in proto.ObjectGenerationsByName.Values)
        {
            if (obj.GetObjectType() != ObjectType.Mod) continue;

            await GenerateMultiModOverlay(proto, obj);
        }
    }

    private async Task GenerateMultiModOverlay(ProtocolGeneration proto, ObjectGeneration obj)
    {
        var objData = obj.GetObjectData();
        var gameName = ModModule.ModName(obj);
        var className = $"{gameName}MultiModOverlay";

        StructuredStringBuilder sb = new StructuredStringBuilder();

        // Using statements
        sb.AppendLine("using System.Collections;");
        sb.AppendLine("using System.Diagnostics.CodeAnalysis;");
        sb.AppendLine("using Loqui;");
        sb.AppendLine("using Mutagen.Bethesda.Plugins;");
        sb.AppendLine("using Mutagen.Bethesda.Plugins.Assets;");
        sb.AppendLine("using Mutagen.Bethesda.Plugins.Binary.Parameters;");
        sb.AppendLine("using Mutagen.Bethesda.Plugins.Binary.Streams;");
        sb.AppendLine("using Mutagen.Bethesda.Plugins.Binary.Translations;");
        sb.AppendLine("using Mutagen.Bethesda.Plugins.Cache;");
        sb.AppendLine("using Mutagen.Bethesda.Plugins.Records;");
        sb.AppendLine("using Mutagen.Bethesda.Plugins.Exceptions;");
        sb.AppendLine("using Noggog;");
        sb.AppendLine("using Noggog.StructuredStrings;");
        sb.AppendLine("using Loqui.Internal;");
        sb.AppendLine();

        using (sb.Namespace(obj.Namespace, fileScoped: true))
        {
            // Summary comment
            using (var comment = sb.Comment())
            {
                comment.Summary.AppendLine($"Multi-mod overlay that presents multiple {gameName} mods as a single unified mod.");
                comment.Summary.AppendLine("Typically used for reading split mods that were written due to exceeding master limits,");
                comment.Summary.AppendLine("but can be used with any collection of mods.");
            }

            // Class declaration - implement IModDisposeGetter for proper resource cleanup
            sb.AppendLine($"internal class {className} : I{gameName}ModDisposableGetter");
            using (sb.CurlyBrace())
            {
                GenerateFields(sb, obj, gameName);
                sb.AppendLine();
                GenerateConstructor(sb, obj, className, gameName);
                sb.AppendLine();
                GenerateProperties(sb, obj, gameName);
                sb.AppendLine();
                GenerateGroupProperties(sb, obj, gameName);
                sb.AppendLine();
                GenerateInterfaceMembers(sb, obj, gameName);
            }
            
            // Generate game-specific MergedGroup wrapper FIRST
            GenerateMergedGroupWrapper(sb, gameName);
            sb.AppendLine();

            // Generate game-specific MergedListGroup wrapper (for Cells)
            GenerateMergedListGroupWrapper(sb, gameName);
            sb.AppendLine();

            // Generate MergedCellBlock class
            GenerateMergedCellBlockWrapper(sb, gameName);
            sb.AppendLine();
        }

        // Write to file
        var path = Path.Combine(proto.DefFileLocation.FullName, $"../{className}{Loqui.Generation.Constants.AutogeneratedMarkerString}.cs");
        ExportStringToFile exportStringToFile = new(IFileSystemExt.DefaultFilesystem);
        exportStringToFile.ExportToFile(path, sb.GetString());
        proto.GeneratedFiles.Add(path, ProjItemType.Compile);
    }

    private void GenerateMergedListGroupWrapper(StructuredStringBuilder sb, string gameName)
    {
        using (var comment = sb.Comment())
        {
            comment.Summary.AppendLine("Merged list group that combines multiple list groups (like Cells) into a single unified view.");
            comment.Summary.AppendLine("CellBlocks from different mods are merged by BlockNumber.");
        }
        sb.AppendLine($"internal class MergedListGroup : I{gameName}ListGroupGetter<ICellBlockGetter>");
        using (sb.CurlyBrace())
        {
            // Fields
            sb.AppendLine($"private readonly IEnumerable<I{gameName}ListGroupGetter<ICellBlockGetter>> _sourceGroups;");
            sb.AppendLine("private List<ICellBlockGetter>? _cache;");
            sb.AppendLine("private readonly object _cacheLock = new object();");
            sb.AppendLine();

            // Constructor
            sb.AppendLine($"public MergedListGroup(IEnumerable<I{gameName}ListGroupGetter<ICellBlockGetter>> sourceGroups)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("_sourceGroups = sourceGroups;");
            }
            sb.AppendLine();

            // Cache property with block merging logic
            sb.AppendLine("private List<ICellBlockGetter> Cache");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("get");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("if (_cache != null) return _cache;");
                    sb.AppendLine();
                    sb.AppendLine("lock (_cacheLock)");
                    using (sb.CurlyBrace())
                    {
                        sb.AppendLine("if (_cache != null) return _cache;");
                        sb.AppendLine();
                        sb.AppendLine("// Merge CellBlocks by BlockNumber");
                        sb.AppendLine("var blocksByNumber = new Dictionary<int, List<ICellBlockGetter>>();");
                        sb.AppendLine();
                        sb.AppendLine("foreach (var group in _sourceGroups)");
                        using (sb.CurlyBrace())
                        {
                            sb.AppendLine("foreach (var block in group.Records)");
                            using (sb.CurlyBrace())
                            {
                                sb.AppendLine("if (!blocksByNumber.ContainsKey(block.BlockNumber))");
                                using (sb.CurlyBrace())
                                {
                                    sb.AppendLine("blocksByNumber[block.BlockNumber] = new List<ICellBlockGetter>();");
                                }
                                sb.AppendLine("blocksByNumber[block.BlockNumber].Add(block);");
                            }
                        }
                        sb.AppendLine();
                        sb.AppendLine("// Create merged blocks");
                        sb.AppendLine("var result = new List<ICellBlockGetter>();");
                        sb.AppendLine("foreach (var blockNumber in blocksByNumber.Keys.OrderBy(k => k))");
                        using (sb.CurlyBrace())
                        {
                            sb.AppendLine("var blocksForNumber = blocksByNumber[blockNumber];");
                            sb.AppendLine("if (blocksForNumber.Count == 1)");
                            using (sb.CurlyBrace())
                            {
                                sb.AppendLine("result.Add(blocksForNumber[0]);");
                            }
                            sb.AppendLine("else");
                            using (sb.CurlyBrace())
                            {
                                sb.AppendLine("// Multiple blocks with same number - merge them");
                                sb.AppendLine("result.Add(new MergedCellBlock(blockNumber, blocksForNumber));");
                            }
                        }
                        sb.AppendLine();
                        sb.AppendLine("_cache = result;");
                        sb.AppendLine("return _cache;");
                    }
                }
            }
            sb.AppendLine();

            // IEnumerable implementation
            sb.AppendLine("public IEnumerator<ICellBlockGetter> GetEnumerator() => Cache.GetEnumerator();");
            sb.AppendLine("IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();");
            sb.AppendLine();

            // Properties
            sb.AppendLine("public int Count => Cache.Count;");
            sb.AppendLine("public ICellBlockGetter this[int index] => Cache[index];");
            sb.AppendLine("public IReadOnlyList<ICellBlockGetter> Records => Cache;");
            sb.AppendLine();

            // ILoquiObject
            sb.AppendLine($"ILoquiRegistration ILoquiObject.Registration => {gameName}Mod_Registration.Instance;");
            sb.AppendLine($"public static ILoquiRegistration StaticRegistration => {gameName}Mod_Registration.Instance;");
            sb.AppendLine();
            sb.AppendLine("public void Print(StructuredStringBuilder sb, string? name = null)");
            using (sb.CurlyBrace())
            {
                using (var c = sb.Call($"{gameName}ListGroupMixIn.Print"))
                {
                    c.Add("item: this");
                    c.AddPassArg("sb");
                    c.AddPassArg("name");
                }
            }
            sb.AppendLine();

            // ISkyrimListGroupGetter members
            sb.AppendLine($"// I{gameName}ListGroupGetter properties");
            sb.AppendLine("public GroupTypeEnum Type => _sourceGroups.FirstOrDefault()?.Type ?? GroupTypeEnum.InteriorCellBlock;");
            sb.AppendLine("public int LastModified => _sourceGroups.Max(g => g.LastModified);");
            sb.AppendLine("public int Unknown => 0;");
            sb.AppendLine();
            sb.AppendLine($"public object CommonInstance(Type type) => GenericCommonInstanceGetter.Get({gameName}ListGroupCommon<ICellBlockGetter>.Instance, typeof(ICellBlockGetter), type);");
            sb.AppendLine($"public object? CommonSetterInstance(Type type) => GenericCommonInstanceGetter.Get({gameName}ListGroupSetterCommon<ICellBlock>.Instance, typeof(ICellBlockGetter), type);");
            sb.AppendLine($"public object CommonSetterTranslationInstance() => {gameName}ListGroupSetterTranslationCommon.Instance;");
            sb.AppendLine();

            // IAssetLinkContainerGetter
            sb.AppendLine("public IEnumerable<IAssetLinkGetter> EnumerateAssetLinks(AssetLinkQuery queryCategories = AssetLinkQuery.Listed, IAssetLinkCache? linkCache = null, Type? assetType = null)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("foreach (var block in Cache)");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("if (block is IAssetLinkContainerGetter assetContainer)");
                    using (sb.CurlyBrace())
                    {
                        sb.AppendLine("foreach (var link in assetContainer.EnumerateAssetLinks(queryCategories, linkCache, assetType))");
                        using (sb.CurlyBrace())
                        {
                            sb.AppendLine("yield return link;");
                        }
                    }
                }
            }
            sb.AppendLine();

            // IBinaryItem
            sb.AppendLine("void IBinaryItem.WriteToBinary(MutagenWriter writer, TypedWriteParams translationParams)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("throw new NotSupportedException(\"Merged groups cannot be written to binary. Write the source mods individually.\");");
            }
            sb.AppendLine();
            sb.AppendLine("object IBinaryItem.BinaryWriteTranslator => throw new NotSupportedException(\"Merged groups do not support binary writing.\");");
            sb.AppendLine();

            // IFormLinkContainerGetter
            sb.AppendLine("public IEnumerable<IFormLinkGetter> EnumerateFormLinks(bool iterateNestedRecords = true)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("foreach (var block in Cache)");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("if (block is IFormLinkContainerGetter formLinkContainer)");
                    using (sb.CurlyBrace())
                    {
                        sb.AppendLine("foreach (var link in formLinkContainer.EnumerateFormLinks(iterateNestedRecords))");
                        using (sb.CurlyBrace())
                        {
                            sb.AppendLine("yield return link;");
                        }
                    }
                }
            }
            sb.AppendLine();

            // IMajorRecordGetterEnumerable
            sb.AppendLine("public IEnumerable<IMajorRecordGetter> EnumerateMajorRecords()");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("foreach (var block in Cache)");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("if (block is IMajorRecordGetterEnumerable enumerable)");
                    using (sb.CurlyBrace())
                    {
                        sb.AppendLine("foreach (var record in enumerable.EnumerateMajorRecords())");
                        using (sb.CurlyBrace())
                        {
                            sb.AppendLine("yield return record;");
                        }
                    }
                }
            }
            sb.AppendLine();

            sb.AppendLine("IEnumerable<T> IMajorRecordGetterEnumerable.EnumerateMajorRecords<T>(bool throwIfUnknown)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("foreach (var block in Cache)");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("if (block is IMajorRecordGetterEnumerable enumerable)");
                    using (sb.CurlyBrace())
                    {
                        sb.AppendLine("foreach (var record in enumerable.EnumerateMajorRecords<T>(throwIfUnknown))");
                        using (sb.CurlyBrace())
                        {
                            sb.AppendLine("yield return record;");
                        }
                    }
                }
            }
            sb.AppendLine();

            sb.AppendLine("public IEnumerable<IMajorRecordGetter> EnumerateMajorRecords(Type type, bool throwIfUnknown = true)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("foreach (var block in Cache)");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("if (block is IMajorRecordGetterEnumerable enumerable)");
                    using (sb.CurlyBrace())
                    {
                        sb.AppendLine("foreach (var record in enumerable.EnumerateMajorRecords(type, throwIfUnknown))");
                        using (sb.CurlyBrace())
                        {
                            sb.AppendLine("yield return record;");
                        }
                    }
                }
            }
        }
    }

    private void GenerateMergedCellBlockWrapper(StructuredStringBuilder sb, string gameName)
    {
        using (var comment = sb.Comment())
        {
            comment.Summary.AppendLine("Merged cell block that combines multiple cell blocks with the same BlockNumber.");
        }
        sb.AppendLine("internal class MergedCellBlock : ICellBlockGetter");
        using (sb.CurlyBrace())
        {
            // Fields
            sb.AppendLine("private readonly int _blockNumber;");
            sb.AppendLine("private readonly List<ICellBlockGetter> _sourceBlocks;");
            sb.AppendLine("private List<ICellSubBlockGetter>? _mergedSubBlocks;");
            sb.AppendLine("private readonly object _mergeLock = new object();");
            sb.AppendLine();

            // Constructor
            sb.AppendLine("public MergedCellBlock(int blockNumber, List<ICellBlockGetter> sourceBlocks)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("_blockNumber = blockNumber;");
                sb.AppendLine("_sourceBlocks = sourceBlocks;");
            }
            sb.AppendLine();

            // BlockNumber property
            sb.AppendLine("public int BlockNumber => _blockNumber;");
            sb.AppendLine("public GroupTypeEnum GroupType => _sourceBlocks.FirstOrDefault()?.GroupType ?? GroupTypeEnum.InteriorCellBlock;");
            sb.AppendLine("public int LastModified => _sourceBlocks.Max(b => b.LastModified);");
            sb.AppendLine("public int Unknown => 0;");
            sb.AppendLine();

            // SubBlocks property
            sb.AppendLine("public IReadOnlyList<ICellSubBlockGetter> SubBlocks");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("get");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("if (_mergedSubBlocks != null) return _mergedSubBlocks;");
                    sb.AppendLine();
                    sb.AppendLine("lock (_mergeLock)");
                    using (sb.CurlyBrace())
                    {
                        sb.AppendLine("if (_mergedSubBlocks != null) return _mergedSubBlocks;");
                        sb.AppendLine();
                        sb.AppendLine("// Merge SubBlocks from all source blocks");
                        sb.AppendLine("var allSubBlocks = new List<ICellSubBlockGetter>();");
                        sb.AppendLine("foreach (var block in _sourceBlocks)");
                        using (sb.CurlyBrace())
                        {
                            sb.AppendLine("allSubBlocks.AddRange(block.SubBlocks);");
                        }
                        sb.AppendLine();
                        sb.AppendLine("_mergedSubBlocks = allSubBlocks;");
                        sb.AppendLine("return _mergedSubBlocks;");
                    }
                }
            }
            sb.AppendLine();

            // ILoquiObject
            sb.AppendLine("ILoquiRegistration ILoquiObject.Registration => null!;");
            sb.AppendLine();
            sb.AppendLine("public void Print(StructuredStringBuilder sb, string? name = null)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("sb.AppendLine($\"Merged Cell Block {BlockNumber} ({SubBlocks.Count} sub-blocks from {_sourceBlocks.Count} source blocks)\");");
            }
            sb.AppendLine();

            sb.AppendLine($"public object CommonInstance() => CellBlockCommon.Instance;");
            sb.AppendLine($"public object? CommonSetterInstance() => null;");
            sb.AppendLine($"public object CommonSetterTranslationInstance() => CellBlockSetterTranslationCommon.Instance;");
            sb.AppendLine();

            // IBinaryItem
            sb.AppendLine("void IBinaryItem.WriteToBinary(MutagenWriter writer, TypedWriteParams translationParams)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("throw new NotSupportedException(\"Merged cell blocks cannot be written to binary.\");");
            }
            sb.AppendLine();
            sb.AppendLine("object IBinaryItem.BinaryWriteTranslator => throw new NotSupportedException(\"Merged cell blocks do not support binary writing.\");");
            sb.AppendLine();

            // IAssetLinkContainerGetter
            sb.AppendLine("public IEnumerable<IAssetLinkGetter> EnumerateAssetLinks(AssetLinkQuery queryCategories = AssetLinkQuery.Listed, IAssetLinkCache? linkCache = null, Type? assetType = null)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("foreach (var subBlock in SubBlocks)");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("if (subBlock is IAssetLinkContainerGetter assetContainer)");
                    using (sb.CurlyBrace())
                    {
                        sb.AppendLine("foreach (var link in assetContainer.EnumerateAssetLinks(queryCategories, linkCache, assetType))");
                        using (sb.CurlyBrace())
                        {
                            sb.AppendLine("yield return link;");
                        }
                    }
                }
            }
            sb.AppendLine();

            // IFormLinkContainerGetter
            sb.AppendLine("public IEnumerable<IFormLinkGetter> EnumerateFormLinks(bool iterateNestedRecords = true)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("foreach (var subBlock in SubBlocks)");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("if (subBlock is IFormLinkContainerGetter formLinkContainer)");
                    using (sb.CurlyBrace())
                    {
                        sb.AppendLine("foreach (var link in formLinkContainer.EnumerateFormLinks(iterateNestedRecords))");
                        using (sb.CurlyBrace())
                        {
                            sb.AppendLine("yield return link;");
                        }
                    }
                }
            }
            sb.AppendLine();

            // IMajorRecordGetterEnumerable
            sb.AppendLine("public IEnumerable<IMajorRecordGetter> EnumerateMajorRecords()");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("foreach (var subBlock in SubBlocks)");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("if (subBlock is IMajorRecordGetterEnumerable enumerable)");
                    using (sb.CurlyBrace())
                    {
                        sb.AppendLine("foreach (var record in enumerable.EnumerateMajorRecords())");
                        using (sb.CurlyBrace())
                        {
                            sb.AppendLine("yield return record;");
                        }
                    }
                }
            }
            sb.AppendLine();

            sb.AppendLine("public IEnumerable<T> EnumerateMajorRecords<T>(bool throwIfUnknown = true) where T : class, IMajorRecordQueryableGetter");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("foreach (var subBlock in SubBlocks)");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("if (subBlock is IMajorRecordGetterEnumerable enumerable)");
                    using (sb.CurlyBrace())
                    {
                        sb.AppendLine("foreach (var record in enumerable.EnumerateMajorRecords<T>(throwIfUnknown))");
                        using (sb.CurlyBrace())
                        {
                            sb.AppendLine("yield return record;");
                        }
                    }
                }
            }
            sb.AppendLine();

            sb.AppendLine("public IEnumerable<IMajorRecordGetter> EnumerateMajorRecords(Type type, bool throwIfUnknown = true)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("foreach (var subBlock in SubBlocks)");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("if (subBlock is IMajorRecordGetterEnumerable enumerable)");
                    using (sb.CurlyBrace())
                    {
                        sb.AppendLine("foreach (var record in enumerable.EnumerateMajorRecords(type, throwIfUnknown))");
                        using (sb.CurlyBrace())
                        {
                            sb.AppendLine("yield return record;");
                        }
                    }
                }
            }
        }
    }

    private void GenerateMergedGroupWrapper(StructuredStringBuilder sb, string gameName)
    {
        using (var comment = sb.Comment())
        {
            comment.Summary.AppendLine("Merged group that combines multiple groups into a single unified view.");
            comment.Summary.AppendLine("Validates no duplicate FormKeys exist and caches results.");
        }
        sb.AppendLine($"internal class MergedGroup<TGetter> : I{gameName}GroupGetter<TGetter>, IReadOnlyCache<TGetter, FormKey>");
        using (sb.IncreaseDepth())
        {
            sb.AppendLine($"where TGetter : class, I{gameName}MajorRecordGetter, IBinaryItem");
        }
        using (sb.CurlyBrace())
        {
            // Fields
            sb.AppendLine("private readonly IEnumerable<IGroupGetter<TGetter>> _sourceGroups;");
            sb.AppendLine("private Dictionary<FormKey, TGetter>? _cache;");
            sb.AppendLine("private readonly object _cacheLock = new object();");
            sb.AppendLine();

            // Constructor
            sb.AppendLine("public MergedGroup(IEnumerable<IGroupGetter<TGetter>> sourceGroups)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("_sourceGroups = sourceGroups;");
            }
            sb.AppendLine();

            // Cache property
            sb.AppendLine("private Dictionary<FormKey, TGetter> Cache");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("get");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("if (_cache != null) return _cache;");
                    sb.AppendLine();
                    sb.AppendLine("lock (_cacheLock)");
                    using (sb.CurlyBrace())
                    {
                        sb.AppendLine("if (_cache != null) return _cache;");
                        sb.AppendLine();
                        sb.AppendLine("var cache = new Dictionary<FormKey, TGetter>();");
                        sb.AppendLine("foreach (var group in _sourceGroups)");
                        using (sb.CurlyBrace())
                        {
                            sb.AppendLine("foreach (var record in group)");
                            using (sb.CurlyBrace())
                            {
                                sb.AppendLine("if (!cache.TryAdd(record.FormKey, record))");
                                using (sb.CurlyBrace())
                                {
                                    sb.AppendLine("throw new SplitModException(");
                                    using (sb.IncreaseDepth())
                                    {
                                        sb.AppendLine("$\"Duplicate FormKey {record.FormKey} found in split mods. \" +");
                                        sb.AppendLine("\"This indicates corruption or an error in the splitting logic.\");");
                                    }
                                }
                            }
                        }
                        sb.AppendLine();
                        sb.AppendLine("_cache = cache;");
                        sb.AppendLine("return _cache;");
                    }
                }
            }
            sb.AppendLine();

            // Enumeration methods
            sb.AppendLine("public IEnumerator<TGetter> GetEnumerator() => Cache.Values.GetEnumerator();");
            sb.AppendLine("IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();");
            sb.AppendLine();

            // Properties
            sb.AppendLine("public int Count => Cache.Count;");
            sb.AppendLine();
            sb.AppendLine("public bool TryGetValue(FormKey key, [MaybeNullWhen(false)] out TGetter value)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("return Cache.TryGetValue(key, out value);");
            }
            sb.AppendLine();
            sb.AppendLine("public TGetter this[FormKey key] => Cache[key];");
            sb.AppendLine("IMajorRecordGetter IGroupGetter.this[FormKey key] => this[key];");
            sb.AppendLine();
            sb.AppendLine("public bool ContainsKey(FormKey key) => Cache.ContainsKey(key);");
            sb.AppendLine("public IEnumerable<FormKey> FormKeys => Cache.Keys;");
            sb.AppendLine("public Type Type => typeof(TGetter);");
            sb.AppendLine("public IEnumerable<TGetter> Records => Cache.Values;");
            sb.AppendLine();

            // IGroupGetter members
            sb.AppendLine("IMod IGroupGetter.SourceMod => throw new NotSupportedException(\"Merged group has multiple source mods, not a single source.\");");
            sb.AppendLine("IEnumerable<TGetter> IGroupCommonGetter<TGetter>.Records => Cache.Values;");
            sb.AppendLine("IEnumerable<ILoquiObject> IGroupCommonGetter.Records => Cache.Values;");
            sb.AppendLine("IEnumerable<IMajorRecordGetter> IGroupGetter.Records => Cache.Values.Cast<IMajorRecordGetter>();");
            sb.AppendLine("IReadOnlyCache<IMajorRecordGetter, FormKey> IGroupGetter.RecordCache => new MajorRecordCacheWrapper(this);");
            sb.AppendLine();

            // IGroupCommonGetter members
            sb.AppendLine("public ILoquiRegistration ContainedRecordRegistration => _sourceGroups.First().ContainedRecordRegistration;");
            sb.AppendLine("public Type ContainedRecordType => typeof(TGetter);");
            sb.AppendLine();

            // IAssetLinkContainerGetter
            sb.AppendLine("public IEnumerable<IAssetLinkGetter> EnumerateAssetLinks(AssetLinkQuery queryCategories = AssetLinkQuery.Listed, IAssetLinkCache? linkCache = null, Type? assetType = null)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("foreach (var record in Cache.Values)");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("if (record is IAssetLinkContainerGetter assetContainer)");
                    using (sb.CurlyBrace())
                    {
                        sb.AppendLine("foreach (var link in assetContainer.EnumerateAssetLinks(queryCategories, linkCache, assetType))");
                        using (sb.CurlyBrace())
                        {
                            sb.AppendLine("yield return link;");
                        }
                    }
                }
            }
            sb.AppendLine();

            // IBinaryItem
            sb.AppendLine("void IBinaryItem.WriteToBinary(MutagenWriter writer, TypedWriteParams translationParams)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("throw new NotSupportedException(\"Merged groups cannot be written to binary. Write the source mods individually.\");");
            }
            sb.AppendLine();
            sb.AppendLine("object IBinaryItem.BinaryWriteTranslator => throw new NotSupportedException(\"Merged groups do not support binary writing.\");");
            sb.AppendLine();

            // IFormLinkContainerGetter
            sb.AppendLine("public IEnumerable<IFormLinkGetter> EnumerateFormLinks(bool iterateNestedRecords = true)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("foreach (var record in Cache.Values)");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("if (record is IFormLinkContainerGetter formLinkContainer)");
                    using (sb.CurlyBrace())
                    {
                        sb.AppendLine("foreach (var link in formLinkContainer.EnumerateFormLinks(iterateNestedRecords))");
                        using (sb.CurlyBrace())
                        {
                            sb.AppendLine("yield return link;");
                        }
                    }
                }
            }
            sb.AppendLine();

            // IMajorRecordGetterEnumerable
            sb.AppendLine("public IEnumerable<IMajorRecordGetter> EnumerateMajorRecords()");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("return Cache.Values;");
            }
            sb.AppendLine();
            sb.AppendLine("IEnumerable<T> IMajorRecordGetterEnumerable.EnumerateMajorRecords<T>(bool throwIfUnknown)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("return Cache.Values.WhereCastable<TGetter, T>();");
            }
            sb.AppendLine();
            sb.AppendLine("public IEnumerable<IMajorRecordGetter> EnumerateMajorRecords(Type type, bool throwIfUnknown = true)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("return Cache.Values.Where(r => type.IsAssignableFrom(r.GetType()));");
            }
            sb.AppendLine();

            // ISkyrimGroupGetter members
            sb.AppendLine($"// I{gameName}GroupGetter members");
            sb.AppendLine($"public object CommonInstance(Type type) => GenericCommonInstanceGetter.Get({gameName}GroupCommon<TGetter>.Instance, typeof(ICellBlockGetter), type);");
            sb.AppendLine($"public object? CommonSetterInstance(Type type) => null;");
            sb.AppendLine($"public object CommonSetterTranslationInstance() => {gameName}GroupSetterTranslationCommon.Instance;");
            sb.AppendLine();
            sb.AppendLine($"GroupTypeEnum I{gameName}GroupGetter<TGetter>.Type => GroupTypeEnum.Type;");
            sb.AppendLine($"int I{gameName}GroupGetter<TGetter>.LastModified => 0;");
            sb.AppendLine("public int Unknown => 0;");
            sb.AppendLine();
            sb.AppendLine($"IReadOnlyCache<TGetter, FormKey> I{gameName}GroupGetter<TGetter>.RecordCache => this;");
            sb.AppendLine("IReadOnlyCache<TGetter, FormKey> IGroupGetter<TGetter>.RecordCache => this;");
            sb.AppendLine();

            // IReadOnlyCache explicit implementations
            sb.AppendLine("// IReadOnlyCache explicit implementations");
            sb.AppendLine("IEnumerable<FormKey> IReadOnlyCache<TGetter, FormKey>.Keys => Cache.Keys;");
            sb.AppendLine("IEnumerable<TGetter> IReadOnlyCache<TGetter, FormKey>.Items => Cache.Values;");
            sb.AppendLine();
            sb.AppendLine("TGetter? IReadOnlyCache<TGetter, FormKey>.TryGetValue(FormKey key)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("return TryGetValue(key, out var value) ? value : null;");
            }
            sb.AppendLine();
            sb.AppendLine("IEnumerator<IKeyValue<FormKey, TGetter>> IEnumerable<IKeyValue<FormKey, TGetter>>.GetEnumerator()");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("return Cache.Select(kvp => (IKeyValue<FormKey, TGetter>)new KeyValue<FormKey, TGetter>(kvp.Key, kvp.Value)).GetEnumerator();");
            }
            sb.AppendLine();

            // MajorRecordCacheWrapper
            sb.AppendLine("// Wrapper to cast TGetter to IMajorRecordGetter for IGroupGetter.RecordCache");
            sb.AppendLine("private class MajorRecordCacheWrapper : IReadOnlyCache<IMajorRecordGetter, FormKey>");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("private readonly MergedGroup<TGetter> _source;");
                sb.AppendLine();
                sb.AppendLine("public MajorRecordCacheWrapper(MergedGroup<TGetter> source)");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("_source = source;");
                }
                sb.AppendLine();
                sb.AppendLine("public IMajorRecordGetter this[FormKey key] => _source[key];");
                sb.AppendLine("public IEnumerable<FormKey> Keys => _source.Cache.Keys;");
                sb.AppendLine("public IEnumerable<IMajorRecordGetter> Items => _source.Cache.Values.Cast<IMajorRecordGetter>();");
                sb.AppendLine("public int Count => _source.Count;");
                sb.AppendLine("public bool ContainsKey(FormKey key) => _source.ContainsKey(key);");
                sb.AppendLine("public IMajorRecordGetter? TryGetValue(FormKey key) => _source.TryGetValue(key, out var value) ? value : null;");
                sb.AppendLine();
                sb.AppendLine("public IEnumerator<IKeyValue<FormKey, IMajorRecordGetter>> GetEnumerator()");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("return _source.Cache.Select(kvp => (IKeyValue<FormKey, IMajorRecordGetter>)new KeyValue<FormKey, IMajorRecordGetter>(kvp.Key, kvp.Value)).GetEnumerator();");
                }
                sb.AppendLine();
                sb.AppendLine("IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();");
            }
            sb.AppendLine();

            // ILoquiObject
            sb.AppendLine("// ILoquiObject");
            sb.AppendLine("ILoquiRegistration ILoquiObject.Registration => null!;");
            sb.AppendLine();
            sb.AppendLine("public void Print(StructuredStringBuilder sb, string? name = null)");
            using (sb.CurlyBrace())
            {
                using (var c = sb.Call($"{gameName}GroupMixIn.Print"))
                {
                    c.Add("item: this");
                    c.AddPassArg("sb");
                    c.AddPassArg("name");
                }
            }
        }
    }

    private void GenerateFields(StructuredStringBuilder sb, ObjectGeneration obj, string gameName)
    {
        // Source mods collection - stored as IModDisposeGetter for proper disposal
        sb.AppendLine($"private readonly IReadOnlyList<I{gameName}ModGetter> _sourceMods;");
        sb.AppendLine("private readonly IReadOnlyList<IModDisposeGetter>? _disposeSourceMods;");

        // ModKey and masters
        sb.AppendLine("private readonly ModKey _modKey;");
        sb.AppendLine("private readonly IReadOnlyList<IMasterReferenceGetter> _masters;");
        sb.AppendLine();

        // Cached fields for each group
        foreach (var field in obj.IterateFields())
        {
            if (field is not LoquiType loqui) continue;
            if (loqui.TargetObjectGeneration?.GetObjectType() != ObjectType.Group) continue;

            var fieldName = $"_{char.ToLower(loqui.Name[0])}{loqui.Name.Substring(1)}";
            var recordType = GetGroupRecordType(loqui);

            // Use the game-specific non-generic wrapper classes
            if (IsListGroup(loqui))
            {
                // Use the game-specific non-generic MergedListGroup (for Cells)
                sb.AppendLine($"private MergedListGroup? {fieldName};");
            }
            else
            {
                // Use the game-specific MergedGroup with interface forms
                sb.AppendLine($"private MergedGroup<I{recordType}Getter>? {fieldName};");
            }
        }
    }

    private void GenerateConstructor(StructuredStringBuilder sb, ObjectGeneration obj, string className, string gameName)
    {
        using (var comment = sb.Comment())
        {
            comment.Summary.AppendLine($"Creates a new {className} from multiple source mod files.");
        }
        sb.AppendLine($"public {className}(");
        using (sb.IncreaseDepth())
        {
            sb.AppendLine($"ModKey modKey,");
            sb.AppendLine($"IEnumerable<I{gameName}ModGetter> sourceMods,");
            sb.AppendLine($"IReadOnlyList<IMasterReferenceGetter> mergedMasters)");
        }
        using (sb.CurlyBrace())
        {
            sb.AppendLine("_modKey = modKey;");
            sb.AppendLine($"var sourceList = sourceMods.ToList();");
            sb.AppendLine("_sourceMods = sourceList;");
            sb.AppendLine("_masters = mergedMasters;");
            sb.AppendLine();
            sb.AppendLine("// Track disposable mods for cleanup");
            sb.AppendLine("var disposables = sourceList.OfType<IModDisposeGetter>().ToList();");
            sb.AppendLine("_disposeSourceMods = disposables.Count > 0 ? disposables : null;");
            sb.AppendLine();
            sb.AppendLine("if (_sourceMods.Count == 0)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("throw new ArgumentException(\"Must provide at least one source mod\", nameof(sourceMods));");
            }
        }
    }

    private void GenerateProperties(StructuredStringBuilder sb, ObjectGeneration obj, string gameName)
    {
        // Basic properties
        sb.AppendLine("public ModKey ModKey => _modKey;");
        sb.AppendLine($"public I{gameName}ModHeaderGetter ModHeader => _sourceMods[0].ModHeader;");
        sb.AppendLine("public IReadOnlyList<IMasterReferenceGetter> MasterReferences => _masters;");

        var objData = obj.GetObjectData();
        if (objData.GameReleaseOptions != null)
        {
            var releaseEnum = ModModule.ReleaseEnumName(obj);
            sb.AppendLine($"public {releaseEnum} {releaseEnum} => _sourceMods[0].{releaseEnum};");
            sb.AppendLine($"GameRelease IModGetter.GameRelease => {releaseEnum}.ToGameRelease();");
        }
        else
        {
            sb.AppendLine($"public GameRelease GameRelease => GameRelease.{objData.GameCategory};");
        }

        sb.AppendLine();
        sb.AppendLine($"public object CommonInstance() => {gameName}ModCommon.Instance;");
        sb.AppendLine($"public object? CommonSetterInstance() => {gameName}ModSetterCommon.Instance;");
        sb.AppendLine($"public object CommonSetterTranslationInstance() => {gameName}ModSetterTranslationCommon.Instance;");
        sb.AppendLine();
    }
    
    private void GenerateGroupProperties(StructuredStringBuilder sb, ObjectGeneration obj, string gameName)
    {
        foreach (var field in obj.IterateFields())
        {
            if (field is not LoquiType loqui) continue;
            if (loqui.TargetObjectGeneration?.GetObjectType() != ObjectType.Group) continue;

            var fieldName = $"_{char.ToLower(loqui.Name[0])}{loqui.Name.Substring(1)}";

            // Determine the record type for the group (as interface form)
            var recordType = GetGroupRecordType(loqui);

            // Get the game-specific group getter interface
            var groupGetter = loqui.TypeName(getter: true);

            // Generate property with game-specific type
            sb.AppendLine($"public {groupGetter} {loqui.Name} =>");
            using (sb.IncreaseDepth())
            {
                if (IsListGroup(loqui))
                {
                    // For list groups (like Cells), use the non-generic MergedListGroup
                    sb.AppendLine($"{fieldName} ??= new MergedListGroup(_sourceMods.Select(m => m.{loqui.Name}));");
                }
                else
                {
                    // For regular groups, use the game-specific MergedGroup wrapper
                    sb.AppendLine($"{fieldName} ??= new MergedGroup<I{recordType}Getter>(");
                    using (sb.IncreaseDepth())
                    {
                        sb.AppendLine($"_sourceMods.Select(m => m.{loqui.Name}));");
                    }
                }
            }
        }
    }

    private void GenerateInterfaceMembers(StructuredStringBuilder sb, ObjectGeneration obj, string gameName)
    {
        // BeginWrite
        sb.AppendLine($"BinaryModdedWriteBuilderTargetChoice<I{gameName}ModGetter> I{gameName}ModGetter.BeginWrite =>");
        using (sb.IncreaseDepth())
        {
            sb.AppendLine($"new BinaryModdedWriteBuilderTargetChoice<I{gameName}ModGetter>(this, {gameName}Mod.{gameName}WriteBuilderInstantiator.Instance);");
        }
        sb.AppendLine();

        sb.AppendLine("IBinaryModdedWriteBuilderTargetChoice IModGetter.BeginWrite =>");
        using (sb.IncreaseDepth())
        {
            sb.AppendLine($"new BinaryModdedWriteBuilderTargetChoice<I{gameName}ModGetter>(this, {gameName}Mod.{gameName}WriteBuilderInstantiator.Instance);");
        }
        sb.AppendLine();

        // EnumerateAssetLinks
        sb.AppendLine("public IEnumerable<IAssetLinkGetter> EnumerateAssetLinks(AssetLinkQuery queryCategories = AssetLinkQuery.Listed, IAssetLinkCache? linkCache = null, Type? assetType = null)");
        using (sb.CurlyBrace())
        {
            sb.AppendLine("foreach (var mod in _sourceMods)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("foreach (var link in mod.EnumerateAssetLinks(queryCategories, linkCache, assetType))");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("yield return link;");
                }
            }
        }
        sb.AppendLine();

        // EnumerateFormLinks
        sb.AppendLine("public IEnumerable<IFormLinkGetter> EnumerateFormLinks(bool iterateNestedRecords = true)");
        using (sb.CurlyBrace())
        {
            sb.AppendLine("foreach (var mod in _sourceMods)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("foreach (var link in mod.EnumerateFormLinks(iterateNestedRecords))");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("yield return link;");
                }
            }
        }
        sb.AppendLine();

        // EnumerateMajorRecords
        sb.AppendLine("public IEnumerable<IMajorRecordGetter> EnumerateMajorRecords()");
        using (sb.CurlyBrace())
        {
            sb.AppendLine("foreach (var mod in _sourceMods)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("foreach (var record in mod.EnumerateMajorRecords())");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("yield return record;");
                }
            }
        }
        sb.AppendLine();

        sb.AppendLine("public IEnumerable<T> EnumerateMajorRecords<T>(bool throwIfUnknown = true) where T : class, IMajorRecordQueryableGetter");
        using (sb.CurlyBrace())
        {
            sb.AppendLine("foreach (var mod in _sourceMods)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("foreach (var record in mod.EnumerateMajorRecords<T>(throwIfUnknown))");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("yield return record;");
                }
            }
        }
        sb.AppendLine();

        sb.AppendLine("public IEnumerable<IMajorRecordGetter> EnumerateMajorRecords(Type type, bool throwIfUnknown = true)");
        using (sb.CurlyBrace())
        {
            sb.AppendLine("foreach (var mod in _sourceMods)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("foreach (var record in mod.EnumerateMajorRecords(type, throwIfUnknown))");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("yield return record;");
                }
            }
        }
        sb.AppendLine();

        // TryGetTopLevelGroup
        sb.AppendLine("IGroupGetter<TMajor>? IModGetter.TryGetTopLevelGroup<TMajor>()");
        using (sb.CurlyBrace())
        {
            sb.AppendLine($"return (IGroupGetter<TMajor>?)(({gameName}ModCommon)((I{gameName}ModGetter)this).CommonInstance()!).GetGroup(");
            using (sb.IncreaseDepth())
            {
                sb.AppendLine("obj: this,");
                sb.AppendLine("type: typeof(TMajor));");
            }
        }
        sb.AppendLine();

        sb.AppendLine("public IGroupGetter? TryGetTopLevelGroup(Type type)");
        using (sb.CurlyBrace())
        {
            sb.AppendLine($"return (IGroupGetter?)(({gameName}ModCommon)((I{gameName}ModGetter)this).CommonInstance()!).GetGroup(");
            using (sb.IncreaseDepth())
            {
                sb.AppendLine("obj: this,");
                sb.AppendLine("type: type);");
            }
        }
        sb.AppendLine();

        // EnumerateMajorRecordContexts
        sb.AppendLine($"IEnumerable<IModContext<I{gameName}Mod, I{gameName}ModGetter, TSetter, TGetter>> IMajorRecordContextEnumerable<I{gameName}Mod, I{gameName}ModGetter>.EnumerateMajorRecordContexts<TSetter, TGetter>(ILinkCache linkCache, bool throwIfUnknown)");
        using (sb.CurlyBrace())
        {
            sb.AppendLine("foreach (var mod in _sourceMods)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("foreach (var context in mod.EnumerateMajorRecordContexts<TSetter, TGetter>(linkCache, throwIfUnknown))");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("yield return context;");
                }
            }
        }
        sb.AppendLine();

        sb.AppendLine($"IEnumerable<IModContext<I{gameName}Mod, I{gameName}ModGetter, IMajorRecord, IMajorRecordGetter>> IMajorRecordContextEnumerable<I{gameName}Mod, I{gameName}ModGetter>.EnumerateMajorRecordContexts(ILinkCache linkCache, Type type, bool throwIfUnknown)");
        using (sb.CurlyBrace())
        {
            sb.AppendLine("foreach (var mod in _sourceMods)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("foreach (var context in mod.EnumerateMajorRecordContexts(linkCache, type, throwIfUnknown))");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("yield return context;");
                }
            }
        }
        sb.AppendLine();

        // EnumerateMajorRecordSimpleContexts
        sb.AppendLine("public IEnumerable<IModContext<IMajorRecordGetter>> EnumerateMajorRecordSimpleContexts()");
        using (sb.CurlyBrace())
        {
            sb.AppendLine("foreach (var mod in _sourceMods)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("foreach (var context in mod.EnumerateMajorRecordSimpleContexts())");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("yield return context;");
                }
            }
        }
        sb.AppendLine();

        sb.AppendLine("public IEnumerable<IModContext<TGetter>> EnumerateMajorRecordSimpleContexts<TGetter>(bool throwIfUnknown = true) where TGetter : class, IMajorRecordQueryableGetter");
        using (sb.CurlyBrace())
        {
            sb.AppendLine("foreach (var mod in _sourceMods)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("foreach (var context in mod.EnumerateMajorRecordSimpleContexts<TGetter>(throwIfUnknown))");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("yield return context;");
                }
            }
        }
        sb.AppendLine();

        sb.AppendLine("public IEnumerable<IModContext<IMajorRecordGetter>> EnumerateMajorRecordSimpleContexts(Type type, bool throwIfUnknown = true)");
        using (sb.CurlyBrace())
        {
            sb.AppendLine("foreach (var mod in _sourceMods)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("foreach (var context in mod.EnumerateMajorRecordSimpleContexts(type, throwIfUnknown))");
                using (sb.CurlyBrace())
                {
                    sb.AppendLine("yield return context;");
                }
            }
        }
        sb.AppendLine();

        // WriteToBinary
        sb.AppendLine("public void WriteToBinary(FilePath path, BinaryWriteParameters? param = null) => this.WriteToBinary(path, importMask: null, param: param);");
        sb.AppendLine();
        sb.AppendLine("public void WriteToBinary(Stream stream, BinaryWriteParameters? param = null) => this.WriteToBinary(stream, importMask: null, param: param);");
        sb.AppendLine();

        // GetDefaultInitialNextFormID
        sb.AppendLine("public uint GetDefaultInitialNextFormID(bool? isSmallMasterOverride = null)");
        using (sb.CurlyBrace())
        {
            sb.AppendLine("return _sourceMods[0].GetDefaultInitialNextFormID(isSmallMasterOverride);");
        }
        sb.AppendLine();

        // GetRecordCount
        sb.AppendLine("public uint GetRecordCount()");
        using (sb.CurlyBrace())
        {
            sb.AppendLine("return (uint)_sourceMods.Sum(m => m.GetRecordCount());");
        }
        sb.AppendLine();

        // DeepCopy
        sb.AppendLine("IMod IModGetter.DeepCopy()");
        using (sb.CurlyBrace())
        {
            sb.AppendLine($"return (({gameName}ModSetterTranslationCommon)((I{gameName}ModGetter)this).CommonSetterTranslationInstance()!).DeepCopy(");
            using (sb.IncreaseDepth())
            {
                sb.AppendLine("item: this,");
                sb.AppendLine("errorMask: null,");
                sb.AppendLine("copyMask: null);");
            }
        }
        sb.AppendLine();

        // OverriddenForms
        sb.AppendLine("#pragma warning disable CS8603 // Possible null reference return");
        sb.AppendLine("IReadOnlyList<IFormLinkGetter<IMajorRecordGetter>> IModGetter.OverriddenForms");
        using (sb.CurlyBrace())
        {
            sb.AppendLine("get => _sourceMods.SelectMany(m => m.OverriddenForms).ToList();");
        }
        sb.AppendLine("#pragma warning restore CS8603");
        sb.AppendLine();

        // NextFormID - return max across all mods to avoid collisions
        sb.AppendLine("public uint NextFormID => _sourceMods.Max(m => m.NextFormID);");
        sb.AppendLine();

        // ILoquiObject.Registration
        sb.AppendLine($"public ILoquiRegistration Registration => {gameName}Mod_Registration.Instance;");
        sb.AppendLine();

        // IPrintable.Print
        sb.AppendLine("public void Print(StructuredStringBuilder sb, string? name = null)");
        using (sb.CurlyBrace())
        {
            sb.AppendLine("throw new NotSupportedException(\"Multi-mod overlay does not support printing.\");");
        }
        sb.AppendLine();

        // IEqualsMask.GetEqualsMask
        sb.AppendLine("public IMask<bool> GetEqualsMask(object rhs, EqualsMaskHelper.Include include)");
        using (sb.CurlyBrace())
        {
            sb.AppendLine("throw new NotSupportedException(\"Multi-mod overlay does not support equality masking.\");");
        }
        sb.AppendLine();

        // IModFlagsGetter members
        sb.AppendLine("// IModFlagsGetter members");
        sb.AppendLine("public bool CanUseLocalization => _sourceMods[0].CanUseLocalization;");
        sb.AppendLine("public bool UsingLocalization => _sourceMods[0].UsingLocalization;");
        sb.AppendLine("public bool CanBeSmallMaster => _sourceMods[0].CanBeSmallMaster;");
        sb.AppendLine("public bool IsSmallMaster => _sourceMods[0].IsSmallMaster;");
        sb.AppendLine("public bool CanBeMediumMaster => _sourceMods[0].CanBeMediumMaster;");
        sb.AppendLine("public bool IsMediumMaster => _sourceMods[0].IsMediumMaster;");
        sb.AppendLine("public bool IsMaster => _sourceMods[0].IsMaster;");
        sb.AppendLine("public bool ListsOverriddenForms => _sourceMods[0].ListsOverriddenForms;");
        sb.AppendLine();

        // IModMasterStyledGetter
        sb.AppendLine("// IModMasterStyledGetter");
        sb.AppendLine("public MasterStyle MasterStyle => _sourceMods[0].MasterStyle;");
        sb.AppendLine();

        // IDisposable
        sb.AppendLine("// IDisposable");
        sb.AppendLine("public void Dispose()");
        using (sb.CurlyBrace())
        {
            sb.AppendLine("if (_disposeSourceMods == null) return;");
            sb.AppendLine();
            sb.AppendLine("foreach (var mod in _disposeSourceMods)");
            using (sb.CurlyBrace())
            {
                sb.AppendLine("mod.Dispose();");
            }
        }
    }

    private string GetGroupRecordType(LoquiType loqui)
    {
        // Get the contained record type from the group's generic parameter
        if (loqui.GenericSpecification?.Specifications.TryGetValue("T", out var getterType) == true)
        {
            // The getterType might be fully qualified (e.g., "ISkyrim.GameSettingGetter") or simple (e.g., "IGameSettingGetter")
            // We need to return just the class name without namespace, I prefix, and Getter suffix
            // E.g., "ISkyrim.GameSettingGetter" -> "GameSetting" or "IGameSettingGetter" -> "GameSetting"
            var typeName = getterType;

            // Remove namespace qualifier if present (e.g., "ISkyrim.GameSettingGetter" -> "GameSettingGetter")
            if (typeName.Contains("."))
            {
                typeName = typeName.Substring(typeName.LastIndexOf('.') + 1);
            }

            // Remove "Getter" suffix first (e.g., "IGameSettingGetter" -> "IGameSetting")
            typeName = typeName.TrimStringFromEnd("Getter");

            // Remove "I" prefix if it's an interface prefix (e.g., "IGameSetting" -> "GameSetting")
            // Only remove if it's followed by an uppercase letter (to avoid removing "I" from types like "Ingredient")
            if (typeName.StartsWith("I") && typeName.Length > 1 && char.IsUpper(typeName[1]))
            {
                typeName = typeName.Substring(1);
            }

            return typeName;
        }

        throw new ArgumentException($"Could not determine record type for group {loqui.Name}");
    }

    private bool IsListGroup(LoquiType loqui)
    {
        // Check if this is a list group (like Cells) by looking at the type
        // List groups implement IListGroupGetter
        return loqui.TypeName(getter: true).Contains("ListGroup");
    }
}
