/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Autogenerated by Loqui.  Do not manually change.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*/
#region Usings
using Loqui;
using Loqui.Interfaces;
using Loqui.Internal;
using Mutagen.Bethesda.Binary;
using Mutagen.Bethesda.Fallout3.Internals;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Binary.Headers;
using Mutagen.Bethesda.Plugins.Binary.Overlay;
using Mutagen.Bethesda.Plugins.Binary.Streams;
using Mutagen.Bethesda.Plugins.Binary.Translations;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Exceptions;
using Mutagen.Bethesda.Plugins.Internals;
using Mutagen.Bethesda.Plugins.Meta;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Plugins.Records.Internals;
using Mutagen.Bethesda.Plugins.Records.Mapping;
using Mutagen.Bethesda.Translations.Binary;
using Noggog;
using Noggog.StructuredStrings;
using Noggog.StructuredStrings.CSharp;
using RecordTypeInts = Mutagen.Bethesda.Fallout3.Internals.RecordTypeInts;
using RecordTypes = Mutagen.Bethesda.Fallout3.Internals.RecordTypes;
using System.Buffers.Binary;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Reactive.Disposables;
using System.Reactive.Linq;
#endregion

#nullable enable
namespace Mutagen.Bethesda.Fallout3
{
    #region Class
    public partial class MagicEffectData :
        IEquatable<IMagicEffectDataGetter>,
        ILoquiObjectSetter<MagicEffectData>,
        IMagicEffectData
    {
        #region Ctor
        public MagicEffectData()
        {
            CustomCtor();
        }
        partial void CustomCtor();
        #endregion

        #region Flags
        public MagicEffect.MagicFlag Flags { get; set; } = default(MagicEffect.MagicFlag);
        #endregion
        #region BaseCost
        public Single BaseCost { get; set; } = default(Single);
        #endregion
        #region Unused
        public Int32 Unused { get; set; } = default(Int32);
        #endregion
        #region Resistance
        public ActorValue Resistance { get; set; } = default(ActorValue);
        #endregion
        #region CounterEffectCount
        public UInt32 CounterEffectCount { get; set; } = default(UInt32);
        #endregion
        #region Light
        private readonly IFormLink<ILightGetter> _Light = new FormLink<ILightGetter>();
        public IFormLink<ILightGetter> Light
        {
            get => _Light;
            set => _Light.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<ILightGetter> IMagicEffectDataGetter.Light => this.Light;
        #endregion
        #region ProjectileSpeed
        public Single ProjectileSpeed { get; set; } = default(Single);
        #endregion
        #region EffectShader
        private readonly IFormLink<IEffectShaderGetter> _EffectShader = new FormLink<IEffectShaderGetter>();
        public IFormLink<IEffectShaderGetter> EffectShader
        {
            get => _EffectShader;
            set => _EffectShader.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IEffectShaderGetter> IMagicEffectDataGetter.EffectShader => this.EffectShader;
        #endregion
        #region ObjectDisplayShader
        private readonly IFormLink<IEffectShaderGetter> _ObjectDisplayShader = new FormLink<IEffectShaderGetter>();
        public IFormLink<IEffectShaderGetter> ObjectDisplayShader
        {
            get => _ObjectDisplayShader;
            set => _ObjectDisplayShader.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IEffectShaderGetter> IMagicEffectDataGetter.ObjectDisplayShader => this.ObjectDisplayShader;
        #endregion
        #region EffectSound
        private readonly IFormLink<ISoundGetter> _EffectSound = new FormLink<ISoundGetter>();
        public IFormLink<ISoundGetter> EffectSound
        {
            get => _EffectSound;
            set => _EffectSound.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<ISoundGetter> IMagicEffectDataGetter.EffectSound => this.EffectSound;
        #endregion
        #region BoltSound
        private readonly IFormLink<ISoundGetter> _BoltSound = new FormLink<ISoundGetter>();
        public IFormLink<ISoundGetter> BoltSound
        {
            get => _BoltSound;
            set => _BoltSound.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<ISoundGetter> IMagicEffectDataGetter.BoltSound => this.BoltSound;
        #endregion
        #region HitSound
        private readonly IFormLink<ISoundGetter> _HitSound = new FormLink<ISoundGetter>();
        public IFormLink<ISoundGetter> HitSound
        {
            get => _HitSound;
            set => _HitSound.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<ISoundGetter> IMagicEffectDataGetter.HitSound => this.HitSound;
        #endregion
        #region AreaSound
        private readonly IFormLink<ISoundGetter> _AreaSound = new FormLink<ISoundGetter>();
        public IFormLink<ISoundGetter> AreaSound
        {
            get => _AreaSound;
            set => _AreaSound.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<ISoundGetter> IMagicEffectDataGetter.AreaSound => this.AreaSound;
        #endregion
        #region ConstantEffectEnchantmentFactor
        public Single ConstantEffectEnchantmentFactor { get; set; } = default(Single);
        #endregion
        #region ConstantEffectBarterFactor
        public Single ConstantEffectBarterFactor { get; set; } = default(Single);
        #endregion
        #region Archetype
        public MagicEffect.ArchetypeEnum Archetype { get; set; } = default(MagicEffect.ArchetypeEnum);
        #endregion
        #region ActorValue
        public static readonly ActorValue ActorValueDefault = ActorValue.None;
        public ActorValue ActorValue { get; set; } = ActorValueDefault;
        #endregion

        #region To String

        public void Print(
            StructuredStringBuilder sb,
            string? name = null)
        {
            MagicEffectDataMixIn.Print(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is not IMagicEffectDataGetter rhs) return false;
            return ((MagicEffectDataCommon)((IMagicEffectDataGetter)this).CommonInstance()!).Equals(this, rhs, equalsMask: null);
        }

        public bool Equals(IMagicEffectDataGetter? obj)
        {
            return ((MagicEffectDataCommon)((IMagicEffectDataGetter)this).CommonInstance()!).Equals(this, obj, equalsMask: null);
        }

        public override int GetHashCode() => ((MagicEffectDataCommon)((IMagicEffectDataGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        #region Mask
        public class Mask<TItem> :
            IEquatable<Mask<TItem>>,
            IMask<TItem>
        {
            #region Ctors
            public Mask(TItem initialValue)
            {
                this.Flags = initialValue;
                this.BaseCost = initialValue;
                this.Unused = initialValue;
                this.Resistance = initialValue;
                this.CounterEffectCount = initialValue;
                this.Light = initialValue;
                this.ProjectileSpeed = initialValue;
                this.EffectShader = initialValue;
                this.ObjectDisplayShader = initialValue;
                this.EffectSound = initialValue;
                this.BoltSound = initialValue;
                this.HitSound = initialValue;
                this.AreaSound = initialValue;
                this.ConstantEffectEnchantmentFactor = initialValue;
                this.ConstantEffectBarterFactor = initialValue;
                this.Archetype = initialValue;
                this.ActorValue = initialValue;
            }

            public Mask(
                TItem Flags,
                TItem BaseCost,
                TItem Unused,
                TItem Resistance,
                TItem CounterEffectCount,
                TItem Light,
                TItem ProjectileSpeed,
                TItem EffectShader,
                TItem ObjectDisplayShader,
                TItem EffectSound,
                TItem BoltSound,
                TItem HitSound,
                TItem AreaSound,
                TItem ConstantEffectEnchantmentFactor,
                TItem ConstantEffectBarterFactor,
                TItem Archetype,
                TItem ActorValue)
            {
                this.Flags = Flags;
                this.BaseCost = BaseCost;
                this.Unused = Unused;
                this.Resistance = Resistance;
                this.CounterEffectCount = CounterEffectCount;
                this.Light = Light;
                this.ProjectileSpeed = ProjectileSpeed;
                this.EffectShader = EffectShader;
                this.ObjectDisplayShader = ObjectDisplayShader;
                this.EffectSound = EffectSound;
                this.BoltSound = BoltSound;
                this.HitSound = HitSound;
                this.AreaSound = AreaSound;
                this.ConstantEffectEnchantmentFactor = ConstantEffectEnchantmentFactor;
                this.ConstantEffectBarterFactor = ConstantEffectBarterFactor;
                this.Archetype = Archetype;
                this.ActorValue = ActorValue;
            }

            #pragma warning disable CS8618
            protected Mask()
            {
            }
            #pragma warning restore CS8618

            #endregion

            #region Members
            public TItem Flags;
            public TItem BaseCost;
            public TItem Unused;
            public TItem Resistance;
            public TItem CounterEffectCount;
            public TItem Light;
            public TItem ProjectileSpeed;
            public TItem EffectShader;
            public TItem ObjectDisplayShader;
            public TItem EffectSound;
            public TItem BoltSound;
            public TItem HitSound;
            public TItem AreaSound;
            public TItem ConstantEffectEnchantmentFactor;
            public TItem ConstantEffectBarterFactor;
            public TItem Archetype;
            public TItem ActorValue;
            #endregion

            #region Equals
            public override bool Equals(object? obj)
            {
                if (!(obj is Mask<TItem> rhs)) return false;
                return Equals(rhs);
            }

            public bool Equals(Mask<TItem>? rhs)
            {
                if (rhs == null) return false;
                if (!object.Equals(this.Flags, rhs.Flags)) return false;
                if (!object.Equals(this.BaseCost, rhs.BaseCost)) return false;
                if (!object.Equals(this.Unused, rhs.Unused)) return false;
                if (!object.Equals(this.Resistance, rhs.Resistance)) return false;
                if (!object.Equals(this.CounterEffectCount, rhs.CounterEffectCount)) return false;
                if (!object.Equals(this.Light, rhs.Light)) return false;
                if (!object.Equals(this.ProjectileSpeed, rhs.ProjectileSpeed)) return false;
                if (!object.Equals(this.EffectShader, rhs.EffectShader)) return false;
                if (!object.Equals(this.ObjectDisplayShader, rhs.ObjectDisplayShader)) return false;
                if (!object.Equals(this.EffectSound, rhs.EffectSound)) return false;
                if (!object.Equals(this.BoltSound, rhs.BoltSound)) return false;
                if (!object.Equals(this.HitSound, rhs.HitSound)) return false;
                if (!object.Equals(this.AreaSound, rhs.AreaSound)) return false;
                if (!object.Equals(this.ConstantEffectEnchantmentFactor, rhs.ConstantEffectEnchantmentFactor)) return false;
                if (!object.Equals(this.ConstantEffectBarterFactor, rhs.ConstantEffectBarterFactor)) return false;
                if (!object.Equals(this.Archetype, rhs.Archetype)) return false;
                if (!object.Equals(this.ActorValue, rhs.ActorValue)) return false;
                return true;
            }
            public override int GetHashCode()
            {
                var hash = new HashCode();
                hash.Add(this.Flags);
                hash.Add(this.BaseCost);
                hash.Add(this.Unused);
                hash.Add(this.Resistance);
                hash.Add(this.CounterEffectCount);
                hash.Add(this.Light);
                hash.Add(this.ProjectileSpeed);
                hash.Add(this.EffectShader);
                hash.Add(this.ObjectDisplayShader);
                hash.Add(this.EffectSound);
                hash.Add(this.BoltSound);
                hash.Add(this.HitSound);
                hash.Add(this.AreaSound);
                hash.Add(this.ConstantEffectEnchantmentFactor);
                hash.Add(this.ConstantEffectBarterFactor);
                hash.Add(this.Archetype);
                hash.Add(this.ActorValue);
                return hash.ToHashCode();
            }

            #endregion

            #region All
            public bool All(Func<TItem, bool> eval)
            {
                if (!eval(this.Flags)) return false;
                if (!eval(this.BaseCost)) return false;
                if (!eval(this.Unused)) return false;
                if (!eval(this.Resistance)) return false;
                if (!eval(this.CounterEffectCount)) return false;
                if (!eval(this.Light)) return false;
                if (!eval(this.ProjectileSpeed)) return false;
                if (!eval(this.EffectShader)) return false;
                if (!eval(this.ObjectDisplayShader)) return false;
                if (!eval(this.EffectSound)) return false;
                if (!eval(this.BoltSound)) return false;
                if (!eval(this.HitSound)) return false;
                if (!eval(this.AreaSound)) return false;
                if (!eval(this.ConstantEffectEnchantmentFactor)) return false;
                if (!eval(this.ConstantEffectBarterFactor)) return false;
                if (!eval(this.Archetype)) return false;
                if (!eval(this.ActorValue)) return false;
                return true;
            }
            #endregion

            #region Any
            public bool Any(Func<TItem, bool> eval)
            {
                if (eval(this.Flags)) return true;
                if (eval(this.BaseCost)) return true;
                if (eval(this.Unused)) return true;
                if (eval(this.Resistance)) return true;
                if (eval(this.CounterEffectCount)) return true;
                if (eval(this.Light)) return true;
                if (eval(this.ProjectileSpeed)) return true;
                if (eval(this.EffectShader)) return true;
                if (eval(this.ObjectDisplayShader)) return true;
                if (eval(this.EffectSound)) return true;
                if (eval(this.BoltSound)) return true;
                if (eval(this.HitSound)) return true;
                if (eval(this.AreaSound)) return true;
                if (eval(this.ConstantEffectEnchantmentFactor)) return true;
                if (eval(this.ConstantEffectBarterFactor)) return true;
                if (eval(this.Archetype)) return true;
                if (eval(this.ActorValue)) return true;
                return false;
            }
            #endregion

            #region Translate
            public Mask<R> Translate<R>(Func<TItem, R> eval)
            {
                var ret = new MagicEffectData.Mask<R>();
                this.Translate_InternalFill(ret, eval);
                return ret;
            }

            protected void Translate_InternalFill<R>(Mask<R> obj, Func<TItem, R> eval)
            {
                obj.Flags = eval(this.Flags);
                obj.BaseCost = eval(this.BaseCost);
                obj.Unused = eval(this.Unused);
                obj.Resistance = eval(this.Resistance);
                obj.CounterEffectCount = eval(this.CounterEffectCount);
                obj.Light = eval(this.Light);
                obj.ProjectileSpeed = eval(this.ProjectileSpeed);
                obj.EffectShader = eval(this.EffectShader);
                obj.ObjectDisplayShader = eval(this.ObjectDisplayShader);
                obj.EffectSound = eval(this.EffectSound);
                obj.BoltSound = eval(this.BoltSound);
                obj.HitSound = eval(this.HitSound);
                obj.AreaSound = eval(this.AreaSound);
                obj.ConstantEffectEnchantmentFactor = eval(this.ConstantEffectEnchantmentFactor);
                obj.ConstantEffectBarterFactor = eval(this.ConstantEffectBarterFactor);
                obj.Archetype = eval(this.Archetype);
                obj.ActorValue = eval(this.ActorValue);
            }
            #endregion

            #region To String
            public override string ToString() => this.Print();

            public string Print(MagicEffectData.Mask<bool>? printMask = null)
            {
                var sb = new StructuredStringBuilder();
                Print(sb, printMask);
                return sb.ToString();
            }

            public void Print(StructuredStringBuilder sb, MagicEffectData.Mask<bool>? printMask = null)
            {
                sb.AppendLine($"{nameof(MagicEffectData.Mask<TItem>)} =>");
                using (sb.Brace())
                {
                    if (printMask?.Flags ?? true)
                    {
                        sb.AppendItem(Flags, "Flags");
                    }
                    if (printMask?.BaseCost ?? true)
                    {
                        sb.AppendItem(BaseCost, "BaseCost");
                    }
                    if (printMask?.Unused ?? true)
                    {
                        sb.AppendItem(Unused, "Unused");
                    }
                    if (printMask?.Resistance ?? true)
                    {
                        sb.AppendItem(Resistance, "Resistance");
                    }
                    if (printMask?.CounterEffectCount ?? true)
                    {
                        sb.AppendItem(CounterEffectCount, "CounterEffectCount");
                    }
                    if (printMask?.Light ?? true)
                    {
                        sb.AppendItem(Light, "Light");
                    }
                    if (printMask?.ProjectileSpeed ?? true)
                    {
                        sb.AppendItem(ProjectileSpeed, "ProjectileSpeed");
                    }
                    if (printMask?.EffectShader ?? true)
                    {
                        sb.AppendItem(EffectShader, "EffectShader");
                    }
                    if (printMask?.ObjectDisplayShader ?? true)
                    {
                        sb.AppendItem(ObjectDisplayShader, "ObjectDisplayShader");
                    }
                    if (printMask?.EffectSound ?? true)
                    {
                        sb.AppendItem(EffectSound, "EffectSound");
                    }
                    if (printMask?.BoltSound ?? true)
                    {
                        sb.AppendItem(BoltSound, "BoltSound");
                    }
                    if (printMask?.HitSound ?? true)
                    {
                        sb.AppendItem(HitSound, "HitSound");
                    }
                    if (printMask?.AreaSound ?? true)
                    {
                        sb.AppendItem(AreaSound, "AreaSound");
                    }
                    if (printMask?.ConstantEffectEnchantmentFactor ?? true)
                    {
                        sb.AppendItem(ConstantEffectEnchantmentFactor, "ConstantEffectEnchantmentFactor");
                    }
                    if (printMask?.ConstantEffectBarterFactor ?? true)
                    {
                        sb.AppendItem(ConstantEffectBarterFactor, "ConstantEffectBarterFactor");
                    }
                    if (printMask?.Archetype ?? true)
                    {
                        sb.AppendItem(Archetype, "Archetype");
                    }
                    if (printMask?.ActorValue ?? true)
                    {
                        sb.AppendItem(ActorValue, "ActorValue");
                    }
                }
            }
            #endregion

        }

        public class ErrorMask :
            IErrorMask,
            IErrorMask<ErrorMask>
        {
            #region Members
            public Exception? Overall { get; set; }
            private List<string>? _warnings;
            public List<string> Warnings
            {
                get
                {
                    if (_warnings == null)
                    {
                        _warnings = new List<string>();
                    }
                    return _warnings;
                }
            }
            public Exception? Flags;
            public Exception? BaseCost;
            public Exception? Unused;
            public Exception? Resistance;
            public Exception? CounterEffectCount;
            public Exception? Light;
            public Exception? ProjectileSpeed;
            public Exception? EffectShader;
            public Exception? ObjectDisplayShader;
            public Exception? EffectSound;
            public Exception? BoltSound;
            public Exception? HitSound;
            public Exception? AreaSound;
            public Exception? ConstantEffectEnchantmentFactor;
            public Exception? ConstantEffectBarterFactor;
            public Exception? Archetype;
            public Exception? ActorValue;
            #endregion

            #region IErrorMask
            public object? GetNthMask(int index)
            {
                MagicEffectData_FieldIndex enu = (MagicEffectData_FieldIndex)index;
                switch (enu)
                {
                    case MagicEffectData_FieldIndex.Flags:
                        return Flags;
                    case MagicEffectData_FieldIndex.BaseCost:
                        return BaseCost;
                    case MagicEffectData_FieldIndex.Unused:
                        return Unused;
                    case MagicEffectData_FieldIndex.Resistance:
                        return Resistance;
                    case MagicEffectData_FieldIndex.CounterEffectCount:
                        return CounterEffectCount;
                    case MagicEffectData_FieldIndex.Light:
                        return Light;
                    case MagicEffectData_FieldIndex.ProjectileSpeed:
                        return ProjectileSpeed;
                    case MagicEffectData_FieldIndex.EffectShader:
                        return EffectShader;
                    case MagicEffectData_FieldIndex.ObjectDisplayShader:
                        return ObjectDisplayShader;
                    case MagicEffectData_FieldIndex.EffectSound:
                        return EffectSound;
                    case MagicEffectData_FieldIndex.BoltSound:
                        return BoltSound;
                    case MagicEffectData_FieldIndex.HitSound:
                        return HitSound;
                    case MagicEffectData_FieldIndex.AreaSound:
                        return AreaSound;
                    case MagicEffectData_FieldIndex.ConstantEffectEnchantmentFactor:
                        return ConstantEffectEnchantmentFactor;
                    case MagicEffectData_FieldIndex.ConstantEffectBarterFactor:
                        return ConstantEffectBarterFactor;
                    case MagicEffectData_FieldIndex.Archetype:
                        return Archetype;
                    case MagicEffectData_FieldIndex.ActorValue:
                        return ActorValue;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthException(int index, Exception ex)
            {
                MagicEffectData_FieldIndex enu = (MagicEffectData_FieldIndex)index;
                switch (enu)
                {
                    case MagicEffectData_FieldIndex.Flags:
                        this.Flags = ex;
                        break;
                    case MagicEffectData_FieldIndex.BaseCost:
                        this.BaseCost = ex;
                        break;
                    case MagicEffectData_FieldIndex.Unused:
                        this.Unused = ex;
                        break;
                    case MagicEffectData_FieldIndex.Resistance:
                        this.Resistance = ex;
                        break;
                    case MagicEffectData_FieldIndex.CounterEffectCount:
                        this.CounterEffectCount = ex;
                        break;
                    case MagicEffectData_FieldIndex.Light:
                        this.Light = ex;
                        break;
                    case MagicEffectData_FieldIndex.ProjectileSpeed:
                        this.ProjectileSpeed = ex;
                        break;
                    case MagicEffectData_FieldIndex.EffectShader:
                        this.EffectShader = ex;
                        break;
                    case MagicEffectData_FieldIndex.ObjectDisplayShader:
                        this.ObjectDisplayShader = ex;
                        break;
                    case MagicEffectData_FieldIndex.EffectSound:
                        this.EffectSound = ex;
                        break;
                    case MagicEffectData_FieldIndex.BoltSound:
                        this.BoltSound = ex;
                        break;
                    case MagicEffectData_FieldIndex.HitSound:
                        this.HitSound = ex;
                        break;
                    case MagicEffectData_FieldIndex.AreaSound:
                        this.AreaSound = ex;
                        break;
                    case MagicEffectData_FieldIndex.ConstantEffectEnchantmentFactor:
                        this.ConstantEffectEnchantmentFactor = ex;
                        break;
                    case MagicEffectData_FieldIndex.ConstantEffectBarterFactor:
                        this.ConstantEffectBarterFactor = ex;
                        break;
                    case MagicEffectData_FieldIndex.Archetype:
                        this.Archetype = ex;
                        break;
                    case MagicEffectData_FieldIndex.ActorValue:
                        this.ActorValue = ex;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthMask(int index, object obj)
            {
                MagicEffectData_FieldIndex enu = (MagicEffectData_FieldIndex)index;
                switch (enu)
                {
                    case MagicEffectData_FieldIndex.Flags:
                        this.Flags = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.BaseCost:
                        this.BaseCost = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.Unused:
                        this.Unused = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.Resistance:
                        this.Resistance = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.CounterEffectCount:
                        this.CounterEffectCount = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.Light:
                        this.Light = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.ProjectileSpeed:
                        this.ProjectileSpeed = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.EffectShader:
                        this.EffectShader = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.ObjectDisplayShader:
                        this.ObjectDisplayShader = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.EffectSound:
                        this.EffectSound = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.BoltSound:
                        this.BoltSound = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.HitSound:
                        this.HitSound = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.AreaSound:
                        this.AreaSound = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.ConstantEffectEnchantmentFactor:
                        this.ConstantEffectEnchantmentFactor = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.ConstantEffectBarterFactor:
                        this.ConstantEffectBarterFactor = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.Archetype:
                        this.Archetype = (Exception?)obj;
                        break;
                    case MagicEffectData_FieldIndex.ActorValue:
                        this.ActorValue = (Exception?)obj;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public bool IsInError()
            {
                if (Overall != null) return true;
                if (Flags != null) return true;
                if (BaseCost != null) return true;
                if (Unused != null) return true;
                if (Resistance != null) return true;
                if (CounterEffectCount != null) return true;
                if (Light != null) return true;
                if (ProjectileSpeed != null) return true;
                if (EffectShader != null) return true;
                if (ObjectDisplayShader != null) return true;
                if (EffectSound != null) return true;
                if (BoltSound != null) return true;
                if (HitSound != null) return true;
                if (AreaSound != null) return true;
                if (ConstantEffectEnchantmentFactor != null) return true;
                if (ConstantEffectBarterFactor != null) return true;
                if (Archetype != null) return true;
                if (ActorValue != null) return true;
                return false;
            }
            #endregion

            #region To String
            public override string ToString() => this.Print();

            public void Print(StructuredStringBuilder sb, string? name = null)
            {
                sb.AppendLine($"{(name ?? "ErrorMask")} =>");
                using (sb.Brace())
                {
                    if (this.Overall != null)
                    {
                        sb.AppendLine("Overall =>");
                        using (sb.Brace())
                        {
                            sb.AppendLine($"{this.Overall}");
                        }
                    }
                    PrintFillInternal(sb);
                }
            }
            protected void PrintFillInternal(StructuredStringBuilder sb)
            {
                {
                    sb.AppendItem(Flags, "Flags");
                }
                {
                    sb.AppendItem(BaseCost, "BaseCost");
                }
                {
                    sb.AppendItem(Unused, "Unused");
                }
                {
                    sb.AppendItem(Resistance, "Resistance");
                }
                {
                    sb.AppendItem(CounterEffectCount, "CounterEffectCount");
                }
                {
                    sb.AppendItem(Light, "Light");
                }
                {
                    sb.AppendItem(ProjectileSpeed, "ProjectileSpeed");
                }
                {
                    sb.AppendItem(EffectShader, "EffectShader");
                }
                {
                    sb.AppendItem(ObjectDisplayShader, "ObjectDisplayShader");
                }
                {
                    sb.AppendItem(EffectSound, "EffectSound");
                }
                {
                    sb.AppendItem(BoltSound, "BoltSound");
                }
                {
                    sb.AppendItem(HitSound, "HitSound");
                }
                {
                    sb.AppendItem(AreaSound, "AreaSound");
                }
                {
                    sb.AppendItem(ConstantEffectEnchantmentFactor, "ConstantEffectEnchantmentFactor");
                }
                {
                    sb.AppendItem(ConstantEffectBarterFactor, "ConstantEffectBarterFactor");
                }
                {
                    sb.AppendItem(Archetype, "Archetype");
                }
                {
                    sb.AppendItem(ActorValue, "ActorValue");
                }
            }
            #endregion

            #region Combine
            public ErrorMask Combine(ErrorMask? rhs)
            {
                if (rhs == null) return this;
                var ret = new ErrorMask();
                ret.Flags = this.Flags.Combine(rhs.Flags);
                ret.BaseCost = this.BaseCost.Combine(rhs.BaseCost);
                ret.Unused = this.Unused.Combine(rhs.Unused);
                ret.Resistance = this.Resistance.Combine(rhs.Resistance);
                ret.CounterEffectCount = this.CounterEffectCount.Combine(rhs.CounterEffectCount);
                ret.Light = this.Light.Combine(rhs.Light);
                ret.ProjectileSpeed = this.ProjectileSpeed.Combine(rhs.ProjectileSpeed);
                ret.EffectShader = this.EffectShader.Combine(rhs.EffectShader);
                ret.ObjectDisplayShader = this.ObjectDisplayShader.Combine(rhs.ObjectDisplayShader);
                ret.EffectSound = this.EffectSound.Combine(rhs.EffectSound);
                ret.BoltSound = this.BoltSound.Combine(rhs.BoltSound);
                ret.HitSound = this.HitSound.Combine(rhs.HitSound);
                ret.AreaSound = this.AreaSound.Combine(rhs.AreaSound);
                ret.ConstantEffectEnchantmentFactor = this.ConstantEffectEnchantmentFactor.Combine(rhs.ConstantEffectEnchantmentFactor);
                ret.ConstantEffectBarterFactor = this.ConstantEffectBarterFactor.Combine(rhs.ConstantEffectBarterFactor);
                ret.Archetype = this.Archetype.Combine(rhs.Archetype);
                ret.ActorValue = this.ActorValue.Combine(rhs.ActorValue);
                return ret;
            }
            public static ErrorMask? Combine(ErrorMask? lhs, ErrorMask? rhs)
            {
                if (lhs != null && rhs != null) return lhs.Combine(rhs);
                return lhs ?? rhs;
            }
            #endregion

            #region Factory
            public static ErrorMask Factory(ErrorMaskBuilder errorMask)
            {
                return new ErrorMask();
            }
            #endregion

        }
        public class TranslationMask : ITranslationMask
        {
            #region Members
            private TranslationCrystal? _crystal;
            public readonly bool DefaultOn;
            public bool OnOverall;
            public bool Flags;
            public bool BaseCost;
            public bool Unused;
            public bool Resistance;
            public bool CounterEffectCount;
            public bool Light;
            public bool ProjectileSpeed;
            public bool EffectShader;
            public bool ObjectDisplayShader;
            public bool EffectSound;
            public bool BoltSound;
            public bool HitSound;
            public bool AreaSound;
            public bool ConstantEffectEnchantmentFactor;
            public bool ConstantEffectBarterFactor;
            public bool Archetype;
            public bool ActorValue;
            #endregion

            #region Ctors
            public TranslationMask(
                bool defaultOn,
                bool onOverall = true)
            {
                this.DefaultOn = defaultOn;
                this.OnOverall = onOverall;
                this.Flags = defaultOn;
                this.BaseCost = defaultOn;
                this.Unused = defaultOn;
                this.Resistance = defaultOn;
                this.CounterEffectCount = defaultOn;
                this.Light = defaultOn;
                this.ProjectileSpeed = defaultOn;
                this.EffectShader = defaultOn;
                this.ObjectDisplayShader = defaultOn;
                this.EffectSound = defaultOn;
                this.BoltSound = defaultOn;
                this.HitSound = defaultOn;
                this.AreaSound = defaultOn;
                this.ConstantEffectEnchantmentFactor = defaultOn;
                this.ConstantEffectBarterFactor = defaultOn;
                this.Archetype = defaultOn;
                this.ActorValue = defaultOn;
            }

            #endregion

            public TranslationCrystal GetCrystal()
            {
                if (_crystal != null) return _crystal;
                var ret = new List<(bool On, TranslationCrystal? SubCrystal)>();
                GetCrystal(ret);
                _crystal = new TranslationCrystal(ret.ToArray());
                return _crystal;
            }

            protected void GetCrystal(List<(bool On, TranslationCrystal? SubCrystal)> ret)
            {
                ret.Add((Flags, null));
                ret.Add((BaseCost, null));
                ret.Add((Unused, null));
                ret.Add((Resistance, null));
                ret.Add((CounterEffectCount, null));
                ret.Add((Light, null));
                ret.Add((ProjectileSpeed, null));
                ret.Add((EffectShader, null));
                ret.Add((ObjectDisplayShader, null));
                ret.Add((EffectSound, null));
                ret.Add((BoltSound, null));
                ret.Add((HitSound, null));
                ret.Add((AreaSound, null));
                ret.Add((ConstantEffectEnchantmentFactor, null));
                ret.Add((ConstantEffectBarterFactor, null));
                ret.Add((Archetype, null));
                ret.Add((ActorValue, null));
            }

            public static implicit operator TranslationMask(bool defaultOn)
            {
                return new TranslationMask(defaultOn: defaultOn, onOverall: defaultOn);
            }

        }
        #endregion

        #region Mutagen
        public IEnumerable<IFormLinkGetter> EnumerateFormLinks() => MagicEffectDataCommon.Instance.EnumerateFormLinks(this);
        public void RemapLinks(IReadOnlyDictionary<FormKey, FormKey> mapping) => MagicEffectDataSetterCommon.Instance.RemapLinks(this, mapping);
        #endregion

        #region Binary Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => MagicEffectDataBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((MagicEffectDataBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }
        #region Binary Create
        public static MagicEffectData CreateFromBinary(
            MutagenFrame frame,
            TypedParseParams translationParams = default)
        {
            var ret = new MagicEffectData();
            ((MagicEffectDataSetterCommon)((IMagicEffectDataGetter)ret).CommonSetterInstance()!).CopyInFromBinary(
                item: ret,
                frame: frame,
                translationParams: translationParams);
            return ret;
        }

        #endregion

        public static bool TryCreateFromBinary(
            MutagenFrame frame,
            out MagicEffectData item,
            TypedParseParams translationParams = default)
        {
            var startPos = frame.Position;
            item = CreateFromBinary(
                frame: frame,
                translationParams: translationParams);
            return startPos != frame.Position;
        }
        #endregion

        void IPrintable.Print(StructuredStringBuilder sb, string? name) => this.Print(sb, name);

        void IClearable.Clear()
        {
            ((MagicEffectDataSetterCommon)((IMagicEffectDataGetter)this).CommonSetterInstance()!).Clear(this);
        }

        internal static MagicEffectData GetNew()
        {
            return new MagicEffectData();
        }

    }
    #endregion

    #region Interface
    public partial interface IMagicEffectData :
        IFormLinkContainer,
        ILoquiObjectSetter<IMagicEffectData>,
        IMagicEffectDataGetter
    {
        new MagicEffect.MagicFlag Flags { get; set; }
        new Single BaseCost { get; set; }
        new Int32 Unused { get; set; }
        new ActorValue Resistance { get; set; }
        new UInt32 CounterEffectCount { get; set; }
        new IFormLink<ILightGetter> Light { get; set; }
        new Single ProjectileSpeed { get; set; }
        new IFormLink<IEffectShaderGetter> EffectShader { get; set; }
        new IFormLink<IEffectShaderGetter> ObjectDisplayShader { get; set; }
        new IFormLink<ISoundGetter> EffectSound { get; set; }
        new IFormLink<ISoundGetter> BoltSound { get; set; }
        new IFormLink<ISoundGetter> HitSound { get; set; }
        new IFormLink<ISoundGetter> AreaSound { get; set; }
        new Single ConstantEffectEnchantmentFactor { get; set; }
        new Single ConstantEffectBarterFactor { get; set; }
        new MagicEffect.ArchetypeEnum Archetype { get; set; }
        new ActorValue ActorValue { get; set; }
    }

    public partial interface IMagicEffectDataGetter :
        ILoquiObject,
        IBinaryItem,
        IFormLinkContainerGetter,
        ILoquiObject<IMagicEffectDataGetter>
    {
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object? CommonSetterInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonSetterTranslationInstance();
        static ILoquiRegistration StaticRegistration => MagicEffectData_Registration.Instance;
        MagicEffect.MagicFlag Flags { get; }
        Single BaseCost { get; }
        Int32 Unused { get; }
        ActorValue Resistance { get; }
        UInt32 CounterEffectCount { get; }
        IFormLinkGetter<ILightGetter> Light { get; }
        Single ProjectileSpeed { get; }
        IFormLinkGetter<IEffectShaderGetter> EffectShader { get; }
        IFormLinkGetter<IEffectShaderGetter> ObjectDisplayShader { get; }
        IFormLinkGetter<ISoundGetter> EffectSound { get; }
        IFormLinkGetter<ISoundGetter> BoltSound { get; }
        IFormLinkGetter<ISoundGetter> HitSound { get; }
        IFormLinkGetter<ISoundGetter> AreaSound { get; }
        Single ConstantEffectEnchantmentFactor { get; }
        Single ConstantEffectBarterFactor { get; }
        MagicEffect.ArchetypeEnum Archetype { get; }
        ActorValue ActorValue { get; }

    }

    #endregion

    #region Common MixIn
    public static partial class MagicEffectDataMixIn
    {
        public static void Clear(this IMagicEffectData item)
        {
            ((MagicEffectDataSetterCommon)((IMagicEffectDataGetter)item).CommonSetterInstance()!).Clear(item: item);
        }

        public static MagicEffectData.Mask<bool> GetEqualsMask(
            this IMagicEffectDataGetter item,
            IMagicEffectDataGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            return ((MagicEffectDataCommon)((IMagicEffectDataGetter)item).CommonInstance()!).GetEqualsMask(
                item: item,
                rhs: rhs,
                include: include);
        }

        public static string Print(
            this IMagicEffectDataGetter item,
            string? name = null,
            MagicEffectData.Mask<bool>? printMask = null)
        {
            return ((MagicEffectDataCommon)((IMagicEffectDataGetter)item).CommonInstance()!).Print(
                item: item,
                name: name,
                printMask: printMask);
        }

        public static void Print(
            this IMagicEffectDataGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            MagicEffectData.Mask<bool>? printMask = null)
        {
            ((MagicEffectDataCommon)((IMagicEffectDataGetter)item).CommonInstance()!).Print(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
        }

        public static bool Equals(
            this IMagicEffectDataGetter item,
            IMagicEffectDataGetter rhs,
            MagicEffectData.TranslationMask? equalsMask = null)
        {
            return ((MagicEffectDataCommon)((IMagicEffectDataGetter)item).CommonInstance()!).Equals(
                lhs: item,
                rhs: rhs,
                equalsMask: equalsMask?.GetCrystal());
        }

        public static void DeepCopyIn(
            this IMagicEffectData lhs,
            IMagicEffectDataGetter rhs)
        {
            ((MagicEffectDataSetterTranslationCommon)((IMagicEffectDataGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: default,
                deepCopy: false);
        }

        public static void DeepCopyIn(
            this IMagicEffectData lhs,
            IMagicEffectDataGetter rhs,
            MagicEffectData.TranslationMask? copyMask = null)
        {
            ((MagicEffectDataSetterTranslationCommon)((IMagicEffectDataGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
        }

        public static void DeepCopyIn(
            this IMagicEffectData lhs,
            IMagicEffectDataGetter rhs,
            out MagicEffectData.ErrorMask errorMask,
            MagicEffectData.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            ((MagicEffectDataSetterTranslationCommon)((IMagicEffectDataGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
            errorMask = MagicEffectData.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void DeepCopyIn(
            this IMagicEffectData lhs,
            IMagicEffectDataGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            ((MagicEffectDataSetterTranslationCommon)((IMagicEffectDataGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: false);
        }

        public static MagicEffectData DeepCopy(
            this IMagicEffectDataGetter item,
            MagicEffectData.TranslationMask? copyMask = null)
        {
            return ((MagicEffectDataSetterTranslationCommon)((IMagicEffectDataGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask);
        }

        public static MagicEffectData DeepCopy(
            this IMagicEffectDataGetter item,
            out MagicEffectData.ErrorMask errorMask,
            MagicEffectData.TranslationMask? copyMask = null)
        {
            return ((MagicEffectDataSetterTranslationCommon)((IMagicEffectDataGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: out errorMask);
        }

        public static MagicEffectData DeepCopy(
            this IMagicEffectDataGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            return ((MagicEffectDataSetterTranslationCommon)((IMagicEffectDataGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: errorMask);
        }

        #region Binary Translation
        public static void CopyInFromBinary(
            this IMagicEffectData item,
            MutagenFrame frame,
            TypedParseParams translationParams = default)
        {
            ((MagicEffectDataSetterCommon)((IMagicEffectDataGetter)item).CommonSetterInstance()!).CopyInFromBinary(
                item: item,
                frame: frame,
                translationParams: translationParams);
        }

        #endregion

    }
    #endregion

}

namespace Mutagen.Bethesda.Fallout3
{
    #region Field Index
    internal enum MagicEffectData_FieldIndex
    {
        Flags = 0,
        BaseCost = 1,
        Unused = 2,
        Resistance = 3,
        CounterEffectCount = 4,
        Light = 5,
        ProjectileSpeed = 6,
        EffectShader = 7,
        ObjectDisplayShader = 8,
        EffectSound = 9,
        BoltSound = 10,
        HitSound = 11,
        AreaSound = 12,
        ConstantEffectEnchantmentFactor = 13,
        ConstantEffectBarterFactor = 14,
        Archetype = 15,
        ActorValue = 16,
    }
    #endregion

    #region Registration
    internal partial class MagicEffectData_Registration : ILoquiRegistration
    {
        public static readonly MagicEffectData_Registration Instance = new MagicEffectData_Registration();

        public static ProtocolKey ProtocolKey => ProtocolDefinition_Fallout3.ProtocolKey;

        public const ushort AdditionalFieldCount = 17;

        public const ushort FieldCount = 17;

        public static readonly Type MaskType = typeof(MagicEffectData.Mask<>);

        public static readonly Type ErrorMaskType = typeof(MagicEffectData.ErrorMask);

        public static readonly Type ClassType = typeof(MagicEffectData);

        public static readonly Type GetterType = typeof(IMagicEffectDataGetter);

        public static readonly Type? InternalGetterType = null;

        public static readonly Type SetterType = typeof(IMagicEffectData);

        public static readonly Type? InternalSetterType = null;

        public const string FullName = "Mutagen.Bethesda.Fallout3.MagicEffectData";

        public const string Name = "MagicEffectData";

        public const string Namespace = "Mutagen.Bethesda.Fallout3";

        public const byte GenericCount = 0;

        public static readonly Type? GenericRegistrationType = null;

        public static readonly RecordType TriggeringRecordType = RecordTypes.DATA;
        public static RecordTriggerSpecs TriggerSpecs => _recordSpecs.Value;
        private static readonly Lazy<RecordTriggerSpecs> _recordSpecs = new Lazy<RecordTriggerSpecs>(() =>
        {
            var all = RecordCollection.Factory(RecordTypes.DATA);
            return new RecordTriggerSpecs(allRecordTypes: all);
        });
        public static readonly Type BinaryWriteTranslation = typeof(MagicEffectDataBinaryWriteTranslation);
        #region Interface
        ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;
        ushort ILoquiRegistration.FieldCount => FieldCount;
        ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;
        Type ILoquiRegistration.MaskType => MaskType;
        Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;
        Type ILoquiRegistration.ClassType => ClassType;
        Type ILoquiRegistration.SetterType => SetterType;
        Type? ILoquiRegistration.InternalSetterType => InternalSetterType;
        Type ILoquiRegistration.GetterType => GetterType;
        Type? ILoquiRegistration.InternalGetterType => InternalGetterType;
        string ILoquiRegistration.FullName => FullName;
        string ILoquiRegistration.Name => Name;
        string ILoquiRegistration.Namespace => Namespace;
        byte ILoquiRegistration.GenericCount => GenericCount;
        Type? ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;
        ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsLoqui(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsSingleton(ushort index) => throw new NotImplementedException();
        string ILoquiRegistration.GetNthName(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsNthDerivative(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsProtected(ushort index) => throw new NotImplementedException();
        Type ILoquiRegistration.GetNthType(ushort index) => throw new NotImplementedException();
        #endregion

    }
    #endregion

    #region Common
    internal partial class MagicEffectDataSetterCommon
    {
        public static readonly MagicEffectDataSetterCommon Instance = new MagicEffectDataSetterCommon();

        partial void ClearPartial();
        
        public void Clear(IMagicEffectData item)
        {
            ClearPartial();
            item.Flags = default(MagicEffect.MagicFlag);
            item.BaseCost = default(Single);
            item.Unused = default(Int32);
            item.Resistance = default(ActorValue);
            item.CounterEffectCount = default(UInt32);
            item.Light.Clear();
            item.ProjectileSpeed = default(Single);
            item.EffectShader.Clear();
            item.ObjectDisplayShader.Clear();
            item.EffectSound.Clear();
            item.BoltSound.Clear();
            item.HitSound.Clear();
            item.AreaSound.Clear();
            item.ConstantEffectEnchantmentFactor = default(Single);
            item.ConstantEffectBarterFactor = default(Single);
            item.Archetype = default(MagicEffect.ArchetypeEnum);
            item.ActorValue = MagicEffectData.ActorValueDefault;
        }
        
        #region Mutagen
        public void RemapLinks(IMagicEffectData obj, IReadOnlyDictionary<FormKey, FormKey> mapping)
        {
            obj.Light.Relink(mapping);
            obj.EffectShader.Relink(mapping);
            obj.ObjectDisplayShader.Relink(mapping);
            obj.EffectSound.Relink(mapping);
            obj.BoltSound.Relink(mapping);
            obj.HitSound.Relink(mapping);
            obj.AreaSound.Relink(mapping);
        }
        
        #endregion
        
        #region Binary Translation
        public virtual void CopyInFromBinary(
            IMagicEffectData item,
            MutagenFrame frame,
            TypedParseParams translationParams)
        {
            frame = frame.SpawnWithFinalPosition(HeaderTranslation.ParseSubrecord(
                frame.Reader,
                translationParams.ConvertToCustom(RecordTypes.DATA),
                translationParams.LengthOverride));
            PluginUtilityTranslation.SubrecordParse(
                record: item,
                frame: frame,
                translationParams: translationParams,
                fillStructs: MagicEffectDataBinaryCreateTranslation.FillBinaryStructs);
        }
        
        #endregion
        
    }
    internal partial class MagicEffectDataCommon
    {
        public static readonly MagicEffectDataCommon Instance = new MagicEffectDataCommon();

        public MagicEffectData.Mask<bool> GetEqualsMask(
            IMagicEffectDataGetter item,
            IMagicEffectDataGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            var ret = new MagicEffectData.Mask<bool>(false);
            ((MagicEffectDataCommon)((IMagicEffectDataGetter)item).CommonInstance()!).FillEqualsMask(
                item: item,
                rhs: rhs,
                ret: ret,
                include: include);
            return ret;
        }
        
        public void FillEqualsMask(
            IMagicEffectDataGetter item,
            IMagicEffectDataGetter rhs,
            MagicEffectData.Mask<bool> ret,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            ret.Flags = item.Flags == rhs.Flags;
            ret.BaseCost = item.BaseCost.EqualsWithin(rhs.BaseCost);
            ret.Unused = item.Unused == rhs.Unused;
            ret.Resistance = item.Resistance == rhs.Resistance;
            ret.CounterEffectCount = item.CounterEffectCount == rhs.CounterEffectCount;
            ret.Light = item.Light.Equals(rhs.Light);
            ret.ProjectileSpeed = item.ProjectileSpeed.EqualsWithin(rhs.ProjectileSpeed);
            ret.EffectShader = item.EffectShader.Equals(rhs.EffectShader);
            ret.ObjectDisplayShader = item.ObjectDisplayShader.Equals(rhs.ObjectDisplayShader);
            ret.EffectSound = item.EffectSound.Equals(rhs.EffectSound);
            ret.BoltSound = item.BoltSound.Equals(rhs.BoltSound);
            ret.HitSound = item.HitSound.Equals(rhs.HitSound);
            ret.AreaSound = item.AreaSound.Equals(rhs.AreaSound);
            ret.ConstantEffectEnchantmentFactor = item.ConstantEffectEnchantmentFactor.EqualsWithin(rhs.ConstantEffectEnchantmentFactor);
            ret.ConstantEffectBarterFactor = item.ConstantEffectBarterFactor.EqualsWithin(rhs.ConstantEffectBarterFactor);
            ret.Archetype = item.Archetype == rhs.Archetype;
            ret.ActorValue = item.ActorValue == rhs.ActorValue;
        }
        
        public string Print(
            IMagicEffectDataGetter item,
            string? name = null,
            MagicEffectData.Mask<bool>? printMask = null)
        {
            var sb = new StructuredStringBuilder();
            Print(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
            return sb.ToString();
        }
        
        public void Print(
            IMagicEffectDataGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            MagicEffectData.Mask<bool>? printMask = null)
        {
            if (name == null)
            {
                sb.AppendLine($"MagicEffectData =>");
            }
            else
            {
                sb.AppendLine($"{name} (MagicEffectData) =>");
            }
            using (sb.Brace())
            {
                ToStringFields(
                    item: item,
                    sb: sb,
                    printMask: printMask);
            }
        }
        
        protected static void ToStringFields(
            IMagicEffectDataGetter item,
            StructuredStringBuilder sb,
            MagicEffectData.Mask<bool>? printMask = null)
        {
            if (printMask?.Flags ?? true)
            {
                sb.AppendItem(item.Flags, "Flags");
            }
            if (printMask?.BaseCost ?? true)
            {
                sb.AppendItem(item.BaseCost, "BaseCost");
            }
            if (printMask?.Unused ?? true)
            {
                sb.AppendItem(item.Unused, "Unused");
            }
            if (printMask?.Resistance ?? true)
            {
                sb.AppendItem(item.Resistance, "Resistance");
            }
            if (printMask?.CounterEffectCount ?? true)
            {
                sb.AppendItem(item.CounterEffectCount, "CounterEffectCount");
            }
            if (printMask?.Light ?? true)
            {
                sb.AppendItem(item.Light.FormKey, "Light");
            }
            if (printMask?.ProjectileSpeed ?? true)
            {
                sb.AppendItem(item.ProjectileSpeed, "ProjectileSpeed");
            }
            if (printMask?.EffectShader ?? true)
            {
                sb.AppendItem(item.EffectShader.FormKey, "EffectShader");
            }
            if (printMask?.ObjectDisplayShader ?? true)
            {
                sb.AppendItem(item.ObjectDisplayShader.FormKey, "ObjectDisplayShader");
            }
            if (printMask?.EffectSound ?? true)
            {
                sb.AppendItem(item.EffectSound.FormKey, "EffectSound");
            }
            if (printMask?.BoltSound ?? true)
            {
                sb.AppendItem(item.BoltSound.FormKey, "BoltSound");
            }
            if (printMask?.HitSound ?? true)
            {
                sb.AppendItem(item.HitSound.FormKey, "HitSound");
            }
            if (printMask?.AreaSound ?? true)
            {
                sb.AppendItem(item.AreaSound.FormKey, "AreaSound");
            }
            if (printMask?.ConstantEffectEnchantmentFactor ?? true)
            {
                sb.AppendItem(item.ConstantEffectEnchantmentFactor, "ConstantEffectEnchantmentFactor");
            }
            if (printMask?.ConstantEffectBarterFactor ?? true)
            {
                sb.AppendItem(item.ConstantEffectBarterFactor, "ConstantEffectBarterFactor");
            }
            if (printMask?.Archetype ?? true)
            {
                sb.AppendItem(item.Archetype, "Archetype");
            }
            if (printMask?.ActorValue ?? true)
            {
                sb.AppendItem(item.ActorValue, "ActorValue");
            }
        }
        
        #region Equals and Hash
        public virtual bool Equals(
            IMagicEffectDataGetter? lhs,
            IMagicEffectDataGetter? rhs,
            TranslationCrystal? equalsMask)
        {
            if (!EqualsMaskHelper.RefEquality(lhs, rhs, out var isEqual)) return isEqual;
            if ((equalsMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Flags) ?? true))
            {
                if (lhs.Flags != rhs.Flags) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.BaseCost) ?? true))
            {
                if (!lhs.BaseCost.EqualsWithin(rhs.BaseCost)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Unused) ?? true))
            {
                if (lhs.Unused != rhs.Unused) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Resistance) ?? true))
            {
                if (lhs.Resistance != rhs.Resistance) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.CounterEffectCount) ?? true))
            {
                if (lhs.CounterEffectCount != rhs.CounterEffectCount) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Light) ?? true))
            {
                if (!lhs.Light.Equals(rhs.Light)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.ProjectileSpeed) ?? true))
            {
                if (!lhs.ProjectileSpeed.EqualsWithin(rhs.ProjectileSpeed)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.EffectShader) ?? true))
            {
                if (!lhs.EffectShader.Equals(rhs.EffectShader)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.ObjectDisplayShader) ?? true))
            {
                if (!lhs.ObjectDisplayShader.Equals(rhs.ObjectDisplayShader)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.EffectSound) ?? true))
            {
                if (!lhs.EffectSound.Equals(rhs.EffectSound)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.BoltSound) ?? true))
            {
                if (!lhs.BoltSound.Equals(rhs.BoltSound)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.HitSound) ?? true))
            {
                if (!lhs.HitSound.Equals(rhs.HitSound)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.AreaSound) ?? true))
            {
                if (!lhs.AreaSound.Equals(rhs.AreaSound)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.ConstantEffectEnchantmentFactor) ?? true))
            {
                if (!lhs.ConstantEffectEnchantmentFactor.EqualsWithin(rhs.ConstantEffectEnchantmentFactor)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.ConstantEffectBarterFactor) ?? true))
            {
                if (!lhs.ConstantEffectBarterFactor.EqualsWithin(rhs.ConstantEffectBarterFactor)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Archetype) ?? true))
            {
                if (lhs.Archetype != rhs.Archetype) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.ActorValue) ?? true))
            {
                if (lhs.ActorValue != rhs.ActorValue) return false;
            }
            return true;
        }
        
        public virtual int GetHashCode(IMagicEffectDataGetter item)
        {
            var hash = new HashCode();
            hash.Add(item.Flags);
            hash.Add(item.BaseCost);
            hash.Add(item.Unused);
            hash.Add(item.Resistance);
            hash.Add(item.CounterEffectCount);
            hash.Add(item.Light);
            hash.Add(item.ProjectileSpeed);
            hash.Add(item.EffectShader);
            hash.Add(item.ObjectDisplayShader);
            hash.Add(item.EffectSound);
            hash.Add(item.BoltSound);
            hash.Add(item.HitSound);
            hash.Add(item.AreaSound);
            hash.Add(item.ConstantEffectEnchantmentFactor);
            hash.Add(item.ConstantEffectBarterFactor);
            hash.Add(item.Archetype);
            hash.Add(item.ActorValue);
            return hash.ToHashCode();
        }
        
        #endregion
        
        
        public object GetNew()
        {
            return MagicEffectData.GetNew();
        }
        
        #region Mutagen
        public IEnumerable<IFormLinkGetter> EnumerateFormLinks(IMagicEffectDataGetter obj)
        {
            yield return FormLinkInformation.Factory(obj.Light);
            yield return FormLinkInformation.Factory(obj.EffectShader);
            yield return FormLinkInformation.Factory(obj.ObjectDisplayShader);
            yield return FormLinkInformation.Factory(obj.EffectSound);
            yield return FormLinkInformation.Factory(obj.BoltSound);
            yield return FormLinkInformation.Factory(obj.HitSound);
            yield return FormLinkInformation.Factory(obj.AreaSound);
            yield break;
        }
        
        #endregion
        
    }
    internal partial class MagicEffectDataSetterTranslationCommon
    {
        public static readonly MagicEffectDataSetterTranslationCommon Instance = new MagicEffectDataSetterTranslationCommon();

        #region DeepCopyIn
        public void DeepCopyIn(
            IMagicEffectData item,
            IMagicEffectDataGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Flags) ?? true))
            {
                item.Flags = rhs.Flags;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.BaseCost) ?? true))
            {
                item.BaseCost = rhs.BaseCost;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Unused) ?? true))
            {
                item.Unused = rhs.Unused;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Resistance) ?? true))
            {
                item.Resistance = rhs.Resistance;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.CounterEffectCount) ?? true))
            {
                item.CounterEffectCount = rhs.CounterEffectCount;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Light) ?? true))
            {
                item.Light.SetTo(rhs.Light.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.ProjectileSpeed) ?? true))
            {
                item.ProjectileSpeed = rhs.ProjectileSpeed;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.EffectShader) ?? true))
            {
                item.EffectShader.SetTo(rhs.EffectShader.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.ObjectDisplayShader) ?? true))
            {
                item.ObjectDisplayShader.SetTo(rhs.ObjectDisplayShader.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.EffectSound) ?? true))
            {
                item.EffectSound.SetTo(rhs.EffectSound.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.BoltSound) ?? true))
            {
                item.BoltSound.SetTo(rhs.BoltSound.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.HitSound) ?? true))
            {
                item.HitSound.SetTo(rhs.HitSound.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.AreaSound) ?? true))
            {
                item.AreaSound.SetTo(rhs.AreaSound.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.ConstantEffectEnchantmentFactor) ?? true))
            {
                item.ConstantEffectEnchantmentFactor = rhs.ConstantEffectEnchantmentFactor;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.ConstantEffectBarterFactor) ?? true))
            {
                item.ConstantEffectBarterFactor = rhs.ConstantEffectBarterFactor;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.Archetype) ?? true))
            {
                item.Archetype = rhs.Archetype;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffectData_FieldIndex.ActorValue) ?? true))
            {
                item.ActorValue = rhs.ActorValue;
            }
            DeepCopyInCustom(
                item: item,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        partial void DeepCopyInCustom(
            IMagicEffectData item,
            IMagicEffectDataGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy);
        #endregion
        
        public MagicEffectData DeepCopy(
            IMagicEffectDataGetter item,
            MagicEffectData.TranslationMask? copyMask = null)
        {
            MagicEffectData ret = (MagicEffectData)((MagicEffectDataCommon)((IMagicEffectDataGetter)item).CommonInstance()!).GetNew();
            ((MagicEffectDataSetterTranslationCommon)((IMagicEffectDataGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: null,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            return ret;
        }
        
        public MagicEffectData DeepCopy(
            IMagicEffectDataGetter item,
            out MagicEffectData.ErrorMask errorMask,
            MagicEffectData.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            MagicEffectData ret = (MagicEffectData)((MagicEffectDataCommon)((IMagicEffectDataGetter)item).CommonInstance()!).GetNew();
            ((MagicEffectDataSetterTranslationCommon)((IMagicEffectDataGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                ret,
                item,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            errorMask = MagicEffectData.ErrorMask.Factory(errorMaskBuilder);
            return ret;
        }
        
        public MagicEffectData DeepCopy(
            IMagicEffectDataGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            MagicEffectData ret = (MagicEffectData)((MagicEffectDataCommon)((IMagicEffectDataGetter)item).CommonInstance()!).GetNew();
            ((MagicEffectDataSetterTranslationCommon)((IMagicEffectDataGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: true);
            return ret;
        }
        
    }
    #endregion

}

namespace Mutagen.Bethesda.Fallout3
{
    public partial class MagicEffectData
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => MagicEffectData_Registration.Instance;
        public static ILoquiRegistration StaticRegistration => MagicEffectData_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => MagicEffectDataCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterInstance()
        {
            return MagicEffectDataSetterCommon.Instance;
        }
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => MagicEffectDataSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IMagicEffectDataGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object IMagicEffectDataGetter.CommonSetterInstance() => this.CommonSetterInstance();
        [DebuggerStepThrough]
        object IMagicEffectDataGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

    }
}

#region Modules
#region Binary Translation
namespace Mutagen.Bethesda.Fallout3
{
    public partial class MagicEffectDataBinaryWriteTranslation : IBinaryWriteTranslator
    {
        public static readonly MagicEffectDataBinaryWriteTranslation Instance = new();

        public static void WriteEmbedded(
            IMagicEffectDataGetter item,
            MutagenWriter writer)
        {
            EnumBinaryTranslation<MagicEffect.MagicFlag, MutagenFrame, MutagenWriter>.Instance.Write(
                writer,
                item.Flags,
                length: 4);
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                writer: writer,
                item: item.BaseCost);
            MagicEffectDataBinaryWriteTranslation.WriteBinaryAssociatedItem(
                writer: writer,
                item: item);
            writer.Write(item.Unused);
            EnumBinaryTranslation<ActorValue, MutagenFrame, MutagenWriter>.Instance.Write(
                writer,
                item.Resistance,
                length: 4);
            writer.Write(item.CounterEffectCount);
            FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.Light);
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                writer: writer,
                item: item.ProjectileSpeed);
            FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.EffectShader);
            FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.ObjectDisplayShader);
            FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.EffectSound);
            FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.BoltSound);
            FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.HitSound);
            FormLinkBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.AreaSound);
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                writer: writer,
                item: item.ConstantEffectEnchantmentFactor);
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                writer: writer,
                item: item.ConstantEffectBarterFactor);
            EnumBinaryTranslation<MagicEffect.ArchetypeEnum, MutagenFrame, MutagenWriter>.Instance.Write(
                writer,
                item.Archetype,
                length: 4);
            EnumBinaryTranslation<ActorValue, MutagenFrame, MutagenWriter>.Instance.Write(
                writer,
                item.ActorValue,
                length: 4);
        }

        public static partial void WriteBinaryAssociatedItemCustom(
            MutagenWriter writer,
            IMagicEffectDataGetter item);

        public static void WriteBinaryAssociatedItem(
            MutagenWriter writer,
            IMagicEffectDataGetter item)
        {
            WriteBinaryAssociatedItemCustom(
                writer: writer,
                item: item);
        }

        public void Write(
            MutagenWriter writer,
            IMagicEffectDataGetter item,
            TypedWriteParams translationParams)
        {
            using (HeaderExport.Subrecord(
                writer: writer,
                record: translationParams.ConvertToCustom(RecordTypes.DATA),
                overflowRecord: translationParams.OverflowRecordType,
                out var writerToUse))
            {
                WriteEmbedded(
                    item: item,
                    writer: writerToUse);
            }
        }

        public void Write(
            MutagenWriter writer,
            object item,
            TypedWriteParams translationParams = default)
        {
            Write(
                item: (IMagicEffectDataGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

    }

    internal partial class MagicEffectDataBinaryCreateTranslation
    {
        public static readonly MagicEffectDataBinaryCreateTranslation Instance = new MagicEffectDataBinaryCreateTranslation();

        public static void FillBinaryStructs(
            IMagicEffectData item,
            MutagenFrame frame)
        {
            item.Flags = EnumBinaryTranslation<MagicEffect.MagicFlag, MutagenFrame, MutagenWriter>.Instance.Parse(
                reader: frame,
                length: 4);
            item.BaseCost = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame);
            MagicEffectDataBinaryCreateTranslation.FillBinaryAssociatedItemCustom(
                frame: frame,
                item: item);
            item.Unused = frame.ReadInt32();
            item.Resistance = EnumBinaryTranslation<ActorValue, MutagenFrame, MutagenWriter>.Instance.Parse(
                reader: frame,
                length: 4);
            item.CounterEffectCount = frame.ReadUInt32();
            item.Light.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
            item.ProjectileSpeed = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame);
            item.EffectShader.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
            item.ObjectDisplayShader.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
            item.EffectSound.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
            item.BoltSound.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
            item.HitSound.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
            item.AreaSound.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
            item.ConstantEffectEnchantmentFactor = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame);
            item.ConstantEffectBarterFactor = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame);
            item.Archetype = EnumBinaryTranslation<MagicEffect.ArchetypeEnum, MutagenFrame, MutagenWriter>.Instance.Parse(
                reader: frame,
                length: 4);
            item.ActorValue = EnumBinaryTranslation<ActorValue, MutagenFrame, MutagenWriter>.Instance.Parse(
                reader: frame,
                length: 4);
        }

        public static partial void FillBinaryAssociatedItemCustom(
            MutagenFrame frame,
            IMagicEffectData item);

    }

}
namespace Mutagen.Bethesda.Fallout3
{
    #region Binary Write Mixins
    public static class MagicEffectDataBinaryTranslationMixIn
    {
        public static void WriteToBinary(
            this IMagicEffectDataGetter item,
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((MagicEffectDataBinaryWriteTranslation)item.BinaryWriteTranslator).Write(
                item: item,
                writer: writer,
                translationParams: translationParams);
        }

    }
    #endregion


}
namespace Mutagen.Bethesda.Fallout3
{
    internal partial class MagicEffectDataBinaryOverlay :
        PluginBinaryOverlay,
        IMagicEffectDataGetter
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => MagicEffectData_Registration.Instance;
        public static ILoquiRegistration StaticRegistration => MagicEffectData_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => MagicEffectDataCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => MagicEffectDataSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IMagicEffectDataGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object? IMagicEffectDataGetter.CommonSetterInstance() => null;
        [DebuggerStepThrough]
        object IMagicEffectDataGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

        void IPrintable.Print(StructuredStringBuilder sb, string? name) => this.Print(sb, name);

        public IEnumerable<IFormLinkGetter> EnumerateFormLinks() => MagicEffectDataCommon.Instance.EnumerateFormLinks(this);
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => MagicEffectDataBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((MagicEffectDataBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }

        public MagicEffect.MagicFlag Flags => (MagicEffect.MagicFlag)BinaryPrimitives.ReadInt32LittleEndian(_structData.Span.Slice(0x0, 0x4));
        public Single BaseCost => _structData.Slice(0x4, 0x4).Float();
        #region AssociatedItem
        partial void AssociatedItemCustomParse(
            OverlayStream stream,
            int offset);
        #endregion
        public Int32 Unused => BinaryPrimitives.ReadInt32LittleEndian(_structData.Slice(0xC, 0x4));
        public ActorValue Resistance => (ActorValue)BinaryPrimitives.ReadInt32LittleEndian(_structData.Span.Slice(0x10, 0x4));
        public UInt32 CounterEffectCount => BinaryPrimitives.ReadUInt32LittleEndian(_structData.Slice(0x14, 0x4));
        public IFormLinkGetter<ILightGetter> Light => FormLinkBinaryTranslation.Instance.OverlayFactory<ILightGetter>(_package, _structData.Span.Slice(0x18, 0x4));
        public Single ProjectileSpeed => _structData.Slice(0x1C, 0x4).Float();
        public IFormLinkGetter<IEffectShaderGetter> EffectShader => FormLinkBinaryTranslation.Instance.OverlayFactory<IEffectShaderGetter>(_package, _structData.Span.Slice(0x20, 0x4));
        public IFormLinkGetter<IEffectShaderGetter> ObjectDisplayShader => FormLinkBinaryTranslation.Instance.OverlayFactory<IEffectShaderGetter>(_package, _structData.Span.Slice(0x24, 0x4));
        public IFormLinkGetter<ISoundGetter> EffectSound => FormLinkBinaryTranslation.Instance.OverlayFactory<ISoundGetter>(_package, _structData.Span.Slice(0x28, 0x4));
        public IFormLinkGetter<ISoundGetter> BoltSound => FormLinkBinaryTranslation.Instance.OverlayFactory<ISoundGetter>(_package, _structData.Span.Slice(0x2C, 0x4));
        public IFormLinkGetter<ISoundGetter> HitSound => FormLinkBinaryTranslation.Instance.OverlayFactory<ISoundGetter>(_package, _structData.Span.Slice(0x30, 0x4));
        public IFormLinkGetter<ISoundGetter> AreaSound => FormLinkBinaryTranslation.Instance.OverlayFactory<ISoundGetter>(_package, _structData.Span.Slice(0x34, 0x4));
        public Single ConstantEffectEnchantmentFactor => _structData.Slice(0x38, 0x4).Float();
        public Single ConstantEffectBarterFactor => _structData.Slice(0x3C, 0x4).Float();
        public MagicEffect.ArchetypeEnum Archetype => (MagicEffect.ArchetypeEnum)BinaryPrimitives.ReadInt32LittleEndian(_structData.Span.Slice(0x40, 0x4));
        public ActorValue ActorValue => (ActorValue)BinaryPrimitives.ReadInt32LittleEndian(_structData.Span.Slice(0x44, 0x4));
        partial void CustomFactoryEnd(
            OverlayStream stream,
            int finalPos,
            int offset);

        partial void CustomCtor();
        protected MagicEffectDataBinaryOverlay(
            MemoryPair memoryPair,
            BinaryOverlayFactoryPackage package)
            : base(
                memoryPair: memoryPair,
                package: package)
        {
            this.CustomCtor();
        }

        public static IMagicEffectDataGetter MagicEffectDataFactory(
            OverlayStream stream,
            BinaryOverlayFactoryPackage package,
            TypedParseParams translationParams = default)
        {
            stream = ExtractSubrecordStructMemory(
                stream: stream,
                meta: package.MetaData.Constants,
                translationParams: translationParams,
                length: 0x48,
                memoryPair: out var memoryPair,
                offset: out var offset);
            var ret = new MagicEffectDataBinaryOverlay(
                memoryPair: memoryPair,
                package: package);
            stream.Position += 0x48 + package.MetaData.Constants.SubConstants.HeaderLength;
            ret.CustomFactoryEnd(
                stream: stream,
                finalPos: stream.Length,
                offset: offset);
            return ret;
        }

        public static IMagicEffectDataGetter MagicEffectDataFactory(
            ReadOnlyMemorySlice<byte> slice,
            BinaryOverlayFactoryPackage package,
            TypedParseParams translationParams = default)
        {
            return MagicEffectDataFactory(
                stream: new OverlayStream(slice, package),
                package: package,
                translationParams: translationParams);
        }

        #region To String

        public void Print(
            StructuredStringBuilder sb,
            string? name = null)
        {
            MagicEffectDataMixIn.Print(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is not IMagicEffectDataGetter rhs) return false;
            return ((MagicEffectDataCommon)((IMagicEffectDataGetter)this).CommonInstance()!).Equals(this, rhs, equalsMask: null);
        }

        public bool Equals(IMagicEffectDataGetter? obj)
        {
            return ((MagicEffectDataCommon)((IMagicEffectDataGetter)this).CommonInstance()!).Equals(this, obj, equalsMask: null);
        }

        public override int GetHashCode() => ((MagicEffectDataCommon)((IMagicEffectDataGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

    }

}
#endregion

#endregion

