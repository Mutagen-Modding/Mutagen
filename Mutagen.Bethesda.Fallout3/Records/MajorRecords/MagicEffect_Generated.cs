/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Autogenerated by Loqui.  Do not manually change.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*/
#region Usings
using Loqui;
using Loqui.Interfaces;
using Loqui.Internal;
using Mutagen.Bethesda.Binary;
using Mutagen.Bethesda.Fallout3;
using Mutagen.Bethesda.Fallout3.Internals;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Aspects;
using Mutagen.Bethesda.Plugins.Binary.Headers;
using Mutagen.Bethesda.Plugins.Binary.Overlay;
using Mutagen.Bethesda.Plugins.Binary.Streams;
using Mutagen.Bethesda.Plugins.Binary.Translations;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Exceptions;
using Mutagen.Bethesda.Plugins.Internals;
using Mutagen.Bethesda.Plugins.Meta;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Plugins.Records.Internals;
using Mutagen.Bethesda.Plugins.Records.Mapping;
using Mutagen.Bethesda.Plugins.Utility;
using Mutagen.Bethesda.Translations.Binary;
using Noggog;
using Noggog.StructuredStrings;
using Noggog.StructuredStrings.CSharp;
using RecordTypeInts = Mutagen.Bethesda.Fallout3.Internals.RecordTypeInts;
using RecordTypes = Mutagen.Bethesda.Fallout3.Internals.RecordTypes;
using System.Buffers.Binary;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Reactive.Disposables;
using System.Reactive.Linq;
#endregion

#nullable enable
namespace Mutagen.Bethesda.Fallout3
{
    #region Class
    public partial class MagicEffect :
        Fallout3MajorRecord,
        IEquatable<IMagicEffectGetter>,
        ILoquiObjectSetter<MagicEffect>,
        IMagicEffectInternal
    {
        #region Ctor
        protected MagicEffect()
        {
            CustomCtor();
        }
        partial void CustomCtor();
        #endregion

        #region Name
        /// <summary>
        /// Aspects: INamed, INamedRequired
        /// </summary>
        public String? Name { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        String? IMagicEffectGetter.Name => this.Name;
        #region Aspects
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        string INamedRequiredGetter.Name => this.Name ?? string.Empty;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        string INamedRequired.Name
        {
            get => this.Name ?? string.Empty;
            set => this.Name = value;
        }
        #endregion
        #endregion
        #region Description
        public String? Description { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        String? IMagicEffectGetter.Description => this.Description;
        #endregion
        #region Icon
        public String? Icon { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        String? IMagicEffectGetter.Icon => this.Icon;
        #endregion
        #region Model
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Model? _Model;
        /// <summary>
        /// Aspects: IModeled
        /// </summary>
        public Model? Model
        {
            get => _Model;
            set => _Model = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IModelGetter? IMagicEffectGetter.Model => this.Model;
        #region Aspects
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IModelGetter? IModeledGetter.Model => this.Model;
        #endregion
        #endregion
        #region Flags
        public MagicEffect.MagicFlag Flags { get; set; } = default(MagicEffect.MagicFlag);
        #endregion
        #region BaseCost
        public Single BaseCost { get; set; } = default(Single);
        #endregion
        #region Unused
        public Int32 Unused { get; set; } = default(Int32);
        #endregion
        #region Resistance
        public ActorValue Resistance { get; set; } = default(ActorValue);
        #endregion
        #region CounterEffectCount
        public UInt32 CounterEffectCount { get; set; } = default(UInt32);
        #endregion
        #region Light
        private readonly IFormLink<ILightGetter> _Light = new FormLink<ILightGetter>();
        public IFormLink<ILightGetter> Light
        {
            get => _Light;
            set => _Light.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<ILightGetter> IMagicEffectGetter.Light => this.Light;
        #endregion
        #region ProjectileSpeed
        public Single ProjectileSpeed { get; set; } = default(Single);
        #endregion
        #region EffectShader
        private readonly IFormLink<IEffectShaderGetter> _EffectShader = new FormLink<IEffectShaderGetter>();
        public IFormLink<IEffectShaderGetter> EffectShader
        {
            get => _EffectShader;
            set => _EffectShader.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IEffectShaderGetter> IMagicEffectGetter.EffectShader => this.EffectShader;
        #endregion
        #region ObjectDisplayShader
        private readonly IFormLink<IEffectShaderGetter> _ObjectDisplayShader = new FormLink<IEffectShaderGetter>();
        public IFormLink<IEffectShaderGetter> ObjectDisplayShader
        {
            get => _ObjectDisplayShader;
            set => _ObjectDisplayShader.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<IEffectShaderGetter> IMagicEffectGetter.ObjectDisplayShader => this.ObjectDisplayShader;
        #endregion
        #region EffectSound
        private readonly IFormLink<ISoundGetter> _EffectSound = new FormLink<ISoundGetter>();
        public IFormLink<ISoundGetter> EffectSound
        {
            get => _EffectSound;
            set => _EffectSound.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<ISoundGetter> IMagicEffectGetter.EffectSound => this.EffectSound;
        #endregion
        #region BoltSound
        private readonly IFormLink<ISoundGetter> _BoltSound = new FormLink<ISoundGetter>();
        public IFormLink<ISoundGetter> BoltSound
        {
            get => _BoltSound;
            set => _BoltSound.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<ISoundGetter> IMagicEffectGetter.BoltSound => this.BoltSound;
        #endregion
        #region HitSound
        private readonly IFormLink<ISoundGetter> _HitSound = new FormLink<ISoundGetter>();
        public IFormLink<ISoundGetter> HitSound
        {
            get => _HitSound;
            set => _HitSound.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<ISoundGetter> IMagicEffectGetter.HitSound => this.HitSound;
        #endregion
        #region AreaSound
        private readonly IFormLink<ISoundGetter> _AreaSound = new FormLink<ISoundGetter>();
        public IFormLink<ISoundGetter> AreaSound
        {
            get => _AreaSound;
            set => _AreaSound.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkGetter<ISoundGetter> IMagicEffectGetter.AreaSound => this.AreaSound;
        #endregion
        #region ConstantEffectEnchantmentFactor
        public Single ConstantEffectEnchantmentFactor { get; set; } = default(Single);
        #endregion
        #region ConstantEffectBarterFactor
        public Single ConstantEffectBarterFactor { get; set; } = default(Single);
        #endregion
        #region Archetype
        public AMagicEffectArchetype Archetype { get; set; } = new MagicEffectArchetype();
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IAMagicEffectArchetypeGetter IMagicEffectGetter.Archetype => Archetype;
        #endregion
        #region ActorValue
        public static readonly ActorValue ActorValueDefault = ActorValue.None;
        public ActorValue ActorValue { get; set; } = ActorValueDefault;
        #endregion
        #region CounterEffects
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private ExtendedList<IEDIDLinkGetter<IMagicEffectGetter>>? _CounterEffects;
        public ExtendedList<IEDIDLinkGetter<IMagicEffectGetter>>? CounterEffects
        {
            get => this._CounterEffects;
            set => this._CounterEffects = value;
        }
        #region Interface Members
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IReadOnlyList<IEDIDLinkGetter<IMagicEffectGetter>>? IMagicEffectGetter.CounterEffects => _CounterEffects;
        #endregion

        #endregion

        #region To String

        public override void Print(
            StructuredStringBuilder sb,
            string? name = null)
        {
            MagicEffectMixIn.Print(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        #region Mask
        public new class Mask<TItem> :
            Fallout3MajorRecord.Mask<TItem>,
            IEquatable<Mask<TItem>>,
            IMask<TItem>
        {
            #region Ctors
            public Mask(TItem initialValue)
            : base(initialValue)
            {
                this.Name = initialValue;
                this.Description = initialValue;
                this.Icon = initialValue;
                this.Model = new MaskItem<TItem, Model.Mask<TItem>?>(initialValue, new Model.Mask<TItem>(initialValue));
                this.Flags = initialValue;
                this.BaseCost = initialValue;
                this.Unused = initialValue;
                this.Resistance = initialValue;
                this.CounterEffectCount = initialValue;
                this.Light = initialValue;
                this.ProjectileSpeed = initialValue;
                this.EffectShader = initialValue;
                this.ObjectDisplayShader = initialValue;
                this.EffectSound = initialValue;
                this.BoltSound = initialValue;
                this.HitSound = initialValue;
                this.AreaSound = initialValue;
                this.ConstantEffectEnchantmentFactor = initialValue;
                this.ConstantEffectBarterFactor = initialValue;
                this.Archetype = new MaskItem<TItem, AMagicEffectArchetype.Mask<TItem>?>(initialValue, new AMagicEffectArchetype.Mask<TItem>(initialValue));
                this.ActorValue = initialValue;
                this.CounterEffects = new MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>(initialValue, Enumerable.Empty<(int Index, TItem Value)>());
            }

            public Mask(
                TItem MajorRecordFlagsRaw,
                TItem FormKey,
                TItem VersionControl,
                TItem EditorID,
                TItem FormVersion,
                TItem Version2,
                TItem Fallout3MajorRecordFlags,
                TItem Name,
                TItem Description,
                TItem Icon,
                TItem Model,
                TItem Flags,
                TItem BaseCost,
                TItem Unused,
                TItem Resistance,
                TItem CounterEffectCount,
                TItem Light,
                TItem ProjectileSpeed,
                TItem EffectShader,
                TItem ObjectDisplayShader,
                TItem EffectSound,
                TItem BoltSound,
                TItem HitSound,
                TItem AreaSound,
                TItem ConstantEffectEnchantmentFactor,
                TItem ConstantEffectBarterFactor,
                TItem Archetype,
                TItem ActorValue,
                TItem CounterEffects)
            : base(
                MajorRecordFlagsRaw: MajorRecordFlagsRaw,
                FormKey: FormKey,
                VersionControl: VersionControl,
                EditorID: EditorID,
                FormVersion: FormVersion,
                Version2: Version2,
                Fallout3MajorRecordFlags: Fallout3MajorRecordFlags)
            {
                this.Name = Name;
                this.Description = Description;
                this.Icon = Icon;
                this.Model = new MaskItem<TItem, Model.Mask<TItem>?>(Model, new Model.Mask<TItem>(Model));
                this.Flags = Flags;
                this.BaseCost = BaseCost;
                this.Unused = Unused;
                this.Resistance = Resistance;
                this.CounterEffectCount = CounterEffectCount;
                this.Light = Light;
                this.ProjectileSpeed = ProjectileSpeed;
                this.EffectShader = EffectShader;
                this.ObjectDisplayShader = ObjectDisplayShader;
                this.EffectSound = EffectSound;
                this.BoltSound = BoltSound;
                this.HitSound = HitSound;
                this.AreaSound = AreaSound;
                this.ConstantEffectEnchantmentFactor = ConstantEffectEnchantmentFactor;
                this.ConstantEffectBarterFactor = ConstantEffectBarterFactor;
                this.Archetype = new MaskItem<TItem, AMagicEffectArchetype.Mask<TItem>?>(Archetype, new AMagicEffectArchetype.Mask<TItem>(Archetype));
                this.ActorValue = ActorValue;
                this.CounterEffects = new MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>(CounterEffects, Enumerable.Empty<(int Index, TItem Value)>());
            }

            #pragma warning disable CS8618
            protected Mask()
            {
            }
            #pragma warning restore CS8618

            #endregion

            #region Members
            public TItem Name;
            public TItem Description;
            public TItem Icon;
            public MaskItem<TItem, Model.Mask<TItem>?>? Model { get; set; }
            public TItem Flags;
            public TItem BaseCost;
            public TItem Unused;
            public TItem Resistance;
            public TItem CounterEffectCount;
            public TItem Light;
            public TItem ProjectileSpeed;
            public TItem EffectShader;
            public TItem ObjectDisplayShader;
            public TItem EffectSound;
            public TItem BoltSound;
            public TItem HitSound;
            public TItem AreaSound;
            public TItem ConstantEffectEnchantmentFactor;
            public TItem ConstantEffectBarterFactor;
            public MaskItem<TItem, AMagicEffectArchetype.Mask<TItem>?>? Archetype { get; set; }
            public TItem ActorValue;
            public MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>? CounterEffects;
            #endregion

            #region Equals
            public override bool Equals(object? obj)
            {
                if (!(obj is Mask<TItem> rhs)) return false;
                return Equals(rhs);
            }

            public bool Equals(Mask<TItem>? rhs)
            {
                if (rhs == null) return false;
                if (!base.Equals(rhs)) return false;
                if (!object.Equals(this.Name, rhs.Name)) return false;
                if (!object.Equals(this.Description, rhs.Description)) return false;
                if (!object.Equals(this.Icon, rhs.Icon)) return false;
                if (!object.Equals(this.Model, rhs.Model)) return false;
                if (!object.Equals(this.Flags, rhs.Flags)) return false;
                if (!object.Equals(this.BaseCost, rhs.BaseCost)) return false;
                if (!object.Equals(this.Unused, rhs.Unused)) return false;
                if (!object.Equals(this.Resistance, rhs.Resistance)) return false;
                if (!object.Equals(this.CounterEffectCount, rhs.CounterEffectCount)) return false;
                if (!object.Equals(this.Light, rhs.Light)) return false;
                if (!object.Equals(this.ProjectileSpeed, rhs.ProjectileSpeed)) return false;
                if (!object.Equals(this.EffectShader, rhs.EffectShader)) return false;
                if (!object.Equals(this.ObjectDisplayShader, rhs.ObjectDisplayShader)) return false;
                if (!object.Equals(this.EffectSound, rhs.EffectSound)) return false;
                if (!object.Equals(this.BoltSound, rhs.BoltSound)) return false;
                if (!object.Equals(this.HitSound, rhs.HitSound)) return false;
                if (!object.Equals(this.AreaSound, rhs.AreaSound)) return false;
                if (!object.Equals(this.ConstantEffectEnchantmentFactor, rhs.ConstantEffectEnchantmentFactor)) return false;
                if (!object.Equals(this.ConstantEffectBarterFactor, rhs.ConstantEffectBarterFactor)) return false;
                if (!object.Equals(this.Archetype, rhs.Archetype)) return false;
                if (!object.Equals(this.ActorValue, rhs.ActorValue)) return false;
                if (!object.Equals(this.CounterEffects, rhs.CounterEffects)) return false;
                return true;
            }
            public override int GetHashCode()
            {
                var hash = new HashCode();
                hash.Add(this.Name);
                hash.Add(this.Description);
                hash.Add(this.Icon);
                hash.Add(this.Model);
                hash.Add(this.Flags);
                hash.Add(this.BaseCost);
                hash.Add(this.Unused);
                hash.Add(this.Resistance);
                hash.Add(this.CounterEffectCount);
                hash.Add(this.Light);
                hash.Add(this.ProjectileSpeed);
                hash.Add(this.EffectShader);
                hash.Add(this.ObjectDisplayShader);
                hash.Add(this.EffectSound);
                hash.Add(this.BoltSound);
                hash.Add(this.HitSound);
                hash.Add(this.AreaSound);
                hash.Add(this.ConstantEffectEnchantmentFactor);
                hash.Add(this.ConstantEffectBarterFactor);
                hash.Add(this.Archetype);
                hash.Add(this.ActorValue);
                hash.Add(this.CounterEffects);
                hash.Add(base.GetHashCode());
                return hash.ToHashCode();
            }

            #endregion

            #region All
            public override bool All(Func<TItem, bool> eval)
            {
                if (!base.All(eval)) return false;
                if (!eval(this.Name)) return false;
                if (!eval(this.Description)) return false;
                if (!eval(this.Icon)) return false;
                if (Model != null)
                {
                    if (!eval(this.Model.Overall)) return false;
                    if (this.Model.Specific != null && !this.Model.Specific.All(eval)) return false;
                }
                if (!eval(this.Flags)) return false;
                if (!eval(this.BaseCost)) return false;
                if (!eval(this.Unused)) return false;
                if (!eval(this.Resistance)) return false;
                if (!eval(this.CounterEffectCount)) return false;
                if (!eval(this.Light)) return false;
                if (!eval(this.ProjectileSpeed)) return false;
                if (!eval(this.EffectShader)) return false;
                if (!eval(this.ObjectDisplayShader)) return false;
                if (!eval(this.EffectSound)) return false;
                if (!eval(this.BoltSound)) return false;
                if (!eval(this.HitSound)) return false;
                if (!eval(this.AreaSound)) return false;
                if (!eval(this.ConstantEffectEnchantmentFactor)) return false;
                if (!eval(this.ConstantEffectBarterFactor)) return false;
                if (Archetype != null)
                {
                    if (!eval(this.Archetype.Overall)) return false;
                    if (this.Archetype.Specific != null && !this.Archetype.Specific.All(eval)) return false;
                }
                if (!eval(this.ActorValue)) return false;
                if (this.CounterEffects != null)
                {
                    if (!eval(this.CounterEffects.Overall)) return false;
                    if (this.CounterEffects.Specific != null)
                    {
                        foreach (var item in this.CounterEffects.Specific)
                        {
                            if (!eval(item.Value)) return false;
                        }
                    }
                }
                return true;
            }
            #endregion

            #region Any
            public override bool Any(Func<TItem, bool> eval)
            {
                if (base.Any(eval)) return true;
                if (eval(this.Name)) return true;
                if (eval(this.Description)) return true;
                if (eval(this.Icon)) return true;
                if (Model != null)
                {
                    if (eval(this.Model.Overall)) return true;
                    if (this.Model.Specific != null && this.Model.Specific.Any(eval)) return true;
                }
                if (eval(this.Flags)) return true;
                if (eval(this.BaseCost)) return true;
                if (eval(this.Unused)) return true;
                if (eval(this.Resistance)) return true;
                if (eval(this.CounterEffectCount)) return true;
                if (eval(this.Light)) return true;
                if (eval(this.ProjectileSpeed)) return true;
                if (eval(this.EffectShader)) return true;
                if (eval(this.ObjectDisplayShader)) return true;
                if (eval(this.EffectSound)) return true;
                if (eval(this.BoltSound)) return true;
                if (eval(this.HitSound)) return true;
                if (eval(this.AreaSound)) return true;
                if (eval(this.ConstantEffectEnchantmentFactor)) return true;
                if (eval(this.ConstantEffectBarterFactor)) return true;
                if (Archetype != null)
                {
                    if (eval(this.Archetype.Overall)) return true;
                    if (this.Archetype.Specific != null && this.Archetype.Specific.Any(eval)) return true;
                }
                if (eval(this.ActorValue)) return true;
                if (this.CounterEffects != null)
                {
                    if (eval(this.CounterEffects.Overall)) return true;
                    if (this.CounterEffects.Specific != null)
                    {
                        foreach (var item in this.CounterEffects.Specific)
                        {
                            if (!eval(item.Value)) return false;
                        }
                    }
                }
                return false;
            }
            #endregion

            #region Translate
            public new Mask<R> Translate<R>(Func<TItem, R> eval)
            {
                var ret = new MagicEffect.Mask<R>();
                this.Translate_InternalFill(ret, eval);
                return ret;
            }

            protected void Translate_InternalFill<R>(Mask<R> obj, Func<TItem, R> eval)
            {
                base.Translate_InternalFill(obj, eval);
                obj.Name = eval(this.Name);
                obj.Description = eval(this.Description);
                obj.Icon = eval(this.Icon);
                obj.Model = this.Model == null ? null : new MaskItem<R, Model.Mask<R>?>(eval(this.Model.Overall), this.Model.Specific?.Translate(eval));
                obj.Flags = eval(this.Flags);
                obj.BaseCost = eval(this.BaseCost);
                obj.Unused = eval(this.Unused);
                obj.Resistance = eval(this.Resistance);
                obj.CounterEffectCount = eval(this.CounterEffectCount);
                obj.Light = eval(this.Light);
                obj.ProjectileSpeed = eval(this.ProjectileSpeed);
                obj.EffectShader = eval(this.EffectShader);
                obj.ObjectDisplayShader = eval(this.ObjectDisplayShader);
                obj.EffectSound = eval(this.EffectSound);
                obj.BoltSound = eval(this.BoltSound);
                obj.HitSound = eval(this.HitSound);
                obj.AreaSound = eval(this.AreaSound);
                obj.ConstantEffectEnchantmentFactor = eval(this.ConstantEffectEnchantmentFactor);
                obj.ConstantEffectBarterFactor = eval(this.ConstantEffectBarterFactor);
                obj.Archetype = this.Archetype == null ? null : new MaskItem<R, AMagicEffectArchetype.Mask<R>?>(eval(this.Archetype.Overall), this.Archetype.Specific?.Translate(eval));
                obj.ActorValue = eval(this.ActorValue);
                if (CounterEffects != null)
                {
                    obj.CounterEffects = new MaskItem<R, IEnumerable<(int Index, R Value)>?>(eval(this.CounterEffects.Overall), Enumerable.Empty<(int Index, R Value)>());
                    if (CounterEffects.Specific != null)
                    {
                        var l = new List<(int Index, R Item)>();
                        obj.CounterEffects.Specific = l;
                        foreach (var item in CounterEffects.Specific)
                        {
                            R mask = eval(item.Value);
                            l.Add((item.Index, mask));
                        }
                    }
                }
            }
            #endregion

            #region To String
            public override string ToString() => this.Print();

            public string Print(MagicEffect.Mask<bool>? printMask = null)
            {
                var sb = new StructuredStringBuilder();
                Print(sb, printMask);
                return sb.ToString();
            }

            public void Print(StructuredStringBuilder sb, MagicEffect.Mask<bool>? printMask = null)
            {
                sb.AppendLine($"{nameof(MagicEffect.Mask<TItem>)} =>");
                using (sb.Brace())
                {
                    if (printMask?.Name ?? true)
                    {
                        sb.AppendItem(Name, "Name");
                    }
                    if (printMask?.Description ?? true)
                    {
                        sb.AppendItem(Description, "Description");
                    }
                    if (printMask?.Icon ?? true)
                    {
                        sb.AppendItem(Icon, "Icon");
                    }
                    if (printMask?.Model?.Overall ?? true)
                    {
                        Model?.Print(sb);
                    }
                    if (printMask?.Flags ?? true)
                    {
                        sb.AppendItem(Flags, "Flags");
                    }
                    if (printMask?.BaseCost ?? true)
                    {
                        sb.AppendItem(BaseCost, "BaseCost");
                    }
                    if (printMask?.Unused ?? true)
                    {
                        sb.AppendItem(Unused, "Unused");
                    }
                    if (printMask?.Resistance ?? true)
                    {
                        sb.AppendItem(Resistance, "Resistance");
                    }
                    if (printMask?.CounterEffectCount ?? true)
                    {
                        sb.AppendItem(CounterEffectCount, "CounterEffectCount");
                    }
                    if (printMask?.Light ?? true)
                    {
                        sb.AppendItem(Light, "Light");
                    }
                    if (printMask?.ProjectileSpeed ?? true)
                    {
                        sb.AppendItem(ProjectileSpeed, "ProjectileSpeed");
                    }
                    if (printMask?.EffectShader ?? true)
                    {
                        sb.AppendItem(EffectShader, "EffectShader");
                    }
                    if (printMask?.ObjectDisplayShader ?? true)
                    {
                        sb.AppendItem(ObjectDisplayShader, "ObjectDisplayShader");
                    }
                    if (printMask?.EffectSound ?? true)
                    {
                        sb.AppendItem(EffectSound, "EffectSound");
                    }
                    if (printMask?.BoltSound ?? true)
                    {
                        sb.AppendItem(BoltSound, "BoltSound");
                    }
                    if (printMask?.HitSound ?? true)
                    {
                        sb.AppendItem(HitSound, "HitSound");
                    }
                    if (printMask?.AreaSound ?? true)
                    {
                        sb.AppendItem(AreaSound, "AreaSound");
                    }
                    if (printMask?.ConstantEffectEnchantmentFactor ?? true)
                    {
                        sb.AppendItem(ConstantEffectEnchantmentFactor, "ConstantEffectEnchantmentFactor");
                    }
                    if (printMask?.ConstantEffectBarterFactor ?? true)
                    {
                        sb.AppendItem(ConstantEffectBarterFactor, "ConstantEffectBarterFactor");
                    }
                    if (printMask?.Archetype?.Overall ?? true)
                    {
                        Archetype?.Print(sb);
                    }
                    if (printMask?.ActorValue ?? true)
                    {
                        sb.AppendItem(ActorValue, "ActorValue");
                    }
                    if ((printMask?.CounterEffects?.Overall ?? true)
                        && CounterEffects is {} CounterEffectsItem)
                    {
                        sb.AppendLine("CounterEffects =>");
                        using (sb.Brace())
                        {
                            sb.AppendItem(CounterEffectsItem.Overall);
                            if (CounterEffectsItem.Specific != null)
                            {
                                foreach (var subItem in CounterEffectsItem.Specific)
                                {
                                    using (sb.Brace())
                                    {
                                        {
                                            sb.AppendItem(subItem);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            #endregion

        }

        public new class ErrorMask :
            Fallout3MajorRecord.ErrorMask,
            IErrorMask<ErrorMask>
        {
            #region Members
            public Exception? Name;
            public Exception? Description;
            public Exception? Icon;
            public MaskItem<Exception?, Model.ErrorMask?>? Model;
            public Exception? Flags;
            public Exception? BaseCost;
            public Exception? Unused;
            public Exception? Resistance;
            public Exception? CounterEffectCount;
            public Exception? Light;
            public Exception? ProjectileSpeed;
            public Exception? EffectShader;
            public Exception? ObjectDisplayShader;
            public Exception? EffectSound;
            public Exception? BoltSound;
            public Exception? HitSound;
            public Exception? AreaSound;
            public Exception? ConstantEffectEnchantmentFactor;
            public Exception? ConstantEffectBarterFactor;
            public MaskItem<Exception?, AMagicEffectArchetype.ErrorMask?>? Archetype;
            public Exception? ActorValue;
            public MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>? CounterEffects;
            #endregion

            #region IErrorMask
            public override object? GetNthMask(int index)
            {
                MagicEffect_FieldIndex enu = (MagicEffect_FieldIndex)index;
                switch (enu)
                {
                    case MagicEffect_FieldIndex.Name:
                        return Name;
                    case MagicEffect_FieldIndex.Description:
                        return Description;
                    case MagicEffect_FieldIndex.Icon:
                        return Icon;
                    case MagicEffect_FieldIndex.Model:
                        return Model;
                    case MagicEffect_FieldIndex.Flags:
                        return Flags;
                    case MagicEffect_FieldIndex.BaseCost:
                        return BaseCost;
                    case MagicEffect_FieldIndex.Unused:
                        return Unused;
                    case MagicEffect_FieldIndex.Resistance:
                        return Resistance;
                    case MagicEffect_FieldIndex.CounterEffectCount:
                        return CounterEffectCount;
                    case MagicEffect_FieldIndex.Light:
                        return Light;
                    case MagicEffect_FieldIndex.ProjectileSpeed:
                        return ProjectileSpeed;
                    case MagicEffect_FieldIndex.EffectShader:
                        return EffectShader;
                    case MagicEffect_FieldIndex.ObjectDisplayShader:
                        return ObjectDisplayShader;
                    case MagicEffect_FieldIndex.EffectSound:
                        return EffectSound;
                    case MagicEffect_FieldIndex.BoltSound:
                        return BoltSound;
                    case MagicEffect_FieldIndex.HitSound:
                        return HitSound;
                    case MagicEffect_FieldIndex.AreaSound:
                        return AreaSound;
                    case MagicEffect_FieldIndex.ConstantEffectEnchantmentFactor:
                        return ConstantEffectEnchantmentFactor;
                    case MagicEffect_FieldIndex.ConstantEffectBarterFactor:
                        return ConstantEffectBarterFactor;
                    case MagicEffect_FieldIndex.Archetype:
                        return Archetype;
                    case MagicEffect_FieldIndex.ActorValue:
                        return ActorValue;
                    case MagicEffect_FieldIndex.CounterEffects:
                        return CounterEffects;
                    default:
                        return base.GetNthMask(index);
                }
            }

            public override void SetNthException(int index, Exception ex)
            {
                MagicEffect_FieldIndex enu = (MagicEffect_FieldIndex)index;
                switch (enu)
                {
                    case MagicEffect_FieldIndex.Name:
                        this.Name = ex;
                        break;
                    case MagicEffect_FieldIndex.Description:
                        this.Description = ex;
                        break;
                    case MagicEffect_FieldIndex.Icon:
                        this.Icon = ex;
                        break;
                    case MagicEffect_FieldIndex.Model:
                        this.Model = new MaskItem<Exception?, Model.ErrorMask?>(ex, null);
                        break;
                    case MagicEffect_FieldIndex.Flags:
                        this.Flags = ex;
                        break;
                    case MagicEffect_FieldIndex.BaseCost:
                        this.BaseCost = ex;
                        break;
                    case MagicEffect_FieldIndex.Unused:
                        this.Unused = ex;
                        break;
                    case MagicEffect_FieldIndex.Resistance:
                        this.Resistance = ex;
                        break;
                    case MagicEffect_FieldIndex.CounterEffectCount:
                        this.CounterEffectCount = ex;
                        break;
                    case MagicEffect_FieldIndex.Light:
                        this.Light = ex;
                        break;
                    case MagicEffect_FieldIndex.ProjectileSpeed:
                        this.ProjectileSpeed = ex;
                        break;
                    case MagicEffect_FieldIndex.EffectShader:
                        this.EffectShader = ex;
                        break;
                    case MagicEffect_FieldIndex.ObjectDisplayShader:
                        this.ObjectDisplayShader = ex;
                        break;
                    case MagicEffect_FieldIndex.EffectSound:
                        this.EffectSound = ex;
                        break;
                    case MagicEffect_FieldIndex.BoltSound:
                        this.BoltSound = ex;
                        break;
                    case MagicEffect_FieldIndex.HitSound:
                        this.HitSound = ex;
                        break;
                    case MagicEffect_FieldIndex.AreaSound:
                        this.AreaSound = ex;
                        break;
                    case MagicEffect_FieldIndex.ConstantEffectEnchantmentFactor:
                        this.ConstantEffectEnchantmentFactor = ex;
                        break;
                    case MagicEffect_FieldIndex.ConstantEffectBarterFactor:
                        this.ConstantEffectBarterFactor = ex;
                        break;
                    case MagicEffect_FieldIndex.Archetype:
                        this.Archetype = new MaskItem<Exception?, AMagicEffectArchetype.ErrorMask?>(ex, null);
                        break;
                    case MagicEffect_FieldIndex.ActorValue:
                        this.ActorValue = ex;
                        break;
                    case MagicEffect_FieldIndex.CounterEffects:
                        this.CounterEffects = new MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>(ex, null);
                        break;
                    default:
                        base.SetNthException(index, ex);
                        break;
                }
            }

            public override void SetNthMask(int index, object obj)
            {
                MagicEffect_FieldIndex enu = (MagicEffect_FieldIndex)index;
                switch (enu)
                {
                    case MagicEffect_FieldIndex.Name:
                        this.Name = (Exception?)obj;
                        break;
                    case MagicEffect_FieldIndex.Description:
                        this.Description = (Exception?)obj;
                        break;
                    case MagicEffect_FieldIndex.Icon:
                        this.Icon = (Exception?)obj;
                        break;
                    case MagicEffect_FieldIndex.Model:
                        this.Model = (MaskItem<Exception?, Model.ErrorMask?>?)obj;
                        break;
                    case MagicEffect_FieldIndex.Flags:
                        this.Flags = (Exception?)obj;
                        break;
                    case MagicEffect_FieldIndex.BaseCost:
                        this.BaseCost = (Exception?)obj;
                        break;
                    case MagicEffect_FieldIndex.Unused:
                        this.Unused = (Exception?)obj;
                        break;
                    case MagicEffect_FieldIndex.Resistance:
                        this.Resistance = (Exception?)obj;
                        break;
                    case MagicEffect_FieldIndex.CounterEffectCount:
                        this.CounterEffectCount = (Exception?)obj;
                        break;
                    case MagicEffect_FieldIndex.Light:
                        this.Light = (Exception?)obj;
                        break;
                    case MagicEffect_FieldIndex.ProjectileSpeed:
                        this.ProjectileSpeed = (Exception?)obj;
                        break;
                    case MagicEffect_FieldIndex.EffectShader:
                        this.EffectShader = (Exception?)obj;
                        break;
                    case MagicEffect_FieldIndex.ObjectDisplayShader:
                        this.ObjectDisplayShader = (Exception?)obj;
                        break;
                    case MagicEffect_FieldIndex.EffectSound:
                        this.EffectSound = (Exception?)obj;
                        break;
                    case MagicEffect_FieldIndex.BoltSound:
                        this.BoltSound = (Exception?)obj;
                        break;
                    case MagicEffect_FieldIndex.HitSound:
                        this.HitSound = (Exception?)obj;
                        break;
                    case MagicEffect_FieldIndex.AreaSound:
                        this.AreaSound = (Exception?)obj;
                        break;
                    case MagicEffect_FieldIndex.ConstantEffectEnchantmentFactor:
                        this.ConstantEffectEnchantmentFactor = (Exception?)obj;
                        break;
                    case MagicEffect_FieldIndex.ConstantEffectBarterFactor:
                        this.ConstantEffectBarterFactor = (Exception?)obj;
                        break;
                    case MagicEffect_FieldIndex.Archetype:
                        this.Archetype = (MaskItem<Exception?, AMagicEffectArchetype.ErrorMask?>?)obj;
                        break;
                    case MagicEffect_FieldIndex.ActorValue:
                        this.ActorValue = (Exception?)obj;
                        break;
                    case MagicEffect_FieldIndex.CounterEffects:
                        this.CounterEffects = (MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>)obj;
                        break;
                    default:
                        base.SetNthMask(index, obj);
                        break;
                }
            }

            public override bool IsInError()
            {
                if (Overall != null) return true;
                if (Name != null) return true;
                if (Description != null) return true;
                if (Icon != null) return true;
                if (Model != null) return true;
                if (Flags != null) return true;
                if (BaseCost != null) return true;
                if (Unused != null) return true;
                if (Resistance != null) return true;
                if (CounterEffectCount != null) return true;
                if (Light != null) return true;
                if (ProjectileSpeed != null) return true;
                if (EffectShader != null) return true;
                if (ObjectDisplayShader != null) return true;
                if (EffectSound != null) return true;
                if (BoltSound != null) return true;
                if (HitSound != null) return true;
                if (AreaSound != null) return true;
                if (ConstantEffectEnchantmentFactor != null) return true;
                if (ConstantEffectBarterFactor != null) return true;
                if (Archetype != null) return true;
                if (ActorValue != null) return true;
                if (CounterEffects != null) return true;
                return false;
            }
            #endregion

            #region To String
            public override string ToString() => this.Print();

            public override void Print(StructuredStringBuilder sb, string? name = null)
            {
                sb.AppendLine($"{(name ?? "ErrorMask")} =>");
                using (sb.Brace())
                {
                    if (this.Overall != null)
                    {
                        sb.AppendLine("Overall =>");
                        using (sb.Brace())
                        {
                            sb.AppendLine($"{this.Overall}");
                        }
                    }
                    PrintFillInternal(sb);
                }
            }
            protected override void PrintFillInternal(StructuredStringBuilder sb)
            {
                base.PrintFillInternal(sb);
                {
                    sb.AppendItem(Name, "Name");
                }
                {
                    sb.AppendItem(Description, "Description");
                }
                {
                    sb.AppendItem(Icon, "Icon");
                }
                Model?.Print(sb);
                {
                    sb.AppendItem(Flags, "Flags");
                }
                {
                    sb.AppendItem(BaseCost, "BaseCost");
                }
                {
                    sb.AppendItem(Unused, "Unused");
                }
                {
                    sb.AppendItem(Resistance, "Resistance");
                }
                {
                    sb.AppendItem(CounterEffectCount, "CounterEffectCount");
                }
                {
                    sb.AppendItem(Light, "Light");
                }
                {
                    sb.AppendItem(ProjectileSpeed, "ProjectileSpeed");
                }
                {
                    sb.AppendItem(EffectShader, "EffectShader");
                }
                {
                    sb.AppendItem(ObjectDisplayShader, "ObjectDisplayShader");
                }
                {
                    sb.AppendItem(EffectSound, "EffectSound");
                }
                {
                    sb.AppendItem(BoltSound, "BoltSound");
                }
                {
                    sb.AppendItem(HitSound, "HitSound");
                }
                {
                    sb.AppendItem(AreaSound, "AreaSound");
                }
                {
                    sb.AppendItem(ConstantEffectEnchantmentFactor, "ConstantEffectEnchantmentFactor");
                }
                {
                    sb.AppendItem(ConstantEffectBarterFactor, "ConstantEffectBarterFactor");
                }
                Archetype?.Print(sb);
                {
                    sb.AppendItem(ActorValue, "ActorValue");
                }
                if (CounterEffects is {} CounterEffectsItem)
                {
                    sb.AppendLine("CounterEffects =>");
                    using (sb.Brace())
                    {
                        sb.AppendItem(CounterEffectsItem.Overall);
                        if (CounterEffectsItem.Specific != null)
                        {
                            foreach (var subItem in CounterEffectsItem.Specific)
                            {
                                using (sb.Brace())
                                {
                                    {
                                        sb.AppendItem(subItem);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            #endregion

            #region Combine
            public ErrorMask Combine(ErrorMask? rhs)
            {
                if (rhs == null) return this;
                var ret = new ErrorMask();
                ret.Name = this.Name.Combine(rhs.Name);
                ret.Description = this.Description.Combine(rhs.Description);
                ret.Icon = this.Icon.Combine(rhs.Icon);
                ret.Model = this.Model.Combine(rhs.Model, (l, r) => l.Combine(r));
                ret.Flags = this.Flags.Combine(rhs.Flags);
                ret.BaseCost = this.BaseCost.Combine(rhs.BaseCost);
                ret.Unused = this.Unused.Combine(rhs.Unused);
                ret.Resistance = this.Resistance.Combine(rhs.Resistance);
                ret.CounterEffectCount = this.CounterEffectCount.Combine(rhs.CounterEffectCount);
                ret.Light = this.Light.Combine(rhs.Light);
                ret.ProjectileSpeed = this.ProjectileSpeed.Combine(rhs.ProjectileSpeed);
                ret.EffectShader = this.EffectShader.Combine(rhs.EffectShader);
                ret.ObjectDisplayShader = this.ObjectDisplayShader.Combine(rhs.ObjectDisplayShader);
                ret.EffectSound = this.EffectSound.Combine(rhs.EffectSound);
                ret.BoltSound = this.BoltSound.Combine(rhs.BoltSound);
                ret.HitSound = this.HitSound.Combine(rhs.HitSound);
                ret.AreaSound = this.AreaSound.Combine(rhs.AreaSound);
                ret.ConstantEffectEnchantmentFactor = this.ConstantEffectEnchantmentFactor.Combine(rhs.ConstantEffectEnchantmentFactor);
                ret.ConstantEffectBarterFactor = this.ConstantEffectBarterFactor.Combine(rhs.ConstantEffectBarterFactor);
                ret.Archetype = this.Archetype.Combine(rhs.Archetype, (l, r) => l.Combine(r));
                ret.ActorValue = this.ActorValue.Combine(rhs.ActorValue);
                ret.CounterEffects = new MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>(Noggog.ExceptionExt.Combine(this.CounterEffects?.Overall, rhs.CounterEffects?.Overall), Noggog.ExceptionExt.Combine(this.CounterEffects?.Specific, rhs.CounterEffects?.Specific));
                return ret;
            }
            public static ErrorMask? Combine(ErrorMask? lhs, ErrorMask? rhs)
            {
                if (lhs != null && rhs != null) return lhs.Combine(rhs);
                return lhs ?? rhs;
            }
            #endregion

            #region Factory
            public static new ErrorMask Factory(ErrorMaskBuilder errorMask)
            {
                return new ErrorMask();
            }
            #endregion

        }
        public new class TranslationMask :
            Fallout3MajorRecord.TranslationMask,
            ITranslationMask
        {
            #region Members
            public bool Name;
            public bool Description;
            public bool Icon;
            public Model.TranslationMask? Model;
            public bool Flags;
            public bool BaseCost;
            public bool Unused;
            public bool Resistance;
            public bool CounterEffectCount;
            public bool Light;
            public bool ProjectileSpeed;
            public bool EffectShader;
            public bool ObjectDisplayShader;
            public bool EffectSound;
            public bool BoltSound;
            public bool HitSound;
            public bool AreaSound;
            public bool ConstantEffectEnchantmentFactor;
            public bool ConstantEffectBarterFactor;
            public AMagicEffectArchetype.TranslationMask? Archetype;
            public bool ActorValue;
            public bool CounterEffects;
            #endregion

            #region Ctors
            public TranslationMask(
                bool defaultOn,
                bool onOverall = true)
                : base(defaultOn, onOverall)
            {
                this.Name = defaultOn;
                this.Description = defaultOn;
                this.Icon = defaultOn;
                this.Flags = defaultOn;
                this.BaseCost = defaultOn;
                this.Unused = defaultOn;
                this.Resistance = defaultOn;
                this.CounterEffectCount = defaultOn;
                this.Light = defaultOn;
                this.ProjectileSpeed = defaultOn;
                this.EffectShader = defaultOn;
                this.ObjectDisplayShader = defaultOn;
                this.EffectSound = defaultOn;
                this.BoltSound = defaultOn;
                this.HitSound = defaultOn;
                this.AreaSound = defaultOn;
                this.ConstantEffectEnchantmentFactor = defaultOn;
                this.ConstantEffectBarterFactor = defaultOn;
                this.ActorValue = defaultOn;
                this.CounterEffects = defaultOn;
            }

            #endregion

            protected override void GetCrystal(List<(bool On, TranslationCrystal? SubCrystal)> ret)
            {
                base.GetCrystal(ret);
                ret.Add((Name, null));
                ret.Add((Description, null));
                ret.Add((Icon, null));
                ret.Add((Model != null ? Model.OnOverall : DefaultOn, Model?.GetCrystal()));
                ret.Add((Flags, null));
                ret.Add((BaseCost, null));
                ret.Add((Unused, null));
                ret.Add((Resistance, null));
                ret.Add((CounterEffectCount, null));
                ret.Add((Light, null));
                ret.Add((ProjectileSpeed, null));
                ret.Add((EffectShader, null));
                ret.Add((ObjectDisplayShader, null));
                ret.Add((EffectSound, null));
                ret.Add((BoltSound, null));
                ret.Add((HitSound, null));
                ret.Add((AreaSound, null));
                ret.Add((ConstantEffectEnchantmentFactor, null));
                ret.Add((ConstantEffectBarterFactor, null));
                ret.Add((Archetype != null ? Archetype.OnOverall : DefaultOn, Archetype?.GetCrystal()));
                ret.Add((ActorValue, null));
                ret.Add((CounterEffects, null));
            }

            public static implicit operator TranslationMask(bool defaultOn)
            {
                return new TranslationMask(defaultOn: defaultOn, onOverall: defaultOn);
            }

        }
        #endregion

        #region Mutagen
        public static readonly RecordType GrupRecordType = MagicEffect_Registration.TriggeringRecordType;
        public override IEnumerable<IFormLinkGetter> EnumerateFormLinks() => MagicEffectCommon.Instance.EnumerateFormLinks(this);
        public override void RemapLinks(IReadOnlyDictionary<FormKey, FormKey> mapping) => MagicEffectSetterCommon.Instance.RemapLinks(this, mapping);
        public MagicEffect(
            FormKey formKey,
            Fallout3Release gameRelease)
        {
            this.FormKey = formKey;
            CustomCtor();
        }

        private MagicEffect(
            FormKey formKey,
            GameRelease gameRelease)
        {
            this.FormKey = formKey;
            CustomCtor();
        }

        public MagicEffect(IFallout3Mod mod)
            : this(
                mod.GetNextFormKey(),
                mod.Fallout3Release)
        {
        }

        public MagicEffect(IFallout3Mod mod, string editorID)
            : this(
                mod.GetNextFormKey(editorID),
                mod.Fallout3Release)
        {
            this.EditorID = editorID;
        }

        public override string ToString()
        {
            return MajorRecordPrinter<MagicEffect>.ToString(this);
        }

        protected override Type LinkType => typeof(IMagicEffect);

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is IFormLinkGetter formLink)
            {
                return formLink.Equals(this);
            }
            if (obj is not IMagicEffectGetter rhs) return false;
            return ((MagicEffectCommon)((IMagicEffectGetter)this).CommonInstance()!).Equals(this, rhs, equalsMask: null);
        }

        public bool Equals(IMagicEffectGetter? obj)
        {
            return ((MagicEffectCommon)((IMagicEffectGetter)this).CommonInstance()!).Equals(this, obj, equalsMask: null);
        }

        public override int GetHashCode() => ((MagicEffectCommon)((IMagicEffectGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        #endregion

        #region Binary Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected override object BinaryWriteTranslator => MagicEffectBinaryWriteTranslation.Instance;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((MagicEffectBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }
        #region Binary Create
        public new static MagicEffect CreateFromBinary(
            MutagenFrame frame,
            TypedParseParams translationParams = default)
        {
            var ret = new MagicEffect();
            ((MagicEffectSetterCommon)((IMagicEffectGetter)ret).CommonSetterInstance()!).CopyInFromBinary(
                item: ret,
                frame: frame,
                translationParams: translationParams);
            return ret;
        }

        #endregion

        public static bool TryCreateFromBinary(
            MutagenFrame frame,
            out MagicEffect item,
            TypedParseParams translationParams = default)
        {
            var startPos = frame.Position;
            item = CreateFromBinary(
                frame: frame,
                translationParams: translationParams);
            return startPos != frame.Position;
        }
        #endregion

        void IPrintable.Print(StructuredStringBuilder sb, string? name) => this.Print(sb, name);

        void IClearable.Clear()
        {
            ((MagicEffectSetterCommon)((IMagicEffectGetter)this).CommonSetterInstance()!).Clear(this);
        }

        internal static new MagicEffect GetNew()
        {
            return new MagicEffect();
        }

    }
    #endregion

    #region Interface
    public partial interface IMagicEffect :
        IFallout3MajorRecordInternal,
        IFormLinkContainer,
        ILoquiObjectSetter<IMagicEffectInternal>,
        IMagicEffectGetter,
        IModeled,
        INamed,
        INamedRequired
    {
        /// <summary>
        /// Aspects: INamed, INamedRequired
        /// </summary>
        new String? Name { get; set; }
        new String? Description { get; set; }
        new String? Icon { get; set; }
        /// <summary>
        /// Aspects: IModeled
        /// </summary>
        new Model? Model { get; set; }
        new MagicEffect.MagicFlag Flags { get; set; }
        new Single BaseCost { get; set; }
        new Int32 Unused { get; set; }
        new ActorValue Resistance { get; set; }
        new UInt32 CounterEffectCount { get; set; }
        new IFormLink<ILightGetter> Light { get; set; }
        new Single ProjectileSpeed { get; set; }
        new IFormLink<IEffectShaderGetter> EffectShader { get; set; }
        new IFormLink<IEffectShaderGetter> ObjectDisplayShader { get; set; }
        new IFormLink<ISoundGetter> EffectSound { get; set; }
        new IFormLink<ISoundGetter> BoltSound { get; set; }
        new IFormLink<ISoundGetter> HitSound { get; set; }
        new IFormLink<ISoundGetter> AreaSound { get; set; }
        new Single ConstantEffectEnchantmentFactor { get; set; }
        new Single ConstantEffectBarterFactor { get; set; }
        new AMagicEffectArchetype Archetype { get; set; }
        new ActorValue ActorValue { get; set; }
        new ExtendedList<IEDIDLinkGetter<IMagicEffectGetter>>? CounterEffects { get; set; }
    }

    public partial interface IMagicEffectInternal :
        IFallout3MajorRecordInternal,
        IMagicEffect,
        IMagicEffectGetter
    {
    }

    [AssociatedRecordTypesAttribute(Mutagen.Bethesda.Fallout3.Internals.RecordTypeInts.MGEF)]
    public partial interface IMagicEffectGetter :
        IFallout3MajorRecordGetter,
        IBinaryItem,
        IFormLinkContainerGetter,
        ILoquiObject<IMagicEffectGetter>,
        IMapsToGetter<IMagicEffectGetter>,
        IModeledGetter,
        INamedGetter,
        INamedRequiredGetter
    {
        static new ILoquiRegistration StaticRegistration => MagicEffect_Registration.Instance;
        #region Name
        /// <summary>
        /// Aspects: INamedGetter, INamedRequiredGetter
        /// </summary>
        String? Name { get; }
        #endregion
        String? Description { get; }
        String? Icon { get; }
        #region Model
        /// <summary>
        /// Aspects: IModeledGetter
        /// </summary>
        IModelGetter? Model { get; }
        #endregion
        MagicEffect.MagicFlag Flags { get; }
        Single BaseCost { get; }
        Int32 Unused { get; }
        ActorValue Resistance { get; }
        UInt32 CounterEffectCount { get; }
        IFormLinkGetter<ILightGetter> Light { get; }
        Single ProjectileSpeed { get; }
        IFormLinkGetter<IEffectShaderGetter> EffectShader { get; }
        IFormLinkGetter<IEffectShaderGetter> ObjectDisplayShader { get; }
        IFormLinkGetter<ISoundGetter> EffectSound { get; }
        IFormLinkGetter<ISoundGetter> BoltSound { get; }
        IFormLinkGetter<ISoundGetter> HitSound { get; }
        IFormLinkGetter<ISoundGetter> AreaSound { get; }
        Single ConstantEffectEnchantmentFactor { get; }
        Single ConstantEffectBarterFactor { get; }
        IAMagicEffectArchetypeGetter Archetype { get; }
        ActorValue ActorValue { get; }
        IReadOnlyList<IEDIDLinkGetter<IMagicEffectGetter>>? CounterEffects { get; }

    }

    #endregion

    #region Common MixIn
    public static partial class MagicEffectMixIn
    {
        public static void Clear(this IMagicEffectInternal item)
        {
            ((MagicEffectSetterCommon)((IMagicEffectGetter)item).CommonSetterInstance()!).Clear(item: item);
        }

        public static MagicEffect.Mask<bool> GetEqualsMask(
            this IMagicEffectGetter item,
            IMagicEffectGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            return ((MagicEffectCommon)((IMagicEffectGetter)item).CommonInstance()!).GetEqualsMask(
                item: item,
                rhs: rhs,
                include: include);
        }

        public static string Print(
            this IMagicEffectGetter item,
            string? name = null,
            MagicEffect.Mask<bool>? printMask = null)
        {
            return ((MagicEffectCommon)((IMagicEffectGetter)item).CommonInstance()!).Print(
                item: item,
                name: name,
                printMask: printMask);
        }

        public static void Print(
            this IMagicEffectGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            MagicEffect.Mask<bool>? printMask = null)
        {
            ((MagicEffectCommon)((IMagicEffectGetter)item).CommonInstance()!).Print(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
        }

        public static bool Equals(
            this IMagicEffectGetter item,
            IMagicEffectGetter rhs,
            MagicEffect.TranslationMask? equalsMask = null)
        {
            return ((MagicEffectCommon)((IMagicEffectGetter)item).CommonInstance()!).Equals(
                lhs: item,
                rhs: rhs,
                equalsMask: equalsMask?.GetCrystal());
        }

        public static void DeepCopyIn(
            this IMagicEffectInternal lhs,
            IMagicEffectGetter rhs,
            out MagicEffect.ErrorMask errorMask,
            MagicEffect.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            ((MagicEffectSetterTranslationCommon)((IMagicEffectGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
            errorMask = MagicEffect.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void DeepCopyIn(
            this IMagicEffectInternal lhs,
            IMagicEffectGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            ((MagicEffectSetterTranslationCommon)((IMagicEffectGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: false);
        }

        public static MagicEffect DeepCopy(
            this IMagicEffectGetter item,
            MagicEffect.TranslationMask? copyMask = null)
        {
            return ((MagicEffectSetterTranslationCommon)((IMagicEffectGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask);
        }

        public static MagicEffect DeepCopy(
            this IMagicEffectGetter item,
            out MagicEffect.ErrorMask errorMask,
            MagicEffect.TranslationMask? copyMask = null)
        {
            return ((MagicEffectSetterTranslationCommon)((IMagicEffectGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: out errorMask);
        }

        public static MagicEffect DeepCopy(
            this IMagicEffectGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            return ((MagicEffectSetterTranslationCommon)((IMagicEffectGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: errorMask);
        }

        #region Mutagen
        public static MagicEffect Duplicate(
            this IMagicEffectGetter item,
            FormKey formKey,
            MagicEffect.TranslationMask? copyMask = null)
        {
            return ((MagicEffectCommon)((IMagicEffectGetter)item).CommonInstance()!).Duplicate(
                item: item,
                formKey: formKey,
                copyMask: copyMask?.GetCrystal());
        }

        public static MagicEffect Duplicate(
            this IMagicEffectGetter item,
            FormKey formKey,
            TranslationCrystal? copyMask)
        {
            return ((MagicEffectCommon)((IMagicEffectGetter)item).CommonInstance()!).Duplicate(
                item: item,
                formKey: formKey,
                copyMask: copyMask);
        }

        #endregion

        #region Binary Translation
        public static void CopyInFromBinary(
            this IMagicEffectInternal item,
            MutagenFrame frame,
            TypedParseParams translationParams = default)
        {
            ((MagicEffectSetterCommon)((IMagicEffectGetter)item).CommonSetterInstance()!).CopyInFromBinary(
                item: item,
                frame: frame,
                translationParams: translationParams);
        }

        #endregion

    }
    #endregion

}

namespace Mutagen.Bethesda.Fallout3
{
    #region Field Index
    internal enum MagicEffect_FieldIndex
    {
        MajorRecordFlagsRaw = 0,
        FormKey = 1,
        VersionControl = 2,
        EditorID = 3,
        FormVersion = 4,
        Version2 = 5,
        Fallout3MajorRecordFlags = 6,
        Name = 7,
        Description = 8,
        Icon = 9,
        Model = 10,
        Flags = 11,
        BaseCost = 12,
        Unused = 13,
        Resistance = 14,
        CounterEffectCount = 15,
        Light = 16,
        ProjectileSpeed = 17,
        EffectShader = 18,
        ObjectDisplayShader = 19,
        EffectSound = 20,
        BoltSound = 21,
        HitSound = 22,
        AreaSound = 23,
        ConstantEffectEnchantmentFactor = 24,
        ConstantEffectBarterFactor = 25,
        Archetype = 26,
        ActorValue = 27,
        CounterEffects = 28,
    }
    #endregion

    #region Registration
    internal partial class MagicEffect_Registration : ILoquiRegistration
    {
        public static readonly MagicEffect_Registration Instance = new MagicEffect_Registration();

        public static ProtocolKey ProtocolKey => ProtocolDefinition_Fallout3.ProtocolKey;

        public const ushort AdditionalFieldCount = 22;

        public const ushort FieldCount = 29;

        public static readonly Type MaskType = typeof(MagicEffect.Mask<>);

        public static readonly Type ErrorMaskType = typeof(MagicEffect.ErrorMask);

        public static readonly Type ClassType = typeof(MagicEffect);

        public static readonly Type GetterType = typeof(IMagicEffectGetter);

        public static readonly Type? InternalGetterType = null;

        public static readonly Type SetterType = typeof(IMagicEffect);

        public static readonly Type? InternalSetterType = typeof(IMagicEffectInternal);

        public const string FullName = "Mutagen.Bethesda.Fallout3.MagicEffect";

        public const string Name = "MagicEffect";

        public const string Namespace = "Mutagen.Bethesda.Fallout3";

        public const byte GenericCount = 0;

        public static readonly Type? GenericRegistrationType = null;

        public static readonly RecordType TriggeringRecordType = RecordTypes.MGEF;
        public static RecordTriggerSpecs TriggerSpecs => _recordSpecs.Value;
        private static readonly Lazy<RecordTriggerSpecs> _recordSpecs = new Lazy<RecordTriggerSpecs>(() =>
        {
            var triggers = RecordCollection.Factory(RecordTypes.MGEF);
            var all = RecordCollection.Factory(
                RecordTypes.MGEF,
                RecordTypes.FULL,
                RecordTypes.DESC,
                RecordTypes.ICON,
                RecordTypes.MODL,
                RecordTypes.DATA,
                RecordTypes.ESCE);
            return new RecordTriggerSpecs(
                allRecordTypes: all,
                triggeringRecordTypes: triggers);
        });
        public static readonly Type BinaryWriteTranslation = typeof(MagicEffectBinaryWriteTranslation);
        #region Interface
        ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;
        ushort ILoquiRegistration.FieldCount => FieldCount;
        ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;
        Type ILoquiRegistration.MaskType => MaskType;
        Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;
        Type ILoquiRegistration.ClassType => ClassType;
        Type ILoquiRegistration.SetterType => SetterType;
        Type? ILoquiRegistration.InternalSetterType => InternalSetterType;
        Type ILoquiRegistration.GetterType => GetterType;
        Type? ILoquiRegistration.InternalGetterType => InternalGetterType;
        string ILoquiRegistration.FullName => FullName;
        string ILoquiRegistration.Name => Name;
        string ILoquiRegistration.Namespace => Namespace;
        byte ILoquiRegistration.GenericCount => GenericCount;
        Type? ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;
        ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsLoqui(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsSingleton(ushort index) => throw new NotImplementedException();
        string ILoquiRegistration.GetNthName(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsNthDerivative(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsProtected(ushort index) => throw new NotImplementedException();
        Type ILoquiRegistration.GetNthType(ushort index) => throw new NotImplementedException();
        #endregion

    }
    #endregion

    #region Common
    internal partial class MagicEffectSetterCommon : Fallout3MajorRecordSetterCommon
    {
        public new static readonly MagicEffectSetterCommon Instance = new MagicEffectSetterCommon();

        partial void ClearPartial();
        
        public void Clear(IMagicEffectInternal item)
        {
            ClearPartial();
            item.Name = default;
            item.Description = default;
            item.Icon = default;
            item.Model = null;
            item.Flags = default(MagicEffect.MagicFlag);
            item.BaseCost = default(Single);
            item.Unused = default(Int32);
            item.Resistance = default(ActorValue);
            item.CounterEffectCount = default(UInt32);
            item.Light.Clear();
            item.ProjectileSpeed = default(Single);
            item.EffectShader.Clear();
            item.ObjectDisplayShader.Clear();
            item.EffectSound.Clear();
            item.BoltSound.Clear();
            item.HitSound.Clear();
            item.AreaSound.Clear();
            item.ConstantEffectEnchantmentFactor = default(Single);
            item.ConstantEffectBarterFactor = default(Single);
            item.Archetype.Clear();
            item.ActorValue = MagicEffect.ActorValueDefault;
            item.CounterEffects = null;
            base.Clear(item);
        }
        
        public override void Clear(IFallout3MajorRecordInternal item)
        {
            Clear(item: (IMagicEffectInternal)item);
        }
        
        public override void Clear(IMajorRecordInternal item)
        {
            Clear(item: (IMagicEffectInternal)item);
        }
        
        #region Mutagen
        public void RemapLinks(IMagicEffect obj, IReadOnlyDictionary<FormKey, FormKey> mapping)
        {
            base.RemapLinks(obj, mapping);
            obj.Model?.RemapLinks(mapping);
            obj.Light.Relink(mapping);
            obj.EffectShader.Relink(mapping);
            obj.ObjectDisplayShader.Relink(mapping);
            obj.EffectSound.Relink(mapping);
            obj.BoltSound.Relink(mapping);
            obj.HitSound.Relink(mapping);
            obj.AreaSound.Relink(mapping);
            obj.Archetype.RemapLinks(mapping);
        }
        
        #endregion
        
        #region Binary Translation
        public virtual void CopyInFromBinary(
            IMagicEffectInternal item,
            MutagenFrame frame,
            TypedParseParams translationParams)
        {
            PluginUtilityTranslation.MajorRecordParse<IMagicEffectInternal>(
                record: item,
                frame: frame,
                translationParams: translationParams,
                fillStructs: MagicEffectBinaryCreateTranslation.FillBinaryStructs,
                fillTyped: MagicEffectBinaryCreateTranslation.FillBinaryRecordTypes);
        }
        
        public override void CopyInFromBinary(
            IFallout3MajorRecordInternal item,
            MutagenFrame frame,
            TypedParseParams translationParams)
        {
            CopyInFromBinary(
                item: (MagicEffect)item,
                frame: frame,
                translationParams: translationParams);
        }
        
        public override void CopyInFromBinary(
            IMajorRecordInternal item,
            MutagenFrame frame,
            TypedParseParams translationParams)
        {
            CopyInFromBinary(
                item: (MagicEffect)item,
                frame: frame,
                translationParams: translationParams);
        }
        
        #endregion
        
    }
    internal partial class MagicEffectCommon : Fallout3MajorRecordCommon
    {
        public new static readonly MagicEffectCommon Instance = new MagicEffectCommon();

        public MagicEffect.Mask<bool> GetEqualsMask(
            IMagicEffectGetter item,
            IMagicEffectGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            var ret = new MagicEffect.Mask<bool>(false);
            ((MagicEffectCommon)((IMagicEffectGetter)item).CommonInstance()!).FillEqualsMask(
                item: item,
                rhs: rhs,
                ret: ret,
                include: include);
            return ret;
        }
        
        public void FillEqualsMask(
            IMagicEffectGetter item,
            IMagicEffectGetter rhs,
            MagicEffect.Mask<bool> ret,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            ret.Name = string.Equals(item.Name, rhs.Name);
            ret.Description = string.Equals(item.Description, rhs.Description);
            ret.Icon = string.Equals(item.Icon, rhs.Icon);
            ret.Model = EqualsMaskHelper.EqualsHelper(
                item.Model,
                rhs.Model,
                (loqLhs, loqRhs, incl) => loqLhs.GetEqualsMask(loqRhs, incl),
                include);
            ret.Flags = item.Flags == rhs.Flags;
            ret.BaseCost = item.BaseCost.EqualsWithin(rhs.BaseCost);
            ret.Unused = item.Unused == rhs.Unused;
            ret.Resistance = item.Resistance == rhs.Resistance;
            ret.CounterEffectCount = item.CounterEffectCount == rhs.CounterEffectCount;
            ret.Light = item.Light.Equals(rhs.Light);
            ret.ProjectileSpeed = item.ProjectileSpeed.EqualsWithin(rhs.ProjectileSpeed);
            ret.EffectShader = item.EffectShader.Equals(rhs.EffectShader);
            ret.ObjectDisplayShader = item.ObjectDisplayShader.Equals(rhs.ObjectDisplayShader);
            ret.EffectSound = item.EffectSound.Equals(rhs.EffectSound);
            ret.BoltSound = item.BoltSound.Equals(rhs.BoltSound);
            ret.HitSound = item.HitSound.Equals(rhs.HitSound);
            ret.AreaSound = item.AreaSound.Equals(rhs.AreaSound);
            ret.ConstantEffectEnchantmentFactor = item.ConstantEffectEnchantmentFactor.EqualsWithin(rhs.ConstantEffectEnchantmentFactor);
            ret.ConstantEffectBarterFactor = item.ConstantEffectBarterFactor.EqualsWithin(rhs.ConstantEffectBarterFactor);
            ret.Archetype = MaskItemExt.Factory(item.Archetype.GetEqualsMask(rhs.Archetype, include), include);
            ret.ActorValue = item.ActorValue == rhs.ActorValue;
            ret.CounterEffects = item.CounterEffects.CollectionEqualsHelper(
                rhs.CounterEffects,
                (l, r) => object.Equals(l, r),
                include);
            base.FillEqualsMask(item, rhs, ret, include);
        }
        
        public string Print(
            IMagicEffectGetter item,
            string? name = null,
            MagicEffect.Mask<bool>? printMask = null)
        {
            var sb = new StructuredStringBuilder();
            Print(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
            return sb.ToString();
        }
        
        public void Print(
            IMagicEffectGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            MagicEffect.Mask<bool>? printMask = null)
        {
            if (name == null)
            {
                sb.AppendLine($"MagicEffect =>");
            }
            else
            {
                sb.AppendLine($"{name} (MagicEffect) =>");
            }
            using (sb.Brace())
            {
                ToStringFields(
                    item: item,
                    sb: sb,
                    printMask: printMask);
            }
        }
        
        protected static void ToStringFields(
            IMagicEffectGetter item,
            StructuredStringBuilder sb,
            MagicEffect.Mask<bool>? printMask = null)
        {
            Fallout3MajorRecordCommon.ToStringFields(
                item: item,
                sb: sb,
                printMask: printMask);
            if ((printMask?.Name ?? true)
                && item.Name is {} NameItem)
            {
                sb.AppendItem(NameItem, "Name");
            }
            if ((printMask?.Description ?? true)
                && item.Description is {} DescriptionItem)
            {
                sb.AppendItem(DescriptionItem, "Description");
            }
            if ((printMask?.Icon ?? true)
                && item.Icon is {} IconItem)
            {
                sb.AppendItem(IconItem, "Icon");
            }
            if ((printMask?.Model?.Overall ?? true)
                && item.Model is {} ModelItem)
            {
                ModelItem?.Print(sb, "Model");
            }
            if (printMask?.Flags ?? true)
            {
                sb.AppendItem(item.Flags, "Flags");
            }
            if (printMask?.BaseCost ?? true)
            {
                sb.AppendItem(item.BaseCost, "BaseCost");
            }
            if (printMask?.Unused ?? true)
            {
                sb.AppendItem(item.Unused, "Unused");
            }
            if (printMask?.Resistance ?? true)
            {
                sb.AppendItem(item.Resistance, "Resistance");
            }
            if (printMask?.CounterEffectCount ?? true)
            {
                sb.AppendItem(item.CounterEffectCount, "CounterEffectCount");
            }
            if (printMask?.Light ?? true)
            {
                sb.AppendItem(item.Light.FormKey, "Light");
            }
            if (printMask?.ProjectileSpeed ?? true)
            {
                sb.AppendItem(item.ProjectileSpeed, "ProjectileSpeed");
            }
            if (printMask?.EffectShader ?? true)
            {
                sb.AppendItem(item.EffectShader.FormKey, "EffectShader");
            }
            if (printMask?.ObjectDisplayShader ?? true)
            {
                sb.AppendItem(item.ObjectDisplayShader.FormKey, "ObjectDisplayShader");
            }
            if (printMask?.EffectSound ?? true)
            {
                sb.AppendItem(item.EffectSound.FormKey, "EffectSound");
            }
            if (printMask?.BoltSound ?? true)
            {
                sb.AppendItem(item.BoltSound.FormKey, "BoltSound");
            }
            if (printMask?.HitSound ?? true)
            {
                sb.AppendItem(item.HitSound.FormKey, "HitSound");
            }
            if (printMask?.AreaSound ?? true)
            {
                sb.AppendItem(item.AreaSound.FormKey, "AreaSound");
            }
            if (printMask?.ConstantEffectEnchantmentFactor ?? true)
            {
                sb.AppendItem(item.ConstantEffectEnchantmentFactor, "ConstantEffectEnchantmentFactor");
            }
            if (printMask?.ConstantEffectBarterFactor ?? true)
            {
                sb.AppendItem(item.ConstantEffectBarterFactor, "ConstantEffectBarterFactor");
            }
            if (printMask?.Archetype?.Overall ?? true)
            {
                item.Archetype?.Print(sb, "Archetype");
            }
            if (printMask?.ActorValue ?? true)
            {
                sb.AppendItem(item.ActorValue, "ActorValue");
            }
            if ((printMask?.CounterEffects?.Overall ?? true)
                && item.CounterEffects is {} CounterEffectsItem)
            {
                sb.AppendLine("CounterEffects =>");
                using (sb.Brace())
                {
                    foreach (var subItem in CounterEffectsItem)
                    {
                        using (sb.Brace())
                        {
                            sb.AppendItem(subItem.EDID);
                        }
                    }
                }
            }
        }
        
        public static MagicEffect_FieldIndex ConvertFieldIndex(Fallout3MajorRecord_FieldIndex index)
        {
            switch (index)
            {
                case Fallout3MajorRecord_FieldIndex.MajorRecordFlagsRaw:
                    return (MagicEffect_FieldIndex)((int)index);
                case Fallout3MajorRecord_FieldIndex.FormKey:
                    return (MagicEffect_FieldIndex)((int)index);
                case Fallout3MajorRecord_FieldIndex.VersionControl:
                    return (MagicEffect_FieldIndex)((int)index);
                case Fallout3MajorRecord_FieldIndex.EditorID:
                    return (MagicEffect_FieldIndex)((int)index);
                case Fallout3MajorRecord_FieldIndex.FormVersion:
                    return (MagicEffect_FieldIndex)((int)index);
                case Fallout3MajorRecord_FieldIndex.Version2:
                    return (MagicEffect_FieldIndex)((int)index);
                case Fallout3MajorRecord_FieldIndex.Fallout3MajorRecordFlags:
                    return (MagicEffect_FieldIndex)((int)index);
                default:
                    throw new ArgumentException($"Index is out of range: {index.ToStringFast()}");
            }
        }
        
        public static new MagicEffect_FieldIndex ConvertFieldIndex(MajorRecord_FieldIndex index)
        {
            switch (index)
            {
                case MajorRecord_FieldIndex.MajorRecordFlagsRaw:
                    return (MagicEffect_FieldIndex)((int)index);
                case MajorRecord_FieldIndex.FormKey:
                    return (MagicEffect_FieldIndex)((int)index);
                case MajorRecord_FieldIndex.VersionControl:
                    return (MagicEffect_FieldIndex)((int)index);
                case MajorRecord_FieldIndex.EditorID:
                    return (MagicEffect_FieldIndex)((int)index);
                default:
                    throw new ArgumentException($"Index is out of range: {index.ToStringFast()}");
            }
        }
        
        #region Equals and Hash
        public virtual bool Equals(
            IMagicEffectGetter? lhs,
            IMagicEffectGetter? rhs,
            TranslationCrystal? equalsMask)
        {
            if (!EqualsMaskHelper.RefEquality(lhs, rhs, out var isEqual)) return isEqual;
            if (!base.Equals((IFallout3MajorRecordGetter)lhs, (IFallout3MajorRecordGetter)rhs, equalsMask)) return false;
            if ((equalsMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.Name) ?? true))
            {
                if (!string.Equals(lhs.Name, rhs.Name)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.Description) ?? true))
            {
                if (!string.Equals(lhs.Description, rhs.Description)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.Icon) ?? true))
            {
                if (!string.Equals(lhs.Icon, rhs.Icon)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.Model) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Model, rhs.Model, out var lhsModel, out var rhsModel, out var isModelEqual))
                {
                    if (!((ModelCommon)((IModelGetter)lhsModel).CommonInstance()!).Equals(lhsModel, rhsModel, equalsMask?.GetSubCrystal((int)MagicEffect_FieldIndex.Model))) return false;
                }
                else if (!isModelEqual) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.Flags) ?? true))
            {
                if (lhs.Flags != rhs.Flags) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.BaseCost) ?? true))
            {
                if (!lhs.BaseCost.EqualsWithin(rhs.BaseCost)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.Unused) ?? true))
            {
                if (lhs.Unused != rhs.Unused) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.Resistance) ?? true))
            {
                if (lhs.Resistance != rhs.Resistance) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.CounterEffectCount) ?? true))
            {
                if (lhs.CounterEffectCount != rhs.CounterEffectCount) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.Light) ?? true))
            {
                if (!lhs.Light.Equals(rhs.Light)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.ProjectileSpeed) ?? true))
            {
                if (!lhs.ProjectileSpeed.EqualsWithin(rhs.ProjectileSpeed)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.EffectShader) ?? true))
            {
                if (!lhs.EffectShader.Equals(rhs.EffectShader)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.ObjectDisplayShader) ?? true))
            {
                if (!lhs.ObjectDisplayShader.Equals(rhs.ObjectDisplayShader)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.EffectSound) ?? true))
            {
                if (!lhs.EffectSound.Equals(rhs.EffectSound)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.BoltSound) ?? true))
            {
                if (!lhs.BoltSound.Equals(rhs.BoltSound)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.HitSound) ?? true))
            {
                if (!lhs.HitSound.Equals(rhs.HitSound)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.AreaSound) ?? true))
            {
                if (!lhs.AreaSound.Equals(rhs.AreaSound)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.ConstantEffectEnchantmentFactor) ?? true))
            {
                if (!lhs.ConstantEffectEnchantmentFactor.EqualsWithin(rhs.ConstantEffectEnchantmentFactor)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.ConstantEffectBarterFactor) ?? true))
            {
                if (!lhs.ConstantEffectBarterFactor.EqualsWithin(rhs.ConstantEffectBarterFactor)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.Archetype) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Archetype, rhs.Archetype, out var lhsArchetype, out var rhsArchetype, out var isArchetypeEqual))
                {
                    if (!((AMagicEffectArchetypeCommon)((IAMagicEffectArchetypeGetter)lhsArchetype).CommonInstance()!).Equals(lhsArchetype, rhsArchetype, equalsMask?.GetSubCrystal((int)MagicEffect_FieldIndex.Archetype))) return false;
                }
                else if (!isArchetypeEqual) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.ActorValue) ?? true))
            {
                if (lhs.ActorValue != rhs.ActorValue) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.CounterEffects) ?? true))
            {
                if (!lhs.CounterEffects.SequenceEqualNullable(rhs.CounterEffects)) return false;
            }
            return true;
        }
        
        public override bool Equals(
            IFallout3MajorRecordGetter? lhs,
            IFallout3MajorRecordGetter? rhs,
            TranslationCrystal? equalsMask)
        {
            return Equals(
                lhs: (IMagicEffectGetter?)lhs,
                rhs: rhs as IMagicEffectGetter,
                equalsMask: equalsMask);
        }
        
        public override bool Equals(
            IMajorRecordGetter? lhs,
            IMajorRecordGetter? rhs,
            TranslationCrystal? equalsMask)
        {
            return Equals(
                lhs: (IMagicEffectGetter?)lhs,
                rhs: rhs as IMagicEffectGetter,
                equalsMask: equalsMask);
        }
        
        public virtual int GetHashCode(IMagicEffectGetter item)
        {
            var hash = new HashCode();
            if (item.Name is {} Nameitem)
            {
                hash.Add(Nameitem);
            }
            if (item.Description is {} Descriptionitem)
            {
                hash.Add(Descriptionitem);
            }
            if (item.Icon is {} Iconitem)
            {
                hash.Add(Iconitem);
            }
            if (item.Model is {} Modelitem)
            {
                hash.Add(Modelitem);
            }
            hash.Add(item.Flags);
            hash.Add(item.BaseCost);
            hash.Add(item.Unused);
            hash.Add(item.Resistance);
            hash.Add(item.CounterEffectCount);
            hash.Add(item.Light);
            hash.Add(item.ProjectileSpeed);
            hash.Add(item.EffectShader);
            hash.Add(item.ObjectDisplayShader);
            hash.Add(item.EffectSound);
            hash.Add(item.BoltSound);
            hash.Add(item.HitSound);
            hash.Add(item.AreaSound);
            hash.Add(item.ConstantEffectEnchantmentFactor);
            hash.Add(item.ConstantEffectBarterFactor);
            hash.Add(item.Archetype);
            hash.Add(item.ActorValue);
            hash.Add(item.CounterEffects);
            hash.Add(base.GetHashCode());
            return hash.ToHashCode();
        }
        
        public override int GetHashCode(IFallout3MajorRecordGetter item)
        {
            return GetHashCode(item: (IMagicEffectGetter)item);
        }
        
        public override int GetHashCode(IMajorRecordGetter item)
        {
            return GetHashCode(item: (IMagicEffectGetter)item);
        }
        
        #endregion
        
        
        public override object GetNew()
        {
            return MagicEffect.GetNew();
        }
        
        #region Mutagen
        public IEnumerable<IFormLinkGetter> EnumerateFormLinks(IMagicEffectGetter obj)
        {
            foreach (var item in base.EnumerateFormLinks(obj))
            {
                yield return item;
            }
            if (obj.Model is {} ModelItems)
            {
                foreach (var item in ModelItems.EnumerateFormLinks())
                {
                    yield return item;
                }
            }
            yield return FormLinkInformation.Factory(obj.Light);
            yield return FormLinkInformation.Factory(obj.EffectShader);
            yield return FormLinkInformation.Factory(obj.ObjectDisplayShader);
            yield return FormLinkInformation.Factory(obj.EffectSound);
            yield return FormLinkInformation.Factory(obj.BoltSound);
            yield return FormLinkInformation.Factory(obj.HitSound);
            yield return FormLinkInformation.Factory(obj.AreaSound);
            if (obj.Archetype is IFormLinkContainerGetter ArchetypelinkCont)
            {
                foreach (var item in ArchetypelinkCont.EnumerateFormLinks())
                {
                    yield return item;
                }
            }
            yield break;
        }
        
        #region Duplicate
        public MagicEffect Duplicate(
            IMagicEffectGetter item,
            FormKey formKey,
            TranslationCrystal? copyMask)
        {
            var newRec = new MagicEffect(formKey, default(Fallout3Release));
            newRec.DeepCopyIn(item, default(ErrorMaskBuilder?), copyMask);
            return newRec;
        }
        
        public override Fallout3MajorRecord Duplicate(
            IFallout3MajorRecordGetter item,
            FormKey formKey,
            TranslationCrystal? copyMask)
        {
            return this.Duplicate(
                item: (IMagicEffectGetter)item,
                formKey: formKey,
                copyMask: copyMask);
        }
        
        public override MajorRecord Duplicate(
            IMajorRecordGetter item,
            FormKey formKey,
            TranslationCrystal? copyMask)
        {
            return this.Duplicate(
                item: (IMagicEffectGetter)item,
                formKey: formKey,
                copyMask: copyMask);
        }
        
        #endregion
        
        #endregion
        
    }
    internal partial class MagicEffectSetterTranslationCommon : Fallout3MajorRecordSetterTranslationCommon
    {
        public new static readonly MagicEffectSetterTranslationCommon Instance = new MagicEffectSetterTranslationCommon();

        #region DeepCopyIn
        public void DeepCopyIn(
            IMagicEffectInternal item,
            IMagicEffectGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            base.DeepCopyIn(
                item,
                rhs,
                errorMask,
                copyMask,
                deepCopy: deepCopy);
        }
        
        public void DeepCopyIn(
            IMagicEffect item,
            IMagicEffectGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            base.DeepCopyIn(
                (IFallout3MajorRecord)item,
                (IFallout3MajorRecordGetter)rhs,
                errorMask,
                copyMask,
                deepCopy: deepCopy);
            if ((copyMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.Name) ?? true))
            {
                item.Name = rhs.Name;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.Description) ?? true))
            {
                item.Description = rhs.Description;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.Icon) ?? true))
            {
                item.Icon = rhs.Icon;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.Model) ?? true))
            {
                errorMask?.PushIndex((int)MagicEffect_FieldIndex.Model);
                try
                {
                    if(rhs.Model is {} rhsModel)
                    {
                        item.Model = rhsModel.DeepCopy(
                            errorMask: errorMask,
                            copyMask?.GetSubCrystal((int)MagicEffect_FieldIndex.Model));
                    }
                    else
                    {
                        item.Model = default;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.Flags) ?? true))
            {
                item.Flags = rhs.Flags;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.BaseCost) ?? true))
            {
                item.BaseCost = rhs.BaseCost;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.Unused) ?? true))
            {
                item.Unused = rhs.Unused;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.Resistance) ?? true))
            {
                item.Resistance = rhs.Resistance;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.CounterEffectCount) ?? true))
            {
                item.CounterEffectCount = rhs.CounterEffectCount;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.Light) ?? true))
            {
                item.Light.SetTo(rhs.Light.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.ProjectileSpeed) ?? true))
            {
                item.ProjectileSpeed = rhs.ProjectileSpeed;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.EffectShader) ?? true))
            {
                item.EffectShader.SetTo(rhs.EffectShader.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.ObjectDisplayShader) ?? true))
            {
                item.ObjectDisplayShader.SetTo(rhs.ObjectDisplayShader.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.EffectSound) ?? true))
            {
                item.EffectSound.SetTo(rhs.EffectSound.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.BoltSound) ?? true))
            {
                item.BoltSound.SetTo(rhs.BoltSound.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.HitSound) ?? true))
            {
                item.HitSound.SetTo(rhs.HitSound.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.AreaSound) ?? true))
            {
                item.AreaSound.SetTo(rhs.AreaSound.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.ConstantEffectEnchantmentFactor) ?? true))
            {
                item.ConstantEffectEnchantmentFactor = rhs.ConstantEffectEnchantmentFactor;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.ConstantEffectBarterFactor) ?? true))
            {
                item.ConstantEffectBarterFactor = rhs.ConstantEffectBarterFactor;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.Archetype) ?? true))
            {
                errorMask?.PushIndex((int)MagicEffect_FieldIndex.Archetype);
                try
                {
                    if ((copyMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.Archetype) ?? true))
                    {
                        item.Archetype = rhs.Archetype.DeepCopy(
                            copyMask: copyMask?.GetSubCrystal((int)MagicEffect_FieldIndex.Archetype),
                            errorMask: errorMask);
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.ActorValue) ?? true))
            {
                item.ActorValue = rhs.ActorValue;
            }
            if ((copyMask?.GetShouldTranslate((int)MagicEffect_FieldIndex.CounterEffects) ?? true))
            {
                errorMask?.PushIndex((int)MagicEffect_FieldIndex.CounterEffects);
                try
                {
                    if ((rhs.CounterEffects != null))
                    {
                        item.CounterEffects = 
                            rhs.CounterEffects
                                .Select(b => (IEDIDLinkGetter<IMagicEffectGetter>)new EDIDLink<IMagicEffectGetter>(b.EDID))
                            .ToExtendedList<IEDIDLinkGetter<IMagicEffectGetter>>();
                    }
                    else
                    {
                        item.CounterEffects = null;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            DeepCopyInCustom(
                item: item,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        partial void DeepCopyInCustom(
            IMagicEffect item,
            IMagicEffectGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy);
        public override void DeepCopyIn(
            IFallout3MajorRecordInternal item,
            IFallout3MajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IMagicEffectInternal)item,
                rhs: (IMagicEffectGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        public override void DeepCopyIn(
            IFallout3MajorRecord item,
            IFallout3MajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IMagicEffect)item,
                rhs: (IMagicEffectGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        public override void DeepCopyIn(
            IMajorRecordInternal item,
            IMajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IMagicEffectInternal)item,
                rhs: (IMagicEffectGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        public override void DeepCopyIn(
            IMajorRecord item,
            IMajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IMagicEffect)item,
                rhs: (IMagicEffectGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        #endregion
        
        public MagicEffect DeepCopy(
            IMagicEffectGetter item,
            MagicEffect.TranslationMask? copyMask = null)
        {
            MagicEffect ret = (MagicEffect)((MagicEffectCommon)((IMagicEffectGetter)item).CommonInstance()!).GetNew();
            ((MagicEffectSetterTranslationCommon)((IMagicEffectGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: null,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            return ret;
        }
        
        public MagicEffect DeepCopy(
            IMagicEffectGetter item,
            out MagicEffect.ErrorMask errorMask,
            MagicEffect.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            MagicEffect ret = (MagicEffect)((MagicEffectCommon)((IMagicEffectGetter)item).CommonInstance()!).GetNew();
            ((MagicEffectSetterTranslationCommon)((IMagicEffectGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                ret,
                item,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            errorMask = MagicEffect.ErrorMask.Factory(errorMaskBuilder);
            return ret;
        }
        
        public MagicEffect DeepCopy(
            IMagicEffectGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            MagicEffect ret = (MagicEffect)((MagicEffectCommon)((IMagicEffectGetter)item).CommonInstance()!).GetNew();
            ((MagicEffectSetterTranslationCommon)((IMagicEffectGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: true);
            return ret;
        }
        
    }
    #endregion

}

namespace Mutagen.Bethesda.Fallout3
{
    public partial class MagicEffect
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => MagicEffect_Registration.Instance;
        public new static ILoquiRegistration StaticRegistration => MagicEffect_Registration.Instance;
        [DebuggerStepThrough]
        protected override object CommonInstance() => MagicEffectCommon.Instance;
        [DebuggerStepThrough]
        protected override object CommonSetterInstance()
        {
            return MagicEffectSetterCommon.Instance;
        }
        [DebuggerStepThrough]
        protected override object CommonSetterTranslationInstance() => MagicEffectSetterTranslationCommon.Instance;

        #endregion

    }
}

#region Modules
#region Binary Translation
namespace Mutagen.Bethesda.Fallout3
{
    public partial class MagicEffectBinaryWriteTranslation :
        Fallout3MajorRecordBinaryWriteTranslation,
        IBinaryWriteTranslator
    {
        public new static readonly MagicEffectBinaryWriteTranslation Instance = new();

        public static void WriteRecordTypes(
            IMagicEffectGetter item,
            MutagenWriter writer,
            TypedWriteParams translationParams)
        {
            MajorRecordBinaryWriteTranslation.WriteRecordTypes(
                item: item,
                writer: writer,
                translationParams: translationParams);
            StringBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.Name,
                header: translationParams.ConvertToCustom(RecordTypes.FULL),
                binaryType: StringBinaryType.NullTerminate);
            StringBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.Description,
                header: translationParams.ConvertToCustom(RecordTypes.DESC),
                binaryType: StringBinaryType.NullTerminate);
            StringBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.Icon,
                header: translationParams.ConvertToCustom(RecordTypes.ICON),
                binaryType: StringBinaryType.NullTerminate);
            if (item.Model is {} ModelItem)
            {
                ((ModelBinaryWriteTranslation)((IBinaryItem)ModelItem).BinaryWriteTranslator).Write(
                    item: ModelItem,
                    writer: writer,
                    translationParams: translationParams);
            }
            using (HeaderExport.Subrecord(writer, translationParams.ConvertToCustom(RecordTypes.DATA)))
            {
                EnumBinaryTranslation<MagicEffect.MagicFlag, MutagenFrame, MutagenWriter>.Instance.Write(
                    writer,
                    item.Flags,
                    length: 4);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.BaseCost);
                MagicEffectBinaryWriteTranslation.WriteBinaryAssociatedItem(
                    writer: writer,
                    item: item);
                writer.Write(item.Unused);
                EnumBinaryTranslation<ActorValue, MutagenFrame, MutagenWriter>.Instance.Write(
                    writer,
                    item.Resistance,
                    length: 4);
                writer.Write(item.CounterEffectCount);
                FormLinkBinaryTranslation.Instance.Write(
                    writer: writer,
                    item: item.Light);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.ProjectileSpeed);
                FormLinkBinaryTranslation.Instance.Write(
                    writer: writer,
                    item: item.EffectShader);
                FormLinkBinaryTranslation.Instance.Write(
                    writer: writer,
                    item: item.ObjectDisplayShader);
                FormLinkBinaryTranslation.Instance.Write(
                    writer: writer,
                    item: item.EffectSound);
                FormLinkBinaryTranslation.Instance.Write(
                    writer: writer,
                    item: item.BoltSound);
                FormLinkBinaryTranslation.Instance.Write(
                    writer: writer,
                    item: item.HitSound);
                FormLinkBinaryTranslation.Instance.Write(
                    writer: writer,
                    item: item.AreaSound);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.ConstantEffectEnchantmentFactor);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.ConstantEffectBarterFactor);
                MagicEffectBinaryWriteTranslation.WriteBinaryArchetype(
                    writer: writer,
                    item: item);
                EnumBinaryTranslation<ActorValue, MutagenFrame, MutagenWriter>.Instance.Write(
                    writer,
                    item.ActorValue,
                    length: 4);
            }
            Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<IEDIDLinkGetter<IMagicEffectGetter>>.Instance.Write(
                writer: writer,
                items: item.CounterEffects,
                recordType: translationParams.ConvertToCustom(RecordTypes.ESCE),
                transl: (MutagenWriter subWriter, IEDIDLinkGetter<IMagicEffectGetter> subItem, TypedWriteParams conv) =>
                {
                    RecordTypeBinaryTranslation.Instance.Write(
                        writer: subWriter,
                        item: subItem);
                });
        }

        public static partial void WriteBinaryAssociatedItemCustom(
            MutagenWriter writer,
            IMagicEffectGetter item);

        public static void WriteBinaryAssociatedItem(
            MutagenWriter writer,
            IMagicEffectGetter item)
        {
            WriteBinaryAssociatedItemCustom(
                writer: writer,
                item: item);
        }

        public static partial void WriteBinaryArchetypeCustom(
            MutagenWriter writer,
            IMagicEffectGetter item);

        public static void WriteBinaryArchetype(
            MutagenWriter writer,
            IMagicEffectGetter item)
        {
            WriteBinaryArchetypeCustom(
                writer: writer,
                item: item);
        }

        public void Write(
            MutagenWriter writer,
            IMagicEffectGetter item,
            TypedWriteParams translationParams)
        {
            PluginUtilityTranslation.WriteMajorRecord(
                writer: writer,
                item: item,
                translationParams: translationParams,
                type: RecordTypes.MGEF,
                writeEmbedded: Fallout3MajorRecordBinaryWriteTranslation.WriteEmbedded,
                writeRecordTypes: WriteRecordTypes);
        }

        public override void Write(
            MutagenWriter writer,
            object item,
            TypedWriteParams translationParams = default)
        {
            Write(
                item: (IMagicEffectGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

        public override void Write(
            MutagenWriter writer,
            IFallout3MajorRecordGetter item,
            TypedWriteParams translationParams)
        {
            Write(
                item: (IMagicEffectGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

        public override void Write(
            MutagenWriter writer,
            IMajorRecordGetter item,
            TypedWriteParams translationParams)
        {
            Write(
                item: (IMagicEffectGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

    }

    internal partial class MagicEffectBinaryCreateTranslation : Fallout3MajorRecordBinaryCreateTranslation
    {
        public new static readonly MagicEffectBinaryCreateTranslation Instance = new MagicEffectBinaryCreateTranslation();

        public override RecordType RecordType => RecordTypes.MGEF;
        public static ParseResult FillBinaryRecordTypes(
            IMagicEffectInternal item,
            MutagenFrame frame,
            PreviousParse lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            RecordType nextRecordType,
            int contentLength,
            TypedParseParams translationParams = default)
        {
            nextRecordType = translationParams.ConvertToStandard(nextRecordType);
            switch (nextRecordType.TypeInt)
            {
                case RecordTypeInts.FULL:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Name = StringBinaryTranslation.Instance.Parse(
                        reader: frame.SpawnWithLength(contentLength),
                        stringBinaryType: StringBinaryType.NullTerminate,
                        parseWhole: true);
                    return (int)MagicEffect_FieldIndex.Name;
                }
                case RecordTypeInts.DESC:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Description = StringBinaryTranslation.Instance.Parse(
                        reader: frame.SpawnWithLength(contentLength),
                        stringBinaryType: StringBinaryType.NullTerminate,
                        parseWhole: true);
                    return (int)MagicEffect_FieldIndex.Description;
                }
                case RecordTypeInts.ICON:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Icon = StringBinaryTranslation.Instance.Parse(
                        reader: frame.SpawnWithLength(contentLength),
                        stringBinaryType: StringBinaryType.NullTerminate,
                        parseWhole: true);
                    return (int)MagicEffect_FieldIndex.Icon;
                }
                case RecordTypeInts.MODL:
                {
                    item.Model = Mutagen.Bethesda.Fallout3.Model.CreateFromBinary(
                        frame: frame,
                        translationParams: translationParams.DoNotShortCircuit());
                    return (int)MagicEffect_FieldIndex.Model;
                }
                case RecordTypeInts.DATA:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    var dataFrame = frame.SpawnWithLength(contentLength);
                    if (dataFrame.Remaining < 4) return null;
                    item.Flags = EnumBinaryTranslation<MagicEffect.MagicFlag, MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: dataFrame,
                        length: 4);
                    if (dataFrame.Remaining < 4) return null;
                    item.BaseCost = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    if (dataFrame.Remaining < 4) return null;
                    MagicEffectBinaryCreateTranslation.FillBinaryAssociatedItemCustom(
                        frame: dataFrame,
                        item: item);
                    if (dataFrame.Remaining < 4) return null;
                    item.Unused = dataFrame.ReadInt32();
                    if (dataFrame.Remaining < 4) return null;
                    item.Resistance = EnumBinaryTranslation<ActorValue, MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: dataFrame,
                        length: 4);
                    if (dataFrame.Remaining < 4) return null;
                    item.CounterEffectCount = dataFrame.ReadUInt32();
                    if (dataFrame.Remaining < 4) return null;
                    item.Light.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    if (dataFrame.Remaining < 4) return null;
                    item.ProjectileSpeed = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    if (dataFrame.Remaining < 4) return null;
                    item.EffectShader.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    if (dataFrame.Remaining < 4) return null;
                    item.ObjectDisplayShader.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    if (dataFrame.Remaining < 4) return null;
                    item.EffectSound.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    if (dataFrame.Remaining < 4) return null;
                    item.BoltSound.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    if (dataFrame.Remaining < 4) return null;
                    item.HitSound.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    if (dataFrame.Remaining < 4) return null;
                    item.AreaSound.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    if (dataFrame.Remaining < 4) return null;
                    item.ConstantEffectEnchantmentFactor = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    if (dataFrame.Remaining < 4) return null;
                    item.ConstantEffectBarterFactor = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    MagicEffectBinaryCreateTranslation.FillBinaryArchetypeCustom(
                        frame: dataFrame,
                        item: item);
                    if (dataFrame.Remaining < 4) return null;
                    item.ActorValue = EnumBinaryTranslation<ActorValue, MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: dataFrame,
                        length: 4);
                    return (int)MagicEffect_FieldIndex.ActorValue;
                }
                case RecordTypeInts.ESCE:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.CounterEffects = 
                        Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<IEDIDLinkGetter<IMagicEffectGetter>>.Instance.Parse(
                            reader: frame.SpawnWithLength(contentLength),
                            transl: RecordTypeBinaryTranslation.Instance.Parse)
                        .CastExtendedList<IEDIDLinkGetter<IMagicEffectGetter>>();
                    return (int)MagicEffect_FieldIndex.CounterEffects;
                }
                default:
                    return Fallout3MajorRecordBinaryCreateTranslation.FillBinaryRecordTypes(
                        item: item,
                        frame: frame,
                        lastParsed: lastParsed,
                        recordParseCount: recordParseCount,
                        nextRecordType: nextRecordType,
                        contentLength: contentLength,
                        translationParams: translationParams.WithNoConverter());
            }
        }

        public static partial void FillBinaryAssociatedItemCustom(
            MutagenFrame frame,
            IMagicEffectInternal item);

        public static partial void FillBinaryArchetypeCustom(
            MutagenFrame frame,
            IMagicEffectInternal item);

    }

}
namespace Mutagen.Bethesda.Fallout3
{
    #region Binary Write Mixins
    public static class MagicEffectBinaryTranslationMixIn
    {
    }
    #endregion


}
namespace Mutagen.Bethesda.Fallout3
{
    internal partial class MagicEffectBinaryOverlay :
        Fallout3MajorRecordBinaryOverlay,
        IMagicEffectGetter
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => MagicEffect_Registration.Instance;
        public new static ILoquiRegistration StaticRegistration => MagicEffect_Registration.Instance;
        [DebuggerStepThrough]
        protected override object CommonInstance() => MagicEffectCommon.Instance;
        [DebuggerStepThrough]
        protected override object CommonSetterTranslationInstance() => MagicEffectSetterTranslationCommon.Instance;

        #endregion

        void IPrintable.Print(StructuredStringBuilder sb, string? name) => this.Print(sb, name);

        public override IEnumerable<IFormLinkGetter> EnumerateFormLinks() => MagicEffectCommon.Instance.EnumerateFormLinks(this);
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected override object BinaryWriteTranslator => MagicEffectBinaryWriteTranslation.Instance;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((MagicEffectBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }
        protected override Type LinkType => typeof(IMagicEffect);


        #region Name
        private int? _NameLocation;
        public String? Name => _NameLocation.HasValue ? BinaryStringUtility.ProcessWholeToZString(HeaderTranslation.ExtractSubrecordMemory(_recordData, _NameLocation.Value, _package.MetaData.Constants), encoding: _package.MetaData.Encodings.NonTranslated) : default(string?);
        #region Aspects
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        string INamedRequiredGetter.Name => this.Name ?? string.Empty;
        #endregion
        #endregion
        #region Description
        private int? _DescriptionLocation;
        public String? Description => _DescriptionLocation.HasValue ? BinaryStringUtility.ProcessWholeToZString(HeaderTranslation.ExtractSubrecordMemory(_recordData, _DescriptionLocation.Value, _package.MetaData.Constants), encoding: _package.MetaData.Encodings.NonTranslated) : default(string?);
        #endregion
        #region Icon
        private int? _IconLocation;
        public String? Icon => _IconLocation.HasValue ? BinaryStringUtility.ProcessWholeToZString(HeaderTranslation.ExtractSubrecordMemory(_recordData, _IconLocation.Value, _package.MetaData.Constants), encoding: _package.MetaData.Encodings.NonTranslated) : default(string?);
        #endregion
        public IModelGetter? Model { get; private set; }
        private RangeInt32? _DATALocation;
        #region Flags
        private int _FlagsLocation => _DATALocation!.Value.Min;
        private bool _Flags_IsSet => _DATALocation.HasValue;
        public MagicEffect.MagicFlag Flags => _Flags_IsSet ? (MagicEffect.MagicFlag)BinaryPrimitives.ReadInt32LittleEndian(_recordData.Span.Slice(_FlagsLocation, 0x4)) : default;
        #endregion
        #region BaseCost
        private int _BaseCostLocation => _DATALocation!.Value.Min + 0x4;
        private bool _BaseCost_IsSet => _DATALocation.HasValue;
        public Single BaseCost => _BaseCost_IsSet ? _recordData.Slice(_BaseCostLocation, 4).Float() : default(Single);
        #endregion
        #region AssociatedItem
        private int _AssociatedItemLocation => _DATALocation!.Value.Min + 0x8;
        private bool _AssociatedItem_IsSet => _DATALocation.HasValue;
        partial void AssociatedItemCustomParse(
            OverlayStream stream,
            int offset);
        #endregion
        #region Unused
        private int _UnusedLocation => _DATALocation!.Value.Min + 0xC;
        private bool _Unused_IsSet => _DATALocation.HasValue;
        public Int32 Unused => _Unused_IsSet ? BinaryPrimitives.ReadInt32LittleEndian(_recordData.Slice(_UnusedLocation, 4)) : default(Int32);
        #endregion
        #region Resistance
        private int _ResistanceLocation => _DATALocation!.Value.Min + 0x10;
        private bool _Resistance_IsSet => _DATALocation.HasValue;
        public ActorValue Resistance => _Resistance_IsSet ? (ActorValue)BinaryPrimitives.ReadInt32LittleEndian(_recordData.Span.Slice(_ResistanceLocation, 0x4)) : default;
        #endregion
        #region CounterEffectCount
        private int _CounterEffectCountLocation => _DATALocation!.Value.Min + 0x14;
        private bool _CounterEffectCount_IsSet => _DATALocation.HasValue;
        public UInt32 CounterEffectCount => _CounterEffectCount_IsSet ? BinaryPrimitives.ReadUInt32LittleEndian(_recordData.Slice(_CounterEffectCountLocation, 4)) : default(UInt32);
        #endregion
        #region Light
        private int _LightLocation => _DATALocation!.Value.Min + 0x18;
        private bool _Light_IsSet => _DATALocation.HasValue;
        public IFormLinkGetter<ILightGetter> Light => _Light_IsSet ? FormLinkBinaryTranslation.Instance.OverlayFactory<ILightGetter>(_package, _recordData.Span.Slice(_LightLocation, 0x4), isSet: _Light_IsSet) : FormLink<ILightGetter>.Null;
        #endregion
        #region ProjectileSpeed
        private int _ProjectileSpeedLocation => _DATALocation!.Value.Min + 0x1C;
        private bool _ProjectileSpeed_IsSet => _DATALocation.HasValue;
        public Single ProjectileSpeed => _ProjectileSpeed_IsSet ? _recordData.Slice(_ProjectileSpeedLocation, 4).Float() : default(Single);
        #endregion
        #region EffectShader
        private int _EffectShaderLocation => _DATALocation!.Value.Min + 0x20;
        private bool _EffectShader_IsSet => _DATALocation.HasValue;
        public IFormLinkGetter<IEffectShaderGetter> EffectShader => _EffectShader_IsSet ? FormLinkBinaryTranslation.Instance.OverlayFactory<IEffectShaderGetter>(_package, _recordData.Span.Slice(_EffectShaderLocation, 0x4), isSet: _EffectShader_IsSet) : FormLink<IEffectShaderGetter>.Null;
        #endregion
        #region ObjectDisplayShader
        private int _ObjectDisplayShaderLocation => _DATALocation!.Value.Min + 0x24;
        private bool _ObjectDisplayShader_IsSet => _DATALocation.HasValue;
        public IFormLinkGetter<IEffectShaderGetter> ObjectDisplayShader => _ObjectDisplayShader_IsSet ? FormLinkBinaryTranslation.Instance.OverlayFactory<IEffectShaderGetter>(_package, _recordData.Span.Slice(_ObjectDisplayShaderLocation, 0x4), isSet: _ObjectDisplayShader_IsSet) : FormLink<IEffectShaderGetter>.Null;
        #endregion
        #region EffectSound
        private int _EffectSoundLocation => _DATALocation!.Value.Min + 0x28;
        private bool _EffectSound_IsSet => _DATALocation.HasValue;
        public IFormLinkGetter<ISoundGetter> EffectSound => _EffectSound_IsSet ? FormLinkBinaryTranslation.Instance.OverlayFactory<ISoundGetter>(_package, _recordData.Span.Slice(_EffectSoundLocation, 0x4), isSet: _EffectSound_IsSet) : FormLink<ISoundGetter>.Null;
        #endregion
        #region BoltSound
        private int _BoltSoundLocation => _DATALocation!.Value.Min + 0x2C;
        private bool _BoltSound_IsSet => _DATALocation.HasValue;
        public IFormLinkGetter<ISoundGetter> BoltSound => _BoltSound_IsSet ? FormLinkBinaryTranslation.Instance.OverlayFactory<ISoundGetter>(_package, _recordData.Span.Slice(_BoltSoundLocation, 0x4), isSet: _BoltSound_IsSet) : FormLink<ISoundGetter>.Null;
        #endregion
        #region HitSound
        private int _HitSoundLocation => _DATALocation!.Value.Min + 0x30;
        private bool _HitSound_IsSet => _DATALocation.HasValue;
        public IFormLinkGetter<ISoundGetter> HitSound => _HitSound_IsSet ? FormLinkBinaryTranslation.Instance.OverlayFactory<ISoundGetter>(_package, _recordData.Span.Slice(_HitSoundLocation, 0x4), isSet: _HitSound_IsSet) : FormLink<ISoundGetter>.Null;
        #endregion
        #region AreaSound
        private int _AreaSoundLocation => _DATALocation!.Value.Min + 0x34;
        private bool _AreaSound_IsSet => _DATALocation.HasValue;
        public IFormLinkGetter<ISoundGetter> AreaSound => _AreaSound_IsSet ? FormLinkBinaryTranslation.Instance.OverlayFactory<ISoundGetter>(_package, _recordData.Span.Slice(_AreaSoundLocation, 0x4), isSet: _AreaSound_IsSet) : FormLink<ISoundGetter>.Null;
        #endregion
        #region ConstantEffectEnchantmentFactor
        private int _ConstantEffectEnchantmentFactorLocation => _DATALocation!.Value.Min + 0x38;
        private bool _ConstantEffectEnchantmentFactor_IsSet => _DATALocation.HasValue;
        public Single ConstantEffectEnchantmentFactor => _ConstantEffectEnchantmentFactor_IsSet ? _recordData.Slice(_ConstantEffectEnchantmentFactorLocation, 4).Float() : default(Single);
        #endregion
        #region ConstantEffectBarterFactor
        private int _ConstantEffectBarterFactorLocation => _DATALocation!.Value.Min + 0x3C;
        private bool _ConstantEffectBarterFactor_IsSet => _DATALocation.HasValue;
        public Single ConstantEffectBarterFactor => _ConstantEffectBarterFactor_IsSet ? _recordData.Slice(_ConstantEffectBarterFactorLocation, 4).Float() : default(Single);
        #endregion
        #region Archetype
        private int _ArchetypeLocation => _DATALocation!.Value.Min + 0x40;
        public partial IAMagicEffectArchetypeGetter GetArchetypeCustom();
        public IAMagicEffectArchetypeGetter Archetype => GetArchetypeCustom();
        #endregion
        #region ActorValue
        private int _ActorValueLocation => _DATALocation!.Value.Min + 0x44;
        private bool _ActorValue_IsSet => _DATALocation.HasValue;
        public ActorValue ActorValue => _ActorValue_IsSet ? (ActorValue)BinaryPrimitives.ReadInt32LittleEndian(_recordData.Span.Slice(_ActorValueLocation, 0x4)) : default;
        #endregion
        public IReadOnlyList<IEDIDLinkGetter<IMagicEffectGetter>>? CounterEffects { get; private set; }
        partial void CustomFactoryEnd(
            OverlayStream stream,
            int finalPos,
            int offset);

        partial void CustomCtor();
        protected MagicEffectBinaryOverlay(
            MemoryPair memoryPair,
            BinaryOverlayFactoryPackage package)
            : base(
                memoryPair: memoryPair,
                package: package)
        {
            this.CustomCtor();
        }

        public static IMagicEffectGetter MagicEffectFactory(
            OverlayStream stream,
            BinaryOverlayFactoryPackage package,
            TypedParseParams translationParams = default)
        {
            stream = Decompression.DecompressStream(stream);
            stream = ExtractRecordMemory(
                stream: stream,
                meta: package.MetaData.Constants,
                memoryPair: out var memoryPair,
                offset: out var offset,
                finalPos: out var finalPos);
            var ret = new MagicEffectBinaryOverlay(
                memoryPair: memoryPair,
                package: package);
            ret._package.FormVersion = ret;
            ret.CustomFactoryEnd(
                stream: stream,
                finalPos: finalPos,
                offset: offset);
            ret.FillSubrecordTypes(
                majorReference: ret,
                stream: stream,
                finalPos: finalPos,
                offset: offset,
                translationParams: translationParams,
                fill: ret.FillRecordType);
            return ret;
        }

        public static IMagicEffectGetter MagicEffectFactory(
            ReadOnlyMemorySlice<byte> slice,
            BinaryOverlayFactoryPackage package,
            TypedParseParams translationParams = default)
        {
            return MagicEffectFactory(
                stream: new OverlayStream(slice, package),
                package: package,
                translationParams: translationParams);
        }

        public override ParseResult FillRecordType(
            OverlayStream stream,
            int finalPos,
            int offset,
            RecordType type,
            PreviousParse lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            TypedParseParams translationParams = default)
        {
            type = translationParams.ConvertToStandard(type);
            switch (type.TypeInt)
            {
                case RecordTypeInts.FULL:
                {
                    _NameLocation = (stream.Position - offset);
                    return (int)MagicEffect_FieldIndex.Name;
                }
                case RecordTypeInts.DESC:
                {
                    _DescriptionLocation = (stream.Position - offset);
                    return (int)MagicEffect_FieldIndex.Description;
                }
                case RecordTypeInts.ICON:
                {
                    _IconLocation = (stream.Position - offset);
                    return (int)MagicEffect_FieldIndex.Icon;
                }
                case RecordTypeInts.MODL:
                {
                    this.Model = ModelBinaryOverlay.ModelFactory(
                        stream: stream,
                        package: _package,
                        translationParams: translationParams.DoNotShortCircuit());
                    return (int)MagicEffect_FieldIndex.Model;
                }
                case RecordTypeInts.DATA:
                {
                    _DATALocation = new((stream.Position - offset) + _package.MetaData.Constants.SubConstants.TypeAndLengthLength, finalPos - offset - 1);
                    return (int)MagicEffect_FieldIndex.ActorValue;
                }
                case RecordTypeInts.ESCE:
                {
                    this.CounterEffects = BinaryOverlayList.FactoryByStartIndexWithTrigger<IEDIDLinkGetter<IMagicEffectGetter>>(
                        stream: stream,
                        package: _package,
                        finalPos: finalPos,
                        itemLength: 4,
                        getter: (s, p) => new EDIDLink<IMagicEffectGetter>(new RecordType(BinaryPrimitives.ReadInt32LittleEndian(s))));
                    return (int)MagicEffect_FieldIndex.CounterEffects;
                }
                default:
                    return base.FillRecordType(
                        stream: stream,
                        finalPos: finalPos,
                        offset: offset,
                        type: type,
                        lastParsed: lastParsed,
                        recordParseCount: recordParseCount,
                        translationParams: translationParams.WithNoConverter());
            }
        }
        #region To String

        public override void Print(
            StructuredStringBuilder sb,
            string? name = null)
        {
            MagicEffectMixIn.Print(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        public override string ToString()
        {
            return MajorRecordPrinter<MagicEffect>.ToString(this);
        }

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is IFormLinkGetter formLink)
            {
                return formLink.Equals(this);
            }
            if (obj is not IMagicEffectGetter rhs) return false;
            return ((MagicEffectCommon)((IMagicEffectGetter)this).CommonInstance()!).Equals(this, rhs, equalsMask: null);
        }

        public bool Equals(IMagicEffectGetter? obj)
        {
            return ((MagicEffectCommon)((IMagicEffectGetter)this).CommonInstance()!).Equals(this, obj, equalsMask: null);
        }

        public override int GetHashCode() => ((MagicEffectCommon)((IMagicEffectGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

    }

}
#endregion

#endregion

