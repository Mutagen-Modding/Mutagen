/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Autogenerated by Loqui.  Do not manually change.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*/
#region Usings
using Loqui;
using Loqui.Interfaces;
using Loqui.Internal;
using Mutagen.Bethesda.Assets;
using Mutagen.Bethesda.Binary;
using Mutagen.Bethesda.Fallout3;
using Mutagen.Bethesda.Fallout3.Internals;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Assets;
using Mutagen.Bethesda.Plugins.Binary;
using Mutagen.Bethesda.Plugins.Binary.Headers;
using Mutagen.Bethesda.Plugins.Binary.Overlay;
using Mutagen.Bethesda.Plugins.Binary.Parameters;
using Mutagen.Bethesda.Plugins.Binary.Streams;
using Mutagen.Bethesda.Plugins.Binary.Translations;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Cache.Internals;
using Mutagen.Bethesda.Plugins.Exceptions;
using Mutagen.Bethesda.Plugins.Internals;
using Mutagen.Bethesda.Plugins.Masters;
using Mutagen.Bethesda.Plugins.Meta;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Plugins.Records.Internals;
using Mutagen.Bethesda.Plugins.Records.Loqui;
using Mutagen.Bethesda.Plugins.Records.Mapping;
using Mutagen.Bethesda.Plugins.Utility;
using Mutagen.Bethesda.Strings;
using Mutagen.Bethesda.Strings.DI;
using Mutagen.Bethesda.Translations.Binary;
using Noggog;
using Noggog.StructuredStrings;
using Noggog.StructuredStrings.CSharp;
using RecordTypeInts = Mutagen.Bethesda.Fallout3.Internals.RecordTypeInts;
using RecordTypes = Mutagen.Bethesda.Fallout3.Internals.RecordTypes;
using System.Buffers.Binary;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.IO.Abstractions;
using System.Reactive.Disposables;
using System.Reactive.Linq;
using System.Threading.Tasks;
#endregion

#nullable enable
namespace Mutagen.Bethesda.Fallout3
{
    #region Class
    public partial class Fallout3Mod :
        IEquatable<IFallout3ModGetter>,
        IFallout3Mod,
        ILoquiObjectSetter<Fallout3Mod>
    {
        #region Ctor
        public Fallout3Mod()
        {
            _GameSettings_Object = new Fallout3Group<GameSetting>(this);
            _TextureSets_Object = new Fallout3Group<TextureSet>(this);
            _MenuIcons_Object = new Fallout3Group<MenuIcon>(this);
            _Globals_Object = new Fallout3Group<Global>(this);
            _Classes_Object = new Fallout3Group<Class>(this);
            _Factions_Object = new Fallout3Group<Faction>(this);
            _HeadParts_Object = new Fallout3Group<HeadPart>(this);
            _Hairs_Object = new Fallout3Group<Hair>(this);
            _Eyes_Object = new Fallout3Group<Eyes>(this);
            _Races_Object = new Fallout3Group<Race>(this);
            _Sounds_Object = new Fallout3Group<Sound>(this);
            _AcousticSpaces_Object = new Fallout3Group<AcousticSpace>(this);
            _MagicEffects_Object = new Fallout3Group<MagicEffect>(this);
            _Scripts_Object = new Fallout3Group<Script>(this);
            _LandscapeTextures_Object = new Fallout3Group<LandscapeTexture>(this);
            _ObjectEffects_Object = new Fallout3Group<ObjectEffect>(this);
            CustomCtor();
        }
        partial void CustomCtor();
        #endregion

        #region ModHeader
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private readonly Fallout3ModHeader _ModHeader_Object = new Fallout3ModHeader();
        public Fallout3ModHeader ModHeader => _ModHeader_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout3ModHeaderGetter IFallout3ModGetter.ModHeader => _ModHeader_Object;
        #endregion
        #region GameSettings
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout3Group<GameSetting> _GameSettings_Object;
        public Fallout3Group<GameSetting> GameSettings => _GameSettings_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout3GroupGetter<IGameSettingGetter> IFallout3ModGetter.GameSettings => _GameSettings_Object;
        #endregion
        #region TextureSets
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout3Group<TextureSet> _TextureSets_Object;
        public Fallout3Group<TextureSet> TextureSets => _TextureSets_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout3GroupGetter<ITextureSetGetter> IFallout3ModGetter.TextureSets => _TextureSets_Object;
        #endregion
        #region MenuIcons
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout3Group<MenuIcon> _MenuIcons_Object;
        public Fallout3Group<MenuIcon> MenuIcons => _MenuIcons_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout3GroupGetter<IMenuIconGetter> IFallout3ModGetter.MenuIcons => _MenuIcons_Object;
        #endregion
        #region Globals
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout3Group<Global> _Globals_Object;
        public Fallout3Group<Global> Globals => _Globals_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout3GroupGetter<IGlobalGetter> IFallout3ModGetter.Globals => _Globals_Object;
        #endregion
        #region Classes
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout3Group<Class> _Classes_Object;
        public Fallout3Group<Class> Classes => _Classes_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout3GroupGetter<IClassGetter> IFallout3ModGetter.Classes => _Classes_Object;
        #endregion
        #region Factions
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout3Group<Faction> _Factions_Object;
        public Fallout3Group<Faction> Factions => _Factions_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout3GroupGetter<IFactionGetter> IFallout3ModGetter.Factions => _Factions_Object;
        #endregion
        #region HeadParts
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout3Group<HeadPart> _HeadParts_Object;
        public Fallout3Group<HeadPart> HeadParts => _HeadParts_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout3GroupGetter<IHeadPartGetter> IFallout3ModGetter.HeadParts => _HeadParts_Object;
        #endregion
        #region Hairs
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout3Group<Hair> _Hairs_Object;
        public Fallout3Group<Hair> Hairs => _Hairs_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout3GroupGetter<IHairGetter> IFallout3ModGetter.Hairs => _Hairs_Object;
        #endregion
        #region Eyes
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout3Group<Eyes> _Eyes_Object;
        public Fallout3Group<Eyes> Eyes => _Eyes_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout3GroupGetter<IEyesGetter> IFallout3ModGetter.Eyes => _Eyes_Object;
        #endregion
        #region Races
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout3Group<Race> _Races_Object;
        public Fallout3Group<Race> Races => _Races_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout3GroupGetter<IRaceGetter> IFallout3ModGetter.Races => _Races_Object;
        #endregion
        #region Sounds
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout3Group<Sound> _Sounds_Object;
        public Fallout3Group<Sound> Sounds => _Sounds_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout3GroupGetter<ISoundGetter> IFallout3ModGetter.Sounds => _Sounds_Object;
        #endregion
        #region AcousticSpaces
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout3Group<AcousticSpace> _AcousticSpaces_Object;
        public Fallout3Group<AcousticSpace> AcousticSpaces => _AcousticSpaces_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout3GroupGetter<IAcousticSpaceGetter> IFallout3ModGetter.AcousticSpaces => _AcousticSpaces_Object;
        #endregion
        #region MagicEffects
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout3Group<MagicEffect> _MagicEffects_Object;
        public Fallout3Group<MagicEffect> MagicEffects => _MagicEffects_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout3GroupGetter<IMagicEffectGetter> IFallout3ModGetter.MagicEffects => _MagicEffects_Object;
        #endregion
        #region Scripts
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout3Group<Script> _Scripts_Object;
        public Fallout3Group<Script> Scripts => _Scripts_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout3GroupGetter<IScriptGetter> IFallout3ModGetter.Scripts => _Scripts_Object;
        #endregion
        #region LandscapeTextures
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout3Group<LandscapeTexture> _LandscapeTextures_Object;
        public Fallout3Group<LandscapeTexture> LandscapeTextures => _LandscapeTextures_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout3GroupGetter<ILandscapeTextureGetter> IFallout3ModGetter.LandscapeTextures => _LandscapeTextures_Object;
        #endregion
        #region ObjectEffects
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout3Group<ObjectEffect> _ObjectEffects_Object;
        public Fallout3Group<ObjectEffect> ObjectEffects => _ObjectEffects_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout3GroupGetter<IObjectEffectGetter> IFallout3ModGetter.ObjectEffects => _ObjectEffects_Object;
        #endregion

        #region To String

        public void Print(
            StructuredStringBuilder sb,
            string? name = null)
        {
            Fallout3ModMixIn.Print(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is not IFallout3ModGetter rhs) return false;
            return ((Fallout3ModCommon)((IFallout3ModGetter)this).CommonInstance()!).Equals(this, rhs, equalsMask: null);
        }

        public bool Equals(IFallout3ModGetter? obj)
        {
            return ((Fallout3ModCommon)((IFallout3ModGetter)this).CommonInstance()!).Equals(this, obj, equalsMask: null);
        }

        public override int GetHashCode() => ((Fallout3ModCommon)((IFallout3ModGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        #region Mask
        public class Mask<TItem> :
            IEquatable<Mask<TItem>>,
            IMask<TItem>
        {
            #region Ctors
            public Mask(TItem initialValue)
            {
                this.ModHeader = new MaskItem<TItem, Fallout3ModHeader.Mask<TItem>?>(initialValue, new Fallout3ModHeader.Mask<TItem>(initialValue));
                this.GameSettings = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(initialValue, new Fallout3Group.Mask<TItem>(initialValue));
                this.TextureSets = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(initialValue, new Fallout3Group.Mask<TItem>(initialValue));
                this.MenuIcons = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(initialValue, new Fallout3Group.Mask<TItem>(initialValue));
                this.Globals = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(initialValue, new Fallout3Group.Mask<TItem>(initialValue));
                this.Classes = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(initialValue, new Fallout3Group.Mask<TItem>(initialValue));
                this.Factions = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(initialValue, new Fallout3Group.Mask<TItem>(initialValue));
                this.HeadParts = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(initialValue, new Fallout3Group.Mask<TItem>(initialValue));
                this.Hairs = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(initialValue, new Fallout3Group.Mask<TItem>(initialValue));
                this.Eyes = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(initialValue, new Fallout3Group.Mask<TItem>(initialValue));
                this.Races = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(initialValue, new Fallout3Group.Mask<TItem>(initialValue));
                this.Sounds = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(initialValue, new Fallout3Group.Mask<TItem>(initialValue));
                this.AcousticSpaces = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(initialValue, new Fallout3Group.Mask<TItem>(initialValue));
                this.MagicEffects = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(initialValue, new Fallout3Group.Mask<TItem>(initialValue));
                this.Scripts = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(initialValue, new Fallout3Group.Mask<TItem>(initialValue));
                this.LandscapeTextures = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(initialValue, new Fallout3Group.Mask<TItem>(initialValue));
                this.ObjectEffects = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(initialValue, new Fallout3Group.Mask<TItem>(initialValue));
            }

            public Mask(
                TItem ModHeader,
                TItem GameSettings,
                TItem TextureSets,
                TItem MenuIcons,
                TItem Globals,
                TItem Classes,
                TItem Factions,
                TItem HeadParts,
                TItem Hairs,
                TItem Eyes,
                TItem Races,
                TItem Sounds,
                TItem AcousticSpaces,
                TItem MagicEffects,
                TItem Scripts,
                TItem LandscapeTextures,
                TItem ObjectEffects)
            {
                this.ModHeader = new MaskItem<TItem, Fallout3ModHeader.Mask<TItem>?>(ModHeader, new Fallout3ModHeader.Mask<TItem>(ModHeader));
                this.GameSettings = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(GameSettings, new Fallout3Group.Mask<TItem>(GameSettings));
                this.TextureSets = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(TextureSets, new Fallout3Group.Mask<TItem>(TextureSets));
                this.MenuIcons = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(MenuIcons, new Fallout3Group.Mask<TItem>(MenuIcons));
                this.Globals = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(Globals, new Fallout3Group.Mask<TItem>(Globals));
                this.Classes = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(Classes, new Fallout3Group.Mask<TItem>(Classes));
                this.Factions = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(Factions, new Fallout3Group.Mask<TItem>(Factions));
                this.HeadParts = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(HeadParts, new Fallout3Group.Mask<TItem>(HeadParts));
                this.Hairs = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(Hairs, new Fallout3Group.Mask<TItem>(Hairs));
                this.Eyes = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(Eyes, new Fallout3Group.Mask<TItem>(Eyes));
                this.Races = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(Races, new Fallout3Group.Mask<TItem>(Races));
                this.Sounds = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(Sounds, new Fallout3Group.Mask<TItem>(Sounds));
                this.AcousticSpaces = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(AcousticSpaces, new Fallout3Group.Mask<TItem>(AcousticSpaces));
                this.MagicEffects = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(MagicEffects, new Fallout3Group.Mask<TItem>(MagicEffects));
                this.Scripts = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(Scripts, new Fallout3Group.Mask<TItem>(Scripts));
                this.LandscapeTextures = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(LandscapeTextures, new Fallout3Group.Mask<TItem>(LandscapeTextures));
                this.ObjectEffects = new MaskItem<TItem, Fallout3Group.Mask<TItem>?>(ObjectEffects, new Fallout3Group.Mask<TItem>(ObjectEffects));
            }

            #pragma warning disable CS8618
            protected Mask()
            {
            }
            #pragma warning restore CS8618

            #endregion

            #region Members
            public MaskItem<TItem, Fallout3ModHeader.Mask<TItem>?>? ModHeader { get; set; }
            public MaskItem<TItem, Fallout3Group.Mask<TItem>?>? GameSettings { get; set; }
            public MaskItem<TItem, Fallout3Group.Mask<TItem>?>? TextureSets { get; set; }
            public MaskItem<TItem, Fallout3Group.Mask<TItem>?>? MenuIcons { get; set; }
            public MaskItem<TItem, Fallout3Group.Mask<TItem>?>? Globals { get; set; }
            public MaskItem<TItem, Fallout3Group.Mask<TItem>?>? Classes { get; set; }
            public MaskItem<TItem, Fallout3Group.Mask<TItem>?>? Factions { get; set; }
            public MaskItem<TItem, Fallout3Group.Mask<TItem>?>? HeadParts { get; set; }
            public MaskItem<TItem, Fallout3Group.Mask<TItem>?>? Hairs { get; set; }
            public MaskItem<TItem, Fallout3Group.Mask<TItem>?>? Eyes { get; set; }
            public MaskItem<TItem, Fallout3Group.Mask<TItem>?>? Races { get; set; }
            public MaskItem<TItem, Fallout3Group.Mask<TItem>?>? Sounds { get; set; }
            public MaskItem<TItem, Fallout3Group.Mask<TItem>?>? AcousticSpaces { get; set; }
            public MaskItem<TItem, Fallout3Group.Mask<TItem>?>? MagicEffects { get; set; }
            public MaskItem<TItem, Fallout3Group.Mask<TItem>?>? Scripts { get; set; }
            public MaskItem<TItem, Fallout3Group.Mask<TItem>?>? LandscapeTextures { get; set; }
            public MaskItem<TItem, Fallout3Group.Mask<TItem>?>? ObjectEffects { get; set; }
            #endregion

            #region Equals
            public override bool Equals(object? obj)
            {
                if (!(obj is Mask<TItem> rhs)) return false;
                return Equals(rhs);
            }

            public bool Equals(Mask<TItem>? rhs)
            {
                if (rhs == null) return false;
                if (!object.Equals(this.ModHeader, rhs.ModHeader)) return false;
                if (!object.Equals(this.GameSettings, rhs.GameSettings)) return false;
                if (!object.Equals(this.TextureSets, rhs.TextureSets)) return false;
                if (!object.Equals(this.MenuIcons, rhs.MenuIcons)) return false;
                if (!object.Equals(this.Globals, rhs.Globals)) return false;
                if (!object.Equals(this.Classes, rhs.Classes)) return false;
                if (!object.Equals(this.Factions, rhs.Factions)) return false;
                if (!object.Equals(this.HeadParts, rhs.HeadParts)) return false;
                if (!object.Equals(this.Hairs, rhs.Hairs)) return false;
                if (!object.Equals(this.Eyes, rhs.Eyes)) return false;
                if (!object.Equals(this.Races, rhs.Races)) return false;
                if (!object.Equals(this.Sounds, rhs.Sounds)) return false;
                if (!object.Equals(this.AcousticSpaces, rhs.AcousticSpaces)) return false;
                if (!object.Equals(this.MagicEffects, rhs.MagicEffects)) return false;
                if (!object.Equals(this.Scripts, rhs.Scripts)) return false;
                if (!object.Equals(this.LandscapeTextures, rhs.LandscapeTextures)) return false;
                if (!object.Equals(this.ObjectEffects, rhs.ObjectEffects)) return false;
                return true;
            }
            public override int GetHashCode()
            {
                var hash = new HashCode();
                hash.Add(this.ModHeader);
                hash.Add(this.GameSettings);
                hash.Add(this.TextureSets);
                hash.Add(this.MenuIcons);
                hash.Add(this.Globals);
                hash.Add(this.Classes);
                hash.Add(this.Factions);
                hash.Add(this.HeadParts);
                hash.Add(this.Hairs);
                hash.Add(this.Eyes);
                hash.Add(this.Races);
                hash.Add(this.Sounds);
                hash.Add(this.AcousticSpaces);
                hash.Add(this.MagicEffects);
                hash.Add(this.Scripts);
                hash.Add(this.LandscapeTextures);
                hash.Add(this.ObjectEffects);
                return hash.ToHashCode();
            }

            #endregion

            #region All
            public bool All(Func<TItem, bool> eval)
            {
                if (ModHeader != null)
                {
                    if (!eval(this.ModHeader.Overall)) return false;
                    if (this.ModHeader.Specific != null && !this.ModHeader.Specific.All(eval)) return false;
                }
                if (GameSettings != null)
                {
                    if (!eval(this.GameSettings.Overall)) return false;
                    if (this.GameSettings.Specific != null && !this.GameSettings.Specific.All(eval)) return false;
                }
                if (TextureSets != null)
                {
                    if (!eval(this.TextureSets.Overall)) return false;
                    if (this.TextureSets.Specific != null && !this.TextureSets.Specific.All(eval)) return false;
                }
                if (MenuIcons != null)
                {
                    if (!eval(this.MenuIcons.Overall)) return false;
                    if (this.MenuIcons.Specific != null && !this.MenuIcons.Specific.All(eval)) return false;
                }
                if (Globals != null)
                {
                    if (!eval(this.Globals.Overall)) return false;
                    if (this.Globals.Specific != null && !this.Globals.Specific.All(eval)) return false;
                }
                if (Classes != null)
                {
                    if (!eval(this.Classes.Overall)) return false;
                    if (this.Classes.Specific != null && !this.Classes.Specific.All(eval)) return false;
                }
                if (Factions != null)
                {
                    if (!eval(this.Factions.Overall)) return false;
                    if (this.Factions.Specific != null && !this.Factions.Specific.All(eval)) return false;
                }
                if (HeadParts != null)
                {
                    if (!eval(this.HeadParts.Overall)) return false;
                    if (this.HeadParts.Specific != null && !this.HeadParts.Specific.All(eval)) return false;
                }
                if (Hairs != null)
                {
                    if (!eval(this.Hairs.Overall)) return false;
                    if (this.Hairs.Specific != null && !this.Hairs.Specific.All(eval)) return false;
                }
                if (Eyes != null)
                {
                    if (!eval(this.Eyes.Overall)) return false;
                    if (this.Eyes.Specific != null && !this.Eyes.Specific.All(eval)) return false;
                }
                if (Races != null)
                {
                    if (!eval(this.Races.Overall)) return false;
                    if (this.Races.Specific != null && !this.Races.Specific.All(eval)) return false;
                }
                if (Sounds != null)
                {
                    if (!eval(this.Sounds.Overall)) return false;
                    if (this.Sounds.Specific != null && !this.Sounds.Specific.All(eval)) return false;
                }
                if (AcousticSpaces != null)
                {
                    if (!eval(this.AcousticSpaces.Overall)) return false;
                    if (this.AcousticSpaces.Specific != null && !this.AcousticSpaces.Specific.All(eval)) return false;
                }
                if (MagicEffects != null)
                {
                    if (!eval(this.MagicEffects.Overall)) return false;
                    if (this.MagicEffects.Specific != null && !this.MagicEffects.Specific.All(eval)) return false;
                }
                if (Scripts != null)
                {
                    if (!eval(this.Scripts.Overall)) return false;
                    if (this.Scripts.Specific != null && !this.Scripts.Specific.All(eval)) return false;
                }
                if (LandscapeTextures != null)
                {
                    if (!eval(this.LandscapeTextures.Overall)) return false;
                    if (this.LandscapeTextures.Specific != null && !this.LandscapeTextures.Specific.All(eval)) return false;
                }
                if (ObjectEffects != null)
                {
                    if (!eval(this.ObjectEffects.Overall)) return false;
                    if (this.ObjectEffects.Specific != null && !this.ObjectEffects.Specific.All(eval)) return false;
                }
                return true;
            }
            #endregion

            #region Any
            public bool Any(Func<TItem, bool> eval)
            {
                if (ModHeader != null)
                {
                    if (eval(this.ModHeader.Overall)) return true;
                    if (this.ModHeader.Specific != null && this.ModHeader.Specific.Any(eval)) return true;
                }
                if (GameSettings != null)
                {
                    if (eval(this.GameSettings.Overall)) return true;
                    if (this.GameSettings.Specific != null && this.GameSettings.Specific.Any(eval)) return true;
                }
                if (TextureSets != null)
                {
                    if (eval(this.TextureSets.Overall)) return true;
                    if (this.TextureSets.Specific != null && this.TextureSets.Specific.Any(eval)) return true;
                }
                if (MenuIcons != null)
                {
                    if (eval(this.MenuIcons.Overall)) return true;
                    if (this.MenuIcons.Specific != null && this.MenuIcons.Specific.Any(eval)) return true;
                }
                if (Globals != null)
                {
                    if (eval(this.Globals.Overall)) return true;
                    if (this.Globals.Specific != null && this.Globals.Specific.Any(eval)) return true;
                }
                if (Classes != null)
                {
                    if (eval(this.Classes.Overall)) return true;
                    if (this.Classes.Specific != null && this.Classes.Specific.Any(eval)) return true;
                }
                if (Factions != null)
                {
                    if (eval(this.Factions.Overall)) return true;
                    if (this.Factions.Specific != null && this.Factions.Specific.Any(eval)) return true;
                }
                if (HeadParts != null)
                {
                    if (eval(this.HeadParts.Overall)) return true;
                    if (this.HeadParts.Specific != null && this.HeadParts.Specific.Any(eval)) return true;
                }
                if (Hairs != null)
                {
                    if (eval(this.Hairs.Overall)) return true;
                    if (this.Hairs.Specific != null && this.Hairs.Specific.Any(eval)) return true;
                }
                if (Eyes != null)
                {
                    if (eval(this.Eyes.Overall)) return true;
                    if (this.Eyes.Specific != null && this.Eyes.Specific.Any(eval)) return true;
                }
                if (Races != null)
                {
                    if (eval(this.Races.Overall)) return true;
                    if (this.Races.Specific != null && this.Races.Specific.Any(eval)) return true;
                }
                if (Sounds != null)
                {
                    if (eval(this.Sounds.Overall)) return true;
                    if (this.Sounds.Specific != null && this.Sounds.Specific.Any(eval)) return true;
                }
                if (AcousticSpaces != null)
                {
                    if (eval(this.AcousticSpaces.Overall)) return true;
                    if (this.AcousticSpaces.Specific != null && this.AcousticSpaces.Specific.Any(eval)) return true;
                }
                if (MagicEffects != null)
                {
                    if (eval(this.MagicEffects.Overall)) return true;
                    if (this.MagicEffects.Specific != null && this.MagicEffects.Specific.Any(eval)) return true;
                }
                if (Scripts != null)
                {
                    if (eval(this.Scripts.Overall)) return true;
                    if (this.Scripts.Specific != null && this.Scripts.Specific.Any(eval)) return true;
                }
                if (LandscapeTextures != null)
                {
                    if (eval(this.LandscapeTextures.Overall)) return true;
                    if (this.LandscapeTextures.Specific != null && this.LandscapeTextures.Specific.Any(eval)) return true;
                }
                if (ObjectEffects != null)
                {
                    if (eval(this.ObjectEffects.Overall)) return true;
                    if (this.ObjectEffects.Specific != null && this.ObjectEffects.Specific.Any(eval)) return true;
                }
                return false;
            }
            #endregion

            #region Translate
            public Mask<R> Translate<R>(Func<TItem, R> eval)
            {
                var ret = new Fallout3Mod.Mask<R>();
                this.Translate_InternalFill(ret, eval);
                return ret;
            }

            protected void Translate_InternalFill<R>(Mask<R> obj, Func<TItem, R> eval)
            {
                obj.ModHeader = this.ModHeader == null ? null : new MaskItem<R, Fallout3ModHeader.Mask<R>?>(eval(this.ModHeader.Overall), this.ModHeader.Specific?.Translate(eval));
                obj.GameSettings = this.GameSettings == null ? null : new MaskItem<R, Fallout3Group.Mask<R>?>(eval(this.GameSettings.Overall), this.GameSettings.Specific?.Translate(eval));
                obj.TextureSets = this.TextureSets == null ? null : new MaskItem<R, Fallout3Group.Mask<R>?>(eval(this.TextureSets.Overall), this.TextureSets.Specific?.Translate(eval));
                obj.MenuIcons = this.MenuIcons == null ? null : new MaskItem<R, Fallout3Group.Mask<R>?>(eval(this.MenuIcons.Overall), this.MenuIcons.Specific?.Translate(eval));
                obj.Globals = this.Globals == null ? null : new MaskItem<R, Fallout3Group.Mask<R>?>(eval(this.Globals.Overall), this.Globals.Specific?.Translate(eval));
                obj.Classes = this.Classes == null ? null : new MaskItem<R, Fallout3Group.Mask<R>?>(eval(this.Classes.Overall), this.Classes.Specific?.Translate(eval));
                obj.Factions = this.Factions == null ? null : new MaskItem<R, Fallout3Group.Mask<R>?>(eval(this.Factions.Overall), this.Factions.Specific?.Translate(eval));
                obj.HeadParts = this.HeadParts == null ? null : new MaskItem<R, Fallout3Group.Mask<R>?>(eval(this.HeadParts.Overall), this.HeadParts.Specific?.Translate(eval));
                obj.Hairs = this.Hairs == null ? null : new MaskItem<R, Fallout3Group.Mask<R>?>(eval(this.Hairs.Overall), this.Hairs.Specific?.Translate(eval));
                obj.Eyes = this.Eyes == null ? null : new MaskItem<R, Fallout3Group.Mask<R>?>(eval(this.Eyes.Overall), this.Eyes.Specific?.Translate(eval));
                obj.Races = this.Races == null ? null : new MaskItem<R, Fallout3Group.Mask<R>?>(eval(this.Races.Overall), this.Races.Specific?.Translate(eval));
                obj.Sounds = this.Sounds == null ? null : new MaskItem<R, Fallout3Group.Mask<R>?>(eval(this.Sounds.Overall), this.Sounds.Specific?.Translate(eval));
                obj.AcousticSpaces = this.AcousticSpaces == null ? null : new MaskItem<R, Fallout3Group.Mask<R>?>(eval(this.AcousticSpaces.Overall), this.AcousticSpaces.Specific?.Translate(eval));
                obj.MagicEffects = this.MagicEffects == null ? null : new MaskItem<R, Fallout3Group.Mask<R>?>(eval(this.MagicEffects.Overall), this.MagicEffects.Specific?.Translate(eval));
                obj.Scripts = this.Scripts == null ? null : new MaskItem<R, Fallout3Group.Mask<R>?>(eval(this.Scripts.Overall), this.Scripts.Specific?.Translate(eval));
                obj.LandscapeTextures = this.LandscapeTextures == null ? null : new MaskItem<R, Fallout3Group.Mask<R>?>(eval(this.LandscapeTextures.Overall), this.LandscapeTextures.Specific?.Translate(eval));
                obj.ObjectEffects = this.ObjectEffects == null ? null : new MaskItem<R, Fallout3Group.Mask<R>?>(eval(this.ObjectEffects.Overall), this.ObjectEffects.Specific?.Translate(eval));
            }
            #endregion

            #region To String
            public override string ToString() => this.Print();

            public string Print(Fallout3Mod.Mask<bool>? printMask = null)
            {
                var sb = new StructuredStringBuilder();
                Print(sb, printMask);
                return sb.ToString();
            }

            public void Print(StructuredStringBuilder sb, Fallout3Mod.Mask<bool>? printMask = null)
            {
                sb.AppendLine($"{nameof(Fallout3Mod.Mask<TItem>)} =>");
                using (sb.Brace())
                {
                    if (printMask?.ModHeader?.Overall ?? true)
                    {
                        ModHeader?.Print(sb);
                    }
                    if (printMask?.GameSettings?.Overall ?? true)
                    {
                        GameSettings?.Print(sb);
                    }
                    if (printMask?.TextureSets?.Overall ?? true)
                    {
                        TextureSets?.Print(sb);
                    }
                    if (printMask?.MenuIcons?.Overall ?? true)
                    {
                        MenuIcons?.Print(sb);
                    }
                    if (printMask?.Globals?.Overall ?? true)
                    {
                        Globals?.Print(sb);
                    }
                    if (printMask?.Classes?.Overall ?? true)
                    {
                        Classes?.Print(sb);
                    }
                    if (printMask?.Factions?.Overall ?? true)
                    {
                        Factions?.Print(sb);
                    }
                    if (printMask?.HeadParts?.Overall ?? true)
                    {
                        HeadParts?.Print(sb);
                    }
                    if (printMask?.Hairs?.Overall ?? true)
                    {
                        Hairs?.Print(sb);
                    }
                    if (printMask?.Eyes?.Overall ?? true)
                    {
                        Eyes?.Print(sb);
                    }
                    if (printMask?.Races?.Overall ?? true)
                    {
                        Races?.Print(sb);
                    }
                    if (printMask?.Sounds?.Overall ?? true)
                    {
                        Sounds?.Print(sb);
                    }
                    if (printMask?.AcousticSpaces?.Overall ?? true)
                    {
                        AcousticSpaces?.Print(sb);
                    }
                    if (printMask?.MagicEffects?.Overall ?? true)
                    {
                        MagicEffects?.Print(sb);
                    }
                    if (printMask?.Scripts?.Overall ?? true)
                    {
                        Scripts?.Print(sb);
                    }
                    if (printMask?.LandscapeTextures?.Overall ?? true)
                    {
                        LandscapeTextures?.Print(sb);
                    }
                    if (printMask?.ObjectEffects?.Overall ?? true)
                    {
                        ObjectEffects?.Print(sb);
                    }
                }
            }
            #endregion

        }

        public class ErrorMask :
            IErrorMask,
            IErrorMask<ErrorMask>
        {
            #region Members
            public Exception? Overall { get; set; }
            private List<string>? _warnings;
            public List<string> Warnings
            {
                get
                {
                    if (_warnings == null)
                    {
                        _warnings = new List<string>();
                    }
                    return _warnings;
                }
            }
            public MaskItem<Exception?, Fallout3ModHeader.ErrorMask?>? ModHeader;
            public MaskItem<Exception?, Fallout3Group.ErrorMask<GameSetting.ErrorMask>?>? GameSettings;
            public MaskItem<Exception?, Fallout3Group.ErrorMask<TextureSet.ErrorMask>?>? TextureSets;
            public MaskItem<Exception?, Fallout3Group.ErrorMask<MenuIcon.ErrorMask>?>? MenuIcons;
            public MaskItem<Exception?, Fallout3Group.ErrorMask<Global.ErrorMask>?>? Globals;
            public MaskItem<Exception?, Fallout3Group.ErrorMask<Class.ErrorMask>?>? Classes;
            public MaskItem<Exception?, Fallout3Group.ErrorMask<Faction.ErrorMask>?>? Factions;
            public MaskItem<Exception?, Fallout3Group.ErrorMask<HeadPart.ErrorMask>?>? HeadParts;
            public MaskItem<Exception?, Fallout3Group.ErrorMask<Hair.ErrorMask>?>? Hairs;
            public MaskItem<Exception?, Fallout3Group.ErrorMask<Eyes.ErrorMask>?>? Eyes;
            public MaskItem<Exception?, Fallout3Group.ErrorMask<Race.ErrorMask>?>? Races;
            public MaskItem<Exception?, Fallout3Group.ErrorMask<Sound.ErrorMask>?>? Sounds;
            public MaskItem<Exception?, Fallout3Group.ErrorMask<AcousticSpace.ErrorMask>?>? AcousticSpaces;
            public MaskItem<Exception?, Fallout3Group.ErrorMask<MagicEffect.ErrorMask>?>? MagicEffects;
            public MaskItem<Exception?, Fallout3Group.ErrorMask<Script.ErrorMask>?>? Scripts;
            public MaskItem<Exception?, Fallout3Group.ErrorMask<LandscapeTexture.ErrorMask>?>? LandscapeTextures;
            public MaskItem<Exception?, Fallout3Group.ErrorMask<ObjectEffect.ErrorMask>?>? ObjectEffects;
            #endregion

            #region IErrorMask
            public object? GetNthMask(int index)
            {
                Fallout3Mod_FieldIndex enu = (Fallout3Mod_FieldIndex)index;
                switch (enu)
                {
                    case Fallout3Mod_FieldIndex.ModHeader:
                        return ModHeader;
                    case Fallout3Mod_FieldIndex.GameSettings:
                        return GameSettings;
                    case Fallout3Mod_FieldIndex.TextureSets:
                        return TextureSets;
                    case Fallout3Mod_FieldIndex.MenuIcons:
                        return MenuIcons;
                    case Fallout3Mod_FieldIndex.Globals:
                        return Globals;
                    case Fallout3Mod_FieldIndex.Classes:
                        return Classes;
                    case Fallout3Mod_FieldIndex.Factions:
                        return Factions;
                    case Fallout3Mod_FieldIndex.HeadParts:
                        return HeadParts;
                    case Fallout3Mod_FieldIndex.Hairs:
                        return Hairs;
                    case Fallout3Mod_FieldIndex.Eyes:
                        return Eyes;
                    case Fallout3Mod_FieldIndex.Races:
                        return Races;
                    case Fallout3Mod_FieldIndex.Sounds:
                        return Sounds;
                    case Fallout3Mod_FieldIndex.AcousticSpaces:
                        return AcousticSpaces;
                    case Fallout3Mod_FieldIndex.MagicEffects:
                        return MagicEffects;
                    case Fallout3Mod_FieldIndex.Scripts:
                        return Scripts;
                    case Fallout3Mod_FieldIndex.LandscapeTextures:
                        return LandscapeTextures;
                    case Fallout3Mod_FieldIndex.ObjectEffects:
                        return ObjectEffects;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthException(int index, Exception ex)
            {
                Fallout3Mod_FieldIndex enu = (Fallout3Mod_FieldIndex)index;
                switch (enu)
                {
                    case Fallout3Mod_FieldIndex.ModHeader:
                        this.ModHeader = new MaskItem<Exception?, Fallout3ModHeader.ErrorMask?>(ex, null);
                        break;
                    case Fallout3Mod_FieldIndex.GameSettings:
                        this.GameSettings = new MaskItem<Exception?, Fallout3Group.ErrorMask<GameSetting.ErrorMask>?>(ex, null);
                        break;
                    case Fallout3Mod_FieldIndex.TextureSets:
                        this.TextureSets = new MaskItem<Exception?, Fallout3Group.ErrorMask<TextureSet.ErrorMask>?>(ex, null);
                        break;
                    case Fallout3Mod_FieldIndex.MenuIcons:
                        this.MenuIcons = new MaskItem<Exception?, Fallout3Group.ErrorMask<MenuIcon.ErrorMask>?>(ex, null);
                        break;
                    case Fallout3Mod_FieldIndex.Globals:
                        this.Globals = new MaskItem<Exception?, Fallout3Group.ErrorMask<Global.ErrorMask>?>(ex, null);
                        break;
                    case Fallout3Mod_FieldIndex.Classes:
                        this.Classes = new MaskItem<Exception?, Fallout3Group.ErrorMask<Class.ErrorMask>?>(ex, null);
                        break;
                    case Fallout3Mod_FieldIndex.Factions:
                        this.Factions = new MaskItem<Exception?, Fallout3Group.ErrorMask<Faction.ErrorMask>?>(ex, null);
                        break;
                    case Fallout3Mod_FieldIndex.HeadParts:
                        this.HeadParts = new MaskItem<Exception?, Fallout3Group.ErrorMask<HeadPart.ErrorMask>?>(ex, null);
                        break;
                    case Fallout3Mod_FieldIndex.Hairs:
                        this.Hairs = new MaskItem<Exception?, Fallout3Group.ErrorMask<Hair.ErrorMask>?>(ex, null);
                        break;
                    case Fallout3Mod_FieldIndex.Eyes:
                        this.Eyes = new MaskItem<Exception?, Fallout3Group.ErrorMask<Eyes.ErrorMask>?>(ex, null);
                        break;
                    case Fallout3Mod_FieldIndex.Races:
                        this.Races = new MaskItem<Exception?, Fallout3Group.ErrorMask<Race.ErrorMask>?>(ex, null);
                        break;
                    case Fallout3Mod_FieldIndex.Sounds:
                        this.Sounds = new MaskItem<Exception?, Fallout3Group.ErrorMask<Sound.ErrorMask>?>(ex, null);
                        break;
                    case Fallout3Mod_FieldIndex.AcousticSpaces:
                        this.AcousticSpaces = new MaskItem<Exception?, Fallout3Group.ErrorMask<AcousticSpace.ErrorMask>?>(ex, null);
                        break;
                    case Fallout3Mod_FieldIndex.MagicEffects:
                        this.MagicEffects = new MaskItem<Exception?, Fallout3Group.ErrorMask<MagicEffect.ErrorMask>?>(ex, null);
                        break;
                    case Fallout3Mod_FieldIndex.Scripts:
                        this.Scripts = new MaskItem<Exception?, Fallout3Group.ErrorMask<Script.ErrorMask>?>(ex, null);
                        break;
                    case Fallout3Mod_FieldIndex.LandscapeTextures:
                        this.LandscapeTextures = new MaskItem<Exception?, Fallout3Group.ErrorMask<LandscapeTexture.ErrorMask>?>(ex, null);
                        break;
                    case Fallout3Mod_FieldIndex.ObjectEffects:
                        this.ObjectEffects = new MaskItem<Exception?, Fallout3Group.ErrorMask<ObjectEffect.ErrorMask>?>(ex, null);
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthMask(int index, object obj)
            {
                Fallout3Mod_FieldIndex enu = (Fallout3Mod_FieldIndex)index;
                switch (enu)
                {
                    case Fallout3Mod_FieldIndex.ModHeader:
                        this.ModHeader = (MaskItem<Exception?, Fallout3ModHeader.ErrorMask?>?)obj;
                        break;
                    case Fallout3Mod_FieldIndex.GameSettings:
                        this.GameSettings = (MaskItem<Exception?, Fallout3Group.ErrorMask<GameSetting.ErrorMask>?>?)obj;
                        break;
                    case Fallout3Mod_FieldIndex.TextureSets:
                        this.TextureSets = (MaskItem<Exception?, Fallout3Group.ErrorMask<TextureSet.ErrorMask>?>?)obj;
                        break;
                    case Fallout3Mod_FieldIndex.MenuIcons:
                        this.MenuIcons = (MaskItem<Exception?, Fallout3Group.ErrorMask<MenuIcon.ErrorMask>?>?)obj;
                        break;
                    case Fallout3Mod_FieldIndex.Globals:
                        this.Globals = (MaskItem<Exception?, Fallout3Group.ErrorMask<Global.ErrorMask>?>?)obj;
                        break;
                    case Fallout3Mod_FieldIndex.Classes:
                        this.Classes = (MaskItem<Exception?, Fallout3Group.ErrorMask<Class.ErrorMask>?>?)obj;
                        break;
                    case Fallout3Mod_FieldIndex.Factions:
                        this.Factions = (MaskItem<Exception?, Fallout3Group.ErrorMask<Faction.ErrorMask>?>?)obj;
                        break;
                    case Fallout3Mod_FieldIndex.HeadParts:
                        this.HeadParts = (MaskItem<Exception?, Fallout3Group.ErrorMask<HeadPart.ErrorMask>?>?)obj;
                        break;
                    case Fallout3Mod_FieldIndex.Hairs:
                        this.Hairs = (MaskItem<Exception?, Fallout3Group.ErrorMask<Hair.ErrorMask>?>?)obj;
                        break;
                    case Fallout3Mod_FieldIndex.Eyes:
                        this.Eyes = (MaskItem<Exception?, Fallout3Group.ErrorMask<Eyes.ErrorMask>?>?)obj;
                        break;
                    case Fallout3Mod_FieldIndex.Races:
                        this.Races = (MaskItem<Exception?, Fallout3Group.ErrorMask<Race.ErrorMask>?>?)obj;
                        break;
                    case Fallout3Mod_FieldIndex.Sounds:
                        this.Sounds = (MaskItem<Exception?, Fallout3Group.ErrorMask<Sound.ErrorMask>?>?)obj;
                        break;
                    case Fallout3Mod_FieldIndex.AcousticSpaces:
                        this.AcousticSpaces = (MaskItem<Exception?, Fallout3Group.ErrorMask<AcousticSpace.ErrorMask>?>?)obj;
                        break;
                    case Fallout3Mod_FieldIndex.MagicEffects:
                        this.MagicEffects = (MaskItem<Exception?, Fallout3Group.ErrorMask<MagicEffect.ErrorMask>?>?)obj;
                        break;
                    case Fallout3Mod_FieldIndex.Scripts:
                        this.Scripts = (MaskItem<Exception?, Fallout3Group.ErrorMask<Script.ErrorMask>?>?)obj;
                        break;
                    case Fallout3Mod_FieldIndex.LandscapeTextures:
                        this.LandscapeTextures = (MaskItem<Exception?, Fallout3Group.ErrorMask<LandscapeTexture.ErrorMask>?>?)obj;
                        break;
                    case Fallout3Mod_FieldIndex.ObjectEffects:
                        this.ObjectEffects = (MaskItem<Exception?, Fallout3Group.ErrorMask<ObjectEffect.ErrorMask>?>?)obj;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public bool IsInError()
            {
                if (Overall != null) return true;
                if (ModHeader != null) return true;
                if (GameSettings != null) return true;
                if (TextureSets != null) return true;
                if (MenuIcons != null) return true;
                if (Globals != null) return true;
                if (Classes != null) return true;
                if (Factions != null) return true;
                if (HeadParts != null) return true;
                if (Hairs != null) return true;
                if (Eyes != null) return true;
                if (Races != null) return true;
                if (Sounds != null) return true;
                if (AcousticSpaces != null) return true;
                if (MagicEffects != null) return true;
                if (Scripts != null) return true;
                if (LandscapeTextures != null) return true;
                if (ObjectEffects != null) return true;
                return false;
            }
            #endregion

            #region To String
            public override string ToString() => this.Print();

            public void Print(StructuredStringBuilder sb, string? name = null)
            {
                sb.AppendLine($"{(name ?? "ErrorMask")} =>");
                using (sb.Brace())
                {
                    if (this.Overall != null)
                    {
                        sb.AppendLine("Overall =>");
                        using (sb.Brace())
                        {
                            sb.AppendLine($"{this.Overall}");
                        }
                    }
                    PrintFillInternal(sb);
                }
            }
            protected void PrintFillInternal(StructuredStringBuilder sb)
            {
                ModHeader?.Print(sb);
                GameSettings?.Print(sb);
                TextureSets?.Print(sb);
                MenuIcons?.Print(sb);
                Globals?.Print(sb);
                Classes?.Print(sb);
                Factions?.Print(sb);
                HeadParts?.Print(sb);
                Hairs?.Print(sb);
                Eyes?.Print(sb);
                Races?.Print(sb);
                Sounds?.Print(sb);
                AcousticSpaces?.Print(sb);
                MagicEffects?.Print(sb);
                Scripts?.Print(sb);
                LandscapeTextures?.Print(sb);
                ObjectEffects?.Print(sb);
            }
            #endregion

            #region Combine
            public ErrorMask Combine(ErrorMask? rhs)
            {
                if (rhs == null) return this;
                var ret = new ErrorMask();
                ret.ModHeader = this.ModHeader.Combine(rhs.ModHeader, (l, r) => l.Combine(r));
                ret.GameSettings = this.GameSettings.Combine(rhs.GameSettings, (l, r) => l.Combine(r));
                ret.TextureSets = this.TextureSets.Combine(rhs.TextureSets, (l, r) => l.Combine(r));
                ret.MenuIcons = this.MenuIcons.Combine(rhs.MenuIcons, (l, r) => l.Combine(r));
                ret.Globals = this.Globals.Combine(rhs.Globals, (l, r) => l.Combine(r));
                ret.Classes = this.Classes.Combine(rhs.Classes, (l, r) => l.Combine(r));
                ret.Factions = this.Factions.Combine(rhs.Factions, (l, r) => l.Combine(r));
                ret.HeadParts = this.HeadParts.Combine(rhs.HeadParts, (l, r) => l.Combine(r));
                ret.Hairs = this.Hairs.Combine(rhs.Hairs, (l, r) => l.Combine(r));
                ret.Eyes = this.Eyes.Combine(rhs.Eyes, (l, r) => l.Combine(r));
                ret.Races = this.Races.Combine(rhs.Races, (l, r) => l.Combine(r));
                ret.Sounds = this.Sounds.Combine(rhs.Sounds, (l, r) => l.Combine(r));
                ret.AcousticSpaces = this.AcousticSpaces.Combine(rhs.AcousticSpaces, (l, r) => l.Combine(r));
                ret.MagicEffects = this.MagicEffects.Combine(rhs.MagicEffects, (l, r) => l.Combine(r));
                ret.Scripts = this.Scripts.Combine(rhs.Scripts, (l, r) => l.Combine(r));
                ret.LandscapeTextures = this.LandscapeTextures.Combine(rhs.LandscapeTextures, (l, r) => l.Combine(r));
                ret.ObjectEffects = this.ObjectEffects.Combine(rhs.ObjectEffects, (l, r) => l.Combine(r));
                return ret;
            }
            public static ErrorMask? Combine(ErrorMask? lhs, ErrorMask? rhs)
            {
                if (lhs != null && rhs != null) return lhs.Combine(rhs);
                return lhs ?? rhs;
            }
            #endregion

            #region Factory
            public static ErrorMask Factory(ErrorMaskBuilder errorMask)
            {
                return new ErrorMask();
            }
            #endregion

        }
        public class TranslationMask : ITranslationMask
        {
            #region Members
            private TranslationCrystal? _crystal;
            public readonly bool DefaultOn;
            public bool OnOverall;
            public Fallout3ModHeader.TranslationMask? ModHeader;
            public Fallout3Group.TranslationMask<GameSetting.TranslationMask>? GameSettings;
            public Fallout3Group.TranslationMask<TextureSet.TranslationMask>? TextureSets;
            public Fallout3Group.TranslationMask<MenuIcon.TranslationMask>? MenuIcons;
            public Fallout3Group.TranslationMask<Global.TranslationMask>? Globals;
            public Fallout3Group.TranslationMask<Class.TranslationMask>? Classes;
            public Fallout3Group.TranslationMask<Faction.TranslationMask>? Factions;
            public Fallout3Group.TranslationMask<HeadPart.TranslationMask>? HeadParts;
            public Fallout3Group.TranslationMask<Hair.TranslationMask>? Hairs;
            public Fallout3Group.TranslationMask<Eyes.TranslationMask>? Eyes;
            public Fallout3Group.TranslationMask<Race.TranslationMask>? Races;
            public Fallout3Group.TranslationMask<Sound.TranslationMask>? Sounds;
            public Fallout3Group.TranslationMask<AcousticSpace.TranslationMask>? AcousticSpaces;
            public Fallout3Group.TranslationMask<MagicEffect.TranslationMask>? MagicEffects;
            public Fallout3Group.TranslationMask<Script.TranslationMask>? Scripts;
            public Fallout3Group.TranslationMask<LandscapeTexture.TranslationMask>? LandscapeTextures;
            public Fallout3Group.TranslationMask<ObjectEffect.TranslationMask>? ObjectEffects;
            #endregion

            #region Ctors
            public TranslationMask(
                bool defaultOn,
                bool onOverall = true)
            {
                this.DefaultOn = defaultOn;
                this.OnOverall = onOverall;
            }

            #endregion

            public TranslationCrystal GetCrystal()
            {
                if (_crystal != null) return _crystal;
                var ret = new List<(bool On, TranslationCrystal? SubCrystal)>();
                GetCrystal(ret);
                _crystal = new TranslationCrystal(ret.ToArray());
                return _crystal;
            }

            protected void GetCrystal(List<(bool On, TranslationCrystal? SubCrystal)> ret)
            {
                ret.Add((ModHeader != null ? ModHeader.OnOverall : DefaultOn, ModHeader?.GetCrystal()));
                ret.Add((GameSettings != null ? GameSettings.OnOverall : DefaultOn, GameSettings?.GetCrystal()));
                ret.Add((TextureSets != null ? TextureSets.OnOverall : DefaultOn, TextureSets?.GetCrystal()));
                ret.Add((MenuIcons != null ? MenuIcons.OnOverall : DefaultOn, MenuIcons?.GetCrystal()));
                ret.Add((Globals != null ? Globals.OnOverall : DefaultOn, Globals?.GetCrystal()));
                ret.Add((Classes != null ? Classes.OnOverall : DefaultOn, Classes?.GetCrystal()));
                ret.Add((Factions != null ? Factions.OnOverall : DefaultOn, Factions?.GetCrystal()));
                ret.Add((HeadParts != null ? HeadParts.OnOverall : DefaultOn, HeadParts?.GetCrystal()));
                ret.Add((Hairs != null ? Hairs.OnOverall : DefaultOn, Hairs?.GetCrystal()));
                ret.Add((Eyes != null ? Eyes.OnOverall : DefaultOn, Eyes?.GetCrystal()));
                ret.Add((Races != null ? Races.OnOverall : DefaultOn, Races?.GetCrystal()));
                ret.Add((Sounds != null ? Sounds.OnOverall : DefaultOn, Sounds?.GetCrystal()));
                ret.Add((AcousticSpaces != null ? AcousticSpaces.OnOverall : DefaultOn, AcousticSpaces?.GetCrystal()));
                ret.Add((MagicEffects != null ? MagicEffects.OnOverall : DefaultOn, MagicEffects?.GetCrystal()));
                ret.Add((Scripts != null ? Scripts.OnOverall : DefaultOn, Scripts?.GetCrystal()));
                ret.Add((LandscapeTextures != null ? LandscapeTextures.OnOverall : DefaultOn, LandscapeTextures?.GetCrystal()));
                ret.Add((ObjectEffects != null ? ObjectEffects.OnOverall : DefaultOn, ObjectEffects?.GetCrystal()));
            }

            public static implicit operator TranslationMask(bool defaultOn)
            {
                return new TranslationMask(defaultOn: defaultOn, onOverall: defaultOn);
            }

        }
        #endregion

        #region Mutagen
        public Fallout3Release Fallout3Release { get; }
        public override GameRelease GameRelease => Fallout3Release.ToGameRelease();
        IGroupGetter<T>? IModGetter.TryGetTopLevelGroup<T>() => this.TryGetTopLevelGroup<T>();
        IGroupGetter? IModGetter.TryGetTopLevelGroup(Type type) => this.TryGetTopLevelGroup(type);
        IGroup<T>? IMod.TryGetTopLevelGroup<T>() => this.TryGetTopLevelGroup<T>();
        IGroup? IMod.TryGetTopLevelGroup(Type type) => this.TryGetTopLevelGroup(type);
        void IModGetter.WriteToBinary(FilePath path, BinaryWriteParameters? param) => this.WriteToBinary(path, importMask: null, param: param);
        void IModGetter.WriteToBinary(Stream stream, BinaryWriteParameters? param) => this.WriteToBinary(stream, importMask: null, param: param);
        uint IModGetter.GetRecordCount() => this.GetRecordCount();
        IMask<bool> IEqualsMask.GetEqualsMask(object rhs, EqualsMaskHelper.Include include = EqualsMaskHelper.Include.OnlyFailures) => Fallout3ModMixIn.GetEqualsMask(this, (IFallout3ModGetter)rhs, include);
        public override bool CanUseLocalization => false;
        public override bool UsingLocalization
        {
            get => false;
            set => throw new ArgumentException("Tried to set localization flag on unsupported mod type");
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IList<MasterReference> IMod.MasterReferences => this.ModHeader.MasterReferences;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IReadOnlyList<IMasterReferenceGetter> IModGetter.MasterReferences => this.ModHeader.MasterReferences;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        uint IMod.NextFormID
        {
            get => this.ModHeader.Stats.NextFormID;
            set => this.ModHeader.Stats.NextFormID = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        uint IModGetter.NextFormID => this.ModHeader.Stats.NextFormID;
        /// <param name="modKey">ModKey to assign to the mod</param>
        /// <param name="release">Release to assign to the mod</param>
        /// <param name="headerVersion">Header version to assign to the mod.  Default value is latest header version the game supports</param>
        /// <param name="forceUseLowerFormIDRanges">Default value of false, which will not use lower FormID ranges from 1-X.  A null value will refer to header version + game release to determine if it should be allowed.  True will force it to always use FormIDs 1-X</param>
        public Fallout3Mod(
            ModKey modKey,
            Fallout3Release release,
            float? headerVersion = null,
            bool? forceUseLowerFormIDRanges = false)
            : base(modKey)
        {
            this.Fallout3Release = release;
            if (headerVersion != null)
            {
                this.ModHeader.Stats.Version = headerVersion.Value;
            }
            else
            {
                this.ModHeader.Stats.Version = GameConstants.Get(release.ToGameRelease()).DefaultModHeaderVersion ?? 0f;
            }
            this.ModHeader.Stats.NextFormID = GetDefaultInitialNextFormID(forceUseLowerFormIDRanges: forceUseLowerFormIDRanges);
            _GameSettings_Object = new Fallout3Group<GameSetting>(this);
            _TextureSets_Object = new Fallout3Group<TextureSet>(this);
            _MenuIcons_Object = new Fallout3Group<MenuIcon>(this);
            _Globals_Object = new Fallout3Group<Global>(this);
            _Classes_Object = new Fallout3Group<Class>(this);
            _Factions_Object = new Fallout3Group<Faction>(this);
            _HeadParts_Object = new Fallout3Group<HeadPart>(this);
            _Hairs_Object = new Fallout3Group<Hair>(this);
            _Eyes_Object = new Fallout3Group<Eyes>(this);
            _Races_Object = new Fallout3Group<Race>(this);
            _Sounds_Object = new Fallout3Group<Sound>(this);
            _AcousticSpaces_Object = new Fallout3Group<AcousticSpace>(this);
            _MagicEffects_Object = new Fallout3Group<MagicEffect>(this);
            _Scripts_Object = new Fallout3Group<Script>(this);
            _LandscapeTextures_Object = new Fallout3Group<LandscapeTexture>(this);
            _ObjectEffects_Object = new Fallout3Group<ObjectEffect>(this);
            CustomCtor();
        }
        public void AddRecords(
            Fallout3Mod rhsMod,
            GroupMask? mask = null)
        {
            if (mask?.GameSettings ?? true)
            {
                this.GameSettings.RecordCache.Set(rhsMod.GameSettings.RecordCache.Items);
            }
            if (mask?.TextureSets ?? true)
            {
                this.TextureSets.RecordCache.Set(rhsMod.TextureSets.RecordCache.Items);
            }
            if (mask?.MenuIcons ?? true)
            {
                this.MenuIcons.RecordCache.Set(rhsMod.MenuIcons.RecordCache.Items);
            }
            if (mask?.Globals ?? true)
            {
                this.Globals.RecordCache.Set(rhsMod.Globals.RecordCache.Items);
            }
            if (mask?.Classes ?? true)
            {
                this.Classes.RecordCache.Set(rhsMod.Classes.RecordCache.Items);
            }
            if (mask?.Factions ?? true)
            {
                this.Factions.RecordCache.Set(rhsMod.Factions.RecordCache.Items);
            }
            if (mask?.HeadParts ?? true)
            {
                this.HeadParts.RecordCache.Set(rhsMod.HeadParts.RecordCache.Items);
            }
            if (mask?.Hairs ?? true)
            {
                this.Hairs.RecordCache.Set(rhsMod.Hairs.RecordCache.Items);
            }
            if (mask?.Eyes ?? true)
            {
                this.Eyes.RecordCache.Set(rhsMod.Eyes.RecordCache.Items);
            }
            if (mask?.Races ?? true)
            {
                this.Races.RecordCache.Set(rhsMod.Races.RecordCache.Items);
            }
            if (mask?.Sounds ?? true)
            {
                this.Sounds.RecordCache.Set(rhsMod.Sounds.RecordCache.Items);
            }
            if (mask?.AcousticSpaces ?? true)
            {
                this.AcousticSpaces.RecordCache.Set(rhsMod.AcousticSpaces.RecordCache.Items);
            }
            if (mask?.MagicEffects ?? true)
            {
                this.MagicEffects.RecordCache.Set(rhsMod.MagicEffects.RecordCache.Items);
            }
            if (mask?.Scripts ?? true)
            {
                this.Scripts.RecordCache.Set(rhsMod.Scripts.RecordCache.Items);
            }
            if (mask?.LandscapeTextures ?? true)
            {
                this.LandscapeTextures.RecordCache.Set(rhsMod.LandscapeTextures.RecordCache.Items);
            }
            if (mask?.ObjectEffects ?? true)
            {
                this.ObjectEffects.RecordCache.Set(rhsMod.ObjectEffects.RecordCache.Items);
            }
        }

        public override void SyncRecordCount()
        {
            this.ModHeader.Stats.NumRecords = this.GetRecordCount();
        }

        public IEnumerable<IFormLinkGetter> EnumerateFormLinks() => Fallout3ModCommon.Instance.EnumerateFormLinks(this);
        public void RemapLinks(IReadOnlyDictionary<FormKey, FormKey> mapping) => Fallout3ModSetterCommon.Instance.RemapLinks(this, mapping);
        [DebuggerStepThrough]
        IEnumerable<IMajorRecordGetter> IMajorRecordGetterEnumerable.EnumerateMajorRecords() => this.EnumerateMajorRecords();
        [DebuggerStepThrough]
        IEnumerable<TMajor> IMajorRecordGetterEnumerable.EnumerateMajorRecords<TMajor>(bool throwIfUnknown) => this.EnumerateMajorRecords<TMajor>(throwIfUnknown: throwIfUnknown);
        [DebuggerStepThrough]
        IEnumerable<IMajorRecordGetter> IMajorRecordGetterEnumerable.EnumerateMajorRecords(Type type, bool throwIfUnknown) => this.EnumerateMajorRecords(type: type, throwIfUnknown: throwIfUnknown);
        [DebuggerStepThrough]
        IEnumerable<IMajorRecord> IMajorRecordEnumerable.EnumerateMajorRecords() => this.EnumerateMajorRecords();
        [DebuggerStepThrough]
        IEnumerable<TMajor> IMajorRecordEnumerable.EnumerateMajorRecords<TMajor>(bool throwIfUnknown) => this.EnumerateMajorRecords<TMajor>(throwIfUnknown: throwIfUnknown);
        [DebuggerStepThrough]
        IEnumerable<IMajorRecord> IMajorRecordEnumerable.EnumerateMajorRecords(Type? type, bool throwIfUnknown) => this.EnumerateMajorRecords(type: type, throwIfUnknown: throwIfUnknown);
        [DebuggerStepThrough]
        void IMajorRecordEnumerable.Remove(FormKey formKey) => this.Remove(formKey);
        [DebuggerStepThrough]
        void IMajorRecordEnumerable.Remove(HashSet<FormKey> formKeys) => this.Remove(formKeys);
        [DebuggerStepThrough]
        void IMajorRecordEnumerable.Remove(IEnumerable<FormKey> formKeys) => this.Remove(formKeys);
        [DebuggerStepThrough]
        void IMajorRecordEnumerable.Remove(IEnumerable<IFormLinkIdentifier> formLinks) => this.Remove(formLinks);
        [DebuggerStepThrough]
        void IMajorRecordEnumerable.Remove(FormKey formKey, Type type, bool throwIfUnknown) => this.Remove(formKey, type, throwIfUnknown);
        [DebuggerStepThrough]
        void IMajorRecordEnumerable.Remove(HashSet<FormKey> formKeys, Type type, bool throwIfUnknown) => this.Remove(formKeys, type, throwIfUnknown);
        [DebuggerStepThrough]
        void IMajorRecordEnumerable.Remove(IEnumerable<FormKey> formKeys, Type type, bool throwIfUnknown) => this.Remove(formKeys, type, throwIfUnknown);
        [DebuggerStepThrough]
        void IMajorRecordEnumerable.Remove<TMajor>(FormKey formKey, bool throwIfUnknown) => this.Remove<TMajor>(formKey, throwIfUnknown);
        [DebuggerStepThrough]
        void IMajorRecordEnumerable.Remove<TMajor>(HashSet<FormKey> formKeys, bool throwIfUnknown) => this.Remove<TMajor>(formKeys, throwIfUnknown);
        [DebuggerStepThrough]
        void IMajorRecordEnumerable.Remove<TMajor>(IEnumerable<FormKey> formKeys, bool throwIfUnknown) => this.Remove<TMajor>(formKeys, throwIfUnknown);
        [DebuggerStepThrough]
        void IMajorRecordEnumerable.Remove<TMajor>(TMajor record, bool throwIfUnknown) => this.Remove<TMajor>(record, throwIfUnknown);
        [DebuggerStepThrough]
        void IMajorRecordEnumerable.Remove<TMajor>(IEnumerable<TMajor> records, bool throwIfUnknown) => this.Remove<TMajor>(records, throwIfUnknown);
        [DebuggerStepThrough]
        IEnumerable<IModContext<IFallout3Mod, IFallout3ModGetter, TSetter, TGetter>> IMajorRecordContextEnumerable<IFallout3Mod, IFallout3ModGetter>.EnumerateMajorRecordContexts<TSetter, TGetter>(ILinkCache linkCache, bool throwIfUnknown) => this.EnumerateMajorRecordContexts<TSetter, TGetter>(linkCache, throwIfUnknown: throwIfUnknown);
        [DebuggerStepThrough]
        IEnumerable<IModContext<IFallout3Mod, IFallout3ModGetter, IMajorRecord, IMajorRecordGetter>> IMajorRecordContextEnumerable<IFallout3Mod, IFallout3ModGetter>.EnumerateMajorRecordContexts(ILinkCache linkCache, Type type, bool throwIfUnknown) => this.EnumerateMajorRecordContexts(linkCache, type: type, throwIfUnknown: throwIfUnknown);
        [DebuggerStepThrough]
        IEnumerable<IModContext<IMajorRecordGetter>> IMajorRecordSimpleContextEnumerable.EnumerateMajorRecordSimpleContexts() => this.EnumerateMajorRecordContexts();
        [DebuggerStepThrough]
        IEnumerable<IModContext<TMajor>> IMajorRecordSimpleContextEnumerable.EnumerateMajorRecordSimpleContexts<TMajor>(bool throwIfUnknown) => this.EnumerateMajorRecordContexts(linkCache: null!, typeof(TMajor), throwIfUnknown: throwIfUnknown).Select(x => x.AsType<Mutagen.Bethesda.Plugins.Records.IMajorRecordQueryableGetter, TMajor>());
        [DebuggerStepThrough]
        IEnumerable<IModContext<IMajorRecordGetter>> IMajorRecordSimpleContextEnumerable.EnumerateMajorRecordSimpleContexts(Type type, bool throwIfUnknown) => this.EnumerateMajorRecordContexts(linkCache: null!, type: type, throwIfUnknown: throwIfUnknown);
        public IEnumerable<IAssetLinkGetter> EnumerateAssetLinks(AssetLinkQuery queryCategories, IAssetLinkCache? linkCache, Type? assetType) => Fallout3ModCommon.Instance.EnumerateAssetLinks(this, queryCategories, linkCache, assetType);
        public IEnumerable<IAssetLink> EnumerateListedAssetLinks() => Fallout3ModSetterCommon.Instance.EnumerateListedAssetLinks(this);
        public void RemapAssetLinks(IReadOnlyDictionary<IAssetLinkGetter, string> mapping, AssetLinkQuery queryCategories, IAssetLinkCache? linkCache) => Fallout3ModSetterCommon.Instance.RemapAssetLinks(this, mapping, linkCache, queryCategories);
        public void RemapListedAssetLinks(IReadOnlyDictionary<IAssetLinkGetter, string> mapping) => Fallout3ModSetterCommon.Instance.RemapAssetLinks(this, mapping, null, AssetLinkQuery.Listed);
        #endregion

        #region Binary Translation
        #region Binary Create
        public static Fallout3Mod CreateFromBinary(
            ModPath path,
            Fallout3Release release,
            BinaryReadParameters? param = null,
            GroupMask? importMask = null)
        {
            try
            {
                var gameRelease = release.ToGameRelease();
                param ??= BinaryReadParameters.Default;
                var fileSystem = param.FileSystem.GetOrDefault();
                var meta = ParsingMeta.Factory(param, gameRelease, path);
                using (var reader = new MutagenBinaryReadStream(path, meta))
                {
                    var frame = new MutagenFrame(reader);
                    frame.MetaData.RecordInfoCache = new RecordTypeInfoCacheReader(() => new MutagenBinaryReadStream(path, meta), path.ModKey, meta.LinkCache);
                    return CreateFromBinary(
                        release: release,
                        importMask: importMask,
                        frame: frame);
                }
            }
            catch (Exception ex)
            {
                RecordException.EnrichAndThrow(ex, path.ModKey);
                throw;
            }
        }

        public static Fallout3Mod CreateFromBinary(
            ModPath path,
            Fallout3Release release,
            ErrorMaskBuilder? errorMask,
            BinaryReadParameters? param = null,
            GroupMask? importMask = null)
        {
            try
            {
                var gameRelease = release.ToGameRelease();
                param ??= BinaryReadParameters.Default;
                var fileSystem = param.FileSystem.GetOrDefault();
                var meta = ParsingMeta.Factory(param, gameRelease, path);
                using (var reader = new MutagenBinaryReadStream(path, meta))
                {
                    var frame = new MutagenFrame(reader);
                    frame.MetaData.RecordInfoCache = new RecordTypeInfoCacheReader(() => new MutagenBinaryReadStream(path, meta), path.ModKey, meta.LinkCache);
                    return CreateFromBinary(
                        release: release,
                        importMask: importMask,
                        frame: frame);
                }
            }
            catch (Exception ex)
            {
                RecordException.EnrichAndThrow(ex, path.ModKey);
                throw;
            }
        }

        public static Fallout3Mod CreateFromBinary(
            Stream stream,
            ModKey modKey,
            Fallout3Release release,
            RecordTypeInfoCacheReader infoCache,
            BinaryReadParameters? param = null,
            GroupMask? importMask = null)
        {
            try
            {
                param ??= BinaryReadParameters.Default;
                var meta = ParsingMeta.Factory(param, GameRelease.Oblivion, modKey, stream);
                using (var reader = new MutagenBinaryReadStream(stream, meta))
                {
                    var frame = new MutagenFrame(reader);
                    frame.MetaData.RecordInfoCache = infoCache;
                    return CreateFromBinary(
                        release: release,
                        importMask: importMask,
                        frame: frame);
                }
            }
            catch (Exception ex)
            {
                RecordException.EnrichAndThrow(ex, modKey);
                throw;
            }
        }

        public static Fallout3Mod CreateFromBinary(
            Stream stream,
            ModKey modKey,
            Fallout3Release release,
            RecordTypeInfoCacheReader infoCache,
            ErrorMaskBuilder? errorMask,
            BinaryReadParameters? param = null,
            GroupMask? importMask = null)
        {
            try
            {
                param ??= BinaryReadParameters.Default;
                var meta = ParsingMeta.Factory(param, GameRelease.Oblivion, modKey, stream);
                using (var reader = new MutagenBinaryReadStream(stream, meta))
                {
                    var frame = new MutagenFrame(reader);
                    frame.MetaData.RecordInfoCache = infoCache;
                    return CreateFromBinary(
                        release: release,
                        importMask: importMask,
                        frame: frame);
                }
            }
            catch (Exception ex)
            {
                RecordException.EnrichAndThrow(ex, modKey);
                throw;
            }
        }

        #endregion

        public static IFallout3ModDisposableGetter CreateFromBinaryOverlay(
            ModPath path,
            Fallout3Release release,
            BinaryReadParameters? param = null)
        {
            return Fallout3ModBinaryOverlay.Fallout3ModFactory(
                path: path,
                release: release,
                param: param);
        }

        public static IFallout3ModDisposableGetter CreateFromBinaryOverlay(
            Stream stream,
            Fallout3Release release,
            ModKey modKey,
            BinaryReadParameters? param = null)
        {
            param ??= BinaryReadParameters.Default;
            var meta = ParsingMeta.Factory(param, release.ToGameRelease(), modKey, stream);
            return Fallout3ModBinaryOverlay.Fallout3ModFactory(
                stream: new MutagenBinaryReadStream(stream, meta),
                modKey: modKey,
                release: release,
                shouldDispose: false);
        }

        public static Fallout3Mod CreateFromBinary(
            MutagenFrame frame,
            Fallout3Release release,
            GroupMask? importMask = null)
        {
            try
            {
                var ret = new Fallout3Mod(
                    modKey: frame.MetaData.ModKey,
                    release: release);
                ((Fallout3ModSetterCommon)((IFallout3ModGetter)ret).CommonSetterInstance()!).CopyInFromBinary(
                    item: ret,
                    frame: frame,
                    release: release,
                    importMask: importMask);
                return ret;
            }
            catch (Exception ex)
            {
                RecordException.EnrichAndThrow(ex, frame.MetaData.ModKey);
                throw;
            }
        }

        #endregion

        void IPrintable.Print(StructuredStringBuilder sb, string? name) => this.Print(sb, name);

        void IClearable.Clear()
        {
            ((Fallout3ModSetterCommon)((IFallout3ModGetter)this).CommonSetterInstance()!).Clear(this);
        }

        internal static Fallout3Mod GetNew()
        {
            return new Fallout3Mod();
        }

    }
    #endregion

    #region Interface
    public partial interface IFallout3Mod :
        IAssetLinkContainer,
        IContextMod<IFallout3Mod, IFallout3ModGetter>,
        IFallout3ModGetter,
        IFormLinkContainer,
        ILoquiObjectSetter<IFallout3Mod>,
        IMajorRecordEnumerable,
        IMod
    {
        new Fallout3ModHeader ModHeader { get; }
        new Fallout3Group<GameSetting> GameSettings { get; }
        new Fallout3Group<TextureSet> TextureSets { get; }
        new Fallout3Group<MenuIcon> MenuIcons { get; }
        new Fallout3Group<Global> Globals { get; }
        new Fallout3Group<Class> Classes { get; }
        new Fallout3Group<Faction> Factions { get; }
        new Fallout3Group<HeadPart> HeadParts { get; }
        new Fallout3Group<Hair> Hairs { get; }
        new Fallout3Group<Eyes> Eyes { get; }
        new Fallout3Group<Race> Races { get; }
        new Fallout3Group<Sound> Sounds { get; }
        new Fallout3Group<AcousticSpace> AcousticSpaces { get; }
        new Fallout3Group<MagicEffect> MagicEffects { get; }
        new Fallout3Group<Script> Scripts { get; }
        new Fallout3Group<LandscapeTexture> LandscapeTextures { get; }
        new Fallout3Group<ObjectEffect> ObjectEffects { get; }
    }

    public partial interface IFallout3ModGetter :
        ILoquiObject,
        IAssetLinkContainerGetter,
        IContextGetterMod<IFallout3Mod, IFallout3ModGetter>,
        IFormLinkContainerGetter,
        ILoquiObject<IFallout3ModGetter>,
        IMajorRecordContextEnumerable<IFallout3Mod, IFallout3ModGetter>,
        IMajorRecordGetterEnumerable,
        IModGetter
    {
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object? CommonSetterInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonSetterTranslationInstance();
        static ILoquiRegistration StaticRegistration => Fallout3Mod_Registration.Instance;
        IFallout3ModHeaderGetter ModHeader { get; }
        IFallout3GroupGetter<IGameSettingGetter> GameSettings { get; }
        IFallout3GroupGetter<ITextureSetGetter> TextureSets { get; }
        IFallout3GroupGetter<IMenuIconGetter> MenuIcons { get; }
        IFallout3GroupGetter<IGlobalGetter> Globals { get; }
        IFallout3GroupGetter<IClassGetter> Classes { get; }
        IFallout3GroupGetter<IFactionGetter> Factions { get; }
        IFallout3GroupGetter<IHeadPartGetter> HeadParts { get; }
        IFallout3GroupGetter<IHairGetter> Hairs { get; }
        IFallout3GroupGetter<IEyesGetter> Eyes { get; }
        IFallout3GroupGetter<IRaceGetter> Races { get; }
        IFallout3GroupGetter<ISoundGetter> Sounds { get; }
        IFallout3GroupGetter<IAcousticSpaceGetter> AcousticSpaces { get; }
        IFallout3GroupGetter<IMagicEffectGetter> MagicEffects { get; }
        IFallout3GroupGetter<IScriptGetter> Scripts { get; }
        IFallout3GroupGetter<ILandscapeTextureGetter> LandscapeTextures { get; }
        IFallout3GroupGetter<IObjectEffectGetter> ObjectEffects { get; }

        #region Mutagen
        Fallout3Release Fallout3Release { get; }
        #endregion

    }

    #endregion

    #region Common MixIn
    public static partial class Fallout3ModMixIn
    {
        public static void Clear(this IFallout3Mod item)
        {
            ((Fallout3ModSetterCommon)((IFallout3ModGetter)item).CommonSetterInstance()!).Clear(item: item);
        }

        public static Fallout3Mod.Mask<bool> GetEqualsMask(
            this IFallout3ModGetter item,
            IFallout3ModGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            return ((Fallout3ModCommon)((IFallout3ModGetter)item).CommonInstance()!).GetEqualsMask(
                item: item,
                rhs: rhs,
                include: include);
        }

        public static string Print(
            this IFallout3ModGetter item,
            string? name = null,
            Fallout3Mod.Mask<bool>? printMask = null)
        {
            return ((Fallout3ModCommon)((IFallout3ModGetter)item).CommonInstance()!).Print(
                item: item,
                name: name,
                printMask: printMask);
        }

        public static void Print(
            this IFallout3ModGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            Fallout3Mod.Mask<bool>? printMask = null)
        {
            ((Fallout3ModCommon)((IFallout3ModGetter)item).CommonInstance()!).Print(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
        }

        public static bool Equals(
            this IFallout3ModGetter item,
            IFallout3ModGetter rhs,
            Fallout3Mod.TranslationMask? equalsMask = null)
        {
            return ((Fallout3ModCommon)((IFallout3ModGetter)item).CommonInstance()!).Equals(
                lhs: item,
                rhs: rhs,
                equalsMask: equalsMask?.GetCrystal());
        }

        public static void DeepCopyIn(
            this IFallout3Mod lhs,
            IFallout3ModGetter rhs)
        {
            ((Fallout3ModSetterTranslationCommon)((IFallout3ModGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: default,
                deepCopy: false);
        }

        public static void DeepCopyIn(
            this IFallout3Mod lhs,
            IFallout3ModGetter rhs,
            Fallout3Mod.TranslationMask? copyMask = null)
        {
            ((Fallout3ModSetterTranslationCommon)((IFallout3ModGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
        }

        public static void DeepCopyIn(
            this IFallout3Mod lhs,
            IFallout3ModGetter rhs,
            out Fallout3Mod.ErrorMask errorMask,
            Fallout3Mod.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            ((Fallout3ModSetterTranslationCommon)((IFallout3ModGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
            errorMask = Fallout3Mod.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void DeepCopyIn(
            this IFallout3Mod lhs,
            IFallout3ModGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            ((Fallout3ModSetterTranslationCommon)((IFallout3ModGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: false);
        }

        public static Fallout3Mod DeepCopy(
            this IFallout3ModGetter item,
            Fallout3Mod.TranslationMask? copyMask = null)
        {
            return ((Fallout3ModSetterTranslationCommon)((IFallout3ModGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask);
        }

        public static Fallout3Mod DeepCopy(
            this IFallout3ModGetter item,
            out Fallout3Mod.ErrorMask errorMask,
            Fallout3Mod.TranslationMask? copyMask = null)
        {
            return ((Fallout3ModSetterTranslationCommon)((IFallout3ModGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: out errorMask);
        }

        public static Fallout3Mod DeepCopy(
            this IFallout3ModGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            return ((Fallout3ModSetterTranslationCommon)((IFallout3ModGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: errorMask);
        }

        #region Mutagen
        public static IGroupGetter<T>? TryGetTopLevelGroup<T>(this IFallout3ModGetter obj)
            where T : IMajorRecordGetter
        {
            return (IGroupGetter<T>?)((Fallout3ModCommon)((IFallout3ModGetter)obj).CommonInstance()!).GetGroup(
                obj: obj,
                type: typeof(T));
        }

        public static IGroupGetter? TryGetTopLevelGroup(
            this IFallout3ModGetter obj,
            Type type)
        {
            return (IGroupGetter?)((Fallout3ModCommon)((IFallout3ModGetter)obj).CommonInstance()!).GetGroup(
                obj: obj,
                type: type);
        }

        public static IGroup<T>? TryGetTopLevelGroup<T>(this IFallout3Mod obj)
            where T : IMajorRecord
        {
            return (IGroup<T>?)((Fallout3ModCommon)((IFallout3ModGetter)obj).CommonInstance()!).GetGroup(
                obj: obj,
                type: typeof(T));
        }

        public static IGroup? TryGetTopLevelGroup(
            this IFallout3Mod obj,
            Type type)
        {
            return (IGroup?)((Fallout3ModCommon)((IFallout3ModGetter)obj).CommonInstance()!).GetGroup(
                obj: obj,
                type: type);
        }

        public static uint GetRecordCount(this IFallout3ModGetter item)
        {
            return ((Fallout3ModCommon)((IFallout3ModGetter)item).CommonInstance()!).GetRecordCount(item: item);
        }

        [DebuggerStepThrough]
        public static IEnumerable<IMajorRecordGetter> EnumerateMajorRecords(this IFallout3ModGetter obj)
        {
            return ((Fallout3ModCommon)((IFallout3ModGetter)obj).CommonInstance()!).EnumerateMajorRecords(obj: obj).Catch(e => RecordException.EnrichAndThrow(e, obj.ModKey));
        }

        [DebuggerStepThrough]
        public static IEnumerable<TMajor> EnumerateMajorRecords<TMajor>(
            this IFallout3ModGetter obj,
            bool throwIfUnknown = true)
            where TMajor : class, IMajorRecordQueryableGetter
        {
            return ((Fallout3ModCommon)((IFallout3ModGetter)obj).CommonInstance()!).EnumerateMajorRecords(
                obj: obj,
                type: typeof(TMajor),
                throwIfUnknown: throwIfUnknown)
                .Select(m => (TMajor)m)
                .Catch(e => RecordException.EnrichAndThrow(e, obj.ModKey));
        }

        [DebuggerStepThrough]
        public static IEnumerable<IMajorRecordGetter> EnumerateMajorRecords(
            this IFallout3ModGetter obj,
            Type type,
            bool throwIfUnknown = true)
        {
            return ((Fallout3ModCommon)((IFallout3ModGetter)obj).CommonInstance()!).EnumerateMajorRecords(
                obj: obj,
                type: type,
                throwIfUnknown: throwIfUnknown)
                .Select(m => (IMajorRecordGetter)m)
                .Catch(e => RecordException.EnrichAndThrow(e, obj.ModKey));
        }

        [DebuggerStepThrough]
        public static IEnumerable<IMajorRecord> EnumerateMajorRecords(this IFallout3Mod obj)
        {
            return ((Fallout3ModSetterCommon)((IFallout3ModGetter)obj).CommonSetterInstance()!).EnumerateMajorRecords(obj: obj).Catch(e => RecordException.EnrichAndThrow(e, obj.ModKey));
        }

        [DebuggerStepThrough]
        public static IEnumerable<TMajor> EnumerateMajorRecords<TMajor>(this IFallout3Mod obj)
            where TMajor : class, IMajorRecordQueryable
        {
            return ((Fallout3ModSetterCommon)((IFallout3ModGetter)obj).CommonSetterInstance()!).EnumerateMajorRecords(
                obj: obj,
                type: typeof(TMajor),
                throwIfUnknown: true)
                .Select(m => (TMajor)m)
                .Catch(e => RecordException.EnrichAndThrow(e, obj.ModKey));
        }

        [DebuggerStepThrough]
        public static IEnumerable<IMajorRecord> EnumerateMajorRecords(
            this IFallout3Mod obj,
            Type? type,
            bool throwIfUnknown = true)
        {
            return ((Fallout3ModSetterCommon)((IFallout3ModGetter)obj).CommonSetterInstance()!).EnumeratePotentiallyTypedMajorRecords(
                obj: obj,
                type: type,
                throwIfUnknown: throwIfUnknown)
                .Select(m => (IMajorRecord)m)
                .Catch(e => RecordException.EnrichAndThrow(e, obj.ModKey));
        }

        [DebuggerStepThrough]
        public static void Remove(
            this IFallout3Mod obj,
            FormKey key)
        {
            var keys = new HashSet<FormKey>();
            keys.Add(key);
            ((Fallout3ModSetterCommon)((IFallout3ModGetter)obj).CommonSetterInstance()!).Remove(
                obj: obj,
                keys: keys);
        }

        [DebuggerStepThrough]
        public static void Remove(
            this IFallout3Mod obj,
            IEnumerable<FormKey> keys)
        {
            ((Fallout3ModSetterCommon)((IFallout3ModGetter)obj).CommonSetterInstance()!).Remove(
                obj: obj,
                keys: keys.ToHashSet());
        }

        [DebuggerStepThrough]
        public static void Remove(
            this IFallout3Mod obj,
            IEnumerable<IFormLinkIdentifier> keys)
        {
            foreach (var g in keys.GroupBy(x => x.Type))
            {
                Remove(
                    obj: obj,
                    keys: g.Select(x => x.FormKey),
                    type: g.Key);
            }
        }

        [DebuggerStepThrough]
        public static void Remove(
            this IFallout3Mod obj,
            HashSet<FormKey> keys)
        {
            ((Fallout3ModSetterCommon)((IFallout3ModGetter)obj).CommonSetterInstance()!).Remove(
                obj: obj,
                keys: keys);
        }

        [DebuggerStepThrough]
        public static void Remove(
            this IFallout3Mod obj,
            FormKey key,
            Type type,
            bool throwIfUnknown = true)
        {
            var keys = new HashSet<FormKey>();
            keys.Add(key);
            ((Fallout3ModSetterCommon)((IFallout3ModGetter)obj).CommonSetterInstance()!).Remove(
                obj: obj,
                keys: keys,
                type: type,
                throwIfUnknown: throwIfUnknown);
        }

        [DebuggerStepThrough]
        public static void Remove(
            this IFallout3Mod obj,
            IEnumerable<FormKey> keys,
            Type type,
            bool throwIfUnknown = true)
        {
            ((Fallout3ModSetterCommon)((IFallout3ModGetter)obj).CommonSetterInstance()!).Remove(
                obj: obj,
                keys: keys.ToHashSet(),
                type: type,
                throwIfUnknown: throwIfUnknown);
        }

        [DebuggerStepThrough]
        public static void Remove(
            this IFallout3Mod obj,
            HashSet<FormKey> keys,
            Type type,
            bool throwIfUnknown = true)
        {
            ((Fallout3ModSetterCommon)((IFallout3ModGetter)obj).CommonSetterInstance()!).Remove(
                obj: obj,
                keys: keys,
                type: type,
                throwIfUnknown: throwIfUnknown);
        }

        [DebuggerStepThrough]
        public static void Remove<TMajor>(
            this IFallout3Mod obj,
            TMajor record,
            bool throwIfUnknown = true)
            where TMajor : IMajorRecordGetter
        {
            var keys = new HashSet<FormKey>();
            keys.Add(record.FormKey);
            ((Fallout3ModSetterCommon)((IFallout3ModGetter)obj).CommonSetterInstance()!).Remove(
                obj: obj,
                keys: keys,
                type: typeof(TMajor),
                throwIfUnknown: throwIfUnknown);
        }

        [DebuggerStepThrough]
        public static void Remove<TMajor>(
            this IFallout3Mod obj,
            IEnumerable<TMajor> records,
            bool throwIfUnknown = true)
            where TMajor : IMajorRecordGetter
        {
            ((Fallout3ModSetterCommon)((IFallout3ModGetter)obj).CommonSetterInstance()!).Remove(
                obj: obj,
                keys: records.Select(m => m.FormKey).ToHashSet(),
                type: typeof(TMajor),
                throwIfUnknown: throwIfUnknown);
        }

        [DebuggerStepThrough]
        public static void Remove<TMajor>(
            this IFallout3Mod obj,
            FormKey key,
            bool throwIfUnknown = true)
            where TMajor : IMajorRecordGetter
        {
            var keys = new HashSet<FormKey>();
            keys.Add(key);
            ((Fallout3ModSetterCommon)((IFallout3ModGetter)obj).CommonSetterInstance()!).Remove(
                obj: obj,
                keys: keys,
                type: typeof(TMajor),
                throwIfUnknown: throwIfUnknown);
        }

        [DebuggerStepThrough]
        public static void Remove<TMajor>(
            this IFallout3Mod obj,
            IEnumerable<FormKey> keys,
            bool throwIfUnknown = true)
            where TMajor : IMajorRecordGetter
        {
            ((Fallout3ModSetterCommon)((IFallout3ModGetter)obj).CommonSetterInstance()!).Remove(
                obj: obj,
                keys: keys.ToHashSet(),
                type: typeof(TMajor),
                throwIfUnknown: throwIfUnknown);
        }

        [DebuggerStepThrough]
        public static void Remove<TMajor>(
            this IFallout3Mod obj,
            HashSet<FormKey> keys,
            bool throwIfUnknown = true)
            where TMajor : IMajorRecordGetter
        {
            ((Fallout3ModSetterCommon)((IFallout3ModGetter)obj).CommonSetterInstance()!).Remove(
                obj: obj,
                keys: keys,
                type: typeof(TMajor),
                throwIfUnknown: throwIfUnknown);
        }

        [DebuggerStepThrough]
        public static IEnumerable<IModContext<IFallout3Mod, IFallout3ModGetter, TSetter, TGetter>> EnumerateMajorRecordContexts<TSetter, TGetter>(
            this IFallout3ModGetter obj,
            ILinkCache linkCache,
            bool throwIfUnknown = true)
            where TSetter : class, IMajorRecordQueryable, TGetter
            where TGetter : class, IMajorRecordQueryableGetter
        {
            return ((Fallout3ModCommon)((IFallout3ModGetter)obj).CommonInstance()!).EnumerateMajorRecordContexts(
                obj: obj,
                linkCache: linkCache,
                type: typeof(TGetter),
                throwIfUnknown: throwIfUnknown)
                .Select(m => m.AsType<IFallout3Mod, IFallout3ModGetter, IMajorRecordQueryable, IMajorRecordQueryableGetter, TSetter, TGetter>())
                .Catch(e => RecordException.EnrichAndThrow(e, obj.ModKey));
        }

        [DebuggerStepThrough]
        public static IEnumerable<IModContext<IMajorRecordGetter>> EnumerateMajorRecordContexts(this IFallout3ModGetter obj)
        {
            return ((Fallout3ModCommon)((IFallout3ModGetter)obj).CommonInstance()!).EnumerateMajorRecordContexts(
                obj: obj,
                linkCache: null!)
                .Catch(e => RecordException.EnrichAndThrow(e, obj.ModKey));
        }

        [DebuggerStepThrough]
        public static IEnumerable<IModContext<IFallout3Mod, IFallout3ModGetter, IMajorRecord, IMajorRecordGetter>> EnumerateMajorRecordContexts(
            this IFallout3ModGetter obj,
            ILinkCache linkCache,
            Type type,
            bool throwIfUnknown = true)
        {
            return ((Fallout3ModCommon)((IFallout3ModGetter)obj).CommonInstance()!).EnumerateMajorRecordContexts(
                obj: obj,
                linkCache: linkCache,
                type: type,
                throwIfUnknown: throwIfUnknown)
                .Catch(e => RecordException.EnrichAndThrow(e, obj.ModKey));
        }

        #endregion

        #region Binary Translation
        public static void CopyInFromBinary(
            this IFallout3Mod item,
            MutagenFrame frame,
            Fallout3Release release,
            GroupMask? importMask = null)
        {
            ((Fallout3ModSetterCommon)((IFallout3ModGetter)item).CommonSetterInstance()!).CopyInFromBinary(
                item: item,
                frame: frame,
                release: release,
                importMask: importMask);
        }

        public static void CopyInFromBinary(
            this IFallout3Mod item,
            ModPath path,
            Fallout3Release release,
            BinaryReadParameters? param = null,
            GroupMask? importMask = null)
        {
            try
            {
                var gameRelease = release.ToGameRelease();
                param ??= BinaryReadParameters.Default;
                var fileSystem = param.FileSystem.GetOrDefault();
                var meta = ParsingMeta.Factory(param, gameRelease, path);
                using (var reader = new MutagenBinaryReadStream(path, meta))
                {
                    var frame = new MutagenFrame(reader);
                    frame.MetaData.RecordInfoCache = new RecordTypeInfoCacheReader(() => new MutagenBinaryReadStream(path, meta), path.ModKey, meta.LinkCache);
                    CopyInFromBinary(
                        item: item,
                        release: release,
                        importMask: importMask,
                        frame: frame);
                }
            }
            catch (Exception ex)
            {
                RecordException.EnrichAndThrow(ex, path.ModKey);
                throw;
            }
        }

        public static void CopyInFromBinary(
            this IFallout3Mod item,
            Stream stream,
            ModKey modKey,
            Fallout3Release release,
            RecordTypeInfoCacheReader infoCache,
            BinaryReadParameters? param = null,
            GroupMask? importMask = null)
        {
            try
            {
                param ??= BinaryReadParameters.Default;
                var meta = ParsingMeta.Factory(param, GameRelease.Oblivion, modKey, stream);
                using (var reader = new MutagenBinaryReadStream(stream, meta))
                {
                    var frame = new MutagenFrame(reader);
                    frame.MetaData.RecordInfoCache = infoCache;
                    CopyInFromBinary(
                        item: item,
                        release: release,
                        importMask: importMask,
                        frame: frame);
                }
            }
            catch (Exception ex)
            {
                RecordException.EnrichAndThrow(ex, modKey);
                throw;
            }
        }

        #endregion

    }
    #endregion

}

namespace Mutagen.Bethesda.Fallout3
{
    #region Field Index
    internal enum Fallout3Mod_FieldIndex
    {
        ModHeader = 0,
        GameSettings = 1,
        TextureSets = 2,
        MenuIcons = 3,
        Globals = 4,
        Classes = 5,
        Factions = 6,
        HeadParts = 7,
        Hairs = 8,
        Eyes = 9,
        Races = 10,
        Sounds = 11,
        AcousticSpaces = 12,
        MagicEffects = 13,
        Scripts = 14,
        LandscapeTextures = 15,
        ObjectEffects = 16,
    }
    #endregion

    #region Registration
    internal partial class Fallout3Mod_Registration : ILoquiRegistration
    {
        public static readonly Fallout3Mod_Registration Instance = new Fallout3Mod_Registration();

        public static ProtocolKey ProtocolKey => ProtocolDefinition_Fallout3.ProtocolKey;

        public const ushort AdditionalFieldCount = 17;

        public const ushort FieldCount = 17;

        public static readonly Type MaskType = typeof(Fallout3Mod.Mask<>);

        public static readonly Type ErrorMaskType = typeof(Fallout3Mod.ErrorMask);

        public static readonly Type ClassType = typeof(Fallout3Mod);

        public static readonly Type GetterType = typeof(IFallout3ModGetter);

        public static readonly Type? InternalGetterType = null;

        public static readonly Type SetterType = typeof(IFallout3Mod);

        public static readonly Type? InternalSetterType = null;

        public const string FullName = "Mutagen.Bethesda.Fallout3.Fallout3Mod";

        public const string Name = "Fallout3Mod";

        public const string Namespace = "Mutagen.Bethesda.Fallout3";

        public const byte GenericCount = 0;

        public static readonly Type? GenericRegistrationType = null;

        public static readonly RecordType TriggeringRecordType = RecordTypes.TES4;
        public static readonly Type BinaryWriteTranslation = typeof(Fallout3ModBinaryWriteTranslation);
        #region Interface
        ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;
        ushort ILoquiRegistration.FieldCount => FieldCount;
        ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;
        Type ILoquiRegistration.MaskType => MaskType;
        Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;
        Type ILoquiRegistration.ClassType => ClassType;
        Type ILoquiRegistration.SetterType => SetterType;
        Type? ILoquiRegistration.InternalSetterType => InternalSetterType;
        Type ILoquiRegistration.GetterType => GetterType;
        Type? ILoquiRegistration.InternalGetterType => InternalGetterType;
        string ILoquiRegistration.FullName => FullName;
        string ILoquiRegistration.Name => Name;
        string ILoquiRegistration.Namespace => Namespace;
        byte ILoquiRegistration.GenericCount => GenericCount;
        Type? ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;
        ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsLoqui(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsSingleton(ushort index) => throw new NotImplementedException();
        string ILoquiRegistration.GetNthName(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsNthDerivative(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsProtected(ushort index) => throw new NotImplementedException();
        Type ILoquiRegistration.GetNthType(ushort index) => throw new NotImplementedException();
        #endregion

    }
    #endregion

    #region Common
    internal partial class Fallout3ModSetterCommon
    {
        public static readonly Fallout3ModSetterCommon Instance = new Fallout3ModSetterCommon();

        partial void ClearPartial();
        
        public void Clear(IFallout3Mod item)
        {
            ClearPartial();
            item.GameSettings.Clear();
            item.TextureSets.Clear();
            item.MenuIcons.Clear();
            item.Globals.Clear();
            item.Classes.Clear();
            item.Factions.Clear();
            item.HeadParts.Clear();
            item.Hairs.Clear();
            item.Eyes.Clear();
            item.Races.Clear();
            item.Sounds.Clear();
            item.AcousticSpaces.Clear();
            item.MagicEffects.Clear();
            item.Scripts.Clear();
            item.LandscapeTextures.Clear();
            item.ObjectEffects.Clear();
        }
        
        #region Mutagen
        public void RemapLinks(IFallout3Mod obj, IReadOnlyDictionary<FormKey, FormKey> mapping)
        {
            obj.ModHeader.RemapLinks(mapping);
            obj.Factions.RemapLinks(mapping);
            obj.HeadParts.RemapLinks(mapping);
            obj.Hairs.RemapLinks(mapping);
            obj.Races.RemapLinks(mapping);
            obj.AcousticSpaces.RemapLinks(mapping);
            obj.MagicEffects.RemapLinks(mapping);
            obj.Scripts.RemapLinks(mapping);
            obj.LandscapeTextures.RemapLinks(mapping);
            obj.ObjectEffects.RemapLinks(mapping);
        }
        
        public IEnumerable<IMajorRecord> EnumerateMajorRecords(IFallout3Mod obj)
        {
            var ret = EnumerateMajorRecordsLoopLogic(obj: obj);
            if (obj is IMod)
            {
                ret = ret.ToList();
            }
            return ret;
        }
        
        public IEnumerable<IMajorRecord> EnumerateMajorRecordsLoopLogic(IFallout3Mod obj)
        {
            foreach (var item in Fallout3ModCommon.Instance.EnumerateMajorRecords(obj))
            {
                yield return (item as IMajorRecord)!;
            }
        }
        
        public IEnumerable<IMajorRecordGetter> EnumeratePotentiallyTypedMajorRecords(
            IFallout3Mod obj,
            Type? type,
            bool throwIfUnknown)
        {
            if (type == null) return Fallout3ModCommon.Instance.EnumerateMajorRecords(obj);
            return Fallout3ModCommon.Instance.EnumerateMajorRecords(obj, type, throwIfUnknown);
        }
        
        public IEnumerable<IMajorRecordGetter> EnumerateMajorRecords(
            IFallout3Mod obj,
            Type type,
            bool throwIfUnknown)
        {
            var ret = EnumerateMajorRecordsLoopLogic(
                obj: obj,
                type: type,
                throwIfUnknown: throwIfUnknown);
            if (obj is IMod)
            {
                ret = ret.ToList();
            }
            return ret;
        }
        
        public IEnumerable<IMajorRecordGetter> EnumerateMajorRecordsLoopLogic(
            IFallout3Mod obj,
            Type type,
            bool throwIfUnknown)
        {
            foreach (var item in Fallout3ModCommon.Instance.EnumerateMajorRecordsLoopLogic(obj, type, throwIfUnknown))
            {
                yield return item;
            }
        }
        
        public void Remove(
            IFallout3Mod obj,
            HashSet<FormKey> keys)
        {
            obj.GameSettings.Remove(keys);
            obj.TextureSets.Remove(keys);
            obj.MenuIcons.Remove(keys);
            obj.Globals.Remove(keys);
            obj.Classes.Remove(keys);
            obj.Factions.Remove(keys);
            obj.HeadParts.Remove(keys);
            obj.Hairs.Remove(keys);
            obj.Eyes.Remove(keys);
            obj.Races.Remove(keys);
            obj.Sounds.Remove(keys);
            obj.AcousticSpaces.Remove(keys);
            obj.MagicEffects.Remove(keys);
            obj.Scripts.Remove(keys);
            obj.LandscapeTextures.Remove(keys);
            obj.ObjectEffects.Remove(keys);
        }
        
        public void Remove(
            IFallout3Mod obj,
            HashSet<FormKey> keys,
            Type type,
            bool throwIfUnknown)
        {
            switch (type.Name)
            {
                case "IMajorRecord":
                case "MajorRecord":
                case "IFallout3MajorRecord":
                case "Fallout3MajorRecord":
                case "IMajorRecordGetter":
                case "IFallout3MajorRecordGetter":
                    if (!Fallout3Mod_Registration.SetterType.IsAssignableFrom(obj.GetType())) return;
                    this.Remove(obj, keys);
                    break;
                case "GameSetting":
                case "IGameSettingGetter":
                case "IGameSetting":
                case "IGameSettingInternal":
                case "GameSettingInt":
                case "IGameSettingIntGetter":
                case "IGameSettingInt":
                case "IGameSettingIntInternal":
                case "GameSettingFloat":
                case "IGameSettingFloatGetter":
                case "IGameSettingFloat":
                case "IGameSettingFloatInternal":
                case "GameSettingString":
                case "IGameSettingStringGetter":
                case "IGameSettingString":
                case "IGameSettingStringInternal":
                    obj.GameSettings.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "TextureSet":
                case "ITextureSetGetter":
                case "ITextureSet":
                case "ITextureSetInternal":
                    obj.TextureSets.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "MenuIcon":
                case "IMenuIconGetter":
                case "IMenuIcon":
                case "IMenuIconInternal":
                    obj.MenuIcons.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "Global":
                case "IGlobalGetter":
                case "IGlobal":
                case "IGlobalInternal":
                case "GlobalInt":
                case "IGlobalIntGetter":
                case "IGlobalInt":
                case "IGlobalIntInternal":
                case "GlobalShort":
                case "IGlobalShortGetter":
                case "IGlobalShort":
                case "IGlobalShortInternal":
                case "GlobalFloat":
                case "IGlobalFloatGetter":
                case "IGlobalFloat":
                case "IGlobalFloatInternal":
                case "GlobalUnknown":
                case "IGlobalUnknownGetter":
                case "IGlobalUnknown":
                case "IGlobalUnknownInternal":
                    obj.Globals.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "Class":
                case "IClassGetter":
                case "IClass":
                case "IClassInternal":
                    obj.Classes.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "Faction":
                case "IFactionGetter":
                case "IFaction":
                case "IFactionInternal":
                    obj.Factions.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "HeadPart":
                case "IHeadPartGetter":
                case "IHeadPart":
                case "IHeadPartInternal":
                    obj.HeadParts.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "Hair":
                case "IHairGetter":
                case "IHair":
                case "IHairInternal":
                    obj.Hairs.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "Eyes":
                case "IEyesGetter":
                case "IEyes":
                case "IEyesInternal":
                    obj.Eyes.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "Race":
                case "IRaceGetter":
                case "IRace":
                case "IRaceInternal":
                    obj.Races.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "Sound":
                case "ISoundGetter":
                case "ISound":
                case "ISoundInternal":
                    obj.Sounds.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "AcousticSpace":
                case "IAcousticSpaceGetter":
                case "IAcousticSpace":
                case "IAcousticSpaceInternal":
                    obj.AcousticSpaces.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "MagicEffect":
                case "IMagicEffectGetter":
                case "IMagicEffect":
                case "IMagicEffectInternal":
                    obj.MagicEffects.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "Script":
                case "IScriptGetter":
                case "IScript":
                case "IScriptInternal":
                    obj.Scripts.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "LandscapeTexture":
                case "ILandscapeTextureGetter":
                case "ILandscapeTexture":
                case "ILandscapeTextureInternal":
                    obj.LandscapeTextures.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "ObjectEffect":
                case "IObjectEffectGetter":
                case "IObjectEffect":
                case "IObjectEffectInternal":
                    obj.ObjectEffects.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "IPlaceableObject":
                case "IPlaceableObjectGetter":
                    Remove(obj, keys, typeof(IAcousticSpaceGetter), throwIfUnknown: throwIfUnknown);
                    break;
                case "IReferenceableObject":
                case "IReferenceableObjectGetter":
                    Remove(obj, keys, typeof(IAcousticSpaceGetter), throwIfUnknown: throwIfUnknown);
                    break;
                case "IExplodeSpawn":
                case "IExplodeSpawnGetter":
                    Remove(obj, keys, typeof(IAcousticSpaceGetter), throwIfUnknown: throwIfUnknown);
                    break;
                case "IRelatable":
                case "IRelatableGetter":
                    Remove(obj, keys, typeof(IFactionGetter), throwIfUnknown: throwIfUnknown);
                    Remove(obj, keys, typeof(IRaceGetter), throwIfUnknown: throwIfUnknown);
                    break;
                default:
                    if (throwIfUnknown)
                    {
                        throw new ArgumentException($"Unknown major record type: {type}");
                    }
                    else
                    {
                        break;
                    }
            }
        }
        
        public IEnumerable<IAssetLink> EnumerateListedAssetLinks(IFallout3Mod obj)
        {
            {
                foreach (var item in obj.TextureSets.EnumerateListedAssetLinks())
                {
                    yield return item;
                }
            }
            {
                foreach (var item in obj.MenuIcons.EnumerateListedAssetLinks())
                {
                    yield return item;
                }
            }
            {
                foreach (var item in obj.Eyes.EnumerateListedAssetLinks())
                {
                    yield return item;
                }
            }
            {
                foreach (var item in obj.Races.EnumerateListedAssetLinks())
                {
                    yield return item;
                }
            }
            {
                foreach (var item in obj.LandscapeTextures.EnumerateListedAssetLinks())
                {
                    yield return item;
                }
            }
            yield break;
        }
        
        public void RemapAssetLinks(
            IFallout3Mod obj,
            IReadOnlyDictionary<IAssetLinkGetter, string> mapping,
            IAssetLinkCache? linkCache,
            AssetLinkQuery queryCategories)
        {
            obj.TextureSets.RemapAssetLinks(mapping, queryCategories, linkCache);
            obj.MenuIcons.RemapAssetLinks(mapping, queryCategories, linkCache);
            obj.Eyes.RemapAssetLinks(mapping, queryCategories, linkCache);
            obj.Races.RemapAssetLinks(mapping, queryCategories, linkCache);
            obj.LandscapeTextures.RemapAssetLinks(mapping, queryCategories, linkCache);
        }
        
        #endregion
        
        #region Binary Translation
        public virtual void CopyInFromBinary(
            IFallout3Mod item,
            MutagenFrame frame,
            Fallout3Release release,
            GroupMask? importMask = null)
        {
            PluginUtilityTranslation.ModParse(
                record: item,
                frame: frame,
                importMask: importMask,
                fillTyped: Fallout3ModBinaryCreateTranslation.FillBinaryRecordTypes);
        }
        
        #endregion
        
    }
    internal partial class Fallout3ModCommon
    {
        public static readonly Fallout3ModCommon Instance = new Fallout3ModCommon();

        public Fallout3Mod.Mask<bool> GetEqualsMask(
            IFallout3ModGetter item,
            IFallout3ModGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            var ret = new Fallout3Mod.Mask<bool>(false);
            ((Fallout3ModCommon)((IFallout3ModGetter)item).CommonInstance()!).FillEqualsMask(
                item: item,
                rhs: rhs,
                ret: ret,
                include: include);
            return ret;
        }
        
        public void FillEqualsMask(
            IFallout3ModGetter item,
            IFallout3ModGetter rhs,
            Fallout3Mod.Mask<bool> ret,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            ret.ModHeader = MaskItemExt.Factory(item.ModHeader.GetEqualsMask(rhs.ModHeader, include), include);
            ret.GameSettings = MaskItemExt.Factory(item.GameSettings.GetEqualsMask(rhs.GameSettings, include), include);
            ret.TextureSets = MaskItemExt.Factory(item.TextureSets.GetEqualsMask(rhs.TextureSets, include), include);
            ret.MenuIcons = MaskItemExt.Factory(item.MenuIcons.GetEqualsMask(rhs.MenuIcons, include), include);
            ret.Globals = MaskItemExt.Factory(item.Globals.GetEqualsMask(rhs.Globals, include), include);
            ret.Classes = MaskItemExt.Factory(item.Classes.GetEqualsMask(rhs.Classes, include), include);
            ret.Factions = MaskItemExt.Factory(item.Factions.GetEqualsMask(rhs.Factions, include), include);
            ret.HeadParts = MaskItemExt.Factory(item.HeadParts.GetEqualsMask(rhs.HeadParts, include), include);
            ret.Hairs = MaskItemExt.Factory(item.Hairs.GetEqualsMask(rhs.Hairs, include), include);
            ret.Eyes = MaskItemExt.Factory(item.Eyes.GetEqualsMask(rhs.Eyes, include), include);
            ret.Races = MaskItemExt.Factory(item.Races.GetEqualsMask(rhs.Races, include), include);
            ret.Sounds = MaskItemExt.Factory(item.Sounds.GetEqualsMask(rhs.Sounds, include), include);
            ret.AcousticSpaces = MaskItemExt.Factory(item.AcousticSpaces.GetEqualsMask(rhs.AcousticSpaces, include), include);
            ret.MagicEffects = MaskItemExt.Factory(item.MagicEffects.GetEqualsMask(rhs.MagicEffects, include), include);
            ret.Scripts = MaskItemExt.Factory(item.Scripts.GetEqualsMask(rhs.Scripts, include), include);
            ret.LandscapeTextures = MaskItemExt.Factory(item.LandscapeTextures.GetEqualsMask(rhs.LandscapeTextures, include), include);
            ret.ObjectEffects = MaskItemExt.Factory(item.ObjectEffects.GetEqualsMask(rhs.ObjectEffects, include), include);
        }
        
        public string Print(
            IFallout3ModGetter item,
            string? name = null,
            Fallout3Mod.Mask<bool>? printMask = null)
        {
            var sb = new StructuredStringBuilder();
            Print(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
            return sb.ToString();
        }
        
        public void Print(
            IFallout3ModGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            Fallout3Mod.Mask<bool>? printMask = null)
        {
            if (name == null)
            {
                sb.AppendLine($"Fallout3Mod =>");
            }
            else
            {
                sb.AppendLine($"{name} (Fallout3Mod) =>");
            }
            using (sb.Brace())
            {
                ToStringFields(
                    item: item,
                    sb: sb,
                    printMask: printMask);
            }
        }
        
        protected static void ToStringFields(
            IFallout3ModGetter item,
            StructuredStringBuilder sb,
            Fallout3Mod.Mask<bool>? printMask = null)
        {
            if (printMask?.ModHeader?.Overall ?? true)
            {
                item.ModHeader?.Print(sb, "ModHeader");
            }
            if (printMask?.GameSettings?.Overall ?? true)
            {
                item.GameSettings?.Print(sb, "GameSettings");
            }
            if (printMask?.TextureSets?.Overall ?? true)
            {
                item.TextureSets?.Print(sb, "TextureSets");
            }
            if (printMask?.MenuIcons?.Overall ?? true)
            {
                item.MenuIcons?.Print(sb, "MenuIcons");
            }
            if (printMask?.Globals?.Overall ?? true)
            {
                item.Globals?.Print(sb, "Globals");
            }
            if (printMask?.Classes?.Overall ?? true)
            {
                item.Classes?.Print(sb, "Classes");
            }
            if (printMask?.Factions?.Overall ?? true)
            {
                item.Factions?.Print(sb, "Factions");
            }
            if (printMask?.HeadParts?.Overall ?? true)
            {
                item.HeadParts?.Print(sb, "HeadParts");
            }
            if (printMask?.Hairs?.Overall ?? true)
            {
                item.Hairs?.Print(sb, "Hairs");
            }
            if (printMask?.Eyes?.Overall ?? true)
            {
                item.Eyes?.Print(sb, "Eyes");
            }
            if (printMask?.Races?.Overall ?? true)
            {
                item.Races?.Print(sb, "Races");
            }
            if (printMask?.Sounds?.Overall ?? true)
            {
                item.Sounds?.Print(sb, "Sounds");
            }
            if (printMask?.AcousticSpaces?.Overall ?? true)
            {
                item.AcousticSpaces?.Print(sb, "AcousticSpaces");
            }
            if (printMask?.MagicEffects?.Overall ?? true)
            {
                item.MagicEffects?.Print(sb, "MagicEffects");
            }
            if (printMask?.Scripts?.Overall ?? true)
            {
                item.Scripts?.Print(sb, "Scripts");
            }
            if (printMask?.LandscapeTextures?.Overall ?? true)
            {
                item.LandscapeTextures?.Print(sb, "LandscapeTextures");
            }
            if (printMask?.ObjectEffects?.Overall ?? true)
            {
                item.ObjectEffects?.Print(sb, "ObjectEffects");
            }
        }
        
        #region Equals and Hash
        public virtual bool Equals(
            IFallout3ModGetter? lhs,
            IFallout3ModGetter? rhs,
            TranslationCrystal? equalsMask)
        {
            if (!EqualsMaskHelper.RefEquality(lhs, rhs, out var isEqual)) return isEqual;
            if ((equalsMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.ModHeader) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.ModHeader, rhs.ModHeader, out var lhsModHeader, out var rhsModHeader, out var isModHeaderEqual))
                {
                    if (!((Fallout3ModHeaderCommon)((IFallout3ModHeaderGetter)lhsModHeader).CommonInstance()!).Equals(lhsModHeader, rhsModHeader, equalsMask?.GetSubCrystal((int)Fallout3Mod_FieldIndex.ModHeader))) return false;
                }
                else if (!isModHeaderEqual) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.GameSettings) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.GameSettings, rhs.GameSettings, out var lhsGameSettings, out var rhsGameSettings, out var isGameSettingsEqual))
                {
                    if (!object.Equals(lhsGameSettings, rhsGameSettings)) return false;
                }
                else if (!isGameSettingsEqual) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.TextureSets) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.TextureSets, rhs.TextureSets, out var lhsTextureSets, out var rhsTextureSets, out var isTextureSetsEqual))
                {
                    if (!object.Equals(lhsTextureSets, rhsTextureSets)) return false;
                }
                else if (!isTextureSetsEqual) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.MenuIcons) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.MenuIcons, rhs.MenuIcons, out var lhsMenuIcons, out var rhsMenuIcons, out var isMenuIconsEqual))
                {
                    if (!object.Equals(lhsMenuIcons, rhsMenuIcons)) return false;
                }
                else if (!isMenuIconsEqual) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.Globals) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Globals, rhs.Globals, out var lhsGlobals, out var rhsGlobals, out var isGlobalsEqual))
                {
                    if (!object.Equals(lhsGlobals, rhsGlobals)) return false;
                }
                else if (!isGlobalsEqual) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.Classes) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Classes, rhs.Classes, out var lhsClasses, out var rhsClasses, out var isClassesEqual))
                {
                    if (!object.Equals(lhsClasses, rhsClasses)) return false;
                }
                else if (!isClassesEqual) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.Factions) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Factions, rhs.Factions, out var lhsFactions, out var rhsFactions, out var isFactionsEqual))
                {
                    if (!object.Equals(lhsFactions, rhsFactions)) return false;
                }
                else if (!isFactionsEqual) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.HeadParts) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.HeadParts, rhs.HeadParts, out var lhsHeadParts, out var rhsHeadParts, out var isHeadPartsEqual))
                {
                    if (!object.Equals(lhsHeadParts, rhsHeadParts)) return false;
                }
                else if (!isHeadPartsEqual) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.Hairs) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Hairs, rhs.Hairs, out var lhsHairs, out var rhsHairs, out var isHairsEqual))
                {
                    if (!object.Equals(lhsHairs, rhsHairs)) return false;
                }
                else if (!isHairsEqual) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.Eyes) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Eyes, rhs.Eyes, out var lhsEyes, out var rhsEyes, out var isEyesEqual))
                {
                    if (!object.Equals(lhsEyes, rhsEyes)) return false;
                }
                else if (!isEyesEqual) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.Races) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Races, rhs.Races, out var lhsRaces, out var rhsRaces, out var isRacesEqual))
                {
                    if (!object.Equals(lhsRaces, rhsRaces)) return false;
                }
                else if (!isRacesEqual) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.Sounds) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Sounds, rhs.Sounds, out var lhsSounds, out var rhsSounds, out var isSoundsEqual))
                {
                    if (!object.Equals(lhsSounds, rhsSounds)) return false;
                }
                else if (!isSoundsEqual) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.AcousticSpaces) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.AcousticSpaces, rhs.AcousticSpaces, out var lhsAcousticSpaces, out var rhsAcousticSpaces, out var isAcousticSpacesEqual))
                {
                    if (!object.Equals(lhsAcousticSpaces, rhsAcousticSpaces)) return false;
                }
                else if (!isAcousticSpacesEqual) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.MagicEffects) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.MagicEffects, rhs.MagicEffects, out var lhsMagicEffects, out var rhsMagicEffects, out var isMagicEffectsEqual))
                {
                    if (!object.Equals(lhsMagicEffects, rhsMagicEffects)) return false;
                }
                else if (!isMagicEffectsEqual) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.Scripts) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Scripts, rhs.Scripts, out var lhsScripts, out var rhsScripts, out var isScriptsEqual))
                {
                    if (!object.Equals(lhsScripts, rhsScripts)) return false;
                }
                else if (!isScriptsEqual) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.LandscapeTextures) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.LandscapeTextures, rhs.LandscapeTextures, out var lhsLandscapeTextures, out var rhsLandscapeTextures, out var isLandscapeTexturesEqual))
                {
                    if (!object.Equals(lhsLandscapeTextures, rhsLandscapeTextures)) return false;
                }
                else if (!isLandscapeTexturesEqual) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.ObjectEffects) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.ObjectEffects, rhs.ObjectEffects, out var lhsObjectEffects, out var rhsObjectEffects, out var isObjectEffectsEqual))
                {
                    if (!object.Equals(lhsObjectEffects, rhsObjectEffects)) return false;
                }
                else if (!isObjectEffectsEqual) return false;
            }
            return true;
        }
        
        public virtual int GetHashCode(IFallout3ModGetter item)
        {
            var hash = new HashCode();
            hash.Add(item.ModHeader);
            hash.Add(item.GameSettings);
            hash.Add(item.TextureSets);
            hash.Add(item.MenuIcons);
            hash.Add(item.Globals);
            hash.Add(item.Classes);
            hash.Add(item.Factions);
            hash.Add(item.HeadParts);
            hash.Add(item.Hairs);
            hash.Add(item.Eyes);
            hash.Add(item.Races);
            hash.Add(item.Sounds);
            hash.Add(item.AcousticSpaces);
            hash.Add(item.MagicEffects);
            hash.Add(item.Scripts);
            hash.Add(item.LandscapeTextures);
            hash.Add(item.ObjectEffects);
            return hash.ToHashCode();
        }
        
        #endregion
        
        
        public object GetNew()
        {
            return Fallout3Mod.GetNew();
        }
        
        #region Mutagen
        public object? GetGroup(
            IFallout3ModGetter obj,
            Type type)
        {
            switch (type.Name)
            {
                case "GameSetting":
                case "IGameSettingGetter":
                case "IGameSetting":
                case "IGameSettingInternal":
                case "GameSettingInt":
                case "IGameSettingIntGetter":
                case "IGameSettingInt":
                case "IGameSettingIntInternal":
                case "GameSettingFloat":
                case "IGameSettingFloatGetter":
                case "IGameSettingFloat":
                case "IGameSettingFloatInternal":
                case "GameSettingString":
                case "IGameSettingStringGetter":
                case "IGameSettingString":
                case "IGameSettingStringInternal":
                    return obj.GameSettings;
                case "TextureSet":
                case "ITextureSetGetter":
                case "ITextureSet":
                case "ITextureSetInternal":
                    return obj.TextureSets;
                case "MenuIcon":
                case "IMenuIconGetter":
                case "IMenuIcon":
                case "IMenuIconInternal":
                    return obj.MenuIcons;
                case "Global":
                case "IGlobalGetter":
                case "IGlobal":
                case "IGlobalInternal":
                case "GlobalInt":
                case "IGlobalIntGetter":
                case "IGlobalInt":
                case "IGlobalIntInternal":
                case "GlobalShort":
                case "IGlobalShortGetter":
                case "IGlobalShort":
                case "IGlobalShortInternal":
                case "GlobalFloat":
                case "IGlobalFloatGetter":
                case "IGlobalFloat":
                case "IGlobalFloatInternal":
                case "GlobalUnknown":
                case "IGlobalUnknownGetter":
                case "IGlobalUnknown":
                case "IGlobalUnknownInternal":
                    return obj.Globals;
                case "Class":
                case "IClassGetter":
                case "IClass":
                case "IClassInternal":
                    return obj.Classes;
                case "Faction":
                case "IFactionGetter":
                case "IFaction":
                case "IFactionInternal":
                    return obj.Factions;
                case "HeadPart":
                case "IHeadPartGetter":
                case "IHeadPart":
                case "IHeadPartInternal":
                    return obj.HeadParts;
                case "Hair":
                case "IHairGetter":
                case "IHair":
                case "IHairInternal":
                    return obj.Hairs;
                case "Eyes":
                case "IEyesGetter":
                case "IEyes":
                case "IEyesInternal":
                    return obj.Eyes;
                case "Race":
                case "IRaceGetter":
                case "IRace":
                case "IRaceInternal":
                    return obj.Races;
                case "Sound":
                case "ISoundGetter":
                case "ISound":
                case "ISoundInternal":
                    return obj.Sounds;
                case "AcousticSpace":
                case "IAcousticSpaceGetter":
                case "IAcousticSpace":
                case "IAcousticSpaceInternal":
                    return obj.AcousticSpaces;
                case "MagicEffect":
                case "IMagicEffectGetter":
                case "IMagicEffect":
                case "IMagicEffectInternal":
                    return obj.MagicEffects;
                case "Script":
                case "IScriptGetter":
                case "IScript":
                case "IScriptInternal":
                    return obj.Scripts;
                case "LandscapeTexture":
                case "ILandscapeTextureGetter":
                case "ILandscapeTexture":
                case "ILandscapeTextureInternal":
                    return obj.LandscapeTextures;
                case "ObjectEffect":
                case "IObjectEffectGetter":
                case "IObjectEffect":
                case "IObjectEffectInternal":
                    return obj.ObjectEffects;
                default:
                    return null;
            }
        }
        
        public static void WriteParallel(
            IFallout3ModGetter item,
            MutagenWriter writer,
            BinaryWriteParameters param,
            ModKey modKey)
        {
            ModHeaderWriteLogic.WriteHeader(
                param: param,
                writer: writer,
                mod: item,
                modHeader: item.ModHeader.DeepCopy(),
                modKey: modKey);
            Stream[] outputStreams = new Stream[16];
            List<Action> toDo = new List<Action>();
            toDo.Add(() => WriteGroupParallel(item.GameSettings, 0, outputStreams, writer.MetaData, param.Parallel));
            toDo.Add(() => WriteGroupParallel(item.TextureSets, 1, outputStreams, writer.MetaData, param.Parallel));
            toDo.Add(() => WriteGroupParallel(item.MenuIcons, 2, outputStreams, writer.MetaData, param.Parallel));
            toDo.Add(() => WriteGroupParallel(item.Globals, 3, outputStreams, writer.MetaData, param.Parallel));
            toDo.Add(() => WriteGroupParallel(item.Classes, 4, outputStreams, writer.MetaData, param.Parallel));
            toDo.Add(() => WriteGroupParallel(item.Factions, 5, outputStreams, writer.MetaData, param.Parallel));
            toDo.Add(() => WriteGroupParallel(item.HeadParts, 6, outputStreams, writer.MetaData, param.Parallel));
            toDo.Add(() => WriteGroupParallel(item.Hairs, 7, outputStreams, writer.MetaData, param.Parallel));
            toDo.Add(() => WriteGroupParallel(item.Eyes, 8, outputStreams, writer.MetaData, param.Parallel));
            toDo.Add(() => WriteGroupParallel(item.Races, 9, outputStreams, writer.MetaData, param.Parallel));
            toDo.Add(() => WriteGroupParallel(item.Sounds, 10, outputStreams, writer.MetaData, param.Parallel));
            toDo.Add(() => WriteGroupParallel(item.AcousticSpaces, 11, outputStreams, writer.MetaData, param.Parallel));
            toDo.Add(() => WriteGroupParallel(item.MagicEffects, 12, outputStreams, writer.MetaData, param.Parallel));
            toDo.Add(() => WriteGroupParallel(item.Scripts, 13, outputStreams, writer.MetaData, param.Parallel));
            toDo.Add(() => WriteGroupParallel(item.LandscapeTextures, 14, outputStreams, writer.MetaData, param.Parallel));
            toDo.Add(() => WriteGroupParallel(item.ObjectEffects, 15, outputStreams, writer.MetaData, param.Parallel));
            Parallel.Invoke(param.Parallel.ParallelOptions, toDo.ToArray());
            PluginUtilityTranslation.CompileStreamsInto(
                outputStreams.WhereNotNull(),
                writer.BaseStream);
        }
        
        public static void WriteGroupParallel<T>(
            IFallout3GroupGetter<T> group,
            int targetIndex,
            Stream[] streamDepositArray,
            WritingBundle bundle,
            ParallelWriteParameters parallelParam)
            where T : class, IFallout3MajorRecordGetter, IBinaryItem
        {
            if (group.RecordCache.Count == 0) return;
            var cuts = group.Cut(parallelParam.CutCount).ToArray();
            Stream[] subStreams = new Stream[cuts.Length + 1];
            byte[] groupBytes = new byte[bundle.Constants.GroupConstants.HeaderLength];
            BinaryPrimitives.WriteInt32LittleEndian(groupBytes.AsSpan(), RecordTypes.GRUP.TypeInt);
            var groupByteStream = new MemoryStream(groupBytes);
            using (var stream = new MutagenWriter(groupByteStream, bundle.Constants, dispose: false))
            {
                stream.Position += 8;
                Fallout3GroupBinaryWriteTranslation.WriteEmbedded<T>(group, stream);
            }
            subStreams[0] = groupByteStream;
            Parallel.ForEach(cuts, parallelParam.ParallelOptions, (cutItems, state, counter) =>
            {
                MemoryTributary trib = new MemoryTributary();
                using (var stream = new MutagenWriter(trib, bundle with {}, dispose: false))
                {
                    foreach (var item in cutItems)
                    {
                        item.WriteToBinary(stream);
                    }
                }
                subStreams[(int)counter + 1] = trib;
            });
            PluginUtilityTranslation.CompileSetGroupLength(subStreams, groupBytes);
            streamDepositArray[targetIndex] = new CompositeReadStream(subStreams, resetPositions: true);
        }
        
        public uint GetRecordCount(IFallout3ModGetter item)
        {
            uint count = (uint)item.EnumerateMajorRecords().Count();
            count += item.GameSettings.RecordCache.Count > 0 ? 1 : default(uint);
            count += item.TextureSets.RecordCache.Count > 0 ? 1 : default(uint);
            count += item.MenuIcons.RecordCache.Count > 0 ? 1 : default(uint);
            count += item.Globals.RecordCache.Count > 0 ? 1 : default(uint);
            count += item.Classes.RecordCache.Count > 0 ? 1 : default(uint);
            count += item.Factions.RecordCache.Count > 0 ? 1 : default(uint);
            count += item.HeadParts.RecordCache.Count > 0 ? 1 : default(uint);
            count += item.Hairs.RecordCache.Count > 0 ? 1 : default(uint);
            count += item.Eyes.RecordCache.Count > 0 ? 1 : default(uint);
            count += item.Races.RecordCache.Count > 0 ? 1 : default(uint);
            count += item.Sounds.RecordCache.Count > 0 ? 1 : default(uint);
            count += item.AcousticSpaces.RecordCache.Count > 0 ? 1 : default(uint);
            count += item.MagicEffects.RecordCache.Count > 0 ? 1 : default(uint);
            count += item.Scripts.RecordCache.Count > 0 ? 1 : default(uint);
            count += item.LandscapeTextures.RecordCache.Count > 0 ? 1 : default(uint);
            count += item.ObjectEffects.RecordCache.Count > 0 ? 1 : default(uint);
            GetCustomRecordCount(item, (customCount) => count += customCount);
            return count;
        }
        
        partial void GetCustomRecordCount(IFallout3ModGetter item, Action<uint> setter);
        
        public IEnumerable<IFormLinkGetter> EnumerateFormLinks(IFallout3ModGetter obj)
        {
            foreach (var item in obj.ModHeader.EnumerateFormLinks())
            {
                yield return item;
            }
            foreach (var item in obj.Factions.EnumerateFormLinks())
            {
                yield return item;
            }
            foreach (var item in obj.HeadParts.EnumerateFormLinks())
            {
                yield return item;
            }
            foreach (var item in obj.Hairs.EnumerateFormLinks())
            {
                yield return item;
            }
            foreach (var item in obj.Races.EnumerateFormLinks())
            {
                yield return item;
            }
            foreach (var item in obj.AcousticSpaces.EnumerateFormLinks())
            {
                yield return item;
            }
            foreach (var item in obj.MagicEffects.EnumerateFormLinks())
            {
                yield return item;
            }
            if (obj.Scripts is IFormLinkContainerGetter ScriptslinkCont)
            {
                foreach (var item in ScriptslinkCont.EnumerateFormLinks())
                {
                    yield return item;
                }
            }
            foreach (var item in obj.LandscapeTextures.EnumerateFormLinks())
            {
                yield return item;
            }
            foreach (var item in obj.ObjectEffects.EnumerateFormLinks())
            {
                yield return item;
            }
            yield break;
        }
        
        public IEnumerable<IMajorRecordGetter> EnumerateMajorRecords(IFallout3ModGetter obj)
        {
            var ret = EnumerateMajorRecordsLoopLogic(obj: obj);
            if (obj is IMod)
            {
                ret = ret.ToList();
            }
            return ret;
        }
        
        public IEnumerable<IMajorRecordGetter> EnumerateMajorRecordsLoopLogic(IFallout3ModGetter obj)
        {
            foreach (var item in obj.GameSettings.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.TextureSets.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.MenuIcons.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.Globals.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.Classes.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.Factions.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.HeadParts.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.Hairs.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.Eyes.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.Races.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.Sounds.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.AcousticSpaces.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.MagicEffects.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.Scripts.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.LandscapeTextures.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.ObjectEffects.EnumerateMajorRecords())
            {
                yield return item;
            }
        }
        
        public IEnumerable<IMajorRecordGetter> EnumeratePotentiallyTypedMajorRecords(
            IFallout3ModGetter obj,
            Type? type,
            bool throwIfUnknown)
        {
            if (type == null) return Fallout3ModCommon.Instance.EnumerateMajorRecords(obj);
            return Fallout3ModCommon.Instance.EnumerateMajorRecords(obj, type, throwIfUnknown);
        }
        
        public IEnumerable<IMajorRecordGetter> EnumerateMajorRecords(
            IFallout3ModGetter obj,
            Type type,
            bool throwIfUnknown)
        {
            var ret = EnumerateMajorRecordsLoopLogic(
                obj: obj,
                type: type,
                throwIfUnknown: throwIfUnknown);
            if (obj is IMod)
            {
                ret = ret.ToList();
            }
            return ret;
        }
        
        public IEnumerable<IMajorRecordGetter> EnumerateMajorRecordsLoopLogic(
            IFallout3ModGetter obj,
            Type type,
            bool throwIfUnknown)
        {
            switch (type.Name)
            {
                case "IMajorRecord":
                case "MajorRecord":
                case "IFallout3MajorRecord":
                case "Fallout3MajorRecord":
                    if (!Fallout3Mod_Registration.SetterType.IsAssignableFrom(obj.GetType())) yield break;
                    foreach (var item in this.EnumerateMajorRecordsLoopLogic(obj))
                    {
                        yield return item;
                    }
                    yield break;
                case "IMajorRecordGetter":
                case "IFallout3MajorRecordGetter":
                    foreach (var item in this.EnumerateMajorRecordsLoopLogic(obj))
                    {
                        yield return item;
                    }
                    yield break;
                case "GameSetting":
                case "IGameSettingGetter":
                case "IGameSetting":
                case "IGameSettingInternal":
                    foreach (var item in obj.GameSettings.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "TextureSet":
                case "ITextureSetGetter":
                case "ITextureSet":
                case "ITextureSetInternal":
                    foreach (var item in obj.TextureSets.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "MenuIcon":
                case "IMenuIconGetter":
                case "IMenuIcon":
                case "IMenuIconInternal":
                    foreach (var item in obj.MenuIcons.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "Global":
                case "IGlobalGetter":
                case "IGlobal":
                case "IGlobalInternal":
                    foreach (var item in obj.Globals.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "Class":
                case "IClassGetter":
                case "IClass":
                case "IClassInternal":
                    foreach (var item in obj.Classes.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "Faction":
                case "IFactionGetter":
                case "IFaction":
                case "IFactionInternal":
                    foreach (var item in obj.Factions.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "HeadPart":
                case "IHeadPartGetter":
                case "IHeadPart":
                case "IHeadPartInternal":
                    foreach (var item in obj.HeadParts.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "Hair":
                case "IHairGetter":
                case "IHair":
                case "IHairInternal":
                    foreach (var item in obj.Hairs.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "Eyes":
                case "IEyesGetter":
                case "IEyes":
                case "IEyesInternal":
                    foreach (var item in obj.Eyes.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "Race":
                case "IRaceGetter":
                case "IRace":
                case "IRaceInternal":
                    foreach (var item in obj.Races.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "Sound":
                case "ISoundGetter":
                case "ISound":
                case "ISoundInternal":
                    foreach (var item in obj.Sounds.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "AcousticSpace":
                case "IAcousticSpaceGetter":
                case "IAcousticSpace":
                case "IAcousticSpaceInternal":
                    foreach (var item in obj.AcousticSpaces.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "MagicEffect":
                case "IMagicEffectGetter":
                case "IMagicEffect":
                case "IMagicEffectInternal":
                    foreach (var item in obj.MagicEffects.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "Script":
                case "IScriptGetter":
                case "IScript":
                case "IScriptInternal":
                    foreach (var item in obj.Scripts.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "LandscapeTexture":
                case "ILandscapeTextureGetter":
                case "ILandscapeTexture":
                case "ILandscapeTextureInternal":
                    foreach (var item in obj.LandscapeTextures.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "ObjectEffect":
                case "IObjectEffectGetter":
                case "IObjectEffect":
                case "IObjectEffectInternal":
                    foreach (var item in obj.ObjectEffects.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                default:
                    if (InterfaceEnumerationHelper.TryEnumerateInterfaceRecordsFor(GameCategory.Fallout3, obj, type, out var linkInterfaces))
                    {
                        foreach (var item in linkInterfaces)
                        {
                            yield return item;
                        }
                        yield break;
                    }
                    if (throwIfUnknown)
                    {
                        throw new ArgumentException($"Unknown major record type: {type}");
                    }
                    else
                    {
                        yield break;
                    }
            }
        }
        
        public IEnumerable<IModContext<IFallout3Mod, IFallout3ModGetter, IMajorRecord, IMajorRecordGetter>> EnumerateMajorRecordContexts(
            IFallout3ModGetter obj,
            ILinkCache linkCache)
        {
            foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, GameSetting, IGameSettingGetter>(
                srcGroup: obj.GameSettings,
                type: typeof(IGameSettingGetter),
                modKey: obj.ModKey,
                group: (m) => m.GameSettings,
                groupGetter: (m) => m.GameSettings))
            {
                yield return item;
            }
            foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, TextureSet, ITextureSetGetter>(
                srcGroup: obj.TextureSets,
                type: typeof(ITextureSetGetter),
                modKey: obj.ModKey,
                group: (m) => m.TextureSets,
                groupGetter: (m) => m.TextureSets))
            {
                yield return item;
            }
            foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, MenuIcon, IMenuIconGetter>(
                srcGroup: obj.MenuIcons,
                type: typeof(IMenuIconGetter),
                modKey: obj.ModKey,
                group: (m) => m.MenuIcons,
                groupGetter: (m) => m.MenuIcons))
            {
                yield return item;
            }
            foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, Global, IGlobalGetter>(
                srcGroup: obj.Globals,
                type: typeof(IGlobalGetter),
                modKey: obj.ModKey,
                group: (m) => m.Globals,
                groupGetter: (m) => m.Globals))
            {
                yield return item;
            }
            foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, Class, IClassGetter>(
                srcGroup: obj.Classes,
                type: typeof(IClassGetter),
                modKey: obj.ModKey,
                group: (m) => m.Classes,
                groupGetter: (m) => m.Classes))
            {
                yield return item;
            }
            foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, Faction, IFactionGetter>(
                srcGroup: obj.Factions,
                type: typeof(IFactionGetter),
                modKey: obj.ModKey,
                group: (m) => m.Factions,
                groupGetter: (m) => m.Factions))
            {
                yield return item;
            }
            foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, HeadPart, IHeadPartGetter>(
                srcGroup: obj.HeadParts,
                type: typeof(IHeadPartGetter),
                modKey: obj.ModKey,
                group: (m) => m.HeadParts,
                groupGetter: (m) => m.HeadParts))
            {
                yield return item;
            }
            foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, Hair, IHairGetter>(
                srcGroup: obj.Hairs,
                type: typeof(IHairGetter),
                modKey: obj.ModKey,
                group: (m) => m.Hairs,
                groupGetter: (m) => m.Hairs))
            {
                yield return item;
            }
            foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, Eyes, IEyesGetter>(
                srcGroup: obj.Eyes,
                type: typeof(IEyesGetter),
                modKey: obj.ModKey,
                group: (m) => m.Eyes,
                groupGetter: (m) => m.Eyes))
            {
                yield return item;
            }
            foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, Race, IRaceGetter>(
                srcGroup: obj.Races,
                type: typeof(IRaceGetter),
                modKey: obj.ModKey,
                group: (m) => m.Races,
                groupGetter: (m) => m.Races))
            {
                yield return item;
            }
            foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, Sound, ISoundGetter>(
                srcGroup: obj.Sounds,
                type: typeof(ISoundGetter),
                modKey: obj.ModKey,
                group: (m) => m.Sounds,
                groupGetter: (m) => m.Sounds))
            {
                yield return item;
            }
            foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, AcousticSpace, IAcousticSpaceGetter>(
                srcGroup: obj.AcousticSpaces,
                type: typeof(IAcousticSpaceGetter),
                modKey: obj.ModKey,
                group: (m) => m.AcousticSpaces,
                groupGetter: (m) => m.AcousticSpaces))
            {
                yield return item;
            }
            foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, MagicEffect, IMagicEffectGetter>(
                srcGroup: obj.MagicEffects,
                type: typeof(IMagicEffectGetter),
                modKey: obj.ModKey,
                group: (m) => m.MagicEffects,
                groupGetter: (m) => m.MagicEffects))
            {
                yield return item;
            }
            foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, Script, IScriptGetter>(
                srcGroup: obj.Scripts,
                type: typeof(IScriptGetter),
                modKey: obj.ModKey,
                group: (m) => m.Scripts,
                groupGetter: (m) => m.Scripts))
            {
                yield return item;
            }
            foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, LandscapeTexture, ILandscapeTextureGetter>(
                srcGroup: obj.LandscapeTextures,
                type: typeof(ILandscapeTextureGetter),
                modKey: obj.ModKey,
                group: (m) => m.LandscapeTextures,
                groupGetter: (m) => m.LandscapeTextures))
            {
                yield return item;
            }
            foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, ObjectEffect, IObjectEffectGetter>(
                srcGroup: obj.ObjectEffects,
                type: typeof(IObjectEffectGetter),
                modKey: obj.ModKey,
                group: (m) => m.ObjectEffects,
                groupGetter: (m) => m.ObjectEffects))
            {
                yield return item;
            }
        }
        
        public IEnumerable<IModContext<IFallout3Mod, IFallout3ModGetter, IMajorRecord, IMajorRecordGetter>> EnumerateMajorRecordContexts(
            IFallout3ModGetter obj,
            ILinkCache linkCache,
            Type type,
            bool throwIfUnknown)
        {
            switch (type.Name)
            {
                case "IMajorRecord":
                case "MajorRecord":
                case "IFallout3MajorRecord":
                case "Fallout3MajorRecord":
                    if (!Fallout3Mod_Registration.SetterType.IsAssignableFrom(obj.GetType())) yield break;
                    foreach (var item in this.EnumerateMajorRecordContexts(
                        obj,
                        linkCache: linkCache))
                    {
                        yield return item;
                    }
                    yield break;
                case "IMajorRecordGetter":
                case "IFallout3MajorRecordGetter":
                    foreach (var item in this.EnumerateMajorRecordContexts(
                        obj,
                        linkCache: linkCache))
                    {
                        yield return item;
                    }
                    yield break;
                case "GameSetting":
                case "IGameSettingGetter":
                case "IGameSetting":
                case "IGameSettingInternal":
                    foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, GameSetting, IGameSettingGetter>(
                        srcGroup: obj.GameSettings,
                        type: type,
                        modKey: obj.ModKey,
                        group: (m) => m.GameSettings,
                        groupGetter: (m) => m.GameSettings))
                    {
                        yield return item;
                    }
                    yield break;
                case "TextureSet":
                case "ITextureSetGetter":
                case "ITextureSet":
                case "ITextureSetInternal":
                    foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, TextureSet, ITextureSetGetter>(
                        srcGroup: obj.TextureSets,
                        type: type,
                        modKey: obj.ModKey,
                        group: (m) => m.TextureSets,
                        groupGetter: (m) => m.TextureSets))
                    {
                        yield return item;
                    }
                    yield break;
                case "MenuIcon":
                case "IMenuIconGetter":
                case "IMenuIcon":
                case "IMenuIconInternal":
                    foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, MenuIcon, IMenuIconGetter>(
                        srcGroup: obj.MenuIcons,
                        type: type,
                        modKey: obj.ModKey,
                        group: (m) => m.MenuIcons,
                        groupGetter: (m) => m.MenuIcons))
                    {
                        yield return item;
                    }
                    yield break;
                case "Global":
                case "IGlobalGetter":
                case "IGlobal":
                case "IGlobalInternal":
                    foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, Global, IGlobalGetter>(
                        srcGroup: obj.Globals,
                        type: type,
                        modKey: obj.ModKey,
                        group: (m) => m.Globals,
                        groupGetter: (m) => m.Globals))
                    {
                        yield return item;
                    }
                    yield break;
                case "Class":
                case "IClassGetter":
                case "IClass":
                case "IClassInternal":
                    foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, Class, IClassGetter>(
                        srcGroup: obj.Classes,
                        type: type,
                        modKey: obj.ModKey,
                        group: (m) => m.Classes,
                        groupGetter: (m) => m.Classes))
                    {
                        yield return item;
                    }
                    yield break;
                case "Faction":
                case "IFactionGetter":
                case "IFaction":
                case "IFactionInternal":
                    foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, Faction, IFactionGetter>(
                        srcGroup: obj.Factions,
                        type: type,
                        modKey: obj.ModKey,
                        group: (m) => m.Factions,
                        groupGetter: (m) => m.Factions))
                    {
                        yield return item;
                    }
                    yield break;
                case "HeadPart":
                case "IHeadPartGetter":
                case "IHeadPart":
                case "IHeadPartInternal":
                    foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, HeadPart, IHeadPartGetter>(
                        srcGroup: obj.HeadParts,
                        type: type,
                        modKey: obj.ModKey,
                        group: (m) => m.HeadParts,
                        groupGetter: (m) => m.HeadParts))
                    {
                        yield return item;
                    }
                    yield break;
                case "Hair":
                case "IHairGetter":
                case "IHair":
                case "IHairInternal":
                    foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, Hair, IHairGetter>(
                        srcGroup: obj.Hairs,
                        type: type,
                        modKey: obj.ModKey,
                        group: (m) => m.Hairs,
                        groupGetter: (m) => m.Hairs))
                    {
                        yield return item;
                    }
                    yield break;
                case "Eyes":
                case "IEyesGetter":
                case "IEyes":
                case "IEyesInternal":
                    foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, Eyes, IEyesGetter>(
                        srcGroup: obj.Eyes,
                        type: type,
                        modKey: obj.ModKey,
                        group: (m) => m.Eyes,
                        groupGetter: (m) => m.Eyes))
                    {
                        yield return item;
                    }
                    yield break;
                case "Race":
                case "IRaceGetter":
                case "IRace":
                case "IRaceInternal":
                    foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, Race, IRaceGetter>(
                        srcGroup: obj.Races,
                        type: type,
                        modKey: obj.ModKey,
                        group: (m) => m.Races,
                        groupGetter: (m) => m.Races))
                    {
                        yield return item;
                    }
                    yield break;
                case "Sound":
                case "ISoundGetter":
                case "ISound":
                case "ISoundInternal":
                    foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, Sound, ISoundGetter>(
                        srcGroup: obj.Sounds,
                        type: type,
                        modKey: obj.ModKey,
                        group: (m) => m.Sounds,
                        groupGetter: (m) => m.Sounds))
                    {
                        yield return item;
                    }
                    yield break;
                case "AcousticSpace":
                case "IAcousticSpaceGetter":
                case "IAcousticSpace":
                case "IAcousticSpaceInternal":
                    foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, AcousticSpace, IAcousticSpaceGetter>(
                        srcGroup: obj.AcousticSpaces,
                        type: type,
                        modKey: obj.ModKey,
                        group: (m) => m.AcousticSpaces,
                        groupGetter: (m) => m.AcousticSpaces))
                    {
                        yield return item;
                    }
                    yield break;
                case "MagicEffect":
                case "IMagicEffectGetter":
                case "IMagicEffect":
                case "IMagicEffectInternal":
                    foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, MagicEffect, IMagicEffectGetter>(
                        srcGroup: obj.MagicEffects,
                        type: type,
                        modKey: obj.ModKey,
                        group: (m) => m.MagicEffects,
                        groupGetter: (m) => m.MagicEffects))
                    {
                        yield return item;
                    }
                    yield break;
                case "Script":
                case "IScriptGetter":
                case "IScript":
                case "IScriptInternal":
                    foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, Script, IScriptGetter>(
                        srcGroup: obj.Scripts,
                        type: type,
                        modKey: obj.ModKey,
                        group: (m) => m.Scripts,
                        groupGetter: (m) => m.Scripts))
                    {
                        yield return item;
                    }
                    yield break;
                case "LandscapeTexture":
                case "ILandscapeTextureGetter":
                case "ILandscapeTexture":
                case "ILandscapeTextureInternal":
                    foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, LandscapeTexture, ILandscapeTextureGetter>(
                        srcGroup: obj.LandscapeTextures,
                        type: type,
                        modKey: obj.ModKey,
                        group: (m) => m.LandscapeTextures,
                        groupGetter: (m) => m.LandscapeTextures))
                    {
                        yield return item;
                    }
                    yield break;
                case "ObjectEffect":
                case "IObjectEffectGetter":
                case "IObjectEffect":
                case "IObjectEffectInternal":
                    foreach (var item in InterfaceEnumerationHelper.EnumerateGroupContexts<IFallout3Mod, IFallout3ModGetter, ObjectEffect, IObjectEffectGetter>(
                        srcGroup: obj.ObjectEffects,
                        type: type,
                        modKey: obj.ModKey,
                        group: (m) => m.ObjectEffects,
                        groupGetter: (m) => m.ObjectEffects))
                    {
                        yield return item;
                    }
                    yield break;
                default:
                    if (InterfaceEnumerationHelper.TryEnumerateInterfaceContextsFor<IFallout3ModGetter, IFallout3Mod, IFallout3ModGetter>(
                        GameCategory.Fallout3,
                        obj,
                        type,
                        linkCache,
                        out var linkInterfaces))
                    {
                        foreach (var item in linkInterfaces)
                        {
                            yield return item;
                        }
                        yield break;
                    }
                    if (throwIfUnknown)
                    {
                        throw new ArgumentException($"Unknown major record type: {type}");
                    }
                    else
                    {
                        yield break;
                    }
            }
        }
        
        public IEnumerable<IAssetLinkGetter> EnumerateAssetLinks(IFallout3ModGetter obj, AssetLinkQuery queryCategories, IAssetLinkCache? linkCache, Type? assetType)
        {
            foreach (var item in obj.TextureSets.EnumerateAssetLinks(queryCategories: queryCategories, linkCache: linkCache, assetType: assetType))
            {
                yield return item;
            }
            foreach (var item in obj.MenuIcons.EnumerateAssetLinks(queryCategories: queryCategories, linkCache: linkCache, assetType: assetType))
            {
                yield return item;
            }
            foreach (var item in obj.Eyes.EnumerateAssetLinks(queryCategories: queryCategories, linkCache: linkCache, assetType: assetType))
            {
                yield return item;
            }
            foreach (var item in obj.Races.EnumerateAssetLinks(queryCategories: queryCategories, linkCache: linkCache, assetType: assetType))
            {
                yield return item;
            }
            foreach (var item in obj.LandscapeTextures.EnumerateAssetLinks(queryCategories: queryCategories, linkCache: linkCache, assetType: assetType))
            {
                yield return item;
            }
            yield break;
        }
        
        #endregion
        
    }
    internal partial class Fallout3ModSetterTranslationCommon
    {
        public static readonly Fallout3ModSetterTranslationCommon Instance = new Fallout3ModSetterTranslationCommon();

        #region DeepCopyIn
        public void DeepCopyIn(
            IFallout3Mod item,
            IFallout3ModGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            if ((copyMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.ModHeader) ?? true))
            {
                errorMask?.PushIndex((int)Fallout3Mod_FieldIndex.ModHeader);
                try
                {
                    item.ModHeader.DeepCopyIn(
                        rhs: rhs.ModHeader,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout3Mod_FieldIndex.ModHeader));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.GameSettings) ?? true))
            {
                errorMask?.PushIndex((int)Fallout3Mod_FieldIndex.GameSettings);
                try
                {
                    item.GameSettings.DeepCopyIn(
                        rhs: rhs.GameSettings,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout3Mod_FieldIndex.GameSettings));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.TextureSets) ?? true))
            {
                errorMask?.PushIndex((int)Fallout3Mod_FieldIndex.TextureSets);
                try
                {
                    item.TextureSets.DeepCopyIn(
                        rhs: rhs.TextureSets,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout3Mod_FieldIndex.TextureSets));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.MenuIcons) ?? true))
            {
                errorMask?.PushIndex((int)Fallout3Mod_FieldIndex.MenuIcons);
                try
                {
                    item.MenuIcons.DeepCopyIn(
                        rhs: rhs.MenuIcons,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout3Mod_FieldIndex.MenuIcons));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.Globals) ?? true))
            {
                errorMask?.PushIndex((int)Fallout3Mod_FieldIndex.Globals);
                try
                {
                    item.Globals.DeepCopyIn(
                        rhs: rhs.Globals,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout3Mod_FieldIndex.Globals));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.Classes) ?? true))
            {
                errorMask?.PushIndex((int)Fallout3Mod_FieldIndex.Classes);
                try
                {
                    item.Classes.DeepCopyIn(
                        rhs: rhs.Classes,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout3Mod_FieldIndex.Classes));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.Factions) ?? true))
            {
                errorMask?.PushIndex((int)Fallout3Mod_FieldIndex.Factions);
                try
                {
                    item.Factions.DeepCopyIn(
                        rhs: rhs.Factions,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout3Mod_FieldIndex.Factions));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.HeadParts) ?? true))
            {
                errorMask?.PushIndex((int)Fallout3Mod_FieldIndex.HeadParts);
                try
                {
                    item.HeadParts.DeepCopyIn(
                        rhs: rhs.HeadParts,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout3Mod_FieldIndex.HeadParts));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.Hairs) ?? true))
            {
                errorMask?.PushIndex((int)Fallout3Mod_FieldIndex.Hairs);
                try
                {
                    item.Hairs.DeepCopyIn(
                        rhs: rhs.Hairs,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout3Mod_FieldIndex.Hairs));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.Eyes) ?? true))
            {
                errorMask?.PushIndex((int)Fallout3Mod_FieldIndex.Eyes);
                try
                {
                    item.Eyes.DeepCopyIn(
                        rhs: rhs.Eyes,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout3Mod_FieldIndex.Eyes));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.Races) ?? true))
            {
                errorMask?.PushIndex((int)Fallout3Mod_FieldIndex.Races);
                try
                {
                    item.Races.DeepCopyIn(
                        rhs: rhs.Races,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout3Mod_FieldIndex.Races));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.Sounds) ?? true))
            {
                errorMask?.PushIndex((int)Fallout3Mod_FieldIndex.Sounds);
                try
                {
                    item.Sounds.DeepCopyIn(
                        rhs: rhs.Sounds,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout3Mod_FieldIndex.Sounds));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.AcousticSpaces) ?? true))
            {
                errorMask?.PushIndex((int)Fallout3Mod_FieldIndex.AcousticSpaces);
                try
                {
                    item.AcousticSpaces.DeepCopyIn(
                        rhs: rhs.AcousticSpaces,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout3Mod_FieldIndex.AcousticSpaces));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.MagicEffects) ?? true))
            {
                errorMask?.PushIndex((int)Fallout3Mod_FieldIndex.MagicEffects);
                try
                {
                    item.MagicEffects.DeepCopyIn(
                        rhs: rhs.MagicEffects,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout3Mod_FieldIndex.MagicEffects));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.Scripts) ?? true))
            {
                errorMask?.PushIndex((int)Fallout3Mod_FieldIndex.Scripts);
                try
                {
                    item.Scripts.DeepCopyIn(
                        rhs: rhs.Scripts,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout3Mod_FieldIndex.Scripts));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.LandscapeTextures) ?? true))
            {
                errorMask?.PushIndex((int)Fallout3Mod_FieldIndex.LandscapeTextures);
                try
                {
                    item.LandscapeTextures.DeepCopyIn(
                        rhs: rhs.LandscapeTextures,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout3Mod_FieldIndex.LandscapeTextures));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout3Mod_FieldIndex.ObjectEffects) ?? true))
            {
                errorMask?.PushIndex((int)Fallout3Mod_FieldIndex.ObjectEffects);
                try
                {
                    item.ObjectEffects.DeepCopyIn(
                        rhs: rhs.ObjectEffects,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout3Mod_FieldIndex.ObjectEffects));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            DeepCopyInCustom(
                item: item,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        partial void DeepCopyInCustom(
            IFallout3Mod item,
            IFallout3ModGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy);
        #endregion
        
        public partial Fallout3Mod DeepCopyGetNew(IFallout3ModGetter item);
        public Fallout3Mod DeepCopy(
            IFallout3ModGetter item,
            Fallout3Mod.TranslationMask? copyMask = null)
        {
            var ret = DeepCopyGetNew(item);
            ((Fallout3ModSetterTranslationCommon)((IFallout3ModGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: null,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            return ret;
        }
        
        public Fallout3Mod DeepCopy(
            IFallout3ModGetter item,
            out Fallout3Mod.ErrorMask errorMask,
            Fallout3Mod.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            var ret = DeepCopyGetNew(item);
            ((Fallout3ModSetterTranslationCommon)((IFallout3ModGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                ret,
                item,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            errorMask = Fallout3Mod.ErrorMask.Factory(errorMaskBuilder);
            return ret;
        }
        
        public Fallout3Mod DeepCopy(
            IFallout3ModGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            var ret = DeepCopyGetNew(item);
            ((Fallout3ModSetterTranslationCommon)((IFallout3ModGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: true);
            return ret;
        }
        
    }
    #endregion

}

namespace Mutagen.Bethesda.Fallout3
{
    public partial class Fallout3Mod
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => Fallout3Mod_Registration.Instance;
        public static ILoquiRegistration StaticRegistration => Fallout3Mod_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => Fallout3ModCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterInstance()
        {
            return Fallout3ModSetterCommon.Instance;
        }
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => Fallout3ModSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IFallout3ModGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object IFallout3ModGetter.CommonSetterInstance() => this.CommonSetterInstance();
        [DebuggerStepThrough]
        object IFallout3ModGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

    }
}

#region Modules
#region Mutagen
namespace Mutagen.Bethesda.Fallout3
{
    public class GroupMask
    {
        public bool GameSettings;
        public bool TextureSets;
        public bool MenuIcons;
        public bool Globals;
        public bool Classes;
        public bool Factions;
        public bool HeadParts;
        public bool Hairs;
        public bool Eyes;
        public bool Races;
        public bool Sounds;
        public bool AcousticSpaces;
        public bool MagicEffects;
        public bool Scripts;
        public bool LandscapeTextures;
        public bool ObjectEffects;
        public GroupMask()
        {
        }
        public GroupMask(bool defaultValue)
        {
            GameSettings = defaultValue;
            TextureSets = defaultValue;
            MenuIcons = defaultValue;
            Globals = defaultValue;
            Classes = defaultValue;
            Factions = defaultValue;
            HeadParts = defaultValue;
            Hairs = defaultValue;
            Eyes = defaultValue;
            Races = defaultValue;
            Sounds = defaultValue;
            AcousticSpaces = defaultValue;
            MagicEffects = defaultValue;
            Scripts = defaultValue;
            LandscapeTextures = defaultValue;
            ObjectEffects = defaultValue;
        }
    }

    public interface IFallout3ModDisposableGetter : IFallout3ModGetter, IModDisposeGetter
    {
    }

    /// <summary>
    /// Different game release versions a Fallout3 mod can have
    /// </summary>
    public enum Fallout3Release
    {
        Fallout3 = 11,
        FalloutNV = 12
    }

    public static class Fallout3ReleaseExt
    {
        public static GameRelease ToGameRelease(this Fallout3Release release)
        {
            return release switch
            {
                Fallout3Release.Fallout3 => GameRelease.Fallout3,
                Fallout3Release.FalloutNV => GameRelease.FalloutNV,
                _ => throw new ArgumentException()
            };
        }

        public static Fallout3Release ToFallout3Release(this GameRelease release)
        {
            return release switch
            {
                GameRelease.Fallout3 => Fallout3Release.Fallout3,
                GameRelease.FalloutNV => Fallout3Release.FalloutNV,
                _ => throw new ArgumentException()
            };
        }
    }
}
namespace Mutagen.Bethesda.Fallout3
{
    internal partial class Fallout3Mod_Registration : IModRegistration
    {
        public GameCategory GameCategory => GameCategory.Fallout3;
    }

}
#endregion

#region Binary Translation
namespace Mutagen.Bethesda.Fallout3
{
    public partial class Fallout3ModBinaryWriteTranslation
    {
        public static readonly Fallout3ModBinaryWriteTranslation Instance = new();

        public static void WriteRecordTypes(
            IFallout3ModGetter item,
            MutagenWriter writer,
            GroupMask? importMask,
            TypedWriteParams translationParams = default)
        {
            if (importMask?.GameSettings ?? true)
            {
                var GameSettingsItem = item.GameSettings;
                if (GameSettingsItem.RecordCache.Count > 0)
                {
                    ((Fallout3GroupBinaryWriteTranslation)((IBinaryItem)GameSettingsItem).BinaryWriteTranslator).Write<IGameSettingGetter>(
                        item: GameSettingsItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.TextureSets ?? true)
            {
                var TextureSetsItem = item.TextureSets;
                if (TextureSetsItem.RecordCache.Count > 0)
                {
                    ((Fallout3GroupBinaryWriteTranslation)((IBinaryItem)TextureSetsItem).BinaryWriteTranslator).Write<ITextureSetGetter>(
                        item: TextureSetsItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.MenuIcons ?? true)
            {
                var MenuIconsItem = item.MenuIcons;
                if (MenuIconsItem.RecordCache.Count > 0)
                {
                    ((Fallout3GroupBinaryWriteTranslation)((IBinaryItem)MenuIconsItem).BinaryWriteTranslator).Write<IMenuIconGetter>(
                        item: MenuIconsItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.Globals ?? true)
            {
                var GlobalsItem = item.Globals;
                if (GlobalsItem.RecordCache.Count > 0)
                {
                    ((Fallout3GroupBinaryWriteTranslation)((IBinaryItem)GlobalsItem).BinaryWriteTranslator).Write<IGlobalGetter>(
                        item: GlobalsItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.Classes ?? true)
            {
                var ClassesItem = item.Classes;
                if (ClassesItem.RecordCache.Count > 0)
                {
                    ((Fallout3GroupBinaryWriteTranslation)((IBinaryItem)ClassesItem).BinaryWriteTranslator).Write<IClassGetter>(
                        item: ClassesItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.Factions ?? true)
            {
                var FactionsItem = item.Factions;
                if (FactionsItem.RecordCache.Count > 0)
                {
                    ((Fallout3GroupBinaryWriteTranslation)((IBinaryItem)FactionsItem).BinaryWriteTranslator).Write<IFactionGetter>(
                        item: FactionsItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.HeadParts ?? true)
            {
                var HeadPartsItem = item.HeadParts;
                if (HeadPartsItem.RecordCache.Count > 0)
                {
                    ((Fallout3GroupBinaryWriteTranslation)((IBinaryItem)HeadPartsItem).BinaryWriteTranslator).Write<IHeadPartGetter>(
                        item: HeadPartsItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.Hairs ?? true)
            {
                var HairsItem = item.Hairs;
                if (HairsItem.RecordCache.Count > 0)
                {
                    ((Fallout3GroupBinaryWriteTranslation)((IBinaryItem)HairsItem).BinaryWriteTranslator).Write<IHairGetter>(
                        item: HairsItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.Eyes ?? true)
            {
                var EyesItem = item.Eyes;
                if (EyesItem.RecordCache.Count > 0)
                {
                    ((Fallout3GroupBinaryWriteTranslation)((IBinaryItem)EyesItem).BinaryWriteTranslator).Write<IEyesGetter>(
                        item: EyesItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.Races ?? true)
            {
                var RacesItem = item.Races;
                if (RacesItem.RecordCache.Count > 0)
                {
                    ((Fallout3GroupBinaryWriteTranslation)((IBinaryItem)RacesItem).BinaryWriteTranslator).Write<IRaceGetter>(
                        item: RacesItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.Sounds ?? true)
            {
                var SoundsItem = item.Sounds;
                if (SoundsItem.RecordCache.Count > 0)
                {
                    ((Fallout3GroupBinaryWriteTranslation)((IBinaryItem)SoundsItem).BinaryWriteTranslator).Write<ISoundGetter>(
                        item: SoundsItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.AcousticSpaces ?? true)
            {
                var AcousticSpacesItem = item.AcousticSpaces;
                if (AcousticSpacesItem.RecordCache.Count > 0)
                {
                    ((Fallout3GroupBinaryWriteTranslation)((IBinaryItem)AcousticSpacesItem).BinaryWriteTranslator).Write<IAcousticSpaceGetter>(
                        item: AcousticSpacesItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.MagicEffects ?? true)
            {
                var MagicEffectsItem = item.MagicEffects;
                if (MagicEffectsItem.RecordCache.Count > 0)
                {
                    ((Fallout3GroupBinaryWriteTranslation)((IBinaryItem)MagicEffectsItem).BinaryWriteTranslator).Write<IMagicEffectGetter>(
                        item: MagicEffectsItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.Scripts ?? true)
            {
                var ScriptsItem = item.Scripts;
                if (ScriptsItem.RecordCache.Count > 0)
                {
                    ((Fallout3GroupBinaryWriteTranslation)((IBinaryItem)ScriptsItem).BinaryWriteTranslator).Write<IScriptGetter>(
                        item: ScriptsItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.LandscapeTextures ?? true)
            {
                var LandscapeTexturesItem = item.LandscapeTextures;
                if (LandscapeTexturesItem.RecordCache.Count > 0)
                {
                    ((Fallout3GroupBinaryWriteTranslation)((IBinaryItem)LandscapeTexturesItem).BinaryWriteTranslator).Write<ILandscapeTextureGetter>(
                        item: LandscapeTexturesItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.ObjectEffects ?? true)
            {
                var ObjectEffectsItem = item.ObjectEffects;
                if (ObjectEffectsItem.RecordCache.Count > 0)
                {
                    ((Fallout3GroupBinaryWriteTranslation)((IBinaryItem)ObjectEffectsItem).BinaryWriteTranslator).Write<IObjectEffectGetter>(
                        item: ObjectEffectsItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
        }

        public void Write(
            MutagenWriter writer,
            IFallout3ModGetter item,
            ModKey modKey,
            GroupMask? importMask = null,
            BinaryWriteParameters? param = null)
        {
            param ??= BinaryWriteParameters.Default;
            if (param.Parallel.MaxDegreeOfParallelism != 1)
            {
                Fallout3ModCommon.WriteParallel(
                    item: item,
                    writer: writer,
                    param: param,
                    modKey: modKey);
                return;
            }
            ModHeaderWriteLogic.WriteHeader(
                param: param,
                writer: writer,
                mod: item,
                modHeader: item.ModHeader.DeepCopy(),
                modKey: modKey);
            WriteRecordTypes(
                item: item,
                writer: writer,
                importMask: importMask);
        }

        public void Write(
            MutagenWriter writer,
            object item,
            ModKey modKey,
            GroupMask? importMask = null,
            BinaryWriteParameters? param = null)
        {
            Write(
                item: (IFallout3ModGetter)item,
                writer: writer,
                importMask: importMask,
                param: param,
                modKey: modKey);
        }

    }

    internal partial class Fallout3ModBinaryCreateTranslation
    {
        public static readonly Fallout3ModBinaryCreateTranslation Instance = new Fallout3ModBinaryCreateTranslation();

        public static ParseResult FillBinaryRecordTypes(
            IFallout3Mod item,
            MutagenFrame frame,
            RecordType nextRecordType,
            int contentLength,
            GroupMask? importMask,
            TypedParseParams translationParams = default)
        {
            nextRecordType = translationParams.ConvertToStandard(nextRecordType);
            switch (nextRecordType.TypeInt)
            {
                case RecordTypeInts.TES4:
                {
                    item.ModHeader.CopyInFromBinary(
                        frame: frame,
                        translationParams: null);
                    return (int)Fallout3Mod_FieldIndex.ModHeader;
                }
                case RecordTypeInts.GMST:
                {
                    if (importMask?.GameSettings ?? true)
                    {
                        item.GameSettings.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout3Mod_FieldIndex.GameSettings;
                }
                case RecordTypeInts.TXST:
                {
                    if (importMask?.TextureSets ?? true)
                    {
                        item.TextureSets.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout3Mod_FieldIndex.TextureSets;
                }
                case RecordTypeInts.MICN:
                {
                    if (importMask?.MenuIcons ?? true)
                    {
                        item.MenuIcons.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout3Mod_FieldIndex.MenuIcons;
                }
                case RecordTypeInts.GLOB:
                {
                    if (importMask?.Globals ?? true)
                    {
                        item.Globals.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout3Mod_FieldIndex.Globals;
                }
                case RecordTypeInts.CLAS:
                {
                    if (importMask?.Classes ?? true)
                    {
                        item.Classes.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout3Mod_FieldIndex.Classes;
                }
                case RecordTypeInts.FACT:
                {
                    if (importMask?.Factions ?? true)
                    {
                        item.Factions.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout3Mod_FieldIndex.Factions;
                }
                case RecordTypeInts.HDPT:
                {
                    if (importMask?.HeadParts ?? true)
                    {
                        item.HeadParts.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout3Mod_FieldIndex.HeadParts;
                }
                case RecordTypeInts.HAIR:
                {
                    if (importMask?.Hairs ?? true)
                    {
                        item.Hairs.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout3Mod_FieldIndex.Hairs;
                }
                case RecordTypeInts.EYES:
                {
                    if (importMask?.Eyes ?? true)
                    {
                        item.Eyes.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout3Mod_FieldIndex.Eyes;
                }
                case RecordTypeInts.RACE:
                {
                    if (importMask?.Races ?? true)
                    {
                        item.Races.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout3Mod_FieldIndex.Races;
                }
                case RecordTypeInts.SOUN:
                {
                    if (importMask?.Sounds ?? true)
                    {
                        item.Sounds.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout3Mod_FieldIndex.Sounds;
                }
                case RecordTypeInts.ASPC:
                {
                    if (importMask?.AcousticSpaces ?? true)
                    {
                        item.AcousticSpaces.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout3Mod_FieldIndex.AcousticSpaces;
                }
                case RecordTypeInts.MGEF:
                {
                    if (importMask?.MagicEffects ?? true)
                    {
                        item.MagicEffects.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout3Mod_FieldIndex.MagicEffects;
                }
                case RecordTypeInts.SCPT:
                {
                    if (importMask?.Scripts ?? true)
                    {
                        item.Scripts.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout3Mod_FieldIndex.Scripts;
                }
                case RecordTypeInts.LTEX:
                {
                    if (importMask?.LandscapeTextures ?? true)
                    {
                        item.LandscapeTextures.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout3Mod_FieldIndex.LandscapeTextures;
                }
                case RecordTypeInts.ENCH:
                {
                    if (importMask?.ObjectEffects ?? true)
                    {
                        item.ObjectEffects.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout3Mod_FieldIndex.ObjectEffects;
                }
                default:
                    frame.Position += contentLength;
                    return default(int?);
            }
        }

    }

}
namespace Mutagen.Bethesda.Fallout3
{
    #region Binary Write Mixins
    public static class Fallout3ModBinaryTranslationMixIn
    {
        public static void WriteToBinary(
            this IFallout3ModGetter item,
            MutagenWriter writer,
            GroupMask? importMask = null,
            BinaryWriteParameters? param = null)
        {
            var modKey = item.ModKey;
            Fallout3ModBinaryWriteTranslation.Instance.Write(
                item: item,
                writer: writer,
                importMask: importMask,
                param: param,
                modKey: modKey);
        }

        public static void WriteToBinary(
            this IFallout3ModGetter item,
            FilePath path,
            BinaryWriteParameters? param = null,
            GroupMask? importMask = null)
        {
            param ??= BinaryWriteParameters.Default;
            var modKey = param.RunMasterMatch(
                mod: item,
                path: path);
            var bundle = new WritingBundle(item.Fallout3Release.ToGameRelease())
            {
                CleanNulls = param.CleanNulls,
                TargetLanguageOverride = param.TargetLanguageOverride,
                Header = item,
                ModHeaderVersion = item.ModHeader.Stats.Version
            };
            if (param.Encodings != null)
            {
                bundle.Encodings = param.Encodings;
            }
            using var memStream = new MemoryTributary();
            using (var writer = new MutagenWriter(
                memStream,
                bundle,
                dispose: false))
            {
                Fallout3ModBinaryWriteTranslation.Instance.Write(
                    item: item,
                    importMask: importMask,
                    writer: writer,
                    param: param,
                    modKey: modKey);
            }
            using (var fs = param.FileSystem.GetOrDefault().FileStream.New(path, FileMode.Create, FileAccess.Write))
            {
                memStream.Position = 0;
                memStream.CopyTo(fs);
            }
            param.StringsWriter?.Dispose();
        }

        public static void WriteToBinary(
            this IFallout3ModGetter item,
            Stream stream,
            BinaryWriteParameters? param = null,
            GroupMask? importMask = null)
        {
            var modKey = item.ModKey;
            using (var writer = new MutagenWriter(
                stream: stream,
                new WritingBundle(item.Fallout3Release.ToGameRelease()) { ModHeaderVersion = item.ModHeader.Stats.Version },
                dispose: false))
            {
                Fallout3ModBinaryWriteTranslation.Instance.Write(
                    item: item,
                    importMask: importMask,
                    writer: writer,
                    param: param,
                    modKey: modKey);
            }
        }

    }
    #endregion


}
namespace Mutagen.Bethesda.Fallout3
{
    [DebuggerDisplay("{GameRelease} {ModKey.ToString()}")]
    internal partial class Fallout3ModBinaryOverlay : IFallout3ModDisposableGetter
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => Fallout3Mod_Registration.Instance;
        public static ILoquiRegistration StaticRegistration => Fallout3Mod_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => Fallout3ModCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => Fallout3ModSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IFallout3ModGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object? IFallout3ModGetter.CommonSetterInstance() => null;
        [DebuggerStepThrough]
        object IFallout3ModGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

        void IPrintable.Print(StructuredStringBuilder sb, string? name) => this.Print(sb, name);

        public Fallout3Release Fallout3Release { get; }
        public GameRelease GameRelease => Fallout3Release.ToGameRelease();
        IGroupGetter<T>? IModGetter.TryGetTopLevelGroup<T>() => this.TryGetTopLevelGroup<T>();
        IGroupGetter? IModGetter.TryGetTopLevelGroup(Type type) => this.TryGetTopLevelGroup(type);
        void IModGetter.WriteToBinary(FilePath path, BinaryWriteParameters? param) => this.WriteToBinary(path, importMask: null, param: param);
        void IModGetter.WriteToBinary(Stream stream, BinaryWriteParameters? param) => this.WriteToBinary(stream, importMask: null, param: param);
        uint IModGetter.GetRecordCount() => this.GetRecordCount();
        IReadOnlyList<IMasterReferenceGetter> IModGetter.MasterReferences => this.ModHeader.MasterReferences;
        public bool CanUseLocalization => false;
        public bool UsingLocalization => false;
        public IEnumerable<IFormLinkGetter> EnumerateFormLinks() => Fallout3ModCommon.Instance.EnumerateFormLinks(this);
        public IEnumerable<IAssetLinkGetter> EnumerateAssetLinks(AssetLinkQuery queryCategories, IAssetLinkCache? linkCache, Type? assetType) => Fallout3ModCommon.Instance.EnumerateAssetLinks(this, queryCategories, linkCache, assetType);
        [DebuggerStepThrough]
        IEnumerable<IModContext<IFallout3Mod, IFallout3ModGetter, TSetter, TGetter>> IMajorRecordContextEnumerable<IFallout3Mod, IFallout3ModGetter>.EnumerateMajorRecordContexts<TSetter, TGetter>(ILinkCache linkCache, bool throwIfUnknown) => this.EnumerateMajorRecordContexts<TSetter, TGetter>(linkCache, throwIfUnknown: throwIfUnknown);
        [DebuggerStepThrough]
        IEnumerable<IModContext<IFallout3Mod, IFallout3ModGetter, IMajorRecord, IMajorRecordGetter>> IMajorRecordContextEnumerable<IFallout3Mod, IFallout3ModGetter>.EnumerateMajorRecordContexts(ILinkCache linkCache, Type type, bool throwIfUnknown) => this.EnumerateMajorRecordContexts(linkCache, type: type, throwIfUnknown: throwIfUnknown);
        [DebuggerStepThrough]
        IEnumerable<IModContext<IMajorRecordGetter>> IMajorRecordSimpleContextEnumerable.EnumerateMajorRecordSimpleContexts() => this.EnumerateMajorRecordContexts();
        [DebuggerStepThrough]
        IEnumerable<IModContext<TMajor>> IMajorRecordSimpleContextEnumerable.EnumerateMajorRecordSimpleContexts<TMajor>(bool throwIfUnknown) => this.EnumerateMajorRecordContexts(linkCache: null!, typeof(TMajor), throwIfUnknown: throwIfUnknown).Select(x => x.AsType<Mutagen.Bethesda.Plugins.Records.IMajorRecordQueryableGetter, TMajor>());
        [DebuggerStepThrough]
        IEnumerable<IModContext<IMajorRecordGetter>> IMajorRecordSimpleContextEnumerable.EnumerateMajorRecordSimpleContexts(Type type, bool throwIfUnknown) => this.EnumerateMajorRecordContexts(linkCache: null!, type: type, throwIfUnknown: throwIfUnknown);
        [DebuggerStepThrough]
        IEnumerable<IMajorRecordGetter> IMajorRecordGetterEnumerable.EnumerateMajorRecords() => this.EnumerateMajorRecords();
        [DebuggerStepThrough]
        IEnumerable<TMajor> IMajorRecordGetterEnumerable.EnumerateMajorRecords<TMajor>(bool throwIfUnknown) => this.EnumerateMajorRecords<TMajor>(throwIfUnknown: throwIfUnknown);
        [DebuggerStepThrough]
        IEnumerable<IMajorRecordGetter> IMajorRecordGetterEnumerable.EnumerateMajorRecords(Type type, bool throwIfUnknown) => this.EnumerateMajorRecords(type: type, throwIfUnknown: throwIfUnknown);
        uint IModGetter.NextFormID => ModHeader.Stats.NextFormID;
        public ModKey ModKey { get; }
        private readonly BinaryOverlayFactoryPackage _package;
        private readonly IBinaryReadStream _stream;
        private readonly bool _shouldDispose;
        public void Dispose()
        {
            if (!_shouldDispose) return;
            _stream.Dispose();
        }

        #region ModHeader
        private RangeInt64? _ModHeaderLocation;
        private IFallout3ModHeaderGetter? _ModHeader => _ModHeaderLocation.HasValue ? Fallout3ModHeaderBinaryOverlay.Fallout3ModHeaderFactory(PluginBinaryOverlay.LockExtractMemory(_stream, _ModHeaderLocation!.Value.Min, _ModHeaderLocation!.Value.Max), _package) : default;
        public IFallout3ModHeaderGetter ModHeader => _ModHeader ?? new Fallout3ModHeader();
        #endregion
        #region GameSettings
        private List<RangeInt64>? _GameSettingsLocations;
        private IFallout3GroupGetter<IGameSettingGetter>? _GameSettings => _GameSettingsLocations != null ? Fallout3GroupBinaryOverlay<IGameSettingGetter>.Fallout3GroupFactory(_stream, _GameSettingsLocations, _package) : default;
        public IFallout3GroupGetter<IGameSettingGetter> GameSettings => _GameSettings ?? new Fallout3Group<GameSetting>(this);
        #endregion
        #region TextureSets
        private List<RangeInt64>? _TextureSetsLocations;
        private IFallout3GroupGetter<ITextureSetGetter>? _TextureSets => _TextureSetsLocations != null ? Fallout3GroupBinaryOverlay<ITextureSetGetter>.Fallout3GroupFactory(_stream, _TextureSetsLocations, _package) : default;
        public IFallout3GroupGetter<ITextureSetGetter> TextureSets => _TextureSets ?? new Fallout3Group<TextureSet>(this);
        #endregion
        #region MenuIcons
        private List<RangeInt64>? _MenuIconsLocations;
        private IFallout3GroupGetter<IMenuIconGetter>? _MenuIcons => _MenuIconsLocations != null ? Fallout3GroupBinaryOverlay<IMenuIconGetter>.Fallout3GroupFactory(_stream, _MenuIconsLocations, _package) : default;
        public IFallout3GroupGetter<IMenuIconGetter> MenuIcons => _MenuIcons ?? new Fallout3Group<MenuIcon>(this);
        #endregion
        #region Globals
        private List<RangeInt64>? _GlobalsLocations;
        private IFallout3GroupGetter<IGlobalGetter>? _Globals => _GlobalsLocations != null ? Fallout3GroupBinaryOverlay<IGlobalGetter>.Fallout3GroupFactory(_stream, _GlobalsLocations, _package) : default;
        public IFallout3GroupGetter<IGlobalGetter> Globals => _Globals ?? new Fallout3Group<Global>(this);
        #endregion
        #region Classes
        private List<RangeInt64>? _ClassesLocations;
        private IFallout3GroupGetter<IClassGetter>? _Classes => _ClassesLocations != null ? Fallout3GroupBinaryOverlay<IClassGetter>.Fallout3GroupFactory(_stream, _ClassesLocations, _package) : default;
        public IFallout3GroupGetter<IClassGetter> Classes => _Classes ?? new Fallout3Group<Class>(this);
        #endregion
        #region Factions
        private List<RangeInt64>? _FactionsLocations;
        private IFallout3GroupGetter<IFactionGetter>? _Factions => _FactionsLocations != null ? Fallout3GroupBinaryOverlay<IFactionGetter>.Fallout3GroupFactory(_stream, _FactionsLocations, _package) : default;
        public IFallout3GroupGetter<IFactionGetter> Factions => _Factions ?? new Fallout3Group<Faction>(this);
        #endregion
        #region HeadParts
        private List<RangeInt64>? _HeadPartsLocations;
        private IFallout3GroupGetter<IHeadPartGetter>? _HeadParts => _HeadPartsLocations != null ? Fallout3GroupBinaryOverlay<IHeadPartGetter>.Fallout3GroupFactory(_stream, _HeadPartsLocations, _package) : default;
        public IFallout3GroupGetter<IHeadPartGetter> HeadParts => _HeadParts ?? new Fallout3Group<HeadPart>(this);
        #endregion
        #region Hairs
        private List<RangeInt64>? _HairsLocations;
        private IFallout3GroupGetter<IHairGetter>? _Hairs => _HairsLocations != null ? Fallout3GroupBinaryOverlay<IHairGetter>.Fallout3GroupFactory(_stream, _HairsLocations, _package) : default;
        public IFallout3GroupGetter<IHairGetter> Hairs => _Hairs ?? new Fallout3Group<Hair>(this);
        #endregion
        #region Eyes
        private List<RangeInt64>? _EyesLocations;
        private IFallout3GroupGetter<IEyesGetter>? _Eyes => _EyesLocations != null ? Fallout3GroupBinaryOverlay<IEyesGetter>.Fallout3GroupFactory(_stream, _EyesLocations, _package) : default;
        public IFallout3GroupGetter<IEyesGetter> Eyes => _Eyes ?? new Fallout3Group<Eyes>(this);
        #endregion
        #region Races
        private List<RangeInt64>? _RacesLocations;
        private IFallout3GroupGetter<IRaceGetter>? _Races => _RacesLocations != null ? Fallout3GroupBinaryOverlay<IRaceGetter>.Fallout3GroupFactory(_stream, _RacesLocations, _package) : default;
        public IFallout3GroupGetter<IRaceGetter> Races => _Races ?? new Fallout3Group<Race>(this);
        #endregion
        #region Sounds
        private List<RangeInt64>? _SoundsLocations;
        private IFallout3GroupGetter<ISoundGetter>? _Sounds => _SoundsLocations != null ? Fallout3GroupBinaryOverlay<ISoundGetter>.Fallout3GroupFactory(_stream, _SoundsLocations, _package) : default;
        public IFallout3GroupGetter<ISoundGetter> Sounds => _Sounds ?? new Fallout3Group<Sound>(this);
        #endregion
        #region AcousticSpaces
        private List<RangeInt64>? _AcousticSpacesLocations;
        private IFallout3GroupGetter<IAcousticSpaceGetter>? _AcousticSpaces => _AcousticSpacesLocations != null ? Fallout3GroupBinaryOverlay<IAcousticSpaceGetter>.Fallout3GroupFactory(_stream, _AcousticSpacesLocations, _package) : default;
        public IFallout3GroupGetter<IAcousticSpaceGetter> AcousticSpaces => _AcousticSpaces ?? new Fallout3Group<AcousticSpace>(this);
        #endregion
        #region MagicEffects
        private List<RangeInt64>? _MagicEffectsLocations;
        private IFallout3GroupGetter<IMagicEffectGetter>? _MagicEffects => _MagicEffectsLocations != null ? Fallout3GroupBinaryOverlay<IMagicEffectGetter>.Fallout3GroupFactory(_stream, _MagicEffectsLocations, _package) : default;
        public IFallout3GroupGetter<IMagicEffectGetter> MagicEffects => _MagicEffects ?? new Fallout3Group<MagicEffect>(this);
        #endregion
        #region Scripts
        private List<RangeInt64>? _ScriptsLocations;
        private IFallout3GroupGetter<IScriptGetter>? _Scripts => _ScriptsLocations != null ? Fallout3GroupBinaryOverlay<IScriptGetter>.Fallout3GroupFactory(_stream, _ScriptsLocations, _package) : default;
        public IFallout3GroupGetter<IScriptGetter> Scripts => _Scripts ?? new Fallout3Group<Script>(this);
        #endregion
        #region LandscapeTextures
        private List<RangeInt64>? _LandscapeTexturesLocations;
        private IFallout3GroupGetter<ILandscapeTextureGetter>? _LandscapeTextures => _LandscapeTexturesLocations != null ? Fallout3GroupBinaryOverlay<ILandscapeTextureGetter>.Fallout3GroupFactory(_stream, _LandscapeTexturesLocations, _package) : default;
        public IFallout3GroupGetter<ILandscapeTextureGetter> LandscapeTextures => _LandscapeTextures ?? new Fallout3Group<LandscapeTexture>(this);
        #endregion
        #region ObjectEffects
        private List<RangeInt64>? _ObjectEffectsLocations;
        private IFallout3GroupGetter<IObjectEffectGetter>? _ObjectEffects => _ObjectEffectsLocations != null ? Fallout3GroupBinaryOverlay<IObjectEffectGetter>.Fallout3GroupFactory(_stream, _ObjectEffectsLocations, _package) : default;
        public IFallout3GroupGetter<IObjectEffectGetter> ObjectEffects => _ObjectEffects ?? new Fallout3Group<ObjectEffect>(this);
        #endregion
        protected Fallout3ModBinaryOverlay(
            IMutagenReadStream stream,
            ModKey modKey,
            bool shouldDispose,
            Fallout3Release release)
        {
            this.ModKey = modKey;
            this.Fallout3Release = release;
            this._stream = stream;
            this._package = new BinaryOverlayFactoryPackage(stream.MetaData);
            this._shouldDispose = shouldDispose;
        }

        public static Fallout3ModBinaryOverlay Fallout3ModFactory(
            ModPath path,
            Fallout3Release release,
            BinaryReadParameters? param)
        {
            param ??= BinaryReadParameters.Default;
            var meta = ParsingMeta.Factory(param, release.ToGameRelease(), path);
            meta.RecordInfoCache = new RecordTypeInfoCacheReader(() => new MutagenBinaryReadStream(path, meta), path.ModKey, meta.LinkCache);
            var stream = new MutagenBinaryReadStream(
                path: path.Path,
                metaData: meta);
            try
            {
                return Fallout3ModFactory(
                    stream: stream,
                    path.ModKey,
                    release: release,
                    shouldDispose: true);
            }
            catch (Exception ex)
            {
                stream.Dispose();
                throw ModGroupsMalformedException.Enrich(ex, path.ModKey);
            }
        }

        public static Fallout3ModBinaryOverlay Fallout3ModFactory(
            IMutagenReadStream stream,
            ModKey modKey,
            Fallout3Release release,
            bool shouldDispose)
        {
            var ret = new Fallout3ModBinaryOverlay(
                stream: stream,
                release: release,
                modKey: modKey,
                shouldDispose: shouldDispose);
            PluginBinaryOverlay.FillModTypes(
                stream: stream,
                package: ret._package,
                fill: ret.FillRecordType);
            return ret;
        }


        public ParseResult FillRecordType(
            IBinaryReadStream stream,
            long finalPos,
            int offset,
            RecordType type,
            PreviousParse lastParsed,
            TypedParseParams translationParams = default)
        {
            type = translationParams.ConvertToStandard(type);
            switch (type.TypeInt)
            {
                case RecordTypeInts.TES4:
                {
                    _ModHeaderLocation = new RangeInt64((stream.Position - offset), finalPos - offset);
                    return (int)Fallout3Mod_FieldIndex.ModHeader;
                }
                case RecordTypeInts.GMST:
                {
                    _GameSettingsLocations ??= new();
                    _GameSettingsLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout3Mod_FieldIndex.GameSettings;
                }
                case RecordTypeInts.TXST:
                {
                    _TextureSetsLocations ??= new();
                    _TextureSetsLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout3Mod_FieldIndex.TextureSets;
                }
                case RecordTypeInts.MICN:
                {
                    _MenuIconsLocations ??= new();
                    _MenuIconsLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout3Mod_FieldIndex.MenuIcons;
                }
                case RecordTypeInts.GLOB:
                {
                    _GlobalsLocations ??= new();
                    _GlobalsLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout3Mod_FieldIndex.Globals;
                }
                case RecordTypeInts.CLAS:
                {
                    _ClassesLocations ??= new();
                    _ClassesLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout3Mod_FieldIndex.Classes;
                }
                case RecordTypeInts.FACT:
                {
                    _FactionsLocations ??= new();
                    _FactionsLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout3Mod_FieldIndex.Factions;
                }
                case RecordTypeInts.HDPT:
                {
                    _HeadPartsLocations ??= new();
                    _HeadPartsLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout3Mod_FieldIndex.HeadParts;
                }
                case RecordTypeInts.HAIR:
                {
                    _HairsLocations ??= new();
                    _HairsLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout3Mod_FieldIndex.Hairs;
                }
                case RecordTypeInts.EYES:
                {
                    _EyesLocations ??= new();
                    _EyesLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout3Mod_FieldIndex.Eyes;
                }
                case RecordTypeInts.RACE:
                {
                    _RacesLocations ??= new();
                    _RacesLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout3Mod_FieldIndex.Races;
                }
                case RecordTypeInts.SOUN:
                {
                    _SoundsLocations ??= new();
                    _SoundsLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout3Mod_FieldIndex.Sounds;
                }
                case RecordTypeInts.ASPC:
                {
                    _AcousticSpacesLocations ??= new();
                    _AcousticSpacesLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout3Mod_FieldIndex.AcousticSpaces;
                }
                case RecordTypeInts.MGEF:
                {
                    _MagicEffectsLocations ??= new();
                    _MagicEffectsLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout3Mod_FieldIndex.MagicEffects;
                }
                case RecordTypeInts.SCPT:
                {
                    _ScriptsLocations ??= new();
                    _ScriptsLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout3Mod_FieldIndex.Scripts;
                }
                case RecordTypeInts.LTEX:
                {
                    _LandscapeTexturesLocations ??= new();
                    _LandscapeTexturesLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout3Mod_FieldIndex.LandscapeTextures;
                }
                case RecordTypeInts.ENCH:
                {
                    _ObjectEffectsLocations ??= new();
                    _ObjectEffectsLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout3Mod_FieldIndex.ObjectEffects;
                }
                default:
                    return default(int?);
            }
        }
        #region To String

        public void Print(
            StructuredStringBuilder sb,
            string? name = null)
        {
            Fallout3ModMixIn.Print(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is not IFallout3ModGetter rhs) return false;
            return ((Fallout3ModCommon)((IFallout3ModGetter)this).CommonInstance()!).Equals(this, rhs, equalsMask: null);
        }

        public bool Equals(IFallout3ModGetter? obj)
        {
            return ((Fallout3ModCommon)((IFallout3ModGetter)this).CommonInstance()!).Equals(this, obj, equalsMask: null);
        }

        public override int GetHashCode() => ((Fallout3ModCommon)((IFallout3ModGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        IMask<bool> IEqualsMask.GetEqualsMask(object rhs, EqualsMaskHelper.Include include = EqualsMaskHelper.Include.OnlyFailures) => Fallout3ModMixIn.GetEqualsMask(this, (IFallout3ModGetter)rhs, include);
    }

}
#endregion

#endregion

