/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Autogenerated by Loqui.  Do not manually change.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*/
#region Usings
using Loqui;
using Loqui.Interfaces;
using Loqui.Internal;
using Mutagen.Bethesda.Binary;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Aspects;
using Mutagen.Bethesda.Plugins.Binary.Headers;
using Mutagen.Bethesda.Plugins.Binary.Overlay;
using Mutagen.Bethesda.Plugins.Binary.Streams;
using Mutagen.Bethesda.Plugins.Binary.Translations;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Exceptions;
using Mutagen.Bethesda.Plugins.Internals;
using Mutagen.Bethesda.Plugins.Meta;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Plugins.Records.Internals;
using Mutagen.Bethesda.Plugins.Records.Mapping;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Skyrim.Internals;
using Mutagen.Bethesda.Translations.Binary;
using Noggog;
using Noggog.StructuredStrings;
using Noggog.StructuredStrings.CSharp;
using RecordTypeInts = Mutagen.Bethesda.Skyrim.Internals.RecordTypeInts;
using RecordTypes = Mutagen.Bethesda.Skyrim.Internals.RecordTypes;
using System.Buffers.Binary;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Reactive.Disposables;
using System.Reactive.Linq;
#endregion

#nullable enable
namespace Mutagen.Bethesda.Skyrim
{
    #region Class
    public partial class SceneAction :
        IEquatable<ISceneActionGetter>,
        ILoquiObjectSetter<SceneAction>,
        ISceneAction
    {
        #region Ctor
        public SceneAction()
        {
            CustomCtor();
        }
        partial void CustomCtor();
        #endregion

        #region Type
        public SceneAction.TypeEnum Type { get; set; } = default(SceneAction.TypeEnum);
        #endregion
        #region Name
        /// <summary>
        /// Aspects: INamed, INamedRequired
        /// </summary>
        public String? Name { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        String? ISceneActionGetter.Name => this.Name;
        #region Aspects
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        string INamedRequiredGetter.Name => this.Name ?? string.Empty;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        string INamedRequired.Name
        {
            get => this.Name ?? string.Empty;
            set => this.Name = value;
        }
        #endregion
        #endregion
        #region ActorID
        public Int32? ActorID { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Int32? ISceneActionGetter.ActorID => this.ActorID;
        #endregion
        #region LNAM
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected MemorySlice<Byte>? _LNAM;
        public MemorySlice<Byte>? LNAM
        {
            get => this._LNAM;
            set => this._LNAM = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ReadOnlyMemorySlice<Byte>? ISceneActionGetter.LNAM => this.LNAM;
        #endregion
        #region Index
        public UInt32? Index { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        UInt32? ISceneActionGetter.Index => this.Index;
        #endregion
        #region Flags
        public SceneAction.Flag? Flags { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SceneAction.Flag? ISceneActionGetter.Flags => this.Flags;
        #endregion
        #region StartPhase
        public UInt32? StartPhase { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        UInt32? ISceneActionGetter.StartPhase => this.StartPhase;
        #endregion
        #region EndPhase
        public UInt32? EndPhase { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        UInt32? ISceneActionGetter.EndPhase => this.EndPhase;
        #endregion
        #region TimerSeconds
        public Single? TimerSeconds { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? ISceneActionGetter.TimerSeconds => this.TimerSeconds;
        #endregion
        #region Packages
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private ExtendedList<IFormLinkGetter<IPackageGetter>> _Packages = new ExtendedList<IFormLinkGetter<IPackageGetter>>();
        public ExtendedList<IFormLinkGetter<IPackageGetter>> Packages
        {
            get => this._Packages;
            init => this._Packages = value;
        }
        #region Interface Members
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IReadOnlyList<IFormLinkGetter<IPackageGetter>> ISceneActionGetter.Packages => _Packages;
        #endregion

        #endregion
        #region Topic
        private readonly IFormLinkNullable<IDialogTopicGetter> _Topic = new FormLinkNullable<IDialogTopicGetter>();
        public IFormLinkNullable<IDialogTopicGetter> Topic
        {
            get => _Topic;
            set => _Topic.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IDialogTopicGetter> ISceneActionGetter.Topic => this.Topic;
        #endregion
        #region HeadtrackActorID
        public Int32? HeadtrackActorID { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Int32? ISceneActionGetter.HeadtrackActorID => this.HeadtrackActorID;
        #endregion
        #region LoopingMax
        public Single? LoopingMax { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? ISceneActionGetter.LoopingMax => this.LoopingMax;
        #endregion
        #region LoopingMin
        public Single? LoopingMin { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? ISceneActionGetter.LoopingMin => this.LoopingMin;
        #endregion
        #region Emotion
        public Emotion? Emotion { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Emotion? ISceneActionGetter.Emotion => this.Emotion;
        #endregion
        #region EmotionValue
        public UInt32? EmotionValue { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        UInt32? ISceneActionGetter.EmotionValue => this.EmotionValue;
        #endregion
        #region Unused
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private ScenePhaseUnusedData? _Unused;
        public ScenePhaseUnusedData? Unused
        {
            get => _Unused;
            set => _Unused = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IScenePhaseUnusedDataGetter? ISceneActionGetter.Unused => this.Unused;
        #endregion

        #region To String

        public void Print(
            StructuredStringBuilder sb,
            string? name = null)
        {
            SceneActionMixIn.Print(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is not ISceneActionGetter rhs) return false;
            return ((SceneActionCommon)((ISceneActionGetter)this).CommonInstance()!).Equals(this, rhs, equalsMask: null);
        }

        public bool Equals(ISceneActionGetter? obj)
        {
            return ((SceneActionCommon)((ISceneActionGetter)this).CommonInstance()!).Equals(this, obj, equalsMask: null);
        }

        public override int GetHashCode() => ((SceneActionCommon)((ISceneActionGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        #region Mask
        public class Mask<TItem> :
            IEquatable<Mask<TItem>>,
            IMask<TItem>
        {
            #region Ctors
            public Mask(TItem initialValue)
            {
                this.Type = initialValue;
                this.Name = initialValue;
                this.ActorID = initialValue;
                this.LNAM = initialValue;
                this.Index = initialValue;
                this.Flags = initialValue;
                this.StartPhase = initialValue;
                this.EndPhase = initialValue;
                this.TimerSeconds = initialValue;
                this.Packages = new MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>(initialValue, Enumerable.Empty<(int Index, TItem Value)>());
                this.Topic = initialValue;
                this.HeadtrackActorID = initialValue;
                this.LoopingMax = initialValue;
                this.LoopingMin = initialValue;
                this.Emotion = initialValue;
                this.EmotionValue = initialValue;
                this.Unused = new MaskItem<TItem, ScenePhaseUnusedData.Mask<TItem>?>(initialValue, new ScenePhaseUnusedData.Mask<TItem>(initialValue));
            }

            public Mask(
                TItem Type,
                TItem Name,
                TItem ActorID,
                TItem LNAM,
                TItem Index,
                TItem Flags,
                TItem StartPhase,
                TItem EndPhase,
                TItem TimerSeconds,
                TItem Packages,
                TItem Topic,
                TItem HeadtrackActorID,
                TItem LoopingMax,
                TItem LoopingMin,
                TItem Emotion,
                TItem EmotionValue,
                TItem Unused)
            {
                this.Type = Type;
                this.Name = Name;
                this.ActorID = ActorID;
                this.LNAM = LNAM;
                this.Index = Index;
                this.Flags = Flags;
                this.StartPhase = StartPhase;
                this.EndPhase = EndPhase;
                this.TimerSeconds = TimerSeconds;
                this.Packages = new MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>(Packages, Enumerable.Empty<(int Index, TItem Value)>());
                this.Topic = Topic;
                this.HeadtrackActorID = HeadtrackActorID;
                this.LoopingMax = LoopingMax;
                this.LoopingMin = LoopingMin;
                this.Emotion = Emotion;
                this.EmotionValue = EmotionValue;
                this.Unused = new MaskItem<TItem, ScenePhaseUnusedData.Mask<TItem>?>(Unused, new ScenePhaseUnusedData.Mask<TItem>(Unused));
            }

            #pragma warning disable CS8618
            protected Mask()
            {
            }
            #pragma warning restore CS8618

            #endregion

            #region Members
            public TItem Type;
            public TItem Name;
            public TItem ActorID;
            public TItem LNAM;
            public TItem Index;
            public TItem Flags;
            public TItem StartPhase;
            public TItem EndPhase;
            public TItem TimerSeconds;
            public MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>? Packages;
            public TItem Topic;
            public TItem HeadtrackActorID;
            public TItem LoopingMax;
            public TItem LoopingMin;
            public TItem Emotion;
            public TItem EmotionValue;
            public MaskItem<TItem, ScenePhaseUnusedData.Mask<TItem>?>? Unused { get; set; }
            #endregion

            #region Equals
            public override bool Equals(object? obj)
            {
                if (!(obj is Mask<TItem> rhs)) return false;
                return Equals(rhs);
            }

            public bool Equals(Mask<TItem>? rhs)
            {
                if (rhs == null) return false;
                if (!object.Equals(this.Type, rhs.Type)) return false;
                if (!object.Equals(this.Name, rhs.Name)) return false;
                if (!object.Equals(this.ActorID, rhs.ActorID)) return false;
                if (!object.Equals(this.LNAM, rhs.LNAM)) return false;
                if (!object.Equals(this.Index, rhs.Index)) return false;
                if (!object.Equals(this.Flags, rhs.Flags)) return false;
                if (!object.Equals(this.StartPhase, rhs.StartPhase)) return false;
                if (!object.Equals(this.EndPhase, rhs.EndPhase)) return false;
                if (!object.Equals(this.TimerSeconds, rhs.TimerSeconds)) return false;
                if (!object.Equals(this.Packages, rhs.Packages)) return false;
                if (!object.Equals(this.Topic, rhs.Topic)) return false;
                if (!object.Equals(this.HeadtrackActorID, rhs.HeadtrackActorID)) return false;
                if (!object.Equals(this.LoopingMax, rhs.LoopingMax)) return false;
                if (!object.Equals(this.LoopingMin, rhs.LoopingMin)) return false;
                if (!object.Equals(this.Emotion, rhs.Emotion)) return false;
                if (!object.Equals(this.EmotionValue, rhs.EmotionValue)) return false;
                if (!object.Equals(this.Unused, rhs.Unused)) return false;
                return true;
            }
            public override int GetHashCode()
            {
                var hash = new HashCode();
                hash.Add(this.Type);
                hash.Add(this.Name);
                hash.Add(this.ActorID);
                hash.Add(this.LNAM);
                hash.Add(this.Index);
                hash.Add(this.Flags);
                hash.Add(this.StartPhase);
                hash.Add(this.EndPhase);
                hash.Add(this.TimerSeconds);
                hash.Add(this.Packages);
                hash.Add(this.Topic);
                hash.Add(this.HeadtrackActorID);
                hash.Add(this.LoopingMax);
                hash.Add(this.LoopingMin);
                hash.Add(this.Emotion);
                hash.Add(this.EmotionValue);
                hash.Add(this.Unused);
                return hash.ToHashCode();
            }

            #endregion

            #region All
            public bool All(Func<TItem, bool> eval)
            {
                if (!eval(this.Type)) return false;
                if (!eval(this.Name)) return false;
                if (!eval(this.ActorID)) return false;
                if (!eval(this.LNAM)) return false;
                if (!eval(this.Index)) return false;
                if (!eval(this.Flags)) return false;
                if (!eval(this.StartPhase)) return false;
                if (!eval(this.EndPhase)) return false;
                if (!eval(this.TimerSeconds)) return false;
                if (this.Packages != null)
                {
                    if (!eval(this.Packages.Overall)) return false;
                    if (this.Packages.Specific != null)
                    {
                        foreach (var item in this.Packages.Specific)
                        {
                            if (!eval(item.Value)) return false;
                        }
                    }
                }
                if (!eval(this.Topic)) return false;
                if (!eval(this.HeadtrackActorID)) return false;
                if (!eval(this.LoopingMax)) return false;
                if (!eval(this.LoopingMin)) return false;
                if (!eval(this.Emotion)) return false;
                if (!eval(this.EmotionValue)) return false;
                if (Unused != null)
                {
                    if (!eval(this.Unused.Overall)) return false;
                    if (this.Unused.Specific != null && !this.Unused.Specific.All(eval)) return false;
                }
                return true;
            }
            #endregion

            #region Any
            public bool Any(Func<TItem, bool> eval)
            {
                if (eval(this.Type)) return true;
                if (eval(this.Name)) return true;
                if (eval(this.ActorID)) return true;
                if (eval(this.LNAM)) return true;
                if (eval(this.Index)) return true;
                if (eval(this.Flags)) return true;
                if (eval(this.StartPhase)) return true;
                if (eval(this.EndPhase)) return true;
                if (eval(this.TimerSeconds)) return true;
                if (this.Packages != null)
                {
                    if (eval(this.Packages.Overall)) return true;
                    if (this.Packages.Specific != null)
                    {
                        foreach (var item in this.Packages.Specific)
                        {
                            if (!eval(item.Value)) return false;
                        }
                    }
                }
                if (eval(this.Topic)) return true;
                if (eval(this.HeadtrackActorID)) return true;
                if (eval(this.LoopingMax)) return true;
                if (eval(this.LoopingMin)) return true;
                if (eval(this.Emotion)) return true;
                if (eval(this.EmotionValue)) return true;
                if (Unused != null)
                {
                    if (eval(this.Unused.Overall)) return true;
                    if (this.Unused.Specific != null && this.Unused.Specific.Any(eval)) return true;
                }
                return false;
            }
            #endregion

            #region Translate
            public Mask<R> Translate<R>(Func<TItem, R> eval)
            {
                var ret = new SceneAction.Mask<R>();
                this.Translate_InternalFill(ret, eval);
                return ret;
            }

            protected void Translate_InternalFill<R>(Mask<R> obj, Func<TItem, R> eval)
            {
                obj.Type = eval(this.Type);
                obj.Name = eval(this.Name);
                obj.ActorID = eval(this.ActorID);
                obj.LNAM = eval(this.LNAM);
                obj.Index = eval(this.Index);
                obj.Flags = eval(this.Flags);
                obj.StartPhase = eval(this.StartPhase);
                obj.EndPhase = eval(this.EndPhase);
                obj.TimerSeconds = eval(this.TimerSeconds);
                if (Packages != null)
                {
                    obj.Packages = new MaskItem<R, IEnumerable<(int Index, R Value)>?>(eval(this.Packages.Overall), Enumerable.Empty<(int Index, R Value)>());
                    if (Packages.Specific != null)
                    {
                        var l = new List<(int Index, R Item)>();
                        obj.Packages.Specific = l;
                        foreach (var item in Packages.Specific)
                        {
                            R mask = eval(item.Value);
                            l.Add((item.Index, mask));
                        }
                    }
                }
                obj.Topic = eval(this.Topic);
                obj.HeadtrackActorID = eval(this.HeadtrackActorID);
                obj.LoopingMax = eval(this.LoopingMax);
                obj.LoopingMin = eval(this.LoopingMin);
                obj.Emotion = eval(this.Emotion);
                obj.EmotionValue = eval(this.EmotionValue);
                obj.Unused = this.Unused == null ? null : new MaskItem<R, ScenePhaseUnusedData.Mask<R>?>(eval(this.Unused.Overall), this.Unused.Specific?.Translate(eval));
            }
            #endregion

            #region To String
            public override string ToString() => this.Print();

            public string Print(SceneAction.Mask<bool>? printMask = null)
            {
                var sb = new StructuredStringBuilder();
                Print(sb, printMask);
                return sb.ToString();
            }

            public void Print(StructuredStringBuilder sb, SceneAction.Mask<bool>? printMask = null)
            {
                sb.AppendLine($"{nameof(SceneAction.Mask<TItem>)} =>");
                using (sb.Brace())
                {
                    if (printMask?.Type ?? true)
                    {
                        sb.AppendItem(Type, "Type");
                    }
                    if (printMask?.Name ?? true)
                    {
                        sb.AppendItem(Name, "Name");
                    }
                    if (printMask?.ActorID ?? true)
                    {
                        sb.AppendItem(ActorID, "ActorID");
                    }
                    if (printMask?.LNAM ?? true)
                    {
                        sb.AppendItem(LNAM, "LNAM");
                    }
                    if (printMask?.Index ?? true)
                    {
                        sb.AppendItem(Index, "Index");
                    }
                    if (printMask?.Flags ?? true)
                    {
                        sb.AppendItem(Flags, "Flags");
                    }
                    if (printMask?.StartPhase ?? true)
                    {
                        sb.AppendItem(StartPhase, "StartPhase");
                    }
                    if (printMask?.EndPhase ?? true)
                    {
                        sb.AppendItem(EndPhase, "EndPhase");
                    }
                    if (printMask?.TimerSeconds ?? true)
                    {
                        sb.AppendItem(TimerSeconds, "TimerSeconds");
                    }
                    if ((printMask?.Packages?.Overall ?? true)
                        && Packages is {} PackagesItem)
                    {
                        sb.AppendLine("Packages =>");
                        using (sb.Brace())
                        {
                            sb.AppendItem(PackagesItem.Overall);
                            if (PackagesItem.Specific != null)
                            {
                                foreach (var subItem in PackagesItem.Specific)
                                {
                                    using (sb.Brace())
                                    {
                                        {
                                            sb.AppendItem(subItem);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (printMask?.Topic ?? true)
                    {
                        sb.AppendItem(Topic, "Topic");
                    }
                    if (printMask?.HeadtrackActorID ?? true)
                    {
                        sb.AppendItem(HeadtrackActorID, "HeadtrackActorID");
                    }
                    if (printMask?.LoopingMax ?? true)
                    {
                        sb.AppendItem(LoopingMax, "LoopingMax");
                    }
                    if (printMask?.LoopingMin ?? true)
                    {
                        sb.AppendItem(LoopingMin, "LoopingMin");
                    }
                    if (printMask?.Emotion ?? true)
                    {
                        sb.AppendItem(Emotion, "Emotion");
                    }
                    if (printMask?.EmotionValue ?? true)
                    {
                        sb.AppendItem(EmotionValue, "EmotionValue");
                    }
                    if (printMask?.Unused?.Overall ?? true)
                    {
                        Unused?.Print(sb);
                    }
                }
            }
            #endregion

        }

        public class ErrorMask :
            IErrorMask,
            IErrorMask<ErrorMask>
        {
            #region Members
            public Exception? Overall { get; set; }
            private List<string>? _warnings;
            public List<string> Warnings
            {
                get
                {
                    if (_warnings == null)
                    {
                        _warnings = new List<string>();
                    }
                    return _warnings;
                }
            }
            public Exception? Type;
            public Exception? Name;
            public Exception? ActorID;
            public Exception? LNAM;
            public Exception? Index;
            public Exception? Flags;
            public Exception? StartPhase;
            public Exception? EndPhase;
            public Exception? TimerSeconds;
            public MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>? Packages;
            public Exception? Topic;
            public Exception? HeadtrackActorID;
            public Exception? LoopingMax;
            public Exception? LoopingMin;
            public Exception? Emotion;
            public Exception? EmotionValue;
            public MaskItem<Exception?, ScenePhaseUnusedData.ErrorMask?>? Unused;
            #endregion

            #region IErrorMask
            public object? GetNthMask(int index)
            {
                SceneAction_FieldIndex enu = (SceneAction_FieldIndex)index;
                switch (enu)
                {
                    case SceneAction_FieldIndex.Type:
                        return Type;
                    case SceneAction_FieldIndex.Name:
                        return Name;
                    case SceneAction_FieldIndex.ActorID:
                        return ActorID;
                    case SceneAction_FieldIndex.LNAM:
                        return LNAM;
                    case SceneAction_FieldIndex.Index:
                        return Index;
                    case SceneAction_FieldIndex.Flags:
                        return Flags;
                    case SceneAction_FieldIndex.StartPhase:
                        return StartPhase;
                    case SceneAction_FieldIndex.EndPhase:
                        return EndPhase;
                    case SceneAction_FieldIndex.TimerSeconds:
                        return TimerSeconds;
                    case SceneAction_FieldIndex.Packages:
                        return Packages;
                    case SceneAction_FieldIndex.Topic:
                        return Topic;
                    case SceneAction_FieldIndex.HeadtrackActorID:
                        return HeadtrackActorID;
                    case SceneAction_FieldIndex.LoopingMax:
                        return LoopingMax;
                    case SceneAction_FieldIndex.LoopingMin:
                        return LoopingMin;
                    case SceneAction_FieldIndex.Emotion:
                        return Emotion;
                    case SceneAction_FieldIndex.EmotionValue:
                        return EmotionValue;
                    case SceneAction_FieldIndex.Unused:
                        return Unused;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthException(int index, Exception ex)
            {
                SceneAction_FieldIndex enu = (SceneAction_FieldIndex)index;
                switch (enu)
                {
                    case SceneAction_FieldIndex.Type:
                        this.Type = ex;
                        break;
                    case SceneAction_FieldIndex.Name:
                        this.Name = ex;
                        break;
                    case SceneAction_FieldIndex.ActorID:
                        this.ActorID = ex;
                        break;
                    case SceneAction_FieldIndex.LNAM:
                        this.LNAM = ex;
                        break;
                    case SceneAction_FieldIndex.Index:
                        this.Index = ex;
                        break;
                    case SceneAction_FieldIndex.Flags:
                        this.Flags = ex;
                        break;
                    case SceneAction_FieldIndex.StartPhase:
                        this.StartPhase = ex;
                        break;
                    case SceneAction_FieldIndex.EndPhase:
                        this.EndPhase = ex;
                        break;
                    case SceneAction_FieldIndex.TimerSeconds:
                        this.TimerSeconds = ex;
                        break;
                    case SceneAction_FieldIndex.Packages:
                        this.Packages = new MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>(ex, null);
                        break;
                    case SceneAction_FieldIndex.Topic:
                        this.Topic = ex;
                        break;
                    case SceneAction_FieldIndex.HeadtrackActorID:
                        this.HeadtrackActorID = ex;
                        break;
                    case SceneAction_FieldIndex.LoopingMax:
                        this.LoopingMax = ex;
                        break;
                    case SceneAction_FieldIndex.LoopingMin:
                        this.LoopingMin = ex;
                        break;
                    case SceneAction_FieldIndex.Emotion:
                        this.Emotion = ex;
                        break;
                    case SceneAction_FieldIndex.EmotionValue:
                        this.EmotionValue = ex;
                        break;
                    case SceneAction_FieldIndex.Unused:
                        this.Unused = new MaskItem<Exception?, ScenePhaseUnusedData.ErrorMask?>(ex, null);
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthMask(int index, object obj)
            {
                SceneAction_FieldIndex enu = (SceneAction_FieldIndex)index;
                switch (enu)
                {
                    case SceneAction_FieldIndex.Type:
                        this.Type = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.Name:
                        this.Name = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.ActorID:
                        this.ActorID = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.LNAM:
                        this.LNAM = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.Index:
                        this.Index = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.Flags:
                        this.Flags = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.StartPhase:
                        this.StartPhase = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.EndPhase:
                        this.EndPhase = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.TimerSeconds:
                        this.TimerSeconds = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.Packages:
                        this.Packages = (MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>)obj;
                        break;
                    case SceneAction_FieldIndex.Topic:
                        this.Topic = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.HeadtrackActorID:
                        this.HeadtrackActorID = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.LoopingMax:
                        this.LoopingMax = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.LoopingMin:
                        this.LoopingMin = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.Emotion:
                        this.Emotion = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.EmotionValue:
                        this.EmotionValue = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.Unused:
                        this.Unused = (MaskItem<Exception?, ScenePhaseUnusedData.ErrorMask?>?)obj;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public bool IsInError()
            {
                if (Overall != null) return true;
                if (Type != null) return true;
                if (Name != null) return true;
                if (ActorID != null) return true;
                if (LNAM != null) return true;
                if (Index != null) return true;
                if (Flags != null) return true;
                if (StartPhase != null) return true;
                if (EndPhase != null) return true;
                if (TimerSeconds != null) return true;
                if (Packages != null) return true;
                if (Topic != null) return true;
                if (HeadtrackActorID != null) return true;
                if (LoopingMax != null) return true;
                if (LoopingMin != null) return true;
                if (Emotion != null) return true;
                if (EmotionValue != null) return true;
                if (Unused != null) return true;
                return false;
            }
            #endregion

            #region To String
            public override string ToString() => this.Print();

            public void Print(StructuredStringBuilder sb, string? name = null)
            {
                sb.AppendLine($"{(name ?? "ErrorMask")} =>");
                using (sb.Brace())
                {
                    if (this.Overall != null)
                    {
                        sb.AppendLine("Overall =>");
                        using (sb.Brace())
                        {
                            sb.AppendLine($"{this.Overall}");
                        }
                    }
                    PrintFillInternal(sb);
                }
            }
            protected void PrintFillInternal(StructuredStringBuilder sb)
            {
                {
                    sb.AppendItem(Type, "Type");
                }
                {
                    sb.AppendItem(Name, "Name");
                }
                {
                    sb.AppendItem(ActorID, "ActorID");
                }
                {
                    sb.AppendItem(LNAM, "LNAM");
                }
                {
                    sb.AppendItem(Index, "Index");
                }
                {
                    sb.AppendItem(Flags, "Flags");
                }
                {
                    sb.AppendItem(StartPhase, "StartPhase");
                }
                {
                    sb.AppendItem(EndPhase, "EndPhase");
                }
                {
                    sb.AppendItem(TimerSeconds, "TimerSeconds");
                }
                if (Packages is {} PackagesItem)
                {
                    sb.AppendLine("Packages =>");
                    using (sb.Brace())
                    {
                        sb.AppendItem(PackagesItem.Overall);
                        if (PackagesItem.Specific != null)
                        {
                            foreach (var subItem in PackagesItem.Specific)
                            {
                                using (sb.Brace())
                                {
                                    {
                                        sb.AppendItem(subItem);
                                    }
                                }
                            }
                        }
                    }
                }
                {
                    sb.AppendItem(Topic, "Topic");
                }
                {
                    sb.AppendItem(HeadtrackActorID, "HeadtrackActorID");
                }
                {
                    sb.AppendItem(LoopingMax, "LoopingMax");
                }
                {
                    sb.AppendItem(LoopingMin, "LoopingMin");
                }
                {
                    sb.AppendItem(Emotion, "Emotion");
                }
                {
                    sb.AppendItem(EmotionValue, "EmotionValue");
                }
                Unused?.Print(sb);
            }
            #endregion

            #region Combine
            public ErrorMask Combine(ErrorMask? rhs)
            {
                if (rhs == null) return this;
                var ret = new ErrorMask();
                ret.Type = this.Type.Combine(rhs.Type);
                ret.Name = this.Name.Combine(rhs.Name);
                ret.ActorID = this.ActorID.Combine(rhs.ActorID);
                ret.LNAM = this.LNAM.Combine(rhs.LNAM);
                ret.Index = this.Index.Combine(rhs.Index);
                ret.Flags = this.Flags.Combine(rhs.Flags);
                ret.StartPhase = this.StartPhase.Combine(rhs.StartPhase);
                ret.EndPhase = this.EndPhase.Combine(rhs.EndPhase);
                ret.TimerSeconds = this.TimerSeconds.Combine(rhs.TimerSeconds);
                ret.Packages = new MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>(Noggog.ExceptionExt.Combine(this.Packages?.Overall, rhs.Packages?.Overall), Noggog.ExceptionExt.Combine(this.Packages?.Specific, rhs.Packages?.Specific));
                ret.Topic = this.Topic.Combine(rhs.Topic);
                ret.HeadtrackActorID = this.HeadtrackActorID.Combine(rhs.HeadtrackActorID);
                ret.LoopingMax = this.LoopingMax.Combine(rhs.LoopingMax);
                ret.LoopingMin = this.LoopingMin.Combine(rhs.LoopingMin);
                ret.Emotion = this.Emotion.Combine(rhs.Emotion);
                ret.EmotionValue = this.EmotionValue.Combine(rhs.EmotionValue);
                ret.Unused = this.Unused.Combine(rhs.Unused, (l, r) => l.Combine(r));
                return ret;
            }
            public static ErrorMask? Combine(ErrorMask? lhs, ErrorMask? rhs)
            {
                if (lhs != null && rhs != null) return lhs.Combine(rhs);
                return lhs ?? rhs;
            }
            #endregion

            #region Factory
            public static ErrorMask Factory(ErrorMaskBuilder errorMask)
            {
                return new ErrorMask();
            }
            #endregion

        }
        public class TranslationMask : ITranslationMask
        {
            #region Members
            private TranslationCrystal? _crystal;
            public readonly bool DefaultOn;
            public bool OnOverall;
            public bool Type;
            public bool Name;
            public bool ActorID;
            public bool LNAM;
            public bool Index;
            public bool Flags;
            public bool StartPhase;
            public bool EndPhase;
            public bool TimerSeconds;
            public bool Packages;
            public bool Topic;
            public bool HeadtrackActorID;
            public bool LoopingMax;
            public bool LoopingMin;
            public bool Emotion;
            public bool EmotionValue;
            public ScenePhaseUnusedData.TranslationMask? Unused;
            #endregion

            #region Ctors
            public TranslationMask(
                bool defaultOn,
                bool onOverall = true)
            {
                this.DefaultOn = defaultOn;
                this.OnOverall = onOverall;
                this.Type = defaultOn;
                this.Name = defaultOn;
                this.ActorID = defaultOn;
                this.LNAM = defaultOn;
                this.Index = defaultOn;
                this.Flags = defaultOn;
                this.StartPhase = defaultOn;
                this.EndPhase = defaultOn;
                this.TimerSeconds = defaultOn;
                this.Packages = defaultOn;
                this.Topic = defaultOn;
                this.HeadtrackActorID = defaultOn;
                this.LoopingMax = defaultOn;
                this.LoopingMin = defaultOn;
                this.Emotion = defaultOn;
                this.EmotionValue = defaultOn;
            }

            #endregion

            public TranslationCrystal GetCrystal()
            {
                if (_crystal != null) return _crystal;
                var ret = new List<(bool On, TranslationCrystal? SubCrystal)>();
                GetCrystal(ret);
                _crystal = new TranslationCrystal(ret.ToArray());
                return _crystal;
            }

            protected void GetCrystal(List<(bool On, TranslationCrystal? SubCrystal)> ret)
            {
                ret.Add((Type, null));
                ret.Add((Name, null));
                ret.Add((ActorID, null));
                ret.Add((LNAM, null));
                ret.Add((Index, null));
                ret.Add((Flags, null));
                ret.Add((StartPhase, null));
                ret.Add((EndPhase, null));
                ret.Add((TimerSeconds, null));
                ret.Add((Packages, null));
                ret.Add((Topic, null));
                ret.Add((HeadtrackActorID, null));
                ret.Add((LoopingMax, null));
                ret.Add((LoopingMin, null));
                ret.Add((Emotion, null));
                ret.Add((EmotionValue, null));
                ret.Add((Unused != null ? Unused.OnOverall : DefaultOn, Unused?.GetCrystal()));
            }

            public static implicit operator TranslationMask(bool defaultOn)
            {
                return new TranslationMask(defaultOn: defaultOn, onOverall: defaultOn);
            }

        }
        #endregion

        #region Mutagen
        public IEnumerable<IFormLinkGetter> EnumerateFormLinks() => SceneActionCommon.Instance.EnumerateFormLinks(this);
        public void RemapLinks(IReadOnlyDictionary<FormKey, FormKey> mapping) => SceneActionSetterCommon.Instance.RemapLinks(this, mapping);
        #endregion

        #region Binary Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => SceneActionBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((SceneActionBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }
        #region Binary Create
        public static SceneAction CreateFromBinary(
            MutagenFrame frame,
            TypedParseParams translationParams = default)
        {
            var ret = new SceneAction();
            ((SceneActionSetterCommon)((ISceneActionGetter)ret).CommonSetterInstance()!).CopyInFromBinary(
                item: ret,
                frame: frame,
                translationParams: translationParams);
            return ret;
        }

        #endregion

        public static bool TryCreateFromBinary(
            MutagenFrame frame,
            out SceneAction item,
            TypedParseParams translationParams = default)
        {
            var startPos = frame.Position;
            item = CreateFromBinary(
                frame: frame,
                translationParams: translationParams);
            return startPos != frame.Position;
        }
        #endregion

        void IPrintable.Print(StructuredStringBuilder sb, string? name) => this.Print(sb, name);

        void IClearable.Clear()
        {
            ((SceneActionSetterCommon)((ISceneActionGetter)this).CommonSetterInstance()!).Clear(this);
        }

        internal static SceneAction GetNew()
        {
            return new SceneAction();
        }

    }
    #endregion

    #region Interface
    public partial interface ISceneAction :
        IFormLinkContainer,
        ILoquiObjectSetter<ISceneAction>,
        INamed,
        INamedRequired,
        ISceneActionGetter
    {
        new SceneAction.TypeEnum Type { get; set; }
        /// <summary>
        /// Aspects: INamed, INamedRequired
        /// </summary>
        new String? Name { get; set; }
        new Int32? ActorID { get; set; }
        new MemorySlice<Byte>? LNAM { get; set; }
        new UInt32? Index { get; set; }
        new SceneAction.Flag? Flags { get; set; }
        new UInt32? StartPhase { get; set; }
        new UInt32? EndPhase { get; set; }
        new Single? TimerSeconds { get; set; }
        new ExtendedList<IFormLinkGetter<IPackageGetter>> Packages { get; }
        new IFormLinkNullable<IDialogTopicGetter> Topic { get; set; }
        new Int32? HeadtrackActorID { get; set; }
        new Single? LoopingMax { get; set; }
        new Single? LoopingMin { get; set; }
        new Emotion? Emotion { get; set; }
        new UInt32? EmotionValue { get; set; }
        new ScenePhaseUnusedData? Unused { get; set; }
    }

    public partial interface ISceneActionGetter :
        ILoquiObject,
        IBinaryItem,
        IFormLinkContainerGetter,
        ILoquiObject<ISceneActionGetter>,
        INamedGetter,
        INamedRequiredGetter
    {
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object? CommonSetterInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonSetterTranslationInstance();
        static ILoquiRegistration StaticRegistration => SceneAction_Registration.Instance;
        SceneAction.TypeEnum Type { get; }
        #region Name
        /// <summary>
        /// Aspects: INamedGetter, INamedRequiredGetter
        /// </summary>
        String? Name { get; }
        #endregion
        Int32? ActorID { get; }
        ReadOnlyMemorySlice<Byte>? LNAM { get; }
        UInt32? Index { get; }
        SceneAction.Flag? Flags { get; }
        UInt32? StartPhase { get; }
        UInt32? EndPhase { get; }
        Single? TimerSeconds { get; }
        IReadOnlyList<IFormLinkGetter<IPackageGetter>> Packages { get; }
        IFormLinkNullableGetter<IDialogTopicGetter> Topic { get; }
        Int32? HeadtrackActorID { get; }
        Single? LoopingMax { get; }
        Single? LoopingMin { get; }
        Emotion? Emotion { get; }
        UInt32? EmotionValue { get; }
        IScenePhaseUnusedDataGetter? Unused { get; }

    }

    #endregion

    #region Common MixIn
    public static partial class SceneActionMixIn
    {
        public static void Clear(this ISceneAction item)
        {
            ((SceneActionSetterCommon)((ISceneActionGetter)item).CommonSetterInstance()!).Clear(item: item);
        }

        public static SceneAction.Mask<bool> GetEqualsMask(
            this ISceneActionGetter item,
            ISceneActionGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            return ((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).GetEqualsMask(
                item: item,
                rhs: rhs,
                include: include);
        }

        public static string Print(
            this ISceneActionGetter item,
            string? name = null,
            SceneAction.Mask<bool>? printMask = null)
        {
            return ((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).Print(
                item: item,
                name: name,
                printMask: printMask);
        }

        public static void Print(
            this ISceneActionGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            SceneAction.Mask<bool>? printMask = null)
        {
            ((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).Print(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
        }

        public static bool Equals(
            this ISceneActionGetter item,
            ISceneActionGetter rhs,
            SceneAction.TranslationMask? equalsMask = null)
        {
            return ((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).Equals(
                lhs: item,
                rhs: rhs,
                equalsMask: equalsMask?.GetCrystal());
        }

        public static void DeepCopyIn(
            this ISceneAction lhs,
            ISceneActionGetter rhs)
        {
            ((SceneActionSetterTranslationCommon)((ISceneActionGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: default,
                deepCopy: false);
        }

        public static void DeepCopyIn(
            this ISceneAction lhs,
            ISceneActionGetter rhs,
            SceneAction.TranslationMask? copyMask = null)
        {
            ((SceneActionSetterTranslationCommon)((ISceneActionGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
        }

        public static void DeepCopyIn(
            this ISceneAction lhs,
            ISceneActionGetter rhs,
            out SceneAction.ErrorMask errorMask,
            SceneAction.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            ((SceneActionSetterTranslationCommon)((ISceneActionGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
            errorMask = SceneAction.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void DeepCopyIn(
            this ISceneAction lhs,
            ISceneActionGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            ((SceneActionSetterTranslationCommon)((ISceneActionGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: false);
        }

        public static SceneAction DeepCopy(
            this ISceneActionGetter item,
            SceneAction.TranslationMask? copyMask = null)
        {
            return ((SceneActionSetterTranslationCommon)((ISceneActionGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask);
        }

        public static SceneAction DeepCopy(
            this ISceneActionGetter item,
            out SceneAction.ErrorMask errorMask,
            SceneAction.TranslationMask? copyMask = null)
        {
            return ((SceneActionSetterTranslationCommon)((ISceneActionGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: out errorMask);
        }

        public static SceneAction DeepCopy(
            this ISceneActionGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            return ((SceneActionSetterTranslationCommon)((ISceneActionGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: errorMask);
        }

        #region Binary Translation
        public static void CopyInFromBinary(
            this ISceneAction item,
            MutagenFrame frame,
            TypedParseParams translationParams = default)
        {
            ((SceneActionSetterCommon)((ISceneActionGetter)item).CommonSetterInstance()!).CopyInFromBinary(
                item: item,
                frame: frame,
                translationParams: translationParams);
        }

        #endregion

    }
    #endregion

}

namespace Mutagen.Bethesda.Skyrim
{
    #region Field Index
    internal enum SceneAction_FieldIndex
    {
        Type = 0,
        Name = 1,
        ActorID = 2,
        LNAM = 3,
        Index = 4,
        Flags = 5,
        StartPhase = 6,
        EndPhase = 7,
        TimerSeconds = 8,
        Packages = 9,
        Topic = 10,
        HeadtrackActorID = 11,
        LoopingMax = 12,
        LoopingMin = 13,
        Emotion = 14,
        EmotionValue = 15,
        Unused = 16,
    }
    #endregion

    #region Registration
    internal partial class SceneAction_Registration : ILoquiRegistration
    {
        public static readonly SceneAction_Registration Instance = new SceneAction_Registration();

        public static ProtocolKey ProtocolKey => ProtocolDefinition_Skyrim.ProtocolKey;

        public const ushort AdditionalFieldCount = 17;

        public const ushort FieldCount = 17;

        public static readonly Type MaskType = typeof(SceneAction.Mask<>);

        public static readonly Type ErrorMaskType = typeof(SceneAction.ErrorMask);

        public static readonly Type ClassType = typeof(SceneAction);

        public static readonly Type GetterType = typeof(ISceneActionGetter);

        public static readonly Type? InternalGetterType = null;

        public static readonly Type SetterType = typeof(ISceneAction);

        public static readonly Type? InternalSetterType = null;

        public const string FullName = "Mutagen.Bethesda.Skyrim.SceneAction";

        public const string Name = "SceneAction";

        public const string Namespace = "Mutagen.Bethesda.Skyrim";

        public const byte GenericCount = 0;

        public static readonly Type? GenericRegistrationType = null;

        public static readonly RecordType TriggeringRecordType = RecordTypes.ANAM;
        public static RecordTriggerSpecs TriggerSpecs => _recordSpecs.Value;
        private static readonly Lazy<RecordTriggerSpecs> _recordSpecs = new Lazy<RecordTriggerSpecs>(() =>
        {
            var triggers = RecordCollection.Factory(RecordTypes.ANAM);
            var all = RecordCollection.Factory(
                RecordTypes.ANAM,
                RecordTypes.NAM0,
                RecordTypes.ALID,
                RecordTypes.LNAM,
                RecordTypes.INAM,
                RecordTypes.FNAM,
                RecordTypes.SNAM,
                RecordTypes.ENAM,
                RecordTypes.PNAM,
                RecordTypes.DATA,
                RecordTypes.HTID,
                RecordTypes.DMAX,
                RecordTypes.DMIN,
                RecordTypes.DEMO,
                RecordTypes.DEVA,
                RecordTypes.SCHR,
                RecordTypes.SCDA,
                RecordTypes.SCTX,
                RecordTypes.QNAM,
                RecordTypes.SCRO);
            return new RecordTriggerSpecs(
                allRecordTypes: all,
                triggeringRecordTypes: triggers);
        });
        public static readonly Type BinaryWriteTranslation = typeof(SceneActionBinaryWriteTranslation);
        #region Interface
        ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;
        ushort ILoquiRegistration.FieldCount => FieldCount;
        ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;
        Type ILoquiRegistration.MaskType => MaskType;
        Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;
        Type ILoquiRegistration.ClassType => ClassType;
        Type ILoquiRegistration.SetterType => SetterType;
        Type? ILoquiRegistration.InternalSetterType => InternalSetterType;
        Type ILoquiRegistration.GetterType => GetterType;
        Type? ILoquiRegistration.InternalGetterType => InternalGetterType;
        string ILoquiRegistration.FullName => FullName;
        string ILoquiRegistration.Name => Name;
        string ILoquiRegistration.Namespace => Namespace;
        byte ILoquiRegistration.GenericCount => GenericCount;
        Type? ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;
        ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsLoqui(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsSingleton(ushort index) => throw new NotImplementedException();
        string ILoquiRegistration.GetNthName(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsNthDerivative(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsProtected(ushort index) => throw new NotImplementedException();
        Type ILoquiRegistration.GetNthType(ushort index) => throw new NotImplementedException();
        #endregion

    }
    #endregion

    #region Common
    internal partial class SceneActionSetterCommon
    {
        public static readonly SceneActionSetterCommon Instance = new SceneActionSetterCommon();

        partial void ClearPartial();
        
        public void Clear(ISceneAction item)
        {
            ClearPartial();
            item.Type = default(SceneAction.TypeEnum);
            item.Name = default;
            item.ActorID = default;
            item.LNAM = default;
            item.Index = default;
            item.Flags = default;
            item.StartPhase = default;
            item.EndPhase = default;
            item.TimerSeconds = default;
            item.Packages.Clear();
            item.Topic.Clear();
            item.HeadtrackActorID = default;
            item.LoopingMax = default;
            item.LoopingMin = default;
            item.Emotion = default;
            item.EmotionValue = default;
            item.Unused = null;
        }
        
        #region Mutagen
        public void RemapLinks(ISceneAction obj, IReadOnlyDictionary<FormKey, FormKey> mapping)
        {
            obj.Packages.RemapLinks(mapping);
            obj.Topic.Relink(mapping);
        }
        
        #endregion
        
        #region Binary Translation
        public virtual void CopyInFromBinary(
            ISceneAction item,
            MutagenFrame frame,
            TypedParseParams translationParams)
        {
            PluginUtilityTranslation.SubrecordParse(
                record: item,
                frame: frame,
                translationParams: translationParams,
                fillTyped: SceneActionBinaryCreateTranslation.FillBinaryRecordTypes);
        }
        
        #endregion
        
    }
    internal partial class SceneActionCommon
    {
        public static readonly SceneActionCommon Instance = new SceneActionCommon();

        public SceneAction.Mask<bool> GetEqualsMask(
            ISceneActionGetter item,
            ISceneActionGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            var ret = new SceneAction.Mask<bool>(false);
            ((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).FillEqualsMask(
                item: item,
                rhs: rhs,
                ret: ret,
                include: include);
            return ret;
        }
        
        public void FillEqualsMask(
            ISceneActionGetter item,
            ISceneActionGetter rhs,
            SceneAction.Mask<bool> ret,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            ret.Type = item.Type == rhs.Type;
            ret.Name = string.Equals(item.Name, rhs.Name);
            ret.ActorID = item.ActorID == rhs.ActorID;
            ret.LNAM = MemorySliceExt.SequenceEqual(item.LNAM, rhs.LNAM);
            ret.Index = item.Index == rhs.Index;
            ret.Flags = item.Flags == rhs.Flags;
            ret.StartPhase = item.StartPhase == rhs.StartPhase;
            ret.EndPhase = item.EndPhase == rhs.EndPhase;
            ret.TimerSeconds = item.TimerSeconds.EqualsWithin(rhs.TimerSeconds);
            ret.Packages = item.Packages.CollectionEqualsHelper(
                rhs.Packages,
                (l, r) => object.Equals(l, r),
                include);
            ret.Topic = item.Topic.Equals(rhs.Topic);
            ret.HeadtrackActorID = item.HeadtrackActorID == rhs.HeadtrackActorID;
            ret.LoopingMax = item.LoopingMax.EqualsWithin(rhs.LoopingMax);
            ret.LoopingMin = item.LoopingMin.EqualsWithin(rhs.LoopingMin);
            ret.Emotion = item.Emotion == rhs.Emotion;
            ret.EmotionValue = item.EmotionValue == rhs.EmotionValue;
            ret.Unused = EqualsMaskHelper.EqualsHelper(
                item.Unused,
                rhs.Unused,
                (loqLhs, loqRhs, incl) => loqLhs.GetEqualsMask(loqRhs, incl),
                include);
        }
        
        public string Print(
            ISceneActionGetter item,
            string? name = null,
            SceneAction.Mask<bool>? printMask = null)
        {
            var sb = new StructuredStringBuilder();
            Print(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
            return sb.ToString();
        }
        
        public void Print(
            ISceneActionGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            SceneAction.Mask<bool>? printMask = null)
        {
            if (name == null)
            {
                sb.AppendLine($"SceneAction =>");
            }
            else
            {
                sb.AppendLine($"{name} (SceneAction) =>");
            }
            using (sb.Brace())
            {
                ToStringFields(
                    item: item,
                    sb: sb,
                    printMask: printMask);
            }
        }
        
        protected static void ToStringFields(
            ISceneActionGetter item,
            StructuredStringBuilder sb,
            SceneAction.Mask<bool>? printMask = null)
        {
            if (printMask?.Type ?? true)
            {
                sb.AppendItem(item.Type, "Type");
            }
            if ((printMask?.Name ?? true)
                && item.Name is {} NameItem)
            {
                sb.AppendItem(NameItem, "Name");
            }
            if ((printMask?.ActorID ?? true)
                && item.ActorID is {} ActorIDItem)
            {
                sb.AppendItem(ActorIDItem, "ActorID");
            }
            if ((printMask?.LNAM ?? true)
                && item.LNAM is {} LNAMItem)
            {
                sb.AppendLine($"LNAM => {SpanExt.ToHexString(LNAMItem)}");
            }
            if ((printMask?.Index ?? true)
                && item.Index is {} IndexItem)
            {
                sb.AppendItem(IndexItem, "Index");
            }
            if ((printMask?.Flags ?? true)
                && item.Flags is {} FlagsItem)
            {
                sb.AppendItem(FlagsItem, "Flags");
            }
            if ((printMask?.StartPhase ?? true)
                && item.StartPhase is {} StartPhaseItem)
            {
                sb.AppendItem(StartPhaseItem, "StartPhase");
            }
            if ((printMask?.EndPhase ?? true)
                && item.EndPhase is {} EndPhaseItem)
            {
                sb.AppendItem(EndPhaseItem, "EndPhase");
            }
            if ((printMask?.TimerSeconds ?? true)
                && item.TimerSeconds is {} TimerSecondsItem)
            {
                sb.AppendItem(TimerSecondsItem, "TimerSeconds");
            }
            if (printMask?.Packages?.Overall ?? true)
            {
                sb.AppendLine("Packages =>");
                using (sb.Brace())
                {
                    foreach (var subItem in item.Packages)
                    {
                        using (sb.Brace())
                        {
                            sb.AppendItem(subItem.FormKey);
                        }
                    }
                }
            }
            if (printMask?.Topic ?? true)
            {
                sb.AppendItem(item.Topic.FormKeyNullable, "Topic");
            }
            if ((printMask?.HeadtrackActorID ?? true)
                && item.HeadtrackActorID is {} HeadtrackActorIDItem)
            {
                sb.AppendItem(HeadtrackActorIDItem, "HeadtrackActorID");
            }
            if ((printMask?.LoopingMax ?? true)
                && item.LoopingMax is {} LoopingMaxItem)
            {
                sb.AppendItem(LoopingMaxItem, "LoopingMax");
            }
            if ((printMask?.LoopingMin ?? true)
                && item.LoopingMin is {} LoopingMinItem)
            {
                sb.AppendItem(LoopingMinItem, "LoopingMin");
            }
            if ((printMask?.Emotion ?? true)
                && item.Emotion is {} EmotionItem)
            {
                sb.AppendItem(EmotionItem, "Emotion");
            }
            if ((printMask?.EmotionValue ?? true)
                && item.EmotionValue is {} EmotionValueItem)
            {
                sb.AppendItem(EmotionValueItem, "EmotionValue");
            }
            if ((printMask?.Unused?.Overall ?? true)
                && item.Unused is {} UnusedItem)
            {
                UnusedItem?.Print(sb, "Unused");
            }
        }
        
        #region Equals and Hash
        public virtual bool Equals(
            ISceneActionGetter? lhs,
            ISceneActionGetter? rhs,
            TranslationCrystal? equalsMask)
        {
            if (!EqualsMaskHelper.RefEquality(lhs, rhs, out var isEqual)) return isEqual;
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Type) ?? true))
            {
                if (lhs.Type != rhs.Type) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Name) ?? true))
            {
                if (!string.Equals(lhs.Name, rhs.Name)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.ActorID) ?? true))
            {
                if (lhs.ActorID != rhs.ActorID) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.LNAM) ?? true))
            {
                if (!MemorySliceExt.SequenceEqual(lhs.LNAM, rhs.LNAM)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Index) ?? true))
            {
                if (lhs.Index != rhs.Index) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Flags) ?? true))
            {
                if (lhs.Flags != rhs.Flags) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.StartPhase) ?? true))
            {
                if (lhs.StartPhase != rhs.StartPhase) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.EndPhase) ?? true))
            {
                if (lhs.EndPhase != rhs.EndPhase) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.TimerSeconds) ?? true))
            {
                if (!lhs.TimerSeconds.EqualsWithin(rhs.TimerSeconds)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Packages) ?? true))
            {
                if (!lhs.Packages.SequenceEqualNullable(rhs.Packages)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Topic) ?? true))
            {
                if (!lhs.Topic.Equals(rhs.Topic)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.HeadtrackActorID) ?? true))
            {
                if (lhs.HeadtrackActorID != rhs.HeadtrackActorID) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.LoopingMax) ?? true))
            {
                if (!lhs.LoopingMax.EqualsWithin(rhs.LoopingMax)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.LoopingMin) ?? true))
            {
                if (!lhs.LoopingMin.EqualsWithin(rhs.LoopingMin)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Emotion) ?? true))
            {
                if (lhs.Emotion != rhs.Emotion) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.EmotionValue) ?? true))
            {
                if (lhs.EmotionValue != rhs.EmotionValue) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Unused) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Unused, rhs.Unused, out var lhsUnused, out var rhsUnused, out var isUnusedEqual))
                {
                    if (!((ScenePhaseUnusedDataCommon)((IScenePhaseUnusedDataGetter)lhsUnused).CommonInstance()!).Equals(lhsUnused, rhsUnused, equalsMask?.GetSubCrystal((int)SceneAction_FieldIndex.Unused))) return false;
                }
                else if (!isUnusedEqual) return false;
            }
            return true;
        }
        
        public virtual int GetHashCode(ISceneActionGetter item)
        {
            var hash = new HashCode();
            hash.Add(item.Type);
            if (item.Name is {} Nameitem)
            {
                hash.Add(Nameitem);
            }
            if (item.ActorID is {} ActorIDitem)
            {
                hash.Add(ActorIDitem);
            }
            if (item.LNAM is {} LNAMItem)
            {
                hash.Add(LNAMItem);
            }
            if (item.Index is {} Indexitem)
            {
                hash.Add(Indexitem);
            }
            if (item.Flags is {} Flagsitem)
            {
                hash.Add(Flagsitem);
            }
            if (item.StartPhase is {} StartPhaseitem)
            {
                hash.Add(StartPhaseitem);
            }
            if (item.EndPhase is {} EndPhaseitem)
            {
                hash.Add(EndPhaseitem);
            }
            if (item.TimerSeconds is {} TimerSecondsitem)
            {
                hash.Add(TimerSecondsitem);
            }
            hash.Add(item.Packages);
            hash.Add(item.Topic);
            if (item.HeadtrackActorID is {} HeadtrackActorIDitem)
            {
                hash.Add(HeadtrackActorIDitem);
            }
            if (item.LoopingMax is {} LoopingMaxitem)
            {
                hash.Add(LoopingMaxitem);
            }
            if (item.LoopingMin is {} LoopingMinitem)
            {
                hash.Add(LoopingMinitem);
            }
            if (item.Emotion is {} Emotionitem)
            {
                hash.Add(Emotionitem);
            }
            if (item.EmotionValue is {} EmotionValueitem)
            {
                hash.Add(EmotionValueitem);
            }
            if (item.Unused is {} Unuseditem)
            {
                hash.Add(Unuseditem);
            }
            return hash.ToHashCode();
        }
        
        #endregion
        
        
        public object GetNew()
        {
            return SceneAction.GetNew();
        }
        
        #region Mutagen
        public IEnumerable<IFormLinkGetter> EnumerateFormLinks(ISceneActionGetter obj)
        {
            foreach (var item in obj.Packages)
            {
                yield return FormLinkInformation.Factory(item);
            }
            if (FormLinkInformation.TryFactory(obj.Topic, out var TopicInfo))
            {
                yield return TopicInfo;
            }
            yield break;
        }
        
        #endregion
        
    }
    internal partial class SceneActionSetterTranslationCommon
    {
        public static readonly SceneActionSetterTranslationCommon Instance = new SceneActionSetterTranslationCommon();

        #region DeepCopyIn
        public void DeepCopyIn(
            ISceneAction item,
            ISceneActionGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Type) ?? true))
            {
                item.Type = rhs.Type;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Name) ?? true))
            {
                item.Name = rhs.Name;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.ActorID) ?? true))
            {
                item.ActorID = rhs.ActorID;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.LNAM) ?? true))
            {
                if(rhs.LNAM is {} LNAMrhs)
                {
                    item.LNAM = LNAMrhs.ToArray();
                }
                else
                {
                    item.LNAM = default;
                }
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Index) ?? true))
            {
                item.Index = rhs.Index;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Flags) ?? true))
            {
                item.Flags = rhs.Flags;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.StartPhase) ?? true))
            {
                item.StartPhase = rhs.StartPhase;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.EndPhase) ?? true))
            {
                item.EndPhase = rhs.EndPhase;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.TimerSeconds) ?? true))
            {
                item.TimerSeconds = rhs.TimerSeconds;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Packages) ?? true))
            {
                errorMask?.PushIndex((int)SceneAction_FieldIndex.Packages);
                try
                {
                    item.Packages.SetTo(
                        rhs.Packages
                            .Select(b => (IFormLinkGetter<IPackageGetter>)new FormLink<IPackageGetter>(b.FormKey)));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Topic) ?? true))
            {
                item.Topic.SetTo(rhs.Topic.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.HeadtrackActorID) ?? true))
            {
                item.HeadtrackActorID = rhs.HeadtrackActorID;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.LoopingMax) ?? true))
            {
                item.LoopingMax = rhs.LoopingMax;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.LoopingMin) ?? true))
            {
                item.LoopingMin = rhs.LoopingMin;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Emotion) ?? true))
            {
                item.Emotion = rhs.Emotion;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.EmotionValue) ?? true))
            {
                item.EmotionValue = rhs.EmotionValue;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Unused) ?? true))
            {
                errorMask?.PushIndex((int)SceneAction_FieldIndex.Unused);
                try
                {
                    if(rhs.Unused is {} rhsUnused)
                    {
                        item.Unused = rhsUnused.DeepCopy(
                            errorMask: errorMask,
                            copyMask?.GetSubCrystal((int)SceneAction_FieldIndex.Unused));
                    }
                    else
                    {
                        item.Unused = default;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            DeepCopyInCustom(
                item: item,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        partial void DeepCopyInCustom(
            ISceneAction item,
            ISceneActionGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy);
        #endregion
        
        public SceneAction DeepCopy(
            ISceneActionGetter item,
            SceneAction.TranslationMask? copyMask = null)
        {
            SceneAction ret = (SceneAction)((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).GetNew();
            ((SceneActionSetterTranslationCommon)((ISceneActionGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: null,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            return ret;
        }
        
        public SceneAction DeepCopy(
            ISceneActionGetter item,
            out SceneAction.ErrorMask errorMask,
            SceneAction.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            SceneAction ret = (SceneAction)((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).GetNew();
            ((SceneActionSetterTranslationCommon)((ISceneActionGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                ret,
                item,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            errorMask = SceneAction.ErrorMask.Factory(errorMaskBuilder);
            return ret;
        }
        
        public SceneAction DeepCopy(
            ISceneActionGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            SceneAction ret = (SceneAction)((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).GetNew();
            ((SceneActionSetterTranslationCommon)((ISceneActionGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: true);
            return ret;
        }
        
    }
    #endregion

}

namespace Mutagen.Bethesda.Skyrim
{
    public partial class SceneAction
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => SceneAction_Registration.Instance;
        public static ILoquiRegistration StaticRegistration => SceneAction_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => SceneActionCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterInstance()
        {
            return SceneActionSetterCommon.Instance;
        }
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => SceneActionSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object ISceneActionGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object ISceneActionGetter.CommonSetterInstance() => this.CommonSetterInstance();
        [DebuggerStepThrough]
        object ISceneActionGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

    }
}

#region Modules
#region Binary Translation
namespace Mutagen.Bethesda.Skyrim
{
    public partial class SceneActionBinaryWriteTranslation : IBinaryWriteTranslator
    {
        public static readonly SceneActionBinaryWriteTranslation Instance = new();

        public static void WriteRecordTypes(
            ISceneActionGetter item,
            MutagenWriter writer,
            TypedWriteParams translationParams)
        {
            EnumBinaryTranslation<SceneAction.TypeEnum, MutagenFrame, MutagenWriter>.Instance.Write(
                writer,
                item.Type,
                length: 2,
                header: translationParams.ConvertToCustom(RecordTypes.ANAM));
            StringBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.Name,
                header: translationParams.ConvertToCustom(RecordTypes.NAM0),
                binaryType: StringBinaryType.NullTerminate);
            Int32BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.ActorID,
                header: translationParams.ConvertToCustom(RecordTypes.ALID));
            ByteArrayBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                writer: writer,
                item: item.LNAM,
                header: translationParams.ConvertToCustom(RecordTypes.LNAM));
            UInt32BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.Index,
                header: translationParams.ConvertToCustom(RecordTypes.INAM));
            EnumBinaryTranslation<SceneAction.Flag, MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer,
                item.Flags,
                length: 4,
                header: translationParams.ConvertToCustom(RecordTypes.FNAM));
            UInt32BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.StartPhase,
                header: translationParams.ConvertToCustom(RecordTypes.SNAM));
            UInt32BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.EndPhase,
                header: translationParams.ConvertToCustom(RecordTypes.ENAM));
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.TimerSeconds,
                header: translationParams.ConvertToCustom(RecordTypes.SNAM));
            Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<IFormLinkGetter<IPackageGetter>>.Instance.Write(
                writer: writer,
                items: item.Packages,
                transl: (MutagenWriter subWriter, IFormLinkGetter<IPackageGetter> subItem, TypedWriteParams conv) =>
                {
                    FormLinkBinaryTranslation.Instance.Write(
                        writer: subWriter,
                        item: subItem,
                        header: translationParams.ConvertToCustom(RecordTypes.PNAM));
                });
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.Topic,
                header: translationParams.ConvertToCustom(RecordTypes.DATA));
            Int32BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.HeadtrackActorID,
                header: translationParams.ConvertToCustom(RecordTypes.HTID));
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.LoopingMax,
                header: translationParams.ConvertToCustom(RecordTypes.DMAX));
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.LoopingMin,
                header: translationParams.ConvertToCustom(RecordTypes.DMIN));
            EnumBinaryTranslation<Emotion, MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer,
                item.Emotion,
                length: 4,
                header: translationParams.ConvertToCustom(RecordTypes.DEMO));
            UInt32BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.EmotionValue,
                header: translationParams.ConvertToCustom(RecordTypes.DEVA));
            if (item.Unused is {} UnusedItem)
            {
                ((ScenePhaseUnusedDataBinaryWriteTranslation)((IBinaryItem)UnusedItem).BinaryWriteTranslator).Write(
                    item: UnusedItem,
                    writer: writer,
                    translationParams: translationParams);
            }
            using (HeaderExport.Subrecord(writer, RecordTypes.ANAM)) { }
        }

        public void Write(
            MutagenWriter writer,
            ISceneActionGetter item,
            TypedWriteParams translationParams)
        {
            WriteRecordTypes(
                item: item,
                writer: writer,
                translationParams: translationParams);
        }

        public void Write(
            MutagenWriter writer,
            object item,
            TypedWriteParams translationParams = default)
        {
            Write(
                item: (ISceneActionGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

    }

    internal partial class SceneActionBinaryCreateTranslation
    {
        public static readonly SceneActionBinaryCreateTranslation Instance = new SceneActionBinaryCreateTranslation();

        public static ParseResult FillBinaryRecordTypes(
            ISceneAction item,
            MutagenFrame frame,
            PreviousParse lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            RecordType nextRecordType,
            int contentLength,
            TypedParseParams translationParams = default)
        {
            nextRecordType = translationParams.ConvertToStandard(nextRecordType);
            switch (nextRecordType.TypeInt)
            {
                case RecordTypeInts.ANAM:
                {
                    if (!lastParsed.ParsedIndex.HasValue)
                    {
                        if (lastParsed.ShortCircuit((int)SceneAction_FieldIndex.Type, translationParams)) return ParseResult.Stop;
                        frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                        item.Type = EnumBinaryTranslation<SceneAction.TypeEnum, MutagenFrame, MutagenWriter>.Instance.Parse(
                            reader: frame,
                            length: contentLength);
                        return new ParseResult((int)SceneAction_FieldIndex.Type, nextRecordType);
                    }
                    else if (lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.Unused)
                    {
                        frame.ReadSubrecord();
                        return ParseResult.Stop;
                    }
                    else
                    {
                        switch (recordParseCount?.GetOrAdd(nextRecordType) ?? 0)
                        {
                            case 0:
                                if (lastParsed.ShortCircuit((int)SceneAction_FieldIndex.Type, translationParams)) return ParseResult.Stop;
                                frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                                item.Type = EnumBinaryTranslation<SceneAction.TypeEnum, MutagenFrame, MutagenWriter>.Instance.Parse(
                                    reader: frame,
                                    length: contentLength);
                                return new ParseResult((int)SceneAction_FieldIndex.Type, nextRecordType);
                            case 1:
                                frame.ReadSubrecord();
                                return ParseResult.Stop;
                            default:
                                throw new NotImplementedException();
                        }
                    }
                }
                case RecordTypeInts.NAM0:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Name = StringBinaryTranslation.Instance.Parse(
                        reader: frame.SpawnWithLength(contentLength),
                        stringBinaryType: StringBinaryType.NullTerminate,
                        parseWhole: true);
                    return (int)SceneAction_FieldIndex.Name;
                }
                case RecordTypeInts.ALID:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.ActorID = frame.ReadInt32();
                    return (int)SceneAction_FieldIndex.ActorID;
                }
                case RecordTypeInts.LNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.LNAM = ByteArrayBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)SceneAction_FieldIndex.LNAM;
                }
                case RecordTypeInts.INAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Index = frame.ReadUInt32();
                    return (int)SceneAction_FieldIndex.Index;
                }
                case RecordTypeInts.FNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Flags = EnumBinaryTranslation<SceneAction.Flag, MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: frame,
                        length: contentLength);
                    return (int)SceneAction_FieldIndex.Flags;
                }
                case RecordTypeInts.SNAM:
                {
                    if (!lastParsed.ParsedIndex.HasValue
                        || lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.Flags)
                    {
                        frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                        item.StartPhase = frame.ReadUInt32();
                        return new ParseResult((int)SceneAction_FieldIndex.StartPhase, nextRecordType);
                    }
                    else if (lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.EndPhase)
                    {
                        frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                        item.TimerSeconds = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                        return new ParseResult((int)SceneAction_FieldIndex.TimerSeconds, nextRecordType);
                    }
                    else
                    {
                        switch (recordParseCount?.GetOrAdd(nextRecordType) ?? 0)
                        {
                            case 0:
                                frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                                item.StartPhase = frame.ReadUInt32();
                                return new ParseResult((int)SceneAction_FieldIndex.StartPhase, nextRecordType);
                            case 1:
                                frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                                item.TimerSeconds = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                                return new ParseResult((int)SceneAction_FieldIndex.TimerSeconds, nextRecordType);
                            default:
                                throw new NotImplementedException();
                        }
                    }
                }
                case RecordTypeInts.ENAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.EndPhase = frame.ReadUInt32();
                    return (int)SceneAction_FieldIndex.EndPhase;
                }
                case RecordTypeInts.PNAM:
                {
                    item.Packages.SetTo(
                        Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<IFormLinkGetter<IPackageGetter>>.Instance.Parse(
                            reader: frame,
                            triggeringRecord: translationParams.ConvertToCustom(RecordTypes.PNAM),
                            transl: FormLinkBinaryTranslation.Instance.Parse));
                    return (int)SceneAction_FieldIndex.Packages;
                }
                case RecordTypeInts.DATA:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Topic.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)SceneAction_FieldIndex.Topic;
                }
                case RecordTypeInts.HTID:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.HeadtrackActorID = frame.ReadInt32();
                    return (int)SceneAction_FieldIndex.HeadtrackActorID;
                }
                case RecordTypeInts.DMAX:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.LoopingMax = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)SceneAction_FieldIndex.LoopingMax;
                }
                case RecordTypeInts.DMIN:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.LoopingMin = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)SceneAction_FieldIndex.LoopingMin;
                }
                case RecordTypeInts.DEMO:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Emotion = EnumBinaryTranslation<Emotion, MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: frame,
                        length: contentLength);
                    return (int)SceneAction_FieldIndex.Emotion;
                }
                case RecordTypeInts.DEVA:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.EmotionValue = frame.ReadUInt32();
                    return (int)SceneAction_FieldIndex.EmotionValue;
                }
                case RecordTypeInts.SCHR:
                case RecordTypeInts.SCDA:
                case RecordTypeInts.SCTX:
                case RecordTypeInts.QNAM:
                case RecordTypeInts.SCRO:
                {
                    item.Unused = Mutagen.Bethesda.Skyrim.ScenePhaseUnusedData.CreateFromBinary(
                        frame: frame,
                        translationParams: translationParams.DoNotShortCircuit());
                    return (int)SceneAction_FieldIndex.Unused;
                }
                default:
                    return ParseResult.Stop;
            }
        }

    }

}
namespace Mutagen.Bethesda.Skyrim
{
    #region Binary Write Mixins
    public static class SceneActionBinaryTranslationMixIn
    {
        public static void WriteToBinary(
            this ISceneActionGetter item,
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((SceneActionBinaryWriteTranslation)item.BinaryWriteTranslator).Write(
                item: item,
                writer: writer,
                translationParams: translationParams);
        }

    }
    #endregion


}
namespace Mutagen.Bethesda.Skyrim
{
    internal partial class SceneActionBinaryOverlay :
        PluginBinaryOverlay,
        ISceneActionGetter
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => SceneAction_Registration.Instance;
        public static ILoquiRegistration StaticRegistration => SceneAction_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => SceneActionCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => SceneActionSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object ISceneActionGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object? ISceneActionGetter.CommonSetterInstance() => null;
        [DebuggerStepThrough]
        object ISceneActionGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

        void IPrintable.Print(StructuredStringBuilder sb, string? name) => this.Print(sb, name);

        public IEnumerable<IFormLinkGetter> EnumerateFormLinks() => SceneActionCommon.Instance.EnumerateFormLinks(this);
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => SceneActionBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((SceneActionBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }

        #region Type
        private int? _TypeLocation;
        public SceneAction.TypeEnum Type => _TypeLocation.HasValue ? (SceneAction.TypeEnum)BinaryPrimitives.ReadUInt16LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_recordData, _TypeLocation!.Value, _package.MetaData.Constants)) : default(SceneAction.TypeEnum);
        #endregion
        #region Name
        private int? _NameLocation;
        public String? Name => _NameLocation.HasValue ? BinaryStringUtility.ProcessWholeToZString(HeaderTranslation.ExtractSubrecordMemory(_recordData, _NameLocation.Value, _package.MetaData.Constants), encoding: _package.MetaData.Encodings.NonTranslated) : default(string?);
        #region Aspects
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        string INamedRequiredGetter.Name => this.Name ?? string.Empty;
        #endregion
        #endregion
        #region ActorID
        private int? _ActorIDLocation;
        public Int32? ActorID => _ActorIDLocation.HasValue ? BinaryPrimitives.ReadInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_recordData, _ActorIDLocation.Value, _package.MetaData.Constants)) : default(Int32?);
        #endregion
        #region LNAM
        private int? _LNAMLocation;
        public ReadOnlyMemorySlice<Byte>? LNAM => _LNAMLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_recordData, _LNAMLocation.Value, _package.MetaData.Constants) : default(ReadOnlyMemorySlice<byte>?);
        #endregion
        #region Index
        private int? _IndexLocation;
        public UInt32? Index => _IndexLocation.HasValue ? BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_recordData, _IndexLocation.Value, _package.MetaData.Constants)) : default(UInt32?);
        #endregion
        #region Flags
        private int? _FlagsLocation;
        public SceneAction.Flag? Flags => _FlagsLocation.HasValue ? (SceneAction.Flag)BinaryPrimitives.ReadInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_recordData, _FlagsLocation!.Value, _package.MetaData.Constants)) : default(SceneAction.Flag?);
        #endregion
        #region StartPhase
        private int? _StartPhaseLocation;
        public UInt32? StartPhase => _StartPhaseLocation.HasValue ? BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_recordData, _StartPhaseLocation.Value, _package.MetaData.Constants)) : default(UInt32?);
        #endregion
        #region EndPhase
        private int? _EndPhaseLocation;
        public UInt32? EndPhase => _EndPhaseLocation.HasValue ? BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_recordData, _EndPhaseLocation.Value, _package.MetaData.Constants)) : default(UInt32?);
        #endregion
        #region TimerSeconds
        private int? _TimerSecondsLocation;
        public Single? TimerSeconds => _TimerSecondsLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_recordData, _TimerSecondsLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        public IReadOnlyList<IFormLinkGetter<IPackageGetter>> Packages { get; private set; } = Array.Empty<IFormLinkGetter<IPackageGetter>>();
        #region Topic
        private int? _TopicLocation;
        public IFormLinkNullableGetter<IDialogTopicGetter> Topic => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IDialogTopicGetter>(_package, _recordData, _TopicLocation);
        #endregion
        #region HeadtrackActorID
        private int? _HeadtrackActorIDLocation;
        public Int32? HeadtrackActorID => _HeadtrackActorIDLocation.HasValue ? BinaryPrimitives.ReadInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_recordData, _HeadtrackActorIDLocation.Value, _package.MetaData.Constants)) : default(Int32?);
        #endregion
        #region LoopingMax
        private int? _LoopingMaxLocation;
        public Single? LoopingMax => _LoopingMaxLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_recordData, _LoopingMaxLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        #region LoopingMin
        private int? _LoopingMinLocation;
        public Single? LoopingMin => _LoopingMinLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_recordData, _LoopingMinLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        #region Emotion
        private int? _EmotionLocation;
        public Emotion? Emotion => _EmotionLocation.HasValue ? (Emotion)BinaryPrimitives.ReadInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_recordData, _EmotionLocation!.Value, _package.MetaData.Constants)) : default(Emotion?);
        #endregion
        #region EmotionValue
        private int? _EmotionValueLocation;
        public UInt32? EmotionValue => _EmotionValueLocation.HasValue ? BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_recordData, _EmotionValueLocation.Value, _package.MetaData.Constants)) : default(UInt32?);
        #endregion
        public IScenePhaseUnusedDataGetter? Unused { get; private set; }
        partial void CustomFactoryEnd(
            OverlayStream stream,
            int finalPos,
            int offset);

        partial void CustomCtor();
        protected SceneActionBinaryOverlay(
            MemoryPair memoryPair,
            BinaryOverlayFactoryPackage package)
            : base(
                memoryPair: memoryPair,
                package: package)
        {
            this.CustomCtor();
        }

        public static ISceneActionGetter SceneActionFactory(
            OverlayStream stream,
            BinaryOverlayFactoryPackage package,
            TypedParseParams translationParams = default)
        {
            stream = ExtractTypelessSubrecordRecordMemory(
                stream: stream,
                meta: package.MetaData.Constants,
                translationParams: translationParams,
                memoryPair: out var memoryPair,
                offset: out var offset,
                finalPos: out var finalPos);
            var ret = new SceneActionBinaryOverlay(
                memoryPair: memoryPair,
                package: package);
            ret.FillTypelessSubrecordTypes(
                stream: stream,
                finalPos: stream.Length,
                offset: offset,
                translationParams: translationParams,
                fill: ret.FillRecordType);
            return ret;
        }

        public static ISceneActionGetter SceneActionFactory(
            ReadOnlyMemorySlice<byte> slice,
            BinaryOverlayFactoryPackage package,
            TypedParseParams translationParams = default)
        {
            return SceneActionFactory(
                stream: new OverlayStream(slice, package),
                package: package,
                translationParams: translationParams);
        }

        public ParseResult FillRecordType(
            OverlayStream stream,
            int finalPos,
            int offset,
            RecordType type,
            PreviousParse lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            TypedParseParams translationParams = default)
        {
            type = translationParams.ConvertToStandard(type);
            switch (type.TypeInt)
            {
                case RecordTypeInts.ANAM:
                {
                    if (!lastParsed.ParsedIndex.HasValue)
                    {
                        if (lastParsed.ShortCircuit((int)SceneAction_FieldIndex.Type, translationParams)) return ParseResult.Stop;
                        _TypeLocation = (stream.Position - offset);
                        return new ParseResult((int)SceneAction_FieldIndex.Type, type);
                    }
                    else if (lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.Unused)
                    {
                        stream.ReadSubrecord();
                        return ParseResult.Stop;
                    }
                    else
                    {
                        switch (recordParseCount?.GetOrAdd(type) ?? 0)
                        {
                            case 0:
                            {
                                if (lastParsed.ShortCircuit((int)SceneAction_FieldIndex.Type, translationParams)) return ParseResult.Stop;
                                _TypeLocation = (stream.Position - offset);
                                return new ParseResult((int)SceneAction_FieldIndex.Type, type);
                            }
                            case 1:
                            {
                                stream.ReadSubrecord();
                                return ParseResult.Stop;
                            }
                            default:
                                throw new NotImplementedException();
                        }
                    }
                }
                case RecordTypeInts.NAM0:
                {
                    _NameLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.Name;
                }
                case RecordTypeInts.ALID:
                {
                    _ActorIDLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.ActorID;
                }
                case RecordTypeInts.LNAM:
                {
                    _LNAMLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.LNAM;
                }
                case RecordTypeInts.INAM:
                {
                    _IndexLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.Index;
                }
                case RecordTypeInts.FNAM:
                {
                    _FlagsLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.Flags;
                }
                case RecordTypeInts.SNAM:
                {
                    if (!lastParsed.ParsedIndex.HasValue
                        || lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.Flags)
                    {
                        _StartPhaseLocation = (stream.Position - offset);
                        return new ParseResult((int)SceneAction_FieldIndex.StartPhase, type);
                    }
                    else if (lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.EndPhase)
                    {
                        _TimerSecondsLocation = (stream.Position - offset);
                        return new ParseResult((int)SceneAction_FieldIndex.TimerSeconds, type);
                    }
                    else
                    {
                        switch (recordParseCount?.GetOrAdd(type) ?? 0)
                        {
                            case 0:
                            {
                                _StartPhaseLocation = (stream.Position - offset);
                                return new ParseResult((int)SceneAction_FieldIndex.StartPhase, type);
                            }
                            case 1:
                            {
                                _TimerSecondsLocation = (stream.Position - offset);
                                return new ParseResult((int)SceneAction_FieldIndex.TimerSeconds, type);
                            }
                            default:
                                throw new NotImplementedException();
                        }
                    }
                }
                case RecordTypeInts.ENAM:
                {
                    _EndPhaseLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.EndPhase;
                }
                case RecordTypeInts.PNAM:
                {
                    this.Packages = BinaryOverlayList.FactoryByArray<IFormLinkGetter<IPackageGetter>>(
                        mem: stream.RemainingMemory,
                        package: _package,
                        getter: (s, p) => FormLinkBinaryTranslation.Instance.OverlayFactory<IPackageGetter>(p, s),
                        locs: ParseRecordLocations(
                            stream: stream,
                            constants: _package.MetaData.Constants.SubConstants,
                            trigger: RecordTypes.PNAM,
                            skipHeader: true,
                            translationParams: translationParams));
                    return (int)SceneAction_FieldIndex.Packages;
                }
                case RecordTypeInts.DATA:
                {
                    _TopicLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.Topic;
                }
                case RecordTypeInts.HTID:
                {
                    _HeadtrackActorIDLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.HeadtrackActorID;
                }
                case RecordTypeInts.DMAX:
                {
                    _LoopingMaxLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.LoopingMax;
                }
                case RecordTypeInts.DMIN:
                {
                    _LoopingMinLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.LoopingMin;
                }
                case RecordTypeInts.DEMO:
                {
                    _EmotionLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.Emotion;
                }
                case RecordTypeInts.DEVA:
                {
                    _EmotionValueLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.EmotionValue;
                }
                case RecordTypeInts.SCHR:
                case RecordTypeInts.SCDA:
                case RecordTypeInts.SCTX:
                case RecordTypeInts.QNAM:
                case RecordTypeInts.SCRO:
                {
                    this.Unused = ScenePhaseUnusedDataBinaryOverlay.ScenePhaseUnusedDataFactory(
                        stream: stream,
                        package: _package,
                        translationParams: translationParams.DoNotShortCircuit());
                    return (int)SceneAction_FieldIndex.Unused;
                }
                default:
                    return ParseResult.Stop;
            }
        }
        #region To String

        public void Print(
            StructuredStringBuilder sb,
            string? name = null)
        {
            SceneActionMixIn.Print(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is not ISceneActionGetter rhs) return false;
            return ((SceneActionCommon)((ISceneActionGetter)this).CommonInstance()!).Equals(this, rhs, equalsMask: null);
        }

        public bool Equals(ISceneActionGetter? obj)
        {
            return ((SceneActionCommon)((ISceneActionGetter)this).CommonInstance()!).Equals(this, obj, equalsMask: null);
        }

        public override int GetHashCode() => ((SceneActionCommon)((ISceneActionGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

    }

}
#endregion

#endregion

