/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Autogenerated by Loqui.  Do not manually change.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*/
#region Usings
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Loqui;
using Loqui.Internal;
using Noggog;
using Mutagen.Bethesda.Skyrim.Internals;
using System.Reactive.Disposables;
using System.Reactive.Linq;
using Mutagen.Bethesda.Skyrim;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using Mutagen.Bethesda.Binary;
using System.Buffers.Binary;
using Mutagen.Bethesda.Internals;
#endregion

#nullable enable
namespace Mutagen.Bethesda.Skyrim
{
    #region Class
    public partial class SceneAction :
        ISceneAction,
        ILoquiObjectSetter<SceneAction>,
        IEquatable<SceneAction>
    {
        #region Ctor
        public SceneAction()
        {
            CustomCtor();
        }
        partial void CustomCtor();
        #endregion

        #region Type
        public SceneAction.TypeEnum Type { get; set; } = default;
        #endregion
        #region Name
        public String? Name { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        String? ISceneActionGetter.Name => this.Name;
        #endregion
        #region ActorID
        public Int32? ActorID { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Int32? ISceneActionGetter.ActorID => this.ActorID;
        #endregion
        #region LNAM
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected MemorySlice<Byte>? _LNAM;
        public MemorySlice<Byte>? LNAM
        {
            get => this._LNAM;
            set => this._LNAM = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ReadOnlyMemorySlice<Byte>? ISceneActionGetter.LNAM => this.LNAM;
        #endregion
        #region Index
        public UInt32? Index { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        UInt32? ISceneActionGetter.Index => this.Index;
        #endregion
        #region Flags
        public SceneAction.Flag? Flags { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SceneAction.Flag? ISceneActionGetter.Flags => this.Flags;
        #endregion
        #region StartPhase
        public UInt32? StartPhase { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        UInt32? ISceneActionGetter.StartPhase => this.StartPhase;
        #endregion
        #region EndPhase
        public UInt32? EndPhase { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        UInt32? ISceneActionGetter.EndPhase => this.EndPhase;
        #endregion
        #region TimerSeconds
        public Single? TimerSeconds { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? ISceneActionGetter.TimerSeconds => this.TimerSeconds;
        #endregion
        #region Packages
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private IExtendedList<IFormLink<Package>> _Packages = new ExtendedList<IFormLink<Package>>();
        public IExtendedList<IFormLink<Package>> Packages
        {
            get => this._Packages;
            protected set => this._Packages = value;
        }
        #region Interface Members
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IReadOnlyList<IFormLink<IPackageGetter>> ISceneActionGetter.Packages => _Packages;
        #endregion

        #endregion
        #region Topic
        public FormLinkNullable<DialogTopic> Topic { get; set; } = new FormLinkNullable<DialogTopic>();
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        FormLinkNullable<IDialogTopicGetter> ISceneActionGetter.Topic => this.Topic.ToGetter<DialogTopic, IDialogTopicGetter>();
        #endregion
        #region HeadtrackActorID
        public Int32? HeadtrackActorID { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Int32? ISceneActionGetter.HeadtrackActorID => this.HeadtrackActorID;
        #endregion
        #region LoopingMax
        public Single? LoopingMax { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? ISceneActionGetter.LoopingMax => this.LoopingMax;
        #endregion
        #region LoopingMin
        public Single? LoopingMin { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? ISceneActionGetter.LoopingMin => this.LoopingMin;
        #endregion
        #region Emotion
        public Emotion? Emotion { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Emotion? ISceneActionGetter.Emotion => this.Emotion;
        #endregion
        #region EmotionValue
        public UInt32? EmotionValue { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        UInt32? ISceneActionGetter.EmotionValue => this.EmotionValue;
        #endregion
        #region Unused
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private ScenePhaseUnusedData? _Unused;
        public ScenePhaseUnusedData? Unused
        {
            get => _Unused;
            set => _Unused = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IScenePhaseUnusedDataGetter? ISceneActionGetter.Unused => this.Unused;
        #endregion

        #region To String

        public void ToString(
            FileGeneration fg,
            string? name = null)
        {
            SceneActionMixIn.ToString(
                item: this,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (!(obj is ISceneActionGetter rhs)) return false;
            return ((SceneActionCommon)((ISceneActionGetter)this).CommonInstance()!).Equals(this, rhs);
        }

        public bool Equals(SceneAction? obj)
        {
            return ((SceneActionCommon)((ISceneActionGetter)this).CommonInstance()!).Equals(this, obj);
        }

        public override int GetHashCode() => ((SceneActionCommon)((ISceneActionGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        #region Mask
        public class Mask<TItem> :
            IMask<TItem>,
            IEquatable<Mask<TItem>>
        {
            #region Ctors
            public Mask(TItem initialValue)
            {
                this.Type = initialValue;
                this.Name = initialValue;
                this.ActorID = initialValue;
                this.LNAM = initialValue;
                this.Index = initialValue;
                this.Flags = initialValue;
                this.StartPhase = initialValue;
                this.EndPhase = initialValue;
                this.TimerSeconds = initialValue;
                this.Packages = new MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>(initialValue, Enumerable.Empty<(int Index, TItem Value)>());
                this.Topic = initialValue;
                this.HeadtrackActorID = initialValue;
                this.LoopingMax = initialValue;
                this.LoopingMin = initialValue;
                this.Emotion = initialValue;
                this.EmotionValue = initialValue;
                this.Unused = new MaskItem<TItem, ScenePhaseUnusedData.Mask<TItem>?>(initialValue, new ScenePhaseUnusedData.Mask<TItem>(initialValue));
            }

            public Mask(
                TItem Type,
                TItem Name,
                TItem ActorID,
                TItem LNAM,
                TItem Index,
                TItem Flags,
                TItem StartPhase,
                TItem EndPhase,
                TItem TimerSeconds,
                TItem Packages,
                TItem Topic,
                TItem HeadtrackActorID,
                TItem LoopingMax,
                TItem LoopingMin,
                TItem Emotion,
                TItem EmotionValue,
                TItem Unused)
            {
                this.Type = Type;
                this.Name = Name;
                this.ActorID = ActorID;
                this.LNAM = LNAM;
                this.Index = Index;
                this.Flags = Flags;
                this.StartPhase = StartPhase;
                this.EndPhase = EndPhase;
                this.TimerSeconds = TimerSeconds;
                this.Packages = new MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>(Packages, Enumerable.Empty<(int Index, TItem Value)>());
                this.Topic = Topic;
                this.HeadtrackActorID = HeadtrackActorID;
                this.LoopingMax = LoopingMax;
                this.LoopingMin = LoopingMin;
                this.Emotion = Emotion;
                this.EmotionValue = EmotionValue;
                this.Unused = new MaskItem<TItem, ScenePhaseUnusedData.Mask<TItem>?>(Unused, new ScenePhaseUnusedData.Mask<TItem>(Unused));
            }

            #pragma warning disable CS8618
            protected Mask()
            {
            }
            #pragma warning restore CS8618

            #endregion

            #region Members
            public TItem Type;
            public TItem Name;
            public TItem ActorID;
            public TItem LNAM;
            public TItem Index;
            public TItem Flags;
            public TItem StartPhase;
            public TItem EndPhase;
            public TItem TimerSeconds;
            public MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>? Packages;
            public TItem Topic;
            public TItem HeadtrackActorID;
            public TItem LoopingMax;
            public TItem LoopingMin;
            public TItem Emotion;
            public TItem EmotionValue;
            public MaskItem<TItem, ScenePhaseUnusedData.Mask<TItem>?>? Unused { get; set; }
            #endregion

            #region Equals
            public override bool Equals(object? obj)
            {
                if (!(obj is Mask<TItem> rhs)) return false;
                return Equals(rhs);
            }

            public bool Equals(Mask<TItem>? rhs)
            {
                if (rhs == null) return false;
                if (!object.Equals(this.Type, rhs.Type)) return false;
                if (!object.Equals(this.Name, rhs.Name)) return false;
                if (!object.Equals(this.ActorID, rhs.ActorID)) return false;
                if (!object.Equals(this.LNAM, rhs.LNAM)) return false;
                if (!object.Equals(this.Index, rhs.Index)) return false;
                if (!object.Equals(this.Flags, rhs.Flags)) return false;
                if (!object.Equals(this.StartPhase, rhs.StartPhase)) return false;
                if (!object.Equals(this.EndPhase, rhs.EndPhase)) return false;
                if (!object.Equals(this.TimerSeconds, rhs.TimerSeconds)) return false;
                if (!object.Equals(this.Packages, rhs.Packages)) return false;
                if (!object.Equals(this.Topic, rhs.Topic)) return false;
                if (!object.Equals(this.HeadtrackActorID, rhs.HeadtrackActorID)) return false;
                if (!object.Equals(this.LoopingMax, rhs.LoopingMax)) return false;
                if (!object.Equals(this.LoopingMin, rhs.LoopingMin)) return false;
                if (!object.Equals(this.Emotion, rhs.Emotion)) return false;
                if (!object.Equals(this.EmotionValue, rhs.EmotionValue)) return false;
                if (!object.Equals(this.Unused, rhs.Unused)) return false;
                return true;
            }
            public override int GetHashCode()
            {
                var hash = new HashCode();
                hash.Add(this.Type);
                hash.Add(this.Name);
                hash.Add(this.ActorID);
                hash.Add(this.LNAM);
                hash.Add(this.Index);
                hash.Add(this.Flags);
                hash.Add(this.StartPhase);
                hash.Add(this.EndPhase);
                hash.Add(this.TimerSeconds);
                hash.Add(this.Packages);
                hash.Add(this.Topic);
                hash.Add(this.HeadtrackActorID);
                hash.Add(this.LoopingMax);
                hash.Add(this.LoopingMin);
                hash.Add(this.Emotion);
                hash.Add(this.EmotionValue);
                hash.Add(this.Unused);
                return hash.ToHashCode();
            }

            #endregion

            #region All
            public bool All(Func<TItem, bool> eval)
            {
                if (!eval(this.Type)) return false;
                if (!eval(this.Name)) return false;
                if (!eval(this.ActorID)) return false;
                if (!eval(this.LNAM)) return false;
                if (!eval(this.Index)) return false;
                if (!eval(this.Flags)) return false;
                if (!eval(this.StartPhase)) return false;
                if (!eval(this.EndPhase)) return false;
                if (!eval(this.TimerSeconds)) return false;
                if (this.Packages != null)
                {
                    if (!eval(this.Packages.Overall)) return false;
                    if (this.Packages.Specific != null)
                    {
                        foreach (var item in this.Packages.Specific)
                        {
                            if (!eval(item.Value)) return false;
                        }
                    }
                }
                if (!eval(this.Topic)) return false;
                if (!eval(this.HeadtrackActorID)) return false;
                if (!eval(this.LoopingMax)) return false;
                if (!eval(this.LoopingMin)) return false;
                if (!eval(this.Emotion)) return false;
                if (!eval(this.EmotionValue)) return false;
                if (Unused != null)
                {
                    if (!eval(this.Unused.Overall)) return false;
                    if (this.Unused.Specific != null && !this.Unused.Specific.All(eval)) return false;
                }
                return true;
            }
            #endregion

            #region Any
            public bool Any(Func<TItem, bool> eval)
            {
                if (eval(this.Type)) return true;
                if (eval(this.Name)) return true;
                if (eval(this.ActorID)) return true;
                if (eval(this.LNAM)) return true;
                if (eval(this.Index)) return true;
                if (eval(this.Flags)) return true;
                if (eval(this.StartPhase)) return true;
                if (eval(this.EndPhase)) return true;
                if (eval(this.TimerSeconds)) return true;
                if (this.Packages != null)
                {
                    if (eval(this.Packages.Overall)) return true;
                    if (this.Packages.Specific != null)
                    {
                        foreach (var item in this.Packages.Specific)
                        {
                            if (!eval(item.Value)) return false;
                        }
                    }
                }
                if (eval(this.Topic)) return true;
                if (eval(this.HeadtrackActorID)) return true;
                if (eval(this.LoopingMax)) return true;
                if (eval(this.LoopingMin)) return true;
                if (eval(this.Emotion)) return true;
                if (eval(this.EmotionValue)) return true;
                if (Unused != null)
                {
                    if (eval(this.Unused.Overall)) return true;
                    if (this.Unused.Specific != null && this.Unused.Specific.Any(eval)) return true;
                }
                return false;
            }
            #endregion

            #region Translate
            public Mask<R> Translate<R>(Func<TItem, R> eval)
            {
                var ret = new SceneAction.Mask<R>();
                this.Translate_InternalFill(ret, eval);
                return ret;
            }

            protected void Translate_InternalFill<R>(Mask<R> obj, Func<TItem, R> eval)
            {
                obj.Type = eval(this.Type);
                obj.Name = eval(this.Name);
                obj.ActorID = eval(this.ActorID);
                obj.LNAM = eval(this.LNAM);
                obj.Index = eval(this.Index);
                obj.Flags = eval(this.Flags);
                obj.StartPhase = eval(this.StartPhase);
                obj.EndPhase = eval(this.EndPhase);
                obj.TimerSeconds = eval(this.TimerSeconds);
                if (Packages != null)
                {
                    obj.Packages = new MaskItem<R, IEnumerable<(int Index, R Value)>?>(eval(this.Packages.Overall), Enumerable.Empty<(int Index, R Value)>());
                    if (Packages.Specific != null)
                    {
                        var l = new List<(int Index, R Item)>();
                        obj.Packages.Specific = l;
                        foreach (var item in Packages.Specific.WithIndex())
                        {
                            R mask = eval(item.Item.Value);
                            l.Add((item.Index, mask));
                        }
                    }
                }
                obj.Topic = eval(this.Topic);
                obj.HeadtrackActorID = eval(this.HeadtrackActorID);
                obj.LoopingMax = eval(this.LoopingMax);
                obj.LoopingMin = eval(this.LoopingMin);
                obj.Emotion = eval(this.Emotion);
                obj.EmotionValue = eval(this.EmotionValue);
                obj.Unused = this.Unused == null ? null : new MaskItem<R, ScenePhaseUnusedData.Mask<R>?>(eval(this.Unused.Overall), this.Unused.Specific?.Translate(eval));
            }
            #endregion

            #region To String
            public override string ToString()
            {
                return ToString(printMask: null);
            }

            public string ToString(SceneAction.Mask<bool>? printMask = null)
            {
                var fg = new FileGeneration();
                ToString(fg, printMask);
                return fg.ToString();
            }

            public void ToString(FileGeneration fg, SceneAction.Mask<bool>? printMask = null)
            {
                fg.AppendLine($"{nameof(SceneAction.Mask<TItem>)} =>");
                fg.AppendLine("[");
                using (new DepthWrapper(fg))
                {
                    if (printMask?.Type ?? true)
                    {
                        fg.AppendItem(Type, "Type");
                    }
                    if (printMask?.Name ?? true)
                    {
                        fg.AppendItem(Name, "Name");
                    }
                    if (printMask?.ActorID ?? true)
                    {
                        fg.AppendItem(ActorID, "ActorID");
                    }
                    if (printMask?.LNAM ?? true)
                    {
                        fg.AppendItem(LNAM, "LNAM");
                    }
                    if (printMask?.Index ?? true)
                    {
                        fg.AppendItem(Index, "Index");
                    }
                    if (printMask?.Flags ?? true)
                    {
                        fg.AppendItem(Flags, "Flags");
                    }
                    if (printMask?.StartPhase ?? true)
                    {
                        fg.AppendItem(StartPhase, "StartPhase");
                    }
                    if (printMask?.EndPhase ?? true)
                    {
                        fg.AppendItem(EndPhase, "EndPhase");
                    }
                    if (printMask?.TimerSeconds ?? true)
                    {
                        fg.AppendItem(TimerSeconds, "TimerSeconds");
                    }
                    if ((printMask?.Packages?.Overall ?? true)
                        && Packages.TryGet(out var PackagesItem))
                    {
                        fg.AppendLine("Packages =>");
                        fg.AppendLine("[");
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendItem(PackagesItem.Overall);
                            if (PackagesItem.Specific != null)
                            {
                                foreach (var subItem in PackagesItem.Specific)
                                {
                                    fg.AppendLine("[");
                                    using (new DepthWrapper(fg))
                                    {
                                        fg.AppendItem(subItem);
                                    }
                                    fg.AppendLine("]");
                                }
                            }
                        }
                        fg.AppendLine("]");
                    }
                    if (printMask?.Topic ?? true)
                    {
                        fg.AppendItem(Topic, "Topic");
                    }
                    if (printMask?.HeadtrackActorID ?? true)
                    {
                        fg.AppendItem(HeadtrackActorID, "HeadtrackActorID");
                    }
                    if (printMask?.LoopingMax ?? true)
                    {
                        fg.AppendItem(LoopingMax, "LoopingMax");
                    }
                    if (printMask?.LoopingMin ?? true)
                    {
                        fg.AppendItem(LoopingMin, "LoopingMin");
                    }
                    if (printMask?.Emotion ?? true)
                    {
                        fg.AppendItem(Emotion, "Emotion");
                    }
                    if (printMask?.EmotionValue ?? true)
                    {
                        fg.AppendItem(EmotionValue, "EmotionValue");
                    }
                    if (printMask?.Unused?.Overall ?? true)
                    {
                        Unused?.ToString(fg);
                    }
                }
                fg.AppendLine("]");
            }
            #endregion

        }

        public class ErrorMask :
            IErrorMask,
            IErrorMask<ErrorMask>
        {
            #region Members
            public Exception? Overall { get; set; }
            private List<string>? _warnings;
            public List<string> Warnings
            {
                get
                {
                    if (_warnings == null)
                    {
                        _warnings = new List<string>();
                    }
                    return _warnings;
                }
            }
            public Exception? Type;
            public Exception? Name;
            public Exception? ActorID;
            public Exception? LNAM;
            public Exception? Index;
            public Exception? Flags;
            public Exception? StartPhase;
            public Exception? EndPhase;
            public Exception? TimerSeconds;
            public MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>? Packages;
            public Exception? Topic;
            public Exception? HeadtrackActorID;
            public Exception? LoopingMax;
            public Exception? LoopingMin;
            public Exception? Emotion;
            public Exception? EmotionValue;
            public MaskItem<Exception?, ScenePhaseUnusedData.ErrorMask?>? Unused;
            #endregion

            #region IErrorMask
            public object? GetNthMask(int index)
            {
                SceneAction_FieldIndex enu = (SceneAction_FieldIndex)index;
                switch (enu)
                {
                    case SceneAction_FieldIndex.Type:
                        return Type;
                    case SceneAction_FieldIndex.Name:
                        return Name;
                    case SceneAction_FieldIndex.ActorID:
                        return ActorID;
                    case SceneAction_FieldIndex.LNAM:
                        return LNAM;
                    case SceneAction_FieldIndex.Index:
                        return Index;
                    case SceneAction_FieldIndex.Flags:
                        return Flags;
                    case SceneAction_FieldIndex.StartPhase:
                        return StartPhase;
                    case SceneAction_FieldIndex.EndPhase:
                        return EndPhase;
                    case SceneAction_FieldIndex.TimerSeconds:
                        return TimerSeconds;
                    case SceneAction_FieldIndex.Packages:
                        return Packages;
                    case SceneAction_FieldIndex.Topic:
                        return Topic;
                    case SceneAction_FieldIndex.HeadtrackActorID:
                        return HeadtrackActorID;
                    case SceneAction_FieldIndex.LoopingMax:
                        return LoopingMax;
                    case SceneAction_FieldIndex.LoopingMin:
                        return LoopingMin;
                    case SceneAction_FieldIndex.Emotion:
                        return Emotion;
                    case SceneAction_FieldIndex.EmotionValue:
                        return EmotionValue;
                    case SceneAction_FieldIndex.Unused:
                        return Unused;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthException(int index, Exception ex)
            {
                SceneAction_FieldIndex enu = (SceneAction_FieldIndex)index;
                switch (enu)
                {
                    case SceneAction_FieldIndex.Type:
                        this.Type = ex;
                        break;
                    case SceneAction_FieldIndex.Name:
                        this.Name = ex;
                        break;
                    case SceneAction_FieldIndex.ActorID:
                        this.ActorID = ex;
                        break;
                    case SceneAction_FieldIndex.LNAM:
                        this.LNAM = ex;
                        break;
                    case SceneAction_FieldIndex.Index:
                        this.Index = ex;
                        break;
                    case SceneAction_FieldIndex.Flags:
                        this.Flags = ex;
                        break;
                    case SceneAction_FieldIndex.StartPhase:
                        this.StartPhase = ex;
                        break;
                    case SceneAction_FieldIndex.EndPhase:
                        this.EndPhase = ex;
                        break;
                    case SceneAction_FieldIndex.TimerSeconds:
                        this.TimerSeconds = ex;
                        break;
                    case SceneAction_FieldIndex.Packages:
                        this.Packages = new MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>(ex, null);
                        break;
                    case SceneAction_FieldIndex.Topic:
                        this.Topic = ex;
                        break;
                    case SceneAction_FieldIndex.HeadtrackActorID:
                        this.HeadtrackActorID = ex;
                        break;
                    case SceneAction_FieldIndex.LoopingMax:
                        this.LoopingMax = ex;
                        break;
                    case SceneAction_FieldIndex.LoopingMin:
                        this.LoopingMin = ex;
                        break;
                    case SceneAction_FieldIndex.Emotion:
                        this.Emotion = ex;
                        break;
                    case SceneAction_FieldIndex.EmotionValue:
                        this.EmotionValue = ex;
                        break;
                    case SceneAction_FieldIndex.Unused:
                        this.Unused = new MaskItem<Exception?, ScenePhaseUnusedData.ErrorMask?>(ex, null);
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthMask(int index, object obj)
            {
                SceneAction_FieldIndex enu = (SceneAction_FieldIndex)index;
                switch (enu)
                {
                    case SceneAction_FieldIndex.Type:
                        this.Type = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.Name:
                        this.Name = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.ActorID:
                        this.ActorID = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.LNAM:
                        this.LNAM = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.Index:
                        this.Index = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.Flags:
                        this.Flags = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.StartPhase:
                        this.StartPhase = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.EndPhase:
                        this.EndPhase = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.TimerSeconds:
                        this.TimerSeconds = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.Packages:
                        this.Packages = (MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>)obj;
                        break;
                    case SceneAction_FieldIndex.Topic:
                        this.Topic = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.HeadtrackActorID:
                        this.HeadtrackActorID = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.LoopingMax:
                        this.LoopingMax = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.LoopingMin:
                        this.LoopingMin = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.Emotion:
                        this.Emotion = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.EmotionValue:
                        this.EmotionValue = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.Unused:
                        this.Unused = (MaskItem<Exception?, ScenePhaseUnusedData.ErrorMask?>?)obj;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public bool IsInError()
            {
                if (Overall != null) return true;
                if (Type != null) return true;
                if (Name != null) return true;
                if (ActorID != null) return true;
                if (LNAM != null) return true;
                if (Index != null) return true;
                if (Flags != null) return true;
                if (StartPhase != null) return true;
                if (EndPhase != null) return true;
                if (TimerSeconds != null) return true;
                if (Packages != null) return true;
                if (Topic != null) return true;
                if (HeadtrackActorID != null) return true;
                if (LoopingMax != null) return true;
                if (LoopingMin != null) return true;
                if (Emotion != null) return true;
                if (EmotionValue != null) return true;
                if (Unused != null) return true;
                return false;
            }
            #endregion

            #region To String
            public override string ToString()
            {
                var fg = new FileGeneration();
                ToString(fg, null);
                return fg.ToString();
            }

            public void ToString(FileGeneration fg, string? name = null)
            {
                fg.AppendLine($"{(name ?? "ErrorMask")} =>");
                fg.AppendLine("[");
                using (new DepthWrapper(fg))
                {
                    if (this.Overall != null)
                    {
                        fg.AppendLine("Overall =>");
                        fg.AppendLine("[");
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine($"{this.Overall}");
                        }
                        fg.AppendLine("]");
                    }
                    ToString_FillInternal(fg);
                }
                fg.AppendLine("]");
            }
            protected void ToString_FillInternal(FileGeneration fg)
            {
                fg.AppendItem(Type, "Type");
                fg.AppendItem(Name, "Name");
                fg.AppendItem(ActorID, "ActorID");
                fg.AppendItem(LNAM, "LNAM");
                fg.AppendItem(Index, "Index");
                fg.AppendItem(Flags, "Flags");
                fg.AppendItem(StartPhase, "StartPhase");
                fg.AppendItem(EndPhase, "EndPhase");
                fg.AppendItem(TimerSeconds, "TimerSeconds");
                if (Packages.TryGet(out var PackagesItem))
                {
                    fg.AppendLine("Packages =>");
                    fg.AppendLine("[");
                    using (new DepthWrapper(fg))
                    {
                        fg.AppendItem(PackagesItem.Overall);
                        if (PackagesItem.Specific != null)
                        {
                            foreach (var subItem in PackagesItem.Specific)
                            {
                                fg.AppendLine("[");
                                using (new DepthWrapper(fg))
                                {
                                    fg.AppendItem(subItem);
                                }
                                fg.AppendLine("]");
                            }
                        }
                    }
                    fg.AppendLine("]");
                }
                fg.AppendItem(Topic, "Topic");
                fg.AppendItem(HeadtrackActorID, "HeadtrackActorID");
                fg.AppendItem(LoopingMax, "LoopingMax");
                fg.AppendItem(LoopingMin, "LoopingMin");
                fg.AppendItem(Emotion, "Emotion");
                fg.AppendItem(EmotionValue, "EmotionValue");
                Unused?.ToString(fg);
            }
            #endregion

            #region Combine
            public ErrorMask Combine(ErrorMask? rhs)
            {
                if (rhs == null) return this;
                var ret = new ErrorMask();
                ret.Type = this.Type.Combine(rhs.Type);
                ret.Name = this.Name.Combine(rhs.Name);
                ret.ActorID = this.ActorID.Combine(rhs.ActorID);
                ret.LNAM = this.LNAM.Combine(rhs.LNAM);
                ret.Index = this.Index.Combine(rhs.Index);
                ret.Flags = this.Flags.Combine(rhs.Flags);
                ret.StartPhase = this.StartPhase.Combine(rhs.StartPhase);
                ret.EndPhase = this.EndPhase.Combine(rhs.EndPhase);
                ret.TimerSeconds = this.TimerSeconds.Combine(rhs.TimerSeconds);
                ret.Packages = new MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>(ExceptionExt.Combine(this.Packages?.Overall, rhs.Packages?.Overall), ExceptionExt.Combine(this.Packages?.Specific, rhs.Packages?.Specific));
                ret.Topic = this.Topic.Combine(rhs.Topic);
                ret.HeadtrackActorID = this.HeadtrackActorID.Combine(rhs.HeadtrackActorID);
                ret.LoopingMax = this.LoopingMax.Combine(rhs.LoopingMax);
                ret.LoopingMin = this.LoopingMin.Combine(rhs.LoopingMin);
                ret.Emotion = this.Emotion.Combine(rhs.Emotion);
                ret.EmotionValue = this.EmotionValue.Combine(rhs.EmotionValue);
                ret.Unused = this.Unused.Combine(rhs.Unused, (l, r) => l.Combine(r));
                return ret;
            }
            public static ErrorMask? Combine(ErrorMask? lhs, ErrorMask? rhs)
            {
                if (lhs != null && rhs != null) return lhs.Combine(rhs);
                return lhs ?? rhs;
            }
            #endregion

            #region Factory
            public static ErrorMask Factory(ErrorMaskBuilder errorMask)
            {
                return new ErrorMask();
            }
            #endregion

        }
        public class TranslationMask : ITranslationMask
        {
            #region Members
            private TranslationCrystal? _crystal;
            public bool Type;
            public bool Name;
            public bool ActorID;
            public bool LNAM;
            public bool Index;
            public bool Flags;
            public bool StartPhase;
            public bool EndPhase;
            public bool TimerSeconds;
            public bool Packages;
            public bool Topic;
            public bool HeadtrackActorID;
            public bool LoopingMax;
            public bool LoopingMin;
            public bool Emotion;
            public bool EmotionValue;
            public MaskItem<bool, ScenePhaseUnusedData.TranslationMask?> Unused;
            #endregion

            #region Ctors
            public TranslationMask(bool defaultOn)
            {
                this.Type = defaultOn;
                this.Name = defaultOn;
                this.ActorID = defaultOn;
                this.LNAM = defaultOn;
                this.Index = defaultOn;
                this.Flags = defaultOn;
                this.StartPhase = defaultOn;
                this.EndPhase = defaultOn;
                this.TimerSeconds = defaultOn;
                this.Packages = defaultOn;
                this.Topic = defaultOn;
                this.HeadtrackActorID = defaultOn;
                this.LoopingMax = defaultOn;
                this.LoopingMin = defaultOn;
                this.Emotion = defaultOn;
                this.EmotionValue = defaultOn;
                this.Unused = new MaskItem<bool, ScenePhaseUnusedData.TranslationMask?>(defaultOn, null);
            }

            #endregion

            public TranslationCrystal GetCrystal()
            {
                if (_crystal != null) return _crystal;
                var ret = new List<(bool On, TranslationCrystal? SubCrystal)>();
                GetCrystal(ret);
                _crystal = new TranslationCrystal(ret.ToArray());
                return _crystal;
            }

            protected void GetCrystal(List<(bool On, TranslationCrystal? SubCrystal)> ret)
            {
                ret.Add((Type, null));
                ret.Add((Name, null));
                ret.Add((ActorID, null));
                ret.Add((LNAM, null));
                ret.Add((Index, null));
                ret.Add((Flags, null));
                ret.Add((StartPhase, null));
                ret.Add((EndPhase, null));
                ret.Add((TimerSeconds, null));
                ret.Add((Packages, null));
                ret.Add((Topic, null));
                ret.Add((HeadtrackActorID, null));
                ret.Add((LoopingMax, null));
                ret.Add((LoopingMin, null));
                ret.Add((Emotion, null));
                ret.Add((EmotionValue, null));
                ret.Add((Unused?.Overall ?? true, Unused?.Specific?.GetCrystal()));
            }
        }
        #endregion

        #region Mutagen
        public static readonly RecordType GrupRecordType = SceneAction_Registration.TriggeringRecordType;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected IEnumerable<FormKey> LinkFormKeys => SceneActionCommon.Instance.GetLinkFormKeys(this);
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IEnumerable<FormKey> ILinkedFormKeyContainerGetter.LinkFormKeys => SceneActionCommon.Instance.GetLinkFormKeys(this);
        protected void RemapLinks(IReadOnlyDictionary<FormKey, FormKey> mapping) => SceneActionCommon.Instance.RemapLinks(this, mapping);
        void ILinkedFormKeyContainer.RemapLinks(IReadOnlyDictionary<FormKey, FormKey> mapping) => SceneActionCommon.Instance.RemapLinks(this, mapping);
        #endregion

        #region Binary Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => SceneActionBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((SceneActionBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }
        #region Binary Create
        public static SceneAction CreateFromBinary(
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            var ret = new SceneAction();
            ((SceneActionSetterCommon)((ISceneActionGetter)ret).CommonSetterInstance()!).CopyInFromBinary(
                item: ret,
                frame: frame,
                recordTypeConverter: recordTypeConverter);
            return ret;
        }

        #endregion

        public static bool TryCreateFromBinary(
            MutagenFrame frame,
            out SceneAction item,
            RecordTypeConverter? recordTypeConverter = null)
        {
            var startPos = frame.Position;
            item = CreateFromBinary(frame, recordTypeConverter);
            return startPos != frame.Position;
        }
        #endregion

        void IPrintable.ToString(FileGeneration fg, string? name) => this.ToString(fg, name);

        void IClearable.Clear()
        {
            ((SceneActionSetterCommon)((ISceneActionGetter)this).CommonSetterInstance()!).Clear(this);
        }

        internal static SceneAction GetNew()
        {
            return new SceneAction();
        }

    }
    #endregion

    #region Interface
    public partial interface ISceneAction :
        ISceneActionGetter,
        ILoquiObjectSetter<ISceneAction>,
        ILinkedFormKeyContainer
    {
        new SceneAction.TypeEnum Type { get; set; }
        new String? Name { get; set; }
        new Int32? ActorID { get; set; }
        new MemorySlice<Byte>? LNAM { get; set; }
        new UInt32? Index { get; set; }
        new SceneAction.Flag? Flags { get; set; }
        new UInt32? StartPhase { get; set; }
        new UInt32? EndPhase { get; set; }
        new Single? TimerSeconds { get; set; }
        new IExtendedList<IFormLink<Package>> Packages { get; }
        new FormLinkNullable<DialogTopic> Topic { get; set; }
        new Int32? HeadtrackActorID { get; set; }
        new Single? LoopingMax { get; set; }
        new Single? LoopingMin { get; set; }
        new Emotion? Emotion { get; set; }
        new UInt32? EmotionValue { get; set; }
        new ScenePhaseUnusedData? Unused { get; set; }
    }

    public partial interface ISceneActionGetter :
        ILoquiObject,
        ILoquiObject<ISceneActionGetter>,
        ILinkedFormKeyContainerGetter,
        IBinaryItem
    {
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object? CommonSetterInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonSetterTranslationInstance();
        static ILoquiRegistration Registration => SceneAction_Registration.Instance;
        SceneAction.TypeEnum Type { get; }
        String? Name { get; }
        Int32? ActorID { get; }
        ReadOnlyMemorySlice<Byte>? LNAM { get; }
        UInt32? Index { get; }
        SceneAction.Flag? Flags { get; }
        UInt32? StartPhase { get; }
        UInt32? EndPhase { get; }
        Single? TimerSeconds { get; }
        IReadOnlyList<IFormLink<IPackageGetter>> Packages { get; }
        FormLinkNullable<IDialogTopicGetter> Topic { get; }
        Int32? HeadtrackActorID { get; }
        Single? LoopingMax { get; }
        Single? LoopingMin { get; }
        Emotion? Emotion { get; }
        UInt32? EmotionValue { get; }
        IScenePhaseUnusedDataGetter? Unused { get; }

    }

    #endregion

    #region Common MixIn
    public static partial class SceneActionMixIn
    {
        public static void Clear(this ISceneAction item)
        {
            ((SceneActionSetterCommon)((ISceneActionGetter)item).CommonSetterInstance()!).Clear(item: item);
        }

        public static SceneAction.Mask<bool> GetEqualsMask(
            this ISceneActionGetter item,
            ISceneActionGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            return ((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).GetEqualsMask(
                item: item,
                rhs: rhs,
                include: include);
        }

        public static string ToString(
            this ISceneActionGetter item,
            string? name = null,
            SceneAction.Mask<bool>? printMask = null)
        {
            return ((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).ToString(
                item: item,
                name: name,
                printMask: printMask);
        }

        public static void ToString(
            this ISceneActionGetter item,
            FileGeneration fg,
            string? name = null,
            SceneAction.Mask<bool>? printMask = null)
        {
            ((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).ToString(
                item: item,
                fg: fg,
                name: name,
                printMask: printMask);
        }

        public static bool Equals(
            this ISceneActionGetter item,
            ISceneActionGetter rhs)
        {
            return ((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).Equals(
                lhs: item,
                rhs: rhs);
        }

        public static void DeepCopyIn(
            this ISceneAction lhs,
            ISceneActionGetter rhs)
        {
            ((SceneActionSetterTranslationCommon)((ISceneActionGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: default,
                deepCopy: false);
        }

        public static void DeepCopyIn(
            this ISceneAction lhs,
            ISceneActionGetter rhs,
            SceneAction.TranslationMask? copyMask = null)
        {
            ((SceneActionSetterTranslationCommon)((ISceneActionGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
        }

        public static void DeepCopyIn(
            this ISceneAction lhs,
            ISceneActionGetter rhs,
            out SceneAction.ErrorMask errorMask,
            SceneAction.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            ((SceneActionSetterTranslationCommon)((ISceneActionGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
            errorMask = SceneAction.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void DeepCopyIn(
            this ISceneAction lhs,
            ISceneActionGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            ((SceneActionSetterTranslationCommon)((ISceneActionGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: false);
        }

        public static SceneAction DeepCopy(
            this ISceneActionGetter item,
            SceneAction.TranslationMask? copyMask = null)
        {
            return ((SceneActionSetterTranslationCommon)((ISceneActionGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask);
        }

        public static SceneAction DeepCopy(
            this ISceneActionGetter item,
            out SceneAction.ErrorMask errorMask,
            SceneAction.TranslationMask? copyMask = null)
        {
            return ((SceneActionSetterTranslationCommon)((ISceneActionGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: out errorMask);
        }

        public static SceneAction DeepCopy(
            this ISceneActionGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            return ((SceneActionSetterTranslationCommon)((ISceneActionGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: errorMask);
        }

        #region Binary Translation
        public static void CopyInFromBinary(
            this ISceneAction item,
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((SceneActionSetterCommon)((ISceneActionGetter)item).CommonSetterInstance()!).CopyInFromBinary(
                item: item,
                frame: frame,
                recordTypeConverter: recordTypeConverter);
        }

        #endregion

    }
    #endregion

}

namespace Mutagen.Bethesda.Skyrim.Internals
{
    #region Field Index
    public enum SceneAction_FieldIndex
    {
        Type = 0,
        Name = 1,
        ActorID = 2,
        LNAM = 3,
        Index = 4,
        Flags = 5,
        StartPhase = 6,
        EndPhase = 7,
        TimerSeconds = 8,
        Packages = 9,
        Topic = 10,
        HeadtrackActorID = 11,
        LoopingMax = 12,
        LoopingMin = 13,
        Emotion = 14,
        EmotionValue = 15,
        Unused = 16,
    }
    #endregion

    #region Registration
    public partial class SceneAction_Registration : ILoquiRegistration
    {
        public static readonly SceneAction_Registration Instance = new SceneAction_Registration();

        public static ProtocolKey ProtocolKey => ProtocolDefinition_Skyrim.ProtocolKey;

        public static readonly ObjectKey ObjectKey = new ObjectKey(
            protocolKey: ProtocolDefinition_Skyrim.ProtocolKey,
            msgID: 471,
            version: 0);

        public const string GUID = "3f2b0ff3-2e6d-4fce-958e-40dffd9c696d";

        public const ushort AdditionalFieldCount = 17;

        public const ushort FieldCount = 17;

        public static readonly Type MaskType = typeof(SceneAction.Mask<>);

        public static readonly Type ErrorMaskType = typeof(SceneAction.ErrorMask);

        public static readonly Type ClassType = typeof(SceneAction);

        public static readonly Type GetterType = typeof(ISceneActionGetter);

        public static readonly Type? InternalGetterType = null;

        public static readonly Type SetterType = typeof(ISceneAction);

        public static readonly Type? InternalSetterType = null;

        public const string FullName = "Mutagen.Bethesda.Skyrim.SceneAction";

        public const string Name = "SceneAction";

        public const string Namespace = "Mutagen.Bethesda.Skyrim";

        public const byte GenericCount = 0;

        public static readonly Type? GenericRegistrationType = null;

        public static ushort? GetNameIndex(StringCaseAgnostic str)
        {
            switch (str.Upper)
            {
                case "TYPE":
                    return (ushort)SceneAction_FieldIndex.Type;
                case "NAME":
                    return (ushort)SceneAction_FieldIndex.Name;
                case "ACTORID":
                    return (ushort)SceneAction_FieldIndex.ActorID;
                case "LNAM":
                    return (ushort)SceneAction_FieldIndex.LNAM;
                case "INDEX":
                    return (ushort)SceneAction_FieldIndex.Index;
                case "FLAGS":
                    return (ushort)SceneAction_FieldIndex.Flags;
                case "STARTPHASE":
                    return (ushort)SceneAction_FieldIndex.StartPhase;
                case "ENDPHASE":
                    return (ushort)SceneAction_FieldIndex.EndPhase;
                case "TIMERSECONDS":
                    return (ushort)SceneAction_FieldIndex.TimerSeconds;
                case "PACKAGES":
                    return (ushort)SceneAction_FieldIndex.Packages;
                case "TOPIC":
                    return (ushort)SceneAction_FieldIndex.Topic;
                case "HEADTRACKACTORID":
                    return (ushort)SceneAction_FieldIndex.HeadtrackActorID;
                case "LOOPINGMAX":
                    return (ushort)SceneAction_FieldIndex.LoopingMax;
                case "LOOPINGMIN":
                    return (ushort)SceneAction_FieldIndex.LoopingMin;
                case "EMOTION":
                    return (ushort)SceneAction_FieldIndex.Emotion;
                case "EMOTIONVALUE":
                    return (ushort)SceneAction_FieldIndex.EmotionValue;
                case "UNUSED":
                    return (ushort)SceneAction_FieldIndex.Unused;
                default:
                    return null;
            }
        }

        public static bool GetNthIsEnumerable(ushort index)
        {
            SceneAction_FieldIndex enu = (SceneAction_FieldIndex)index;
            switch (enu)
            {
                case SceneAction_FieldIndex.Packages:
                    return true;
                case SceneAction_FieldIndex.Type:
                case SceneAction_FieldIndex.Name:
                case SceneAction_FieldIndex.ActorID:
                case SceneAction_FieldIndex.LNAM:
                case SceneAction_FieldIndex.Index:
                case SceneAction_FieldIndex.Flags:
                case SceneAction_FieldIndex.StartPhase:
                case SceneAction_FieldIndex.EndPhase:
                case SceneAction_FieldIndex.TimerSeconds:
                case SceneAction_FieldIndex.Topic:
                case SceneAction_FieldIndex.HeadtrackActorID:
                case SceneAction_FieldIndex.LoopingMax:
                case SceneAction_FieldIndex.LoopingMin:
                case SceneAction_FieldIndex.Emotion:
                case SceneAction_FieldIndex.EmotionValue:
                case SceneAction_FieldIndex.Unused:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool GetNthIsLoqui(ushort index)
        {
            SceneAction_FieldIndex enu = (SceneAction_FieldIndex)index;
            switch (enu)
            {
                case SceneAction_FieldIndex.Unused:
                    return true;
                case SceneAction_FieldIndex.Type:
                case SceneAction_FieldIndex.Name:
                case SceneAction_FieldIndex.ActorID:
                case SceneAction_FieldIndex.LNAM:
                case SceneAction_FieldIndex.Index:
                case SceneAction_FieldIndex.Flags:
                case SceneAction_FieldIndex.StartPhase:
                case SceneAction_FieldIndex.EndPhase:
                case SceneAction_FieldIndex.TimerSeconds:
                case SceneAction_FieldIndex.Packages:
                case SceneAction_FieldIndex.Topic:
                case SceneAction_FieldIndex.HeadtrackActorID:
                case SceneAction_FieldIndex.LoopingMax:
                case SceneAction_FieldIndex.LoopingMin:
                case SceneAction_FieldIndex.Emotion:
                case SceneAction_FieldIndex.EmotionValue:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool GetNthIsSingleton(ushort index)
        {
            SceneAction_FieldIndex enu = (SceneAction_FieldIndex)index;
            switch (enu)
            {
                case SceneAction_FieldIndex.Type:
                case SceneAction_FieldIndex.Name:
                case SceneAction_FieldIndex.ActorID:
                case SceneAction_FieldIndex.LNAM:
                case SceneAction_FieldIndex.Index:
                case SceneAction_FieldIndex.Flags:
                case SceneAction_FieldIndex.StartPhase:
                case SceneAction_FieldIndex.EndPhase:
                case SceneAction_FieldIndex.TimerSeconds:
                case SceneAction_FieldIndex.Packages:
                case SceneAction_FieldIndex.Topic:
                case SceneAction_FieldIndex.HeadtrackActorID:
                case SceneAction_FieldIndex.LoopingMax:
                case SceneAction_FieldIndex.LoopingMin:
                case SceneAction_FieldIndex.Emotion:
                case SceneAction_FieldIndex.EmotionValue:
                case SceneAction_FieldIndex.Unused:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static string GetNthName(ushort index)
        {
            SceneAction_FieldIndex enu = (SceneAction_FieldIndex)index;
            switch (enu)
            {
                case SceneAction_FieldIndex.Type:
                    return "Type";
                case SceneAction_FieldIndex.Name:
                    return "Name";
                case SceneAction_FieldIndex.ActorID:
                    return "ActorID";
                case SceneAction_FieldIndex.LNAM:
                    return "LNAM";
                case SceneAction_FieldIndex.Index:
                    return "Index";
                case SceneAction_FieldIndex.Flags:
                    return "Flags";
                case SceneAction_FieldIndex.StartPhase:
                    return "StartPhase";
                case SceneAction_FieldIndex.EndPhase:
                    return "EndPhase";
                case SceneAction_FieldIndex.TimerSeconds:
                    return "TimerSeconds";
                case SceneAction_FieldIndex.Packages:
                    return "Packages";
                case SceneAction_FieldIndex.Topic:
                    return "Topic";
                case SceneAction_FieldIndex.HeadtrackActorID:
                    return "HeadtrackActorID";
                case SceneAction_FieldIndex.LoopingMax:
                    return "LoopingMax";
                case SceneAction_FieldIndex.LoopingMin:
                    return "LoopingMin";
                case SceneAction_FieldIndex.Emotion:
                    return "Emotion";
                case SceneAction_FieldIndex.EmotionValue:
                    return "EmotionValue";
                case SceneAction_FieldIndex.Unused:
                    return "Unused";
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool IsNthDerivative(ushort index)
        {
            SceneAction_FieldIndex enu = (SceneAction_FieldIndex)index;
            switch (enu)
            {
                case SceneAction_FieldIndex.Type:
                case SceneAction_FieldIndex.Name:
                case SceneAction_FieldIndex.ActorID:
                case SceneAction_FieldIndex.LNAM:
                case SceneAction_FieldIndex.Index:
                case SceneAction_FieldIndex.Flags:
                case SceneAction_FieldIndex.StartPhase:
                case SceneAction_FieldIndex.EndPhase:
                case SceneAction_FieldIndex.TimerSeconds:
                case SceneAction_FieldIndex.Packages:
                case SceneAction_FieldIndex.Topic:
                case SceneAction_FieldIndex.HeadtrackActorID:
                case SceneAction_FieldIndex.LoopingMax:
                case SceneAction_FieldIndex.LoopingMin:
                case SceneAction_FieldIndex.Emotion:
                case SceneAction_FieldIndex.EmotionValue:
                case SceneAction_FieldIndex.Unused:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static bool IsProtected(ushort index)
        {
            SceneAction_FieldIndex enu = (SceneAction_FieldIndex)index;
            switch (enu)
            {
                case SceneAction_FieldIndex.Type:
                case SceneAction_FieldIndex.Name:
                case SceneAction_FieldIndex.ActorID:
                case SceneAction_FieldIndex.LNAM:
                case SceneAction_FieldIndex.Index:
                case SceneAction_FieldIndex.Flags:
                case SceneAction_FieldIndex.StartPhase:
                case SceneAction_FieldIndex.EndPhase:
                case SceneAction_FieldIndex.TimerSeconds:
                case SceneAction_FieldIndex.Packages:
                case SceneAction_FieldIndex.Topic:
                case SceneAction_FieldIndex.HeadtrackActorID:
                case SceneAction_FieldIndex.LoopingMax:
                case SceneAction_FieldIndex.LoopingMin:
                case SceneAction_FieldIndex.Emotion:
                case SceneAction_FieldIndex.EmotionValue:
                case SceneAction_FieldIndex.Unused:
                    return false;
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static Type GetNthType(ushort index)
        {
            SceneAction_FieldIndex enu = (SceneAction_FieldIndex)index;
            switch (enu)
            {
                case SceneAction_FieldIndex.Type:
                    return typeof(SceneAction.TypeEnum);
                case SceneAction_FieldIndex.Name:
                    return typeof(String);
                case SceneAction_FieldIndex.ActorID:
                    return typeof(Int32);
                case SceneAction_FieldIndex.LNAM:
                    return typeof(MemorySlice<Byte>);
                case SceneAction_FieldIndex.Index:
                    return typeof(UInt32);
                case SceneAction_FieldIndex.Flags:
                    return typeof(SceneAction.Flag);
                case SceneAction_FieldIndex.StartPhase:
                    return typeof(UInt32);
                case SceneAction_FieldIndex.EndPhase:
                    return typeof(UInt32);
                case SceneAction_FieldIndex.TimerSeconds:
                    return typeof(Single);
                case SceneAction_FieldIndex.Packages:
                    return typeof(IExtendedList<IFormLink<Package>>);
                case SceneAction_FieldIndex.Topic:
                    return typeof(FormLinkNullable<DialogTopic>);
                case SceneAction_FieldIndex.HeadtrackActorID:
                    return typeof(Int32);
                case SceneAction_FieldIndex.LoopingMax:
                    return typeof(Single);
                case SceneAction_FieldIndex.LoopingMin:
                    return typeof(Single);
                case SceneAction_FieldIndex.Emotion:
                    return typeof(Emotion);
                case SceneAction_FieldIndex.EmotionValue:
                    return typeof(UInt32);
                case SceneAction_FieldIndex.Unused:
                    return typeof(ScenePhaseUnusedData);
                default:
                    throw new ArgumentException($"Index is out of range: {index}");
            }
        }

        public static readonly RecordType TriggeringRecordType = RecordTypes.ANAM;
        public static readonly Type BinaryWriteTranslation = typeof(SceneActionBinaryWriteTranslation);
        #region Interface
        ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;
        ObjectKey ILoquiRegistration.ObjectKey => ObjectKey;
        string ILoquiRegistration.GUID => GUID;
        ushort ILoquiRegistration.FieldCount => FieldCount;
        ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;
        Type ILoquiRegistration.MaskType => MaskType;
        Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;
        Type ILoquiRegistration.ClassType => ClassType;
        Type ILoquiRegistration.SetterType => SetterType;
        Type? ILoquiRegistration.InternalSetterType => InternalSetterType;
        Type ILoquiRegistration.GetterType => GetterType;
        Type? ILoquiRegistration.InternalGetterType => InternalGetterType;
        string ILoquiRegistration.FullName => FullName;
        string ILoquiRegistration.Name => Name;
        string ILoquiRegistration.Namespace => Namespace;
        byte ILoquiRegistration.GenericCount => GenericCount;
        Type? ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;
        ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => GetNameIndex(name);
        bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => GetNthIsEnumerable(index);
        bool ILoquiRegistration.GetNthIsLoqui(ushort index) => GetNthIsLoqui(index);
        bool ILoquiRegistration.GetNthIsSingleton(ushort index) => GetNthIsSingleton(index);
        string ILoquiRegistration.GetNthName(ushort index) => GetNthName(index);
        bool ILoquiRegistration.IsNthDerivative(ushort index) => IsNthDerivative(index);
        bool ILoquiRegistration.IsProtected(ushort index) => IsProtected(index);
        Type ILoquiRegistration.GetNthType(ushort index) => GetNthType(index);
        #endregion

    }
    #endregion

    #region Common
    public partial class SceneActionSetterCommon
    {
        public static readonly SceneActionSetterCommon Instance = new SceneActionSetterCommon();

        partial void ClearPartial();
        
        public void Clear(ISceneAction item)
        {
            ClearPartial();
            item.Type = default;
            item.Name = default;
            item.ActorID = default;
            item.LNAM = default;
            item.Index = default;
            item.Flags = default;
            item.StartPhase = default;
            item.EndPhase = default;
            item.TimerSeconds = default;
            item.Packages.Clear();
            item.Topic = FormLinkNullable<DialogTopic>.Null;
            item.HeadtrackActorID = default;
            item.LoopingMax = default;
            item.LoopingMin = default;
            item.Emotion = default;
            item.EmotionValue = default;
            item.Unused = null;
        }
        
        #region Binary Translation
        public virtual void CopyInFromBinary(
            ISceneAction item,
            MutagenFrame frame,
            RecordTypeConverter? recordTypeConverter = null)
        {
            UtilityTranslation.SubrecordParse(
                record: item,
                frame: frame,
                recordTypeConverter: recordTypeConverter,
                fillStructs: SceneActionBinaryCreateTranslation.FillBinaryStructs,
                fillTyped: SceneActionBinaryCreateTranslation.FillBinaryRecordTypes);
        }
        
        #endregion
        
    }
    public partial class SceneActionCommon
    {
        public static readonly SceneActionCommon Instance = new SceneActionCommon();

        public SceneAction.Mask<bool> GetEqualsMask(
            ISceneActionGetter item,
            ISceneActionGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            var ret = new SceneAction.Mask<bool>(false);
            ((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).FillEqualsMask(
                item: item,
                rhs: rhs,
                ret: ret,
                include: include);
            return ret;
        }
        
        public void FillEqualsMask(
            ISceneActionGetter item,
            ISceneActionGetter rhs,
            SceneAction.Mask<bool> ret,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            if (rhs == null) return;
            ret.Type = item.Type == rhs.Type;
            ret.Name = string.Equals(item.Name, rhs.Name);
            ret.ActorID = item.ActorID == rhs.ActorID;
            ret.LNAM = MemorySliceExt.Equal(item.LNAM, rhs.LNAM);
            ret.Index = item.Index == rhs.Index;
            ret.Flags = item.Flags == rhs.Flags;
            ret.StartPhase = item.StartPhase == rhs.StartPhase;
            ret.EndPhase = item.EndPhase == rhs.EndPhase;
            ret.TimerSeconds = item.TimerSeconds.EqualsWithin(rhs.TimerSeconds);
            ret.Packages = item.Packages.CollectionEqualsHelper(
                rhs.Packages,
                (l, r) => object.Equals(l, r),
                include);
            ret.Topic = object.Equals(item.Topic, rhs.Topic);
            ret.HeadtrackActorID = item.HeadtrackActorID == rhs.HeadtrackActorID;
            ret.LoopingMax = item.LoopingMax.EqualsWithin(rhs.LoopingMax);
            ret.LoopingMin = item.LoopingMin.EqualsWithin(rhs.LoopingMin);
            ret.Emotion = item.Emotion == rhs.Emotion;
            ret.EmotionValue = item.EmotionValue == rhs.EmotionValue;
            ret.Unused = EqualsMaskHelper.EqualsHelper(
                item.Unused,
                rhs.Unused,
                (loqLhs, loqRhs, incl) => loqLhs.GetEqualsMask(loqRhs, incl),
                include);
        }
        
        public string ToString(
            ISceneActionGetter item,
            string? name = null,
            SceneAction.Mask<bool>? printMask = null)
        {
            var fg = new FileGeneration();
            ToString(
                item: item,
                fg: fg,
                name: name,
                printMask: printMask);
            return fg.ToString();
        }
        
        public void ToString(
            ISceneActionGetter item,
            FileGeneration fg,
            string? name = null,
            SceneAction.Mask<bool>? printMask = null)
        {
            if (name == null)
            {
                fg.AppendLine($"SceneAction =>");
            }
            else
            {
                fg.AppendLine($"{name} (SceneAction) =>");
            }
            fg.AppendLine("[");
            using (new DepthWrapper(fg))
            {
                ToStringFields(
                    item: item,
                    fg: fg,
                    printMask: printMask);
            }
            fg.AppendLine("]");
        }
        
        protected static void ToStringFields(
            ISceneActionGetter item,
            FileGeneration fg,
            SceneAction.Mask<bool>? printMask = null)
        {
            if (printMask?.Type ?? true)
            {
                fg.AppendItem(item.Type, "Type");
            }
            if ((printMask?.Name ?? true)
                && item.Name.TryGet(out var NameItem))
            {
                fg.AppendItem(NameItem, "Name");
            }
            if ((printMask?.ActorID ?? true)
                && item.ActorID.TryGet(out var ActorIDItem))
            {
                fg.AppendItem(ActorIDItem, "ActorID");
            }
            if ((printMask?.LNAM ?? true)
                && item.LNAM.TryGet(out var LNAMItem))
            {
                fg.AppendLine($"LNAM => {SpanExt.ToHexString(LNAMItem)}");
            }
            if ((printMask?.Index ?? true)
                && item.Index.TryGet(out var IndexItem))
            {
                fg.AppendItem(IndexItem, "Index");
            }
            if ((printMask?.Flags ?? true)
                && item.Flags.TryGet(out var FlagsItem))
            {
                fg.AppendItem(FlagsItem, "Flags");
            }
            if ((printMask?.StartPhase ?? true)
                && item.StartPhase.TryGet(out var StartPhaseItem))
            {
                fg.AppendItem(StartPhaseItem, "StartPhase");
            }
            if ((printMask?.EndPhase ?? true)
                && item.EndPhase.TryGet(out var EndPhaseItem))
            {
                fg.AppendItem(EndPhaseItem, "EndPhase");
            }
            if ((printMask?.TimerSeconds ?? true)
                && item.TimerSeconds.TryGet(out var TimerSecondsItem))
            {
                fg.AppendItem(TimerSecondsItem, "TimerSeconds");
            }
            if (printMask?.Packages?.Overall ?? true)
            {
                fg.AppendLine("Packages =>");
                fg.AppendLine("[");
                using (new DepthWrapper(fg))
                {
                    foreach (var subItem in item.Packages)
                    {
                        fg.AppendLine("[");
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendItem(subItem.FormKey);
                        }
                        fg.AppendLine("]");
                    }
                }
                fg.AppendLine("]");
            }
            if (printMask?.Topic ?? true)
            {
                fg.AppendItem(item.Topic.FormKey, "Topic");
            }
            if ((printMask?.HeadtrackActorID ?? true)
                && item.HeadtrackActorID.TryGet(out var HeadtrackActorIDItem))
            {
                fg.AppendItem(HeadtrackActorIDItem, "HeadtrackActorID");
            }
            if ((printMask?.LoopingMax ?? true)
                && item.LoopingMax.TryGet(out var LoopingMaxItem))
            {
                fg.AppendItem(LoopingMaxItem, "LoopingMax");
            }
            if ((printMask?.LoopingMin ?? true)
                && item.LoopingMin.TryGet(out var LoopingMinItem))
            {
                fg.AppendItem(LoopingMinItem, "LoopingMin");
            }
            if ((printMask?.Emotion ?? true)
                && item.Emotion.TryGet(out var EmotionItem))
            {
                fg.AppendItem(EmotionItem, "Emotion");
            }
            if ((printMask?.EmotionValue ?? true)
                && item.EmotionValue.TryGet(out var EmotionValueItem))
            {
                fg.AppendItem(EmotionValueItem, "EmotionValue");
            }
            if ((printMask?.Unused?.Overall ?? true)
                && item.Unused.TryGet(out var UnusedItem))
            {
                UnusedItem?.ToString(fg, "Unused");
            }
        }
        
        #region Equals and Hash
        public virtual bool Equals(
            ISceneActionGetter? lhs,
            ISceneActionGetter? rhs)
        {
            if (lhs == null && rhs == null) return false;
            if (lhs == null || rhs == null) return false;
            if (lhs.Type != rhs.Type) return false;
            if (!string.Equals(lhs.Name, rhs.Name)) return false;
            if (lhs.ActorID != rhs.ActorID) return false;
            if (!MemorySliceExt.Equal(lhs.LNAM, rhs.LNAM)) return false;
            if (lhs.Index != rhs.Index) return false;
            if (lhs.Flags != rhs.Flags) return false;
            if (lhs.StartPhase != rhs.StartPhase) return false;
            if (lhs.EndPhase != rhs.EndPhase) return false;
            if (!lhs.TimerSeconds.EqualsWithin(rhs.TimerSeconds)) return false;
            if (!lhs.Packages.SequenceEqual(rhs.Packages)) return false;
            if (!lhs.Topic.Equals(rhs.Topic)) return false;
            if (lhs.HeadtrackActorID != rhs.HeadtrackActorID) return false;
            if (!lhs.LoopingMax.EqualsWithin(rhs.LoopingMax)) return false;
            if (!lhs.LoopingMin.EqualsWithin(rhs.LoopingMin)) return false;
            if (lhs.Emotion != rhs.Emotion) return false;
            if (lhs.EmotionValue != rhs.EmotionValue) return false;
            if (!object.Equals(lhs.Unused, rhs.Unused)) return false;
            return true;
        }
        
        public virtual int GetHashCode(ISceneActionGetter item)
        {
            var hash = new HashCode();
            hash.Add(item.Type);
            if (item.Name.TryGet(out var Nameitem))
            {
                hash.Add(Nameitem);
            }
            if (item.ActorID.TryGet(out var ActorIDitem))
            {
                hash.Add(ActorIDitem);
            }
            if (item.LNAM.TryGet(out var LNAMItem))
            {
                hash.Add(LNAMItem);
            }
            if (item.Index.TryGet(out var Indexitem))
            {
                hash.Add(Indexitem);
            }
            if (item.Flags.TryGet(out var Flagsitem))
            {
                hash.Add(Flagsitem);
            }
            if (item.StartPhase.TryGet(out var StartPhaseitem))
            {
                hash.Add(StartPhaseitem);
            }
            if (item.EndPhase.TryGet(out var EndPhaseitem))
            {
                hash.Add(EndPhaseitem);
            }
            if (item.TimerSeconds.TryGet(out var TimerSecondsitem))
            {
                hash.Add(TimerSecondsitem);
            }
            hash.Add(item.Packages);
            hash.Add(item.Topic);
            if (item.HeadtrackActorID.TryGet(out var HeadtrackActorIDitem))
            {
                hash.Add(HeadtrackActorIDitem);
            }
            if (item.LoopingMax.TryGet(out var LoopingMaxitem))
            {
                hash.Add(LoopingMaxitem);
            }
            if (item.LoopingMin.TryGet(out var LoopingMinitem))
            {
                hash.Add(LoopingMinitem);
            }
            if (item.Emotion.TryGet(out var Emotionitem))
            {
                hash.Add(Emotionitem);
            }
            if (item.EmotionValue.TryGet(out var EmotionValueitem))
            {
                hash.Add(EmotionValueitem);
            }
            if (item.Unused.TryGet(out var Unuseditem))
            {
                hash.Add(Unuseditem);
            }
            return hash.ToHashCode();
        }
        
        #endregion
        
        
        public object GetNew()
        {
            return SceneAction.GetNew();
        }
        
        #region Mutagen
        public IEnumerable<FormKey> GetLinkFormKeys(ISceneActionGetter obj)
        {
            foreach (var item in obj.Packages.Select(f => f.FormKey))
            {
                yield return item;
            }
            if (obj.Topic.FormKey.TryGet(out var TopicKey))
            {
                yield return TopicKey;
            }
            yield break;
        }
        
        public void RemapLinks(ISceneActionGetter obj, IReadOnlyDictionary<FormKey, FormKey> mapping) => throw new NotImplementedException();
        #endregion
        
    }
    public partial class SceneActionSetterTranslationCommon
    {
        public static readonly SceneActionSetterTranslationCommon Instance = new SceneActionSetterTranslationCommon();

        #region DeepCopyIn
        public void DeepCopyIn(
            ISceneAction item,
            ISceneActionGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Type) ?? true))
            {
                item.Type = rhs.Type;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Name) ?? true))
            {
                item.Name = rhs.Name;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.ActorID) ?? true))
            {
                item.ActorID = rhs.ActorID;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.LNAM) ?? true))
            {
                if(rhs.LNAM.TryGet(out var LNAMrhs))
                {
                    item.LNAM = LNAMrhs.ToArray();
                }
                else
                {
                    item.LNAM = default;
                }
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Index) ?? true))
            {
                item.Index = rhs.Index;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Flags) ?? true))
            {
                item.Flags = rhs.Flags;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.StartPhase) ?? true))
            {
                item.StartPhase = rhs.StartPhase;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.EndPhase) ?? true))
            {
                item.EndPhase = rhs.EndPhase;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.TimerSeconds) ?? true))
            {
                item.TimerSeconds = rhs.TimerSeconds;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Packages) ?? true))
            {
                errorMask?.PushIndex((int)SceneAction_FieldIndex.Packages);
                try
                {
                    item.Packages.SetTo(
                        rhs.Packages
                        .Select(r => (IFormLink<Package>)new FormLink<Package>(r.FormKey)));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Topic) ?? true))
            {
                item.Topic = new FormLinkNullable<DialogTopic>(rhs.Topic.FormKey);
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.HeadtrackActorID) ?? true))
            {
                item.HeadtrackActorID = rhs.HeadtrackActorID;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.LoopingMax) ?? true))
            {
                item.LoopingMax = rhs.LoopingMax;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.LoopingMin) ?? true))
            {
                item.LoopingMin = rhs.LoopingMin;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Emotion) ?? true))
            {
                item.Emotion = rhs.Emotion;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.EmotionValue) ?? true))
            {
                item.EmotionValue = rhs.EmotionValue;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Unused) ?? true))
            {
                errorMask?.PushIndex((int)SceneAction_FieldIndex.Unused);
                try
                {
                    if(rhs.Unused.TryGet(out var rhsUnused))
                    {
                        item.Unused = rhsUnused.DeepCopy(
                            errorMask: errorMask,
                            copyMask?.GetSubCrystal((int)SceneAction_FieldIndex.Unused));
                    }
                    else
                    {
                        item.Unused = default;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
        }
        
        #endregion
        
        public SceneAction DeepCopy(
            ISceneActionGetter item,
            SceneAction.TranslationMask? copyMask = null)
        {
            SceneAction ret = (SceneAction)((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).GetNew();
            ((SceneActionSetterTranslationCommon)((ISceneActionGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: null,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            return ret;
        }
        
        public SceneAction DeepCopy(
            ISceneActionGetter item,
            out SceneAction.ErrorMask errorMask,
            SceneAction.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            SceneAction ret = (SceneAction)((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).GetNew();
            ((SceneActionSetterTranslationCommon)((ISceneActionGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                ret,
                item,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            errorMask = SceneAction.ErrorMask.Factory(errorMaskBuilder);
            return ret;
        }
        
        public SceneAction DeepCopy(
            ISceneActionGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            SceneAction ret = (SceneAction)((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).GetNew();
            ((SceneActionSetterTranslationCommon)((ISceneActionGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: true);
            return ret;
        }
        
    }
    #endregion

}

namespace Mutagen.Bethesda.Skyrim
{
    public partial class SceneAction
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => SceneAction_Registration.Instance;
        public static SceneAction_Registration Registration => SceneAction_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => SceneActionCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterInstance()
        {
            return SceneActionSetterCommon.Instance;
        }
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => SceneActionSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object ISceneActionGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object ISceneActionGetter.CommonSetterInstance() => this.CommonSetterInstance();
        [DebuggerStepThrough]
        object ISceneActionGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

    }
}

#region Modules
#region Binary Translation
namespace Mutagen.Bethesda.Skyrim.Internals
{
    public partial class SceneActionBinaryWriteTranslation : IBinaryWriteTranslator
    {
        public readonly static SceneActionBinaryWriteTranslation Instance = new SceneActionBinaryWriteTranslation();

        public static void WriteRecordTypes(
            ISceneActionGetter item,
            MutagenWriter writer,
            RecordTypeConverter? recordTypeConverter)
        {
            Mutagen.Bethesda.Binary.EnumBinaryTranslation<SceneAction.TypeEnum>.Instance.Write(
                writer,
                item.Type,
                length: 2,
                header: recordTypeConverter.ConvertToCustom(RecordTypes.ANAM));
            Mutagen.Bethesda.Binary.StringBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.Name,
                header: recordTypeConverter.ConvertToCustom(RecordTypes.NAM0),
                binaryType: StringBinaryType.NullTerminate);
            Mutagen.Bethesda.Binary.Int32BinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.ActorID,
                header: recordTypeConverter.ConvertToCustom(RecordTypes.ALID));
            Mutagen.Bethesda.Binary.ByteArrayBinaryTranslation.Instance.Write(
                writer: writer,
                item: item.LNAM,
                header: recordTypeConverter.ConvertToCustom(RecordTypes.LNAM));
            Mutagen.Bethesda.Binary.UInt32BinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.Index,
                header: recordTypeConverter.ConvertToCustom(RecordTypes.INAM));
            Mutagen.Bethesda.Binary.EnumBinaryTranslation<SceneAction.Flag>.Instance.WriteNullable(
                writer,
                item.Flags,
                length: 4,
                header: recordTypeConverter.ConvertToCustom(RecordTypes.FNAM));
            Mutagen.Bethesda.Binary.UInt32BinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.StartPhase,
                header: recordTypeConverter.ConvertToCustom(RecordTypes.SNAM));
            Mutagen.Bethesda.Binary.UInt32BinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.EndPhase,
                header: recordTypeConverter.ConvertToCustom(RecordTypes.ENAM));
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.TimerSeconds,
                header: recordTypeConverter.ConvertToCustom(RecordTypes.SNAM));
            Mutagen.Bethesda.Binary.ListBinaryTranslation<IFormLink<IPackageGetter>>.Instance.Write(
                writer: writer,
                items: item.Packages,
                transl: (MutagenWriter subWriter, IFormLink<IPackageGetter> subItem, RecordTypeConverter? conv) =>
                {
                    Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Write(
                        writer: subWriter,
                        item: subItem,
                        header: recordTypeConverter.ConvertToCustom(RecordTypes.PNAM));
                });
            Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.Topic,
                header: recordTypeConverter.ConvertToCustom(RecordTypes.DATA));
            Mutagen.Bethesda.Binary.Int32BinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.HeadtrackActorID,
                header: recordTypeConverter.ConvertToCustom(RecordTypes.HTID));
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.LoopingMax,
                header: recordTypeConverter.ConvertToCustom(RecordTypes.DMAX));
            Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.LoopingMin,
                header: recordTypeConverter.ConvertToCustom(RecordTypes.DMIN));
            Mutagen.Bethesda.Binary.EnumBinaryTranslation<Emotion>.Instance.WriteNullable(
                writer,
                item.Emotion,
                length: 4,
                header: recordTypeConverter.ConvertToCustom(RecordTypes.DEMO));
            Mutagen.Bethesda.Binary.UInt32BinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.EmotionValue,
                header: recordTypeConverter.ConvertToCustom(RecordTypes.DEVA));
            if (item.Unused.TryGet(out var UnusedItem))
            {
                ((ScenePhaseUnusedDataBinaryWriteTranslation)((IBinaryItem)UnusedItem).BinaryWriteTranslator).Write(
                    item: UnusedItem,
                    writer: writer,
                    recordTypeConverter: recordTypeConverter);
            }
            using (HeaderExport.Subrecord(writer, RecordTypes.ANAM)) { }
        }

        public void Write(
            MutagenWriter writer,
            ISceneActionGetter item,
            RecordTypeConverter? recordTypeConverter = null)
        {
            WriteRecordTypes(
                item: item,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }

        public void Write(
            MutagenWriter writer,
            object item,
            RecordTypeConverter? recordTypeConverter = null)
        {
            Write(
                item: (ISceneActionGetter)item,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }

    }

    public partial class SceneActionBinaryCreateTranslation
    {
        public readonly static SceneActionBinaryCreateTranslation Instance = new SceneActionBinaryCreateTranslation();

        public static void FillBinaryStructs(
            ISceneAction item,
            MutagenFrame frame)
        {
        }

        public static ParseResult FillBinaryRecordTypes(
            ISceneAction item,
            MutagenFrame frame,
            int? lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            RecordType nextRecordType,
            int contentLength,
            RecordTypeConverter? recordTypeConverter = null)
        {
            nextRecordType = recordTypeConverter.ConvertToStandard(nextRecordType);
            switch (nextRecordType.TypeInt)
            {
                case RecordTypeInts.ANAM:
                {
                    switch (recordParseCount?.GetOrAdd(nextRecordType) ?? 0)
                    {
                        case 0:
                            if (lastParsed.HasValue && lastParsed.Value >= (int)SceneAction_FieldIndex.Type) return ParseResult.Stop;
                            frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                            item.Type = EnumBinaryTranslation<SceneAction.TypeEnum>.Instance.Parse(frame: frame.SpawnWithLength(contentLength));
                            return new ParseResult((int)SceneAction_FieldIndex.Type, nextRecordType);
                        case 1:
                            frame.ReadSubrecordFrame();
                            return ParseResult.Stop;
                        default:
                            throw new NotImplementedException();
                    }
                }
                case RecordTypeInts.NAM0:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Name = Mutagen.Bethesda.Binary.StringBinaryTranslation.Instance.Parse(
                        frame: frame.SpawnWithLength(contentLength),
                        stringBinaryType: StringBinaryType.NullTerminate);
                    return (int)SceneAction_FieldIndex.Name;
                }
                case RecordTypeInts.ALID:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.ActorID = frame.ReadInt32();
                    return (int)SceneAction_FieldIndex.ActorID;
                }
                case RecordTypeInts.LNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.LNAM = Mutagen.Bethesda.Binary.ByteArrayBinaryTranslation.Instance.Parse(frame: frame.SpawnWithLength(contentLength));
                    return (int)SceneAction_FieldIndex.LNAM;
                }
                case RecordTypeInts.INAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Index = frame.ReadUInt32();
                    return (int)SceneAction_FieldIndex.Index;
                }
                case RecordTypeInts.FNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Flags = EnumBinaryTranslation<SceneAction.Flag>.Instance.Parse(frame: frame.SpawnWithLength(contentLength));
                    return (int)SceneAction_FieldIndex.Flags;
                }
                case RecordTypeInts.SNAM:
                {
                    switch (recordParseCount?.GetOrAdd(nextRecordType) ?? 0)
                    {
                        case 0:
                            frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                            item.StartPhase = frame.ReadUInt32();
                            return new ParseResult((int)SceneAction_FieldIndex.StartPhase, nextRecordType);
                        case 1:
                            frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                            item.TimerSeconds = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame.SpawnWithLength(contentLength));
                            return new ParseResult((int)SceneAction_FieldIndex.TimerSeconds, nextRecordType);
                        default:
                            throw new NotImplementedException();
                    }
                }
                case RecordTypeInts.ENAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.EndPhase = frame.ReadUInt32();
                    return (int)SceneAction_FieldIndex.EndPhase;
                }
                case RecordTypeInts.PNAM:
                {
                    item.Packages.SetTo(
                        Mutagen.Bethesda.Binary.ListBinaryTranslation<IFormLink<Package>>.Instance.Parse(
                            frame: frame,
                            triggeringRecord: recordTypeConverter.ConvertToCustom(RecordTypes.PNAM),
                            transl: FormLinkBinaryTranslation.Instance.Parse));
                    return (int)SceneAction_FieldIndex.Packages;
                }
                case RecordTypeInts.DATA:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Topic = Mutagen.Bethesda.Binary.FormLinkBinaryTranslation.Instance.Parse(
                        frame: frame.SpawnWithLength(contentLength),
                        defaultVal: FormKey.Null);
                    return (int)SceneAction_FieldIndex.Topic;
                }
                case RecordTypeInts.HTID:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.HeadtrackActorID = frame.ReadInt32();
                    return (int)SceneAction_FieldIndex.HeadtrackActorID;
                }
                case RecordTypeInts.DMAX:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.LoopingMax = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame.SpawnWithLength(contentLength));
                    return (int)SceneAction_FieldIndex.LoopingMax;
                }
                case RecordTypeInts.DMIN:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.LoopingMin = Mutagen.Bethesda.Binary.FloatBinaryTranslation.Instance.Parse(frame: frame.SpawnWithLength(contentLength));
                    return (int)SceneAction_FieldIndex.LoopingMin;
                }
                case RecordTypeInts.DEMO:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Emotion = EnumBinaryTranslation<Emotion>.Instance.Parse(frame: frame.SpawnWithLength(contentLength));
                    return (int)SceneAction_FieldIndex.Emotion;
                }
                case RecordTypeInts.DEVA:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.EmotionValue = frame.ReadUInt32();
                    return (int)SceneAction_FieldIndex.EmotionValue;
                }
                case RecordTypeInts.SCHR:
                case RecordTypeInts.SCDA:
                case RecordTypeInts.SCTX:
                case RecordTypeInts.QNAM:
                case RecordTypeInts.SCRO:
                {
                    item.Unused = Mutagen.Bethesda.Skyrim.ScenePhaseUnusedData.CreateFromBinary(
                        frame: frame,
                        recordTypeConverter: recordTypeConverter);
                    return (int)SceneAction_FieldIndex.Unused;
                }
                default:
                    return ParseResult.Stop;
            }
        }

    }

}
namespace Mutagen.Bethesda.Skyrim
{
    #region Binary Write Mixins
    public static class SceneActionBinaryTranslationMixIn
    {
        public static void WriteToBinary(
            this ISceneActionGetter item,
            MutagenWriter writer,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((SceneActionBinaryWriteTranslation)item.BinaryWriteTranslator).Write(
                item: item,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }

    }
    #endregion


}
namespace Mutagen.Bethesda.Skyrim.Internals
{
    public partial class SceneActionBinaryOverlay :
        BinaryOverlay,
        ISceneActionGetter
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => SceneAction_Registration.Instance;
        public static SceneAction_Registration Registration => SceneAction_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => SceneActionCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => SceneActionSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object ISceneActionGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object? ISceneActionGetter.CommonSetterInstance() => null;
        [DebuggerStepThrough]
        object ISceneActionGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

        void IPrintable.ToString(FileGeneration fg, string? name) => this.ToString(fg, name);

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected IEnumerable<FormKey> LinkFormKeys => SceneActionCommon.Instance.GetLinkFormKeys(this);
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IEnumerable<FormKey> ILinkedFormKeyContainerGetter.LinkFormKeys => SceneActionCommon.Instance.GetLinkFormKeys(this);
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => SceneActionBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            RecordTypeConverter? recordTypeConverter = null)
        {
            ((SceneActionBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                recordTypeConverter: recordTypeConverter);
        }

        #region Type
        private int? _TypeLocation;
        public SceneAction.TypeEnum Type => _TypeLocation.HasValue ? (SceneAction.TypeEnum)BinaryPrimitives.ReadUInt16LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _TypeLocation!.Value, _package.MetaData.Constants)) : default(SceneAction.TypeEnum);
        #endregion
        #region Name
        private int? _NameLocation;
        public String? Name => _NameLocation.HasValue ? BinaryStringUtility.ProcessWholeToZString(HeaderTranslation.ExtractSubrecordMemory(_data, _NameLocation.Value, _package.MetaData.Constants)) : default(string?);
        #endregion
        #region ActorID
        private int? _ActorIDLocation;
        public Int32? ActorID => _ActorIDLocation.HasValue ? BinaryPrimitives.ReadInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _ActorIDLocation.Value, _package.MetaData.Constants)) : default(Int32?);
        #endregion
        #region LNAM
        private int? _LNAMLocation;
        public ReadOnlyMemorySlice<Byte>? LNAM => _LNAMLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_data, _LNAMLocation.Value, _package.MetaData.Constants) : default(ReadOnlyMemorySlice<byte>?);
        #endregion
        #region Index
        private int? _IndexLocation;
        public UInt32? Index => _IndexLocation.HasValue ? BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _IndexLocation.Value, _package.MetaData.Constants)) : default(UInt32?);
        #endregion
        #region Flags
        private int? _FlagsLocation;
        public SceneAction.Flag? Flags => _FlagsLocation.HasValue ? (SceneAction.Flag)BinaryPrimitives.ReadInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _FlagsLocation!.Value, _package.MetaData.Constants)) : default(SceneAction.Flag?);
        #endregion
        #region StartPhase
        private int? _StartPhaseLocation;
        public UInt32? StartPhase => _StartPhaseLocation.HasValue ? BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _StartPhaseLocation.Value, _package.MetaData.Constants)) : default(UInt32?);
        #endregion
        #region EndPhase
        private int? _EndPhaseLocation;
        public UInt32? EndPhase => _EndPhaseLocation.HasValue ? BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _EndPhaseLocation.Value, _package.MetaData.Constants)) : default(UInt32?);
        #endregion
        #region TimerSeconds
        private int? _TimerSecondsLocation;
        public Single? TimerSeconds => _TimerSecondsLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_data, _TimerSecondsLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        public IReadOnlyList<IFormLink<IPackageGetter>> Packages { get; private set; } = ListExt.Empty<IFormLink<IPackageGetter>>();
        #region Topic
        private int? _TopicLocation;
        public FormLinkNullable<IDialogTopicGetter> Topic => _TopicLocation.HasValue ? new FormLinkNullable<IDialogTopicGetter>(FormKey.Factory(_package.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _TopicLocation.Value, _package.MetaData.Constants)))) : FormLinkNullable<IDialogTopicGetter>.Null;
        #endregion
        #region HeadtrackActorID
        private int? _HeadtrackActorIDLocation;
        public Int32? HeadtrackActorID => _HeadtrackActorIDLocation.HasValue ? BinaryPrimitives.ReadInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _HeadtrackActorIDLocation.Value, _package.MetaData.Constants)) : default(Int32?);
        #endregion
        #region LoopingMax
        private int? _LoopingMaxLocation;
        public Single? LoopingMax => _LoopingMaxLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_data, _LoopingMaxLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        #region LoopingMin
        private int? _LoopingMinLocation;
        public Single? LoopingMin => _LoopingMinLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_data, _LoopingMinLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        #region Emotion
        private int? _EmotionLocation;
        public Emotion? Emotion => _EmotionLocation.HasValue ? (Emotion)BinaryPrimitives.ReadInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _EmotionLocation!.Value, _package.MetaData.Constants)) : default(Emotion?);
        #endregion
        #region EmotionValue
        private int? _EmotionValueLocation;
        public UInt32? EmotionValue => _EmotionValueLocation.HasValue ? BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _EmotionValueLocation.Value, _package.MetaData.Constants)) : default(UInt32?);
        #endregion
        public IScenePhaseUnusedDataGetter? Unused { get; private set; }
        partial void CustomFactoryEnd(
            OverlayStream stream,
            int finalPos,
            int offset);

        partial void CustomCtor();
        protected SceneActionBinaryOverlay(
            ReadOnlyMemorySlice<byte> bytes,
            BinaryOverlayFactoryPackage package)
            : base(
                bytes: bytes,
                package: package)
        {
            this.CustomCtor();
        }

        public static SceneActionBinaryOverlay SceneActionFactory(
            OverlayStream stream,
            BinaryOverlayFactoryPackage package,
            RecordTypeConverter? recordTypeConverter = null)
        {
            var ret = new SceneActionBinaryOverlay(
                bytes: stream.RemainingMemory,
                package: package);
            int offset = stream.Position;
            ret.FillTypelessSubrecordTypes(
                stream: stream,
                finalPos: stream.Length,
                offset: offset,
                recordTypeConverter: recordTypeConverter,
                fill: ret.FillRecordType);
            return ret;
        }

        public static SceneActionBinaryOverlay SceneActionFactory(
            ReadOnlyMemorySlice<byte> slice,
            BinaryOverlayFactoryPackage package,
            RecordTypeConverter? recordTypeConverter = null)
        {
            return SceneActionFactory(
                stream: new OverlayStream(slice, package),
                package: package,
                recordTypeConverter: recordTypeConverter);
        }

        public ParseResult FillRecordType(
            OverlayStream stream,
            int finalPos,
            int offset,
            RecordType type,
            int? lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            RecordTypeConverter? recordTypeConverter = null)
        {
            type = recordTypeConverter.ConvertToStandard(type);
            switch (type.TypeInt)
            {
                case RecordTypeInts.ANAM:
                {
                    switch (recordParseCount?.GetOrAdd(type) ?? 0)
                    {
                        case 0:
                            if (lastParsed.HasValue && lastParsed.Value >= (int)SceneAction_FieldIndex.Type) return ParseResult.Stop;
                            _TypeLocation = (stream.Position - offset);
                            return new ParseResult((int)SceneAction_FieldIndex.Type, type);
                        case 1:
                            stream.ReadSubrecordFrame();
                            return ParseResult.Stop;
                        default:
                            throw new NotImplementedException();
                    }
                }
                case RecordTypeInts.NAM0:
                {
                    _NameLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.Name;
                }
                case RecordTypeInts.ALID:
                {
                    _ActorIDLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.ActorID;
                }
                case RecordTypeInts.LNAM:
                {
                    _LNAMLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.LNAM;
                }
                case RecordTypeInts.INAM:
                {
                    _IndexLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.Index;
                }
                case RecordTypeInts.FNAM:
                {
                    _FlagsLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.Flags;
                }
                case RecordTypeInts.SNAM:
                {
                    switch (recordParseCount?.GetOrAdd(type) ?? 0)
                    {
                        case 0:
                            _StartPhaseLocation = (stream.Position - offset);
                            return new ParseResult((int)SceneAction_FieldIndex.StartPhase, type);
                        case 1:
                            _TimerSecondsLocation = (stream.Position - offset);
                            return new ParseResult((int)SceneAction_FieldIndex.TimerSeconds, type);
                        default:
                            throw new NotImplementedException();
                    }
                }
                case RecordTypeInts.ENAM:
                {
                    _EndPhaseLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.EndPhase;
                }
                case RecordTypeInts.PNAM:
                {
                    this.Packages = BinaryOverlayList.FactoryByArray<IFormLink<IPackageGetter>>(
                        mem: stream.RemainingMemory,
                        package: _package,
                        getter: (s, p) => new FormLink<IPackageGetter>(FormKey.Factory(p.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(s))),
                        locs: ParseRecordLocations(
                            stream: stream,
                            constants: _package.MetaData.Constants.SubConstants,
                            trigger: type,
                            skipHeader: true,
                            recordTypeConverter: recordTypeConverter));
                    return (int)SceneAction_FieldIndex.Packages;
                }
                case RecordTypeInts.DATA:
                {
                    _TopicLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.Topic;
                }
                case RecordTypeInts.HTID:
                {
                    _HeadtrackActorIDLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.HeadtrackActorID;
                }
                case RecordTypeInts.DMAX:
                {
                    _LoopingMaxLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.LoopingMax;
                }
                case RecordTypeInts.DMIN:
                {
                    _LoopingMinLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.LoopingMin;
                }
                case RecordTypeInts.DEMO:
                {
                    _EmotionLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.Emotion;
                }
                case RecordTypeInts.DEVA:
                {
                    _EmotionValueLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.EmotionValue;
                }
                case RecordTypeInts.SCHR:
                case RecordTypeInts.SCDA:
                case RecordTypeInts.SCTX:
                case RecordTypeInts.QNAM:
                case RecordTypeInts.SCRO:
                {
                    this.Unused = ScenePhaseUnusedDataBinaryOverlay.ScenePhaseUnusedDataFactory(
                        stream: stream,
                        package: _package,
                        recordTypeConverter: recordTypeConverter);
                    return (int)SceneAction_FieldIndex.Unused;
                }
                default:
                    return ParseResult.Stop;
            }
        }
        #region To String

        public void ToString(
            FileGeneration fg,
            string? name = null)
        {
            SceneActionMixIn.ToString(
                item: this,
                name: name);
        }

        #endregion

    }

}
#endregion

#endregion

