/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Autogenerated by Loqui.  Do not manually change.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*/
#region Usings
using Loqui;
using Loqui.Interfaces;
using Loqui.Internal;
using Mutagen.Bethesda.Binary;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Binary.Overlay;
using Mutagen.Bethesda.Plugins.Binary.Streams;
using Mutagen.Bethesda.Plugins.Binary.Translations;
using Mutagen.Bethesda.Plugins.Exceptions;
using Mutagen.Bethesda.Plugins.Internals;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Plugins.Records.Internals;
using Mutagen.Bethesda.Plugins.Records.Mapping;
using Mutagen.Bethesda.Plugins.RecordTypeMapping;
using Mutagen.Bethesda.Plugins.Utility;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Skyrim.Internals;
using Mutagen.Bethesda.Translations.Binary;
using Noggog;
using RecordTypeInts = Mutagen.Bethesda.Skyrim.Internals.RecordTypeInts;
using RecordTypes = Mutagen.Bethesda.Skyrim.Internals.RecordTypes;
using System;
using System.Buffers.Binary;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reactive.Disposables;
using System.Reactive.Linq;
using System.Text;
#endregion

#nullable enable
namespace Mutagen.Bethesda.Skyrim
{
    #region Class
    public partial class VolumetricLighting :
        SkyrimMajorRecord,
        IEquatable<IVolumetricLightingGetter>,
        ILoquiObjectSetter<VolumetricLighting>,
        IVolumetricLightingInternal
    {
        #region Ctor
        protected VolumetricLighting()
        {
            CustomCtor();
        }
        partial void CustomCtor();
        #endregion

        #region Intensity
        public Single? Intensity { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? IVolumetricLightingGetter.Intensity => this.Intensity;
        #endregion
        #region CustomColorContribution
        public Single? CustomColorContribution { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? IVolumetricLightingGetter.CustomColorContribution => this.CustomColorContribution;
        #endregion
        #region ColorR
        public Single? ColorR { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? IVolumetricLightingGetter.ColorR => this.ColorR;
        public static RangeFloat ColorR_Range = new RangeFloat(0f, 255f);
        #endregion
        #region ColorG
        public Single? ColorG { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? IVolumetricLightingGetter.ColorG => this.ColorG;
        public static RangeFloat ColorG_Range = new RangeFloat(0f, 255f);
        #endregion
        #region ColorB
        public Single? ColorB { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? IVolumetricLightingGetter.ColorB => this.ColorB;
        public static RangeFloat ColorB_Range = new RangeFloat(0f, 255f);
        #endregion
        #region DensityContribution
        public Single? DensityContribution { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? IVolumetricLightingGetter.DensityContribution => this.DensityContribution;
        #endregion
        #region DensitySize
        public Single? DensitySize { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? IVolumetricLightingGetter.DensitySize => this.DensitySize;
        #endregion
        #region DensityWindSpeed
        public Single? DensityWindSpeed { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? IVolumetricLightingGetter.DensityWindSpeed => this.DensityWindSpeed;
        #endregion
        #region DensityFallingSpeed
        public Single? DensityFallingSpeed { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? IVolumetricLightingGetter.DensityFallingSpeed => this.DensityFallingSpeed;
        #endregion
        #region PhaseFunctionContribution
        public Single? PhaseFunctionContribution { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? IVolumetricLightingGetter.PhaseFunctionContribution => this.PhaseFunctionContribution;
        #endregion
        #region PhaseFunctionScattering
        public Single? PhaseFunctionScattering { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? IVolumetricLightingGetter.PhaseFunctionScattering => this.PhaseFunctionScattering;
        #endregion
        #region SamplingRepartitionRangeFactor
        public Single? SamplingRepartitionRangeFactor { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? IVolumetricLightingGetter.SamplingRepartitionRangeFactor => this.SamplingRepartitionRangeFactor;
        public static RangeFloat SamplingRepartitionRangeFactor_Range = new RangeFloat(0f, 1f);
        #endregion

        #region To String

        public override void ToString(
            StructuredStringBuilder sb,
            string? name = null)
        {
            VolumetricLightingMixIn.ToString(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        #region Mask
        public new class Mask<TItem> :
            SkyrimMajorRecord.Mask<TItem>,
            IEquatable<Mask<TItem>>,
            IMask<TItem>
        {
            #region Ctors
            public Mask(TItem initialValue)
            : base(initialValue)
            {
                this.Intensity = initialValue;
                this.CustomColorContribution = initialValue;
                this.ColorR = initialValue;
                this.ColorG = initialValue;
                this.ColorB = initialValue;
                this.DensityContribution = initialValue;
                this.DensitySize = initialValue;
                this.DensityWindSpeed = initialValue;
                this.DensityFallingSpeed = initialValue;
                this.PhaseFunctionContribution = initialValue;
                this.PhaseFunctionScattering = initialValue;
                this.SamplingRepartitionRangeFactor = initialValue;
            }

            public Mask(
                TItem MajorRecordFlagsRaw,
                TItem FormKey,
                TItem VersionControl,
                TItem EditorID,
                TItem FormVersion,
                TItem Version2,
                TItem Intensity,
                TItem CustomColorContribution,
                TItem ColorR,
                TItem ColorG,
                TItem ColorB,
                TItem DensityContribution,
                TItem DensitySize,
                TItem DensityWindSpeed,
                TItem DensityFallingSpeed,
                TItem PhaseFunctionContribution,
                TItem PhaseFunctionScattering,
                TItem SamplingRepartitionRangeFactor)
            : base(
                MajorRecordFlagsRaw: MajorRecordFlagsRaw,
                FormKey: FormKey,
                VersionControl: VersionControl,
                EditorID: EditorID,
                FormVersion: FormVersion,
                Version2: Version2)
            {
                this.Intensity = Intensity;
                this.CustomColorContribution = CustomColorContribution;
                this.ColorR = ColorR;
                this.ColorG = ColorG;
                this.ColorB = ColorB;
                this.DensityContribution = DensityContribution;
                this.DensitySize = DensitySize;
                this.DensityWindSpeed = DensityWindSpeed;
                this.DensityFallingSpeed = DensityFallingSpeed;
                this.PhaseFunctionContribution = PhaseFunctionContribution;
                this.PhaseFunctionScattering = PhaseFunctionScattering;
                this.SamplingRepartitionRangeFactor = SamplingRepartitionRangeFactor;
            }

            #pragma warning disable CS8618
            protected Mask()
            {
            }
            #pragma warning restore CS8618

            #endregion

            #region Members
            public TItem Intensity;
            public TItem CustomColorContribution;
            public TItem ColorR;
            public TItem ColorG;
            public TItem ColorB;
            public TItem DensityContribution;
            public TItem DensitySize;
            public TItem DensityWindSpeed;
            public TItem DensityFallingSpeed;
            public TItem PhaseFunctionContribution;
            public TItem PhaseFunctionScattering;
            public TItem SamplingRepartitionRangeFactor;
            #endregion

            #region Equals
            public override bool Equals(object? obj)
            {
                if (!(obj is Mask<TItem> rhs)) return false;
                return Equals(rhs);
            }

            public bool Equals(Mask<TItem>? rhs)
            {
                if (rhs == null) return false;
                if (!base.Equals(rhs)) return false;
                if (!object.Equals(this.Intensity, rhs.Intensity)) return false;
                if (!object.Equals(this.CustomColorContribution, rhs.CustomColorContribution)) return false;
                if (!object.Equals(this.ColorR, rhs.ColorR)) return false;
                if (!object.Equals(this.ColorG, rhs.ColorG)) return false;
                if (!object.Equals(this.ColorB, rhs.ColorB)) return false;
                if (!object.Equals(this.DensityContribution, rhs.DensityContribution)) return false;
                if (!object.Equals(this.DensitySize, rhs.DensitySize)) return false;
                if (!object.Equals(this.DensityWindSpeed, rhs.DensityWindSpeed)) return false;
                if (!object.Equals(this.DensityFallingSpeed, rhs.DensityFallingSpeed)) return false;
                if (!object.Equals(this.PhaseFunctionContribution, rhs.PhaseFunctionContribution)) return false;
                if (!object.Equals(this.PhaseFunctionScattering, rhs.PhaseFunctionScattering)) return false;
                if (!object.Equals(this.SamplingRepartitionRangeFactor, rhs.SamplingRepartitionRangeFactor)) return false;
                return true;
            }
            public override int GetHashCode()
            {
                var hash = new HashCode();
                hash.Add(this.Intensity);
                hash.Add(this.CustomColorContribution);
                hash.Add(this.ColorR);
                hash.Add(this.ColorG);
                hash.Add(this.ColorB);
                hash.Add(this.DensityContribution);
                hash.Add(this.DensitySize);
                hash.Add(this.DensityWindSpeed);
                hash.Add(this.DensityFallingSpeed);
                hash.Add(this.PhaseFunctionContribution);
                hash.Add(this.PhaseFunctionScattering);
                hash.Add(this.SamplingRepartitionRangeFactor);
                hash.Add(base.GetHashCode());
                return hash.ToHashCode();
            }

            #endregion

            #region All
            public override bool All(Func<TItem, bool> eval)
            {
                if (!base.All(eval)) return false;
                if (!eval(this.Intensity)) return false;
                if (!eval(this.CustomColorContribution)) return false;
                if (!eval(this.ColorR)) return false;
                if (!eval(this.ColorG)) return false;
                if (!eval(this.ColorB)) return false;
                if (!eval(this.DensityContribution)) return false;
                if (!eval(this.DensitySize)) return false;
                if (!eval(this.DensityWindSpeed)) return false;
                if (!eval(this.DensityFallingSpeed)) return false;
                if (!eval(this.PhaseFunctionContribution)) return false;
                if (!eval(this.PhaseFunctionScattering)) return false;
                if (!eval(this.SamplingRepartitionRangeFactor)) return false;
                return true;
            }
            #endregion

            #region Any
            public override bool Any(Func<TItem, bool> eval)
            {
                if (base.Any(eval)) return true;
                if (eval(this.Intensity)) return true;
                if (eval(this.CustomColorContribution)) return true;
                if (eval(this.ColorR)) return true;
                if (eval(this.ColorG)) return true;
                if (eval(this.ColorB)) return true;
                if (eval(this.DensityContribution)) return true;
                if (eval(this.DensitySize)) return true;
                if (eval(this.DensityWindSpeed)) return true;
                if (eval(this.DensityFallingSpeed)) return true;
                if (eval(this.PhaseFunctionContribution)) return true;
                if (eval(this.PhaseFunctionScattering)) return true;
                if (eval(this.SamplingRepartitionRangeFactor)) return true;
                return false;
            }
            #endregion

            #region Translate
            public new Mask<R> Translate<R>(Func<TItem, R> eval)
            {
                var ret = new VolumetricLighting.Mask<R>();
                this.Translate_InternalFill(ret, eval);
                return ret;
            }

            protected void Translate_InternalFill<R>(Mask<R> obj, Func<TItem, R> eval)
            {
                base.Translate_InternalFill(obj, eval);
                obj.Intensity = eval(this.Intensity);
                obj.CustomColorContribution = eval(this.CustomColorContribution);
                obj.ColorR = eval(this.ColorR);
                obj.ColorG = eval(this.ColorG);
                obj.ColorB = eval(this.ColorB);
                obj.DensityContribution = eval(this.DensityContribution);
                obj.DensitySize = eval(this.DensitySize);
                obj.DensityWindSpeed = eval(this.DensityWindSpeed);
                obj.DensityFallingSpeed = eval(this.DensityFallingSpeed);
                obj.PhaseFunctionContribution = eval(this.PhaseFunctionContribution);
                obj.PhaseFunctionScattering = eval(this.PhaseFunctionScattering);
                obj.SamplingRepartitionRangeFactor = eval(this.SamplingRepartitionRangeFactor);
            }
            #endregion

            #region To String
            public override string ToString()
            {
                return ToString(printMask: null);
            }

            public string ToString(VolumetricLighting.Mask<bool>? printMask = null)
            {
                var sb = new StructuredStringBuilder();
                ToString(sb, printMask);
                return sb.ToString();
            }

            public void ToString(StructuredStringBuilder sb, VolumetricLighting.Mask<bool>? printMask = null)
            {
                sb.AppendLine($"{nameof(VolumetricLighting.Mask<TItem>)} =>");
                sb.AppendLine("[");
                using (sb.IncreaseDepth())
                {
                    if (printMask?.Intensity ?? true)
                    {
                        sb.AppendItem(Intensity, "Intensity");
                    }
                    if (printMask?.CustomColorContribution ?? true)
                    {
                        sb.AppendItem(CustomColorContribution, "CustomColorContribution");
                    }
                    if (printMask?.ColorR ?? true)
                    {
                        sb.AppendItem(ColorR, "ColorR");
                    }
                    if (printMask?.ColorG ?? true)
                    {
                        sb.AppendItem(ColorG, "ColorG");
                    }
                    if (printMask?.ColorB ?? true)
                    {
                        sb.AppendItem(ColorB, "ColorB");
                    }
                    if (printMask?.DensityContribution ?? true)
                    {
                        sb.AppendItem(DensityContribution, "DensityContribution");
                    }
                    if (printMask?.DensitySize ?? true)
                    {
                        sb.AppendItem(DensitySize, "DensitySize");
                    }
                    if (printMask?.DensityWindSpeed ?? true)
                    {
                        sb.AppendItem(DensityWindSpeed, "DensityWindSpeed");
                    }
                    if (printMask?.DensityFallingSpeed ?? true)
                    {
                        sb.AppendItem(DensityFallingSpeed, "DensityFallingSpeed");
                    }
                    if (printMask?.PhaseFunctionContribution ?? true)
                    {
                        sb.AppendItem(PhaseFunctionContribution, "PhaseFunctionContribution");
                    }
                    if (printMask?.PhaseFunctionScattering ?? true)
                    {
                        sb.AppendItem(PhaseFunctionScattering, "PhaseFunctionScattering");
                    }
                    if (printMask?.SamplingRepartitionRangeFactor ?? true)
                    {
                        sb.AppendItem(SamplingRepartitionRangeFactor, "SamplingRepartitionRangeFactor");
                    }
                }
                sb.AppendLine("]");
            }
            #endregion

        }

        public new class ErrorMask :
            SkyrimMajorRecord.ErrorMask,
            IErrorMask<ErrorMask>
        {
            #region Members
            public Exception? Intensity;
            public Exception? CustomColorContribution;
            public Exception? ColorR;
            public Exception? ColorG;
            public Exception? ColorB;
            public Exception? DensityContribution;
            public Exception? DensitySize;
            public Exception? DensityWindSpeed;
            public Exception? DensityFallingSpeed;
            public Exception? PhaseFunctionContribution;
            public Exception? PhaseFunctionScattering;
            public Exception? SamplingRepartitionRangeFactor;
            #endregion

            #region IErrorMask
            public override object? GetNthMask(int index)
            {
                VolumetricLighting_FieldIndex enu = (VolumetricLighting_FieldIndex)index;
                switch (enu)
                {
                    case VolumetricLighting_FieldIndex.Intensity:
                        return Intensity;
                    case VolumetricLighting_FieldIndex.CustomColorContribution:
                        return CustomColorContribution;
                    case VolumetricLighting_FieldIndex.ColorR:
                        return ColorR;
                    case VolumetricLighting_FieldIndex.ColorG:
                        return ColorG;
                    case VolumetricLighting_FieldIndex.ColorB:
                        return ColorB;
                    case VolumetricLighting_FieldIndex.DensityContribution:
                        return DensityContribution;
                    case VolumetricLighting_FieldIndex.DensitySize:
                        return DensitySize;
                    case VolumetricLighting_FieldIndex.DensityWindSpeed:
                        return DensityWindSpeed;
                    case VolumetricLighting_FieldIndex.DensityFallingSpeed:
                        return DensityFallingSpeed;
                    case VolumetricLighting_FieldIndex.PhaseFunctionContribution:
                        return PhaseFunctionContribution;
                    case VolumetricLighting_FieldIndex.PhaseFunctionScattering:
                        return PhaseFunctionScattering;
                    case VolumetricLighting_FieldIndex.SamplingRepartitionRangeFactor:
                        return SamplingRepartitionRangeFactor;
                    default:
                        return base.GetNthMask(index);
                }
            }

            public override void SetNthException(int index, Exception ex)
            {
                VolumetricLighting_FieldIndex enu = (VolumetricLighting_FieldIndex)index;
                switch (enu)
                {
                    case VolumetricLighting_FieldIndex.Intensity:
                        this.Intensity = ex;
                        break;
                    case VolumetricLighting_FieldIndex.CustomColorContribution:
                        this.CustomColorContribution = ex;
                        break;
                    case VolumetricLighting_FieldIndex.ColorR:
                        this.ColorR = ex;
                        break;
                    case VolumetricLighting_FieldIndex.ColorG:
                        this.ColorG = ex;
                        break;
                    case VolumetricLighting_FieldIndex.ColorB:
                        this.ColorB = ex;
                        break;
                    case VolumetricLighting_FieldIndex.DensityContribution:
                        this.DensityContribution = ex;
                        break;
                    case VolumetricLighting_FieldIndex.DensitySize:
                        this.DensitySize = ex;
                        break;
                    case VolumetricLighting_FieldIndex.DensityWindSpeed:
                        this.DensityWindSpeed = ex;
                        break;
                    case VolumetricLighting_FieldIndex.DensityFallingSpeed:
                        this.DensityFallingSpeed = ex;
                        break;
                    case VolumetricLighting_FieldIndex.PhaseFunctionContribution:
                        this.PhaseFunctionContribution = ex;
                        break;
                    case VolumetricLighting_FieldIndex.PhaseFunctionScattering:
                        this.PhaseFunctionScattering = ex;
                        break;
                    case VolumetricLighting_FieldIndex.SamplingRepartitionRangeFactor:
                        this.SamplingRepartitionRangeFactor = ex;
                        break;
                    default:
                        base.SetNthException(index, ex);
                        break;
                }
            }

            public override void SetNthMask(int index, object obj)
            {
                VolumetricLighting_FieldIndex enu = (VolumetricLighting_FieldIndex)index;
                switch (enu)
                {
                    case VolumetricLighting_FieldIndex.Intensity:
                        this.Intensity = (Exception?)obj;
                        break;
                    case VolumetricLighting_FieldIndex.CustomColorContribution:
                        this.CustomColorContribution = (Exception?)obj;
                        break;
                    case VolumetricLighting_FieldIndex.ColorR:
                        this.ColorR = (Exception?)obj;
                        break;
                    case VolumetricLighting_FieldIndex.ColorG:
                        this.ColorG = (Exception?)obj;
                        break;
                    case VolumetricLighting_FieldIndex.ColorB:
                        this.ColorB = (Exception?)obj;
                        break;
                    case VolumetricLighting_FieldIndex.DensityContribution:
                        this.DensityContribution = (Exception?)obj;
                        break;
                    case VolumetricLighting_FieldIndex.DensitySize:
                        this.DensitySize = (Exception?)obj;
                        break;
                    case VolumetricLighting_FieldIndex.DensityWindSpeed:
                        this.DensityWindSpeed = (Exception?)obj;
                        break;
                    case VolumetricLighting_FieldIndex.DensityFallingSpeed:
                        this.DensityFallingSpeed = (Exception?)obj;
                        break;
                    case VolumetricLighting_FieldIndex.PhaseFunctionContribution:
                        this.PhaseFunctionContribution = (Exception?)obj;
                        break;
                    case VolumetricLighting_FieldIndex.PhaseFunctionScattering:
                        this.PhaseFunctionScattering = (Exception?)obj;
                        break;
                    case VolumetricLighting_FieldIndex.SamplingRepartitionRangeFactor:
                        this.SamplingRepartitionRangeFactor = (Exception?)obj;
                        break;
                    default:
                        base.SetNthMask(index, obj);
                        break;
                }
            }

            public override bool IsInError()
            {
                if (Overall != null) return true;
                if (Intensity != null) return true;
                if (CustomColorContribution != null) return true;
                if (ColorR != null) return true;
                if (ColorG != null) return true;
                if (ColorB != null) return true;
                if (DensityContribution != null) return true;
                if (DensitySize != null) return true;
                if (DensityWindSpeed != null) return true;
                if (DensityFallingSpeed != null) return true;
                if (PhaseFunctionContribution != null) return true;
                if (PhaseFunctionScattering != null) return true;
                if (SamplingRepartitionRangeFactor != null) return true;
                return false;
            }
            #endregion

            #region To String
            public override string ToString()
            {
                var sb = new StructuredStringBuilder();
                ToString(sb, null);
                return sb.ToString();
            }

            public override void ToString(StructuredStringBuilder sb, string? name = null)
            {
                sb.AppendLine($"{(name ?? "ErrorMask")} =>");
                sb.AppendLine("[");
                using (sb.IncreaseDepth())
                {
                    if (this.Overall != null)
                    {
                        sb.AppendLine("Overall =>");
                        sb.AppendLine("[");
                        using (sb.IncreaseDepth())
                        {
                            sb.AppendLine($"{this.Overall}");
                        }
                        sb.AppendLine("]");
                    }
                    ToString_FillInternal(sb);
                }
                sb.AppendLine("]");
            }
            protected override void ToString_FillInternal(StructuredStringBuilder sb)
            {
                base.ToString_FillInternal(sb);
                {
                    sb.AppendItem(Intensity, "Intensity");
                }
                {
                    sb.AppendItem(CustomColorContribution, "CustomColorContribution");
                }
                {
                    sb.AppendItem(ColorR, "ColorR");
                }
                {
                    sb.AppendItem(ColorG, "ColorG");
                }
                {
                    sb.AppendItem(ColorB, "ColorB");
                }
                {
                    sb.AppendItem(DensityContribution, "DensityContribution");
                }
                {
                    sb.AppendItem(DensitySize, "DensitySize");
                }
                {
                    sb.AppendItem(DensityWindSpeed, "DensityWindSpeed");
                }
                {
                    sb.AppendItem(DensityFallingSpeed, "DensityFallingSpeed");
                }
                {
                    sb.AppendItem(PhaseFunctionContribution, "PhaseFunctionContribution");
                }
                {
                    sb.AppendItem(PhaseFunctionScattering, "PhaseFunctionScattering");
                }
                {
                    sb.AppendItem(SamplingRepartitionRangeFactor, "SamplingRepartitionRangeFactor");
                }
            }
            #endregion

            #region Combine
            public ErrorMask Combine(ErrorMask? rhs)
            {
                if (rhs == null) return this;
                var ret = new ErrorMask();
                ret.Intensity = this.Intensity.Combine(rhs.Intensity);
                ret.CustomColorContribution = this.CustomColorContribution.Combine(rhs.CustomColorContribution);
                ret.ColorR = this.ColorR.Combine(rhs.ColorR);
                ret.ColorG = this.ColorG.Combine(rhs.ColorG);
                ret.ColorB = this.ColorB.Combine(rhs.ColorB);
                ret.DensityContribution = this.DensityContribution.Combine(rhs.DensityContribution);
                ret.DensitySize = this.DensitySize.Combine(rhs.DensitySize);
                ret.DensityWindSpeed = this.DensityWindSpeed.Combine(rhs.DensityWindSpeed);
                ret.DensityFallingSpeed = this.DensityFallingSpeed.Combine(rhs.DensityFallingSpeed);
                ret.PhaseFunctionContribution = this.PhaseFunctionContribution.Combine(rhs.PhaseFunctionContribution);
                ret.PhaseFunctionScattering = this.PhaseFunctionScattering.Combine(rhs.PhaseFunctionScattering);
                ret.SamplingRepartitionRangeFactor = this.SamplingRepartitionRangeFactor.Combine(rhs.SamplingRepartitionRangeFactor);
                return ret;
            }
            public static ErrorMask? Combine(ErrorMask? lhs, ErrorMask? rhs)
            {
                if (lhs != null && rhs != null) return lhs.Combine(rhs);
                return lhs ?? rhs;
            }
            #endregion

            #region Factory
            public static new ErrorMask Factory(ErrorMaskBuilder errorMask)
            {
                return new ErrorMask();
            }
            #endregion

        }
        public new class TranslationMask :
            SkyrimMajorRecord.TranslationMask,
            ITranslationMask
        {
            #region Members
            public bool Intensity;
            public bool CustomColorContribution;
            public bool ColorR;
            public bool ColorG;
            public bool ColorB;
            public bool DensityContribution;
            public bool DensitySize;
            public bool DensityWindSpeed;
            public bool DensityFallingSpeed;
            public bool PhaseFunctionContribution;
            public bool PhaseFunctionScattering;
            public bool SamplingRepartitionRangeFactor;
            #endregion

            #region Ctors
            public TranslationMask(
                bool defaultOn,
                bool onOverall = true)
                : base(defaultOn, onOverall)
            {
                this.Intensity = defaultOn;
                this.CustomColorContribution = defaultOn;
                this.ColorR = defaultOn;
                this.ColorG = defaultOn;
                this.ColorB = defaultOn;
                this.DensityContribution = defaultOn;
                this.DensitySize = defaultOn;
                this.DensityWindSpeed = defaultOn;
                this.DensityFallingSpeed = defaultOn;
                this.PhaseFunctionContribution = defaultOn;
                this.PhaseFunctionScattering = defaultOn;
                this.SamplingRepartitionRangeFactor = defaultOn;
            }

            #endregion

            protected override void GetCrystal(List<(bool On, TranslationCrystal? SubCrystal)> ret)
            {
                base.GetCrystal(ret);
                ret.Add((Intensity, null));
                ret.Add((CustomColorContribution, null));
                ret.Add((ColorR, null));
                ret.Add((ColorG, null));
                ret.Add((ColorB, null));
                ret.Add((DensityContribution, null));
                ret.Add((DensitySize, null));
                ret.Add((DensityWindSpeed, null));
                ret.Add((DensityFallingSpeed, null));
                ret.Add((PhaseFunctionContribution, null));
                ret.Add((PhaseFunctionScattering, null));
                ret.Add((SamplingRepartitionRangeFactor, null));
            }

            public static implicit operator TranslationMask(bool defaultOn)
            {
                return new TranslationMask(defaultOn: defaultOn, onOverall: defaultOn);
            }

        }
        #endregion

        #region Mutagen
        public static readonly RecordType GrupRecordType = VolumetricLighting_Registration.TriggeringRecordType;
        public VolumetricLighting(
            FormKey formKey,
            SkyrimRelease gameRelease)
        {
            this.FormKey = formKey;
            this.FormVersion = gameRelease.ToGameRelease().GetDefaultFormVersion()!.Value;
            CustomCtor();
        }

        private VolumetricLighting(
            FormKey formKey,
            GameRelease gameRelease)
        {
            this.FormKey = formKey;
            this.FormVersion = gameRelease.GetDefaultFormVersion()!.Value;
            CustomCtor();
        }

        internal VolumetricLighting(
            FormKey formKey,
            ushort formVersion)
        {
            this.FormKey = formKey;
            this.FormVersion = formVersion;
            CustomCtor();
        }

        public VolumetricLighting(ISkyrimMod mod)
            : this(
                mod.GetNextFormKey(),
                mod.SkyrimRelease)
        {
        }

        public VolumetricLighting(ISkyrimMod mod, string editorID)
            : this(
                mod.GetNextFormKey(editorID),
                mod.SkyrimRelease)
        {
            this.EditorID = editorID;
        }

        public override string ToString()
        {
            return MajorRecordPrinter<VolumetricLighting>.ToString(this);
        }

        protected override Type LinkType => typeof(IVolumetricLighting);

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is IFormLinkGetter formLink)
            {
                return formLink.Equals(this);
            }
            if (obj is not IVolumetricLightingGetter rhs) return false;
            return ((VolumetricLightingCommon)((IVolumetricLightingGetter)this).CommonInstance()!).Equals(this, rhs, crystal: null);
        }

        public bool Equals(IVolumetricLightingGetter? obj)
        {
            return ((VolumetricLightingCommon)((IVolumetricLightingGetter)this).CommonInstance()!).Equals(this, obj, crystal: null);
        }

        public override int GetHashCode() => ((VolumetricLightingCommon)((IVolumetricLightingGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        #endregion

        #region Binary Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected override object BinaryWriteTranslator => VolumetricLightingBinaryWriteTranslation.Instance;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams? translationParams = null)
        {
            ((VolumetricLightingBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }
        #region Binary Create
        public new static VolumetricLighting CreateFromBinary(
            MutagenFrame frame,
            TypedParseParams? translationParams = null)
        {
            var ret = new VolumetricLighting();
            ((VolumetricLightingSetterCommon)((IVolumetricLightingGetter)ret).CommonSetterInstance()!).CopyInFromBinary(
                item: ret,
                frame: frame,
                translationParams: translationParams);
            return ret;
        }

        #endregion

        public static bool TryCreateFromBinary(
            MutagenFrame frame,
            out VolumetricLighting item,
            TypedParseParams? translationParams = null)
        {
            var startPos = frame.Position;
            item = CreateFromBinary(
                frame: frame,
                translationParams: translationParams);
            return startPos != frame.Position;
        }
        #endregion

        void IPrintable.ToString(StructuredStringBuilder sb, string? name) => this.ToString(sb, name);

        void IClearable.Clear()
        {
            ((VolumetricLightingSetterCommon)((IVolumetricLightingGetter)this).CommonSetterInstance()!).Clear(this);
        }

        internal static new VolumetricLighting GetNew()
        {
            return new VolumetricLighting();
        }

    }
    #endregion

    #region Interface
    public partial interface IVolumetricLighting :
        ILoquiObjectSetter<IVolumetricLightingInternal>,
        ISkyrimMajorRecordInternal,
        IVolumetricLightingGetter
    {
        new Single? Intensity { get; set; }
        new Single? CustomColorContribution { get; set; }
        new Single? ColorR { get; set; }
        new Single? ColorG { get; set; }
        new Single? ColorB { get; set; }
        new Single? DensityContribution { get; set; }
        new Single? DensitySize { get; set; }
        new Single? DensityWindSpeed { get; set; }
        new Single? DensityFallingSpeed { get; set; }
        new Single? PhaseFunctionContribution { get; set; }
        new Single? PhaseFunctionScattering { get; set; }
        new Single? SamplingRepartitionRangeFactor { get; set; }
    }

    public partial interface IVolumetricLightingInternal :
        ISkyrimMajorRecordInternal,
        IVolumetricLighting,
        IVolumetricLightingGetter
    {
    }

    [AssociatedRecordTypesAttribute(Mutagen.Bethesda.Skyrim.Internals.RecordTypeInts.VOLI)]
    public partial interface IVolumetricLightingGetter :
        ISkyrimMajorRecordGetter,
        IBinaryItem,
        ILoquiObject<IVolumetricLightingGetter>,
        IMapsToGetter<IVolumetricLightingGetter>
    {
        static new ILoquiRegistration StaticRegistration => VolumetricLighting_Registration.Instance;
        Single? Intensity { get; }
        Single? CustomColorContribution { get; }
        Single? ColorR { get; }
        Single? ColorG { get; }
        Single? ColorB { get; }
        Single? DensityContribution { get; }
        Single? DensitySize { get; }
        Single? DensityWindSpeed { get; }
        Single? DensityFallingSpeed { get; }
        Single? PhaseFunctionContribution { get; }
        Single? PhaseFunctionScattering { get; }
        Single? SamplingRepartitionRangeFactor { get; }

    }

    #endregion

    #region Common MixIn
    public static partial class VolumetricLightingMixIn
    {
        public static void Clear(this IVolumetricLightingInternal item)
        {
            ((VolumetricLightingSetterCommon)((IVolumetricLightingGetter)item).CommonSetterInstance()!).Clear(item: item);
        }

        public static VolumetricLighting.Mask<bool> GetEqualsMask(
            this IVolumetricLightingGetter item,
            IVolumetricLightingGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            return ((VolumetricLightingCommon)((IVolumetricLightingGetter)item).CommonInstance()!).GetEqualsMask(
                item: item,
                rhs: rhs,
                include: include);
        }

        public static string ToString(
            this IVolumetricLightingGetter item,
            string? name = null,
            VolumetricLighting.Mask<bool>? printMask = null)
        {
            return ((VolumetricLightingCommon)((IVolumetricLightingGetter)item).CommonInstance()!).ToString(
                item: item,
                name: name,
                printMask: printMask);
        }

        public static void ToString(
            this IVolumetricLightingGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            VolumetricLighting.Mask<bool>? printMask = null)
        {
            ((VolumetricLightingCommon)((IVolumetricLightingGetter)item).CommonInstance()!).ToString(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
        }

        public static bool Equals(
            this IVolumetricLightingGetter item,
            IVolumetricLightingGetter rhs,
            VolumetricLighting.TranslationMask? equalsMask = null)
        {
            return ((VolumetricLightingCommon)((IVolumetricLightingGetter)item).CommonInstance()!).Equals(
                lhs: item,
                rhs: rhs,
                crystal: equalsMask?.GetCrystal());
        }

        public static void DeepCopyIn(
            this IVolumetricLightingInternal lhs,
            IVolumetricLightingGetter rhs,
            out VolumetricLighting.ErrorMask errorMask,
            VolumetricLighting.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            ((VolumetricLightingSetterTranslationCommon)((IVolumetricLightingGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
            errorMask = VolumetricLighting.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void DeepCopyIn(
            this IVolumetricLightingInternal lhs,
            IVolumetricLightingGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            ((VolumetricLightingSetterTranslationCommon)((IVolumetricLightingGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: false);
        }

        public static VolumetricLighting DeepCopy(
            this IVolumetricLightingGetter item,
            VolumetricLighting.TranslationMask? copyMask = null)
        {
            return ((VolumetricLightingSetterTranslationCommon)((IVolumetricLightingGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask);
        }

        public static VolumetricLighting DeepCopy(
            this IVolumetricLightingGetter item,
            out VolumetricLighting.ErrorMask errorMask,
            VolumetricLighting.TranslationMask? copyMask = null)
        {
            return ((VolumetricLightingSetterTranslationCommon)((IVolumetricLightingGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: out errorMask);
        }

        public static VolumetricLighting DeepCopy(
            this IVolumetricLightingGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            return ((VolumetricLightingSetterTranslationCommon)((IVolumetricLightingGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: errorMask);
        }

        #region Mutagen
        public static VolumetricLighting Duplicate(
            this IVolumetricLightingGetter item,
            FormKey formKey,
            VolumetricLighting.TranslationMask? copyMask = null)
        {
            return ((VolumetricLightingCommon)((IVolumetricLightingGetter)item).CommonInstance()!).Duplicate(
                item: item,
                formKey: formKey,
                copyMask: copyMask?.GetCrystal());
        }

        #endregion

        #region Binary Translation
        public static void CopyInFromBinary(
            this IVolumetricLightingInternal item,
            MutagenFrame frame,
            TypedParseParams? translationParams = null)
        {
            ((VolumetricLightingSetterCommon)((IVolumetricLightingGetter)item).CommonSetterInstance()!).CopyInFromBinary(
                item: item,
                frame: frame,
                translationParams: translationParams);
        }

        #endregion

    }
    #endregion

}

namespace Mutagen.Bethesda.Skyrim
{
    #region Field Index
    internal enum VolumetricLighting_FieldIndex
    {
        MajorRecordFlagsRaw = 0,
        FormKey = 1,
        VersionControl = 2,
        EditorID = 3,
        FormVersion = 4,
        Version2 = 5,
        Intensity = 6,
        CustomColorContribution = 7,
        ColorR = 8,
        ColorG = 9,
        ColorB = 10,
        DensityContribution = 11,
        DensitySize = 12,
        DensityWindSpeed = 13,
        DensityFallingSpeed = 14,
        PhaseFunctionContribution = 15,
        PhaseFunctionScattering = 16,
        SamplingRepartitionRangeFactor = 17,
    }
    #endregion

    #region Registration
    internal partial class VolumetricLighting_Registration : ILoquiRegistration
    {
        public static readonly VolumetricLighting_Registration Instance = new VolumetricLighting_Registration();

        public static ProtocolKey ProtocolKey => ProtocolDefinition_Skyrim.ProtocolKey;

        public static readonly ObjectKey ObjectKey = new ObjectKey(
            protocolKey: ProtocolDefinition_Skyrim.ProtocolKey,
            msgID: 247,
            version: 0);

        public const string GUID = "825a2586-76f0-41c3-9ba3-138c04e53e06";

        public const ushort AdditionalFieldCount = 12;

        public const ushort FieldCount = 18;

        public static readonly Type MaskType = typeof(VolumetricLighting.Mask<>);

        public static readonly Type ErrorMaskType = typeof(VolumetricLighting.ErrorMask);

        public static readonly Type ClassType = typeof(VolumetricLighting);

        public static readonly Type GetterType = typeof(IVolumetricLightingGetter);

        public static readonly Type? InternalGetterType = null;

        public static readonly Type SetterType = typeof(IVolumetricLighting);

        public static readonly Type? InternalSetterType = typeof(IVolumetricLightingInternal);

        public const string FullName = "Mutagen.Bethesda.Skyrim.VolumetricLighting";

        public const string Name = "VolumetricLighting";

        public const string Namespace = "Mutagen.Bethesda.Skyrim";

        public const byte GenericCount = 0;

        public static readonly Type? GenericRegistrationType = null;

        public static readonly RecordType TriggeringRecordType = RecordTypes.VOLI;
        public static RecordTriggerSpecs TriggerSpecs => _recordSpecs.Value;
        private static readonly Lazy<RecordTriggerSpecs> _recordSpecs = new Lazy<RecordTriggerSpecs>(() =>
        {
            var triggers = RecordCollection.Factory(RecordTypes.VOLI);
            var all = RecordCollection.Factory(
                RecordTypes.VOLI,
                RecordTypes.CNAM,
                RecordTypes.DNAM,
                RecordTypes.ENAM,
                RecordTypes.FNAM,
                RecordTypes.GNAM,
                RecordTypes.HNAM,
                RecordTypes.INAM,
                RecordTypes.JNAM,
                RecordTypes.KNAM,
                RecordTypes.LNAM,
                RecordTypes.MNAM,
                RecordTypes.NNAM);
            return new RecordTriggerSpecs(allRecordTypes: all, triggeringRecordTypes: triggers);
        });
        public static readonly Type BinaryWriteTranslation = typeof(VolumetricLightingBinaryWriteTranslation);
        #region Interface
        ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;
        ObjectKey ILoquiRegistration.ObjectKey => ObjectKey;
        string ILoquiRegistration.GUID => GUID;
        ushort ILoquiRegistration.FieldCount => FieldCount;
        ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;
        Type ILoquiRegistration.MaskType => MaskType;
        Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;
        Type ILoquiRegistration.ClassType => ClassType;
        Type ILoquiRegistration.SetterType => SetterType;
        Type? ILoquiRegistration.InternalSetterType => InternalSetterType;
        Type ILoquiRegistration.GetterType => GetterType;
        Type? ILoquiRegistration.InternalGetterType => InternalGetterType;
        string ILoquiRegistration.FullName => FullName;
        string ILoquiRegistration.Name => Name;
        string ILoquiRegistration.Namespace => Namespace;
        byte ILoquiRegistration.GenericCount => GenericCount;
        Type? ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;
        ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsLoqui(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsSingleton(ushort index) => throw new NotImplementedException();
        string ILoquiRegistration.GetNthName(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsNthDerivative(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsProtected(ushort index) => throw new NotImplementedException();
        Type ILoquiRegistration.GetNthType(ushort index) => throw new NotImplementedException();
        #endregion

    }
    #endregion

    #region Common
    internal partial class VolumetricLightingSetterCommon : SkyrimMajorRecordSetterCommon
    {
        public new static readonly VolumetricLightingSetterCommon Instance = new VolumetricLightingSetterCommon();

        partial void ClearPartial();
        
        public void Clear(IVolumetricLightingInternal item)
        {
            ClearPartial();
            item.Intensity = default;
            item.CustomColorContribution = default;
            item.ColorR = default;
            item.ColorG = default;
            item.ColorB = default;
            item.DensityContribution = default;
            item.DensitySize = default;
            item.DensityWindSpeed = default;
            item.DensityFallingSpeed = default;
            item.PhaseFunctionContribution = default;
            item.PhaseFunctionScattering = default;
            item.SamplingRepartitionRangeFactor = default;
            base.Clear(item);
        }
        
        public override void Clear(ISkyrimMajorRecordInternal item)
        {
            Clear(item: (IVolumetricLightingInternal)item);
        }
        
        public override void Clear(IMajorRecordInternal item)
        {
            Clear(item: (IVolumetricLightingInternal)item);
        }
        
        #region Mutagen
        public void RemapLinks(IVolumetricLighting obj, IReadOnlyDictionary<FormKey, FormKey> mapping)
        {
            base.RemapLinks(obj, mapping);
        }
        
        #endregion
        
        #region Binary Translation
        public virtual void CopyInFromBinary(
            IVolumetricLightingInternal item,
            MutagenFrame frame,
            TypedParseParams? translationParams = null)
        {
            PluginUtilityTranslation.MajorRecordParse<IVolumetricLightingInternal>(
                record: item,
                frame: frame,
                translationParams: translationParams,
                fillStructs: VolumetricLightingBinaryCreateTranslation.FillBinaryStructs,
                fillTyped: VolumetricLightingBinaryCreateTranslation.FillBinaryRecordTypes);
        }
        
        public override void CopyInFromBinary(
            ISkyrimMajorRecordInternal item,
            MutagenFrame frame,
            TypedParseParams? translationParams = null)
        {
            CopyInFromBinary(
                item: (VolumetricLighting)item,
                frame: frame,
                translationParams: translationParams);
        }
        
        public override void CopyInFromBinary(
            IMajorRecordInternal item,
            MutagenFrame frame,
            TypedParseParams? translationParams = null)
        {
            CopyInFromBinary(
                item: (VolumetricLighting)item,
                frame: frame,
                translationParams: translationParams);
        }
        
        #endregion
        
    }
    internal partial class VolumetricLightingCommon : SkyrimMajorRecordCommon
    {
        public new static readonly VolumetricLightingCommon Instance = new VolumetricLightingCommon();

        public VolumetricLighting.Mask<bool> GetEqualsMask(
            IVolumetricLightingGetter item,
            IVolumetricLightingGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            var ret = new VolumetricLighting.Mask<bool>(false);
            ((VolumetricLightingCommon)((IVolumetricLightingGetter)item).CommonInstance()!).FillEqualsMask(
                item: item,
                rhs: rhs,
                ret: ret,
                include: include);
            return ret;
        }
        
        public void FillEqualsMask(
            IVolumetricLightingGetter item,
            IVolumetricLightingGetter rhs,
            VolumetricLighting.Mask<bool> ret,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            if (rhs == null) return;
            ret.Intensity = item.Intensity.EqualsWithin(rhs.Intensity);
            ret.CustomColorContribution = item.CustomColorContribution.EqualsWithin(rhs.CustomColorContribution);
            ret.ColorR = item.ColorR.EqualsWithin(rhs.ColorR);
            ret.ColorG = item.ColorG.EqualsWithin(rhs.ColorG);
            ret.ColorB = item.ColorB.EqualsWithin(rhs.ColorB);
            ret.DensityContribution = item.DensityContribution.EqualsWithin(rhs.DensityContribution);
            ret.DensitySize = item.DensitySize.EqualsWithin(rhs.DensitySize);
            ret.DensityWindSpeed = item.DensityWindSpeed.EqualsWithin(rhs.DensityWindSpeed);
            ret.DensityFallingSpeed = item.DensityFallingSpeed.EqualsWithin(rhs.DensityFallingSpeed);
            ret.PhaseFunctionContribution = item.PhaseFunctionContribution.EqualsWithin(rhs.PhaseFunctionContribution);
            ret.PhaseFunctionScattering = item.PhaseFunctionScattering.EqualsWithin(rhs.PhaseFunctionScattering);
            ret.SamplingRepartitionRangeFactor = item.SamplingRepartitionRangeFactor.EqualsWithin(rhs.SamplingRepartitionRangeFactor);
            base.FillEqualsMask(item, rhs, ret, include);
        }
        
        public string ToString(
            IVolumetricLightingGetter item,
            string? name = null,
            VolumetricLighting.Mask<bool>? printMask = null)
        {
            var sb = new StructuredStringBuilder();
            ToString(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
            return sb.ToString();
        }
        
        public void ToString(
            IVolumetricLightingGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            VolumetricLighting.Mask<bool>? printMask = null)
        {
            if (name == null)
            {
                sb.AppendLine($"VolumetricLighting =>");
            }
            else
            {
                sb.AppendLine($"{name} (VolumetricLighting) =>");
            }
            sb.AppendLine("[");
            using (sb.IncreaseDepth())
            {
                ToStringFields(
                    item: item,
                    sb: sb,
                    printMask: printMask);
            }
            sb.AppendLine("]");
        }
        
        protected static void ToStringFields(
            IVolumetricLightingGetter item,
            StructuredStringBuilder sb,
            VolumetricLighting.Mask<bool>? printMask = null)
        {
            SkyrimMajorRecordCommon.ToStringFields(
                item: item,
                sb: sb,
                printMask: printMask);
            if ((printMask?.Intensity ?? true)
                && item.Intensity is {} IntensityItem)
            {
                sb.AppendItem(IntensityItem, "Intensity");
            }
            if ((printMask?.CustomColorContribution ?? true)
                && item.CustomColorContribution is {} CustomColorContributionItem)
            {
                sb.AppendItem(CustomColorContributionItem, "CustomColorContribution");
            }
            if ((printMask?.ColorR ?? true)
                && item.ColorR is {} ColorRItem)
            {
                sb.AppendItem(ColorRItem, "ColorR");
            }
            if ((printMask?.ColorG ?? true)
                && item.ColorG is {} ColorGItem)
            {
                sb.AppendItem(ColorGItem, "ColorG");
            }
            if ((printMask?.ColorB ?? true)
                && item.ColorB is {} ColorBItem)
            {
                sb.AppendItem(ColorBItem, "ColorB");
            }
            if ((printMask?.DensityContribution ?? true)
                && item.DensityContribution is {} DensityContributionItem)
            {
                sb.AppendItem(DensityContributionItem, "DensityContribution");
            }
            if ((printMask?.DensitySize ?? true)
                && item.DensitySize is {} DensitySizeItem)
            {
                sb.AppendItem(DensitySizeItem, "DensitySize");
            }
            if ((printMask?.DensityWindSpeed ?? true)
                && item.DensityWindSpeed is {} DensityWindSpeedItem)
            {
                sb.AppendItem(DensityWindSpeedItem, "DensityWindSpeed");
            }
            if ((printMask?.DensityFallingSpeed ?? true)
                && item.DensityFallingSpeed is {} DensityFallingSpeedItem)
            {
                sb.AppendItem(DensityFallingSpeedItem, "DensityFallingSpeed");
            }
            if ((printMask?.PhaseFunctionContribution ?? true)
                && item.PhaseFunctionContribution is {} PhaseFunctionContributionItem)
            {
                sb.AppendItem(PhaseFunctionContributionItem, "PhaseFunctionContribution");
            }
            if ((printMask?.PhaseFunctionScattering ?? true)
                && item.PhaseFunctionScattering is {} PhaseFunctionScatteringItem)
            {
                sb.AppendItem(PhaseFunctionScatteringItem, "PhaseFunctionScattering");
            }
            if ((printMask?.SamplingRepartitionRangeFactor ?? true)
                && item.SamplingRepartitionRangeFactor is {} SamplingRepartitionRangeFactorItem)
            {
                sb.AppendItem(SamplingRepartitionRangeFactorItem, "SamplingRepartitionRangeFactor");
            }
        }
        
        public static VolumetricLighting_FieldIndex ConvertFieldIndex(SkyrimMajorRecord_FieldIndex index)
        {
            switch (index)
            {
                case SkyrimMajorRecord_FieldIndex.MajorRecordFlagsRaw:
                    return (VolumetricLighting_FieldIndex)((int)index);
                case SkyrimMajorRecord_FieldIndex.FormKey:
                    return (VolumetricLighting_FieldIndex)((int)index);
                case SkyrimMajorRecord_FieldIndex.VersionControl:
                    return (VolumetricLighting_FieldIndex)((int)index);
                case SkyrimMajorRecord_FieldIndex.EditorID:
                    return (VolumetricLighting_FieldIndex)((int)index);
                case SkyrimMajorRecord_FieldIndex.FormVersion:
                    return (VolumetricLighting_FieldIndex)((int)index);
                case SkyrimMajorRecord_FieldIndex.Version2:
                    return (VolumetricLighting_FieldIndex)((int)index);
                default:
                    throw new ArgumentException($"Index is out of range: {index.ToStringFast_Enum_Only()}");
            }
        }
        
        public static new VolumetricLighting_FieldIndex ConvertFieldIndex(MajorRecord_FieldIndex index)
        {
            switch (index)
            {
                case MajorRecord_FieldIndex.MajorRecordFlagsRaw:
                    return (VolumetricLighting_FieldIndex)((int)index);
                case MajorRecord_FieldIndex.FormKey:
                    return (VolumetricLighting_FieldIndex)((int)index);
                case MajorRecord_FieldIndex.VersionControl:
                    return (VolumetricLighting_FieldIndex)((int)index);
                case MajorRecord_FieldIndex.EditorID:
                    return (VolumetricLighting_FieldIndex)((int)index);
                default:
                    throw new ArgumentException($"Index is out of range: {index.ToStringFast_Enum_Only()}");
            }
        }
        
        #region Equals and Hash
        public virtual bool Equals(
            IVolumetricLightingGetter? lhs,
            IVolumetricLightingGetter? rhs,
            TranslationCrystal? crystal)
        {
            if (!EqualsMaskHelper.RefEquality(lhs, rhs, out var isEqual)) return isEqual;
            if (!base.Equals((ISkyrimMajorRecordGetter)lhs, (ISkyrimMajorRecordGetter)rhs, crystal)) return false;
            if ((crystal?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.Intensity) ?? true))
            {
                if (!lhs.Intensity.EqualsWithin(rhs.Intensity)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.CustomColorContribution) ?? true))
            {
                if (!lhs.CustomColorContribution.EqualsWithin(rhs.CustomColorContribution)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.ColorR) ?? true))
            {
                if (!lhs.ColorR.EqualsWithin(rhs.ColorR)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.ColorG) ?? true))
            {
                if (!lhs.ColorG.EqualsWithin(rhs.ColorG)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.ColorB) ?? true))
            {
                if (!lhs.ColorB.EqualsWithin(rhs.ColorB)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.DensityContribution) ?? true))
            {
                if (!lhs.DensityContribution.EqualsWithin(rhs.DensityContribution)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.DensitySize) ?? true))
            {
                if (!lhs.DensitySize.EqualsWithin(rhs.DensitySize)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.DensityWindSpeed) ?? true))
            {
                if (!lhs.DensityWindSpeed.EqualsWithin(rhs.DensityWindSpeed)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.DensityFallingSpeed) ?? true))
            {
                if (!lhs.DensityFallingSpeed.EqualsWithin(rhs.DensityFallingSpeed)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.PhaseFunctionContribution) ?? true))
            {
                if (!lhs.PhaseFunctionContribution.EqualsWithin(rhs.PhaseFunctionContribution)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.PhaseFunctionScattering) ?? true))
            {
                if (!lhs.PhaseFunctionScattering.EqualsWithin(rhs.PhaseFunctionScattering)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.SamplingRepartitionRangeFactor) ?? true))
            {
                if (!lhs.SamplingRepartitionRangeFactor.EqualsWithin(rhs.SamplingRepartitionRangeFactor)) return false;
            }
            return true;
        }
        
        public override bool Equals(
            ISkyrimMajorRecordGetter? lhs,
            ISkyrimMajorRecordGetter? rhs,
            TranslationCrystal? crystal)
        {
            return Equals(
                lhs: (IVolumetricLightingGetter?)lhs,
                rhs: rhs as IVolumetricLightingGetter,
                crystal: crystal);
        }
        
        public override bool Equals(
            IMajorRecordGetter? lhs,
            IMajorRecordGetter? rhs,
            TranslationCrystal? crystal)
        {
            return Equals(
                lhs: (IVolumetricLightingGetter?)lhs,
                rhs: rhs as IVolumetricLightingGetter,
                crystal: crystal);
        }
        
        public virtual int GetHashCode(IVolumetricLightingGetter item)
        {
            var hash = new HashCode();
            if (item.Intensity is {} Intensityitem)
            {
                hash.Add(Intensityitem);
            }
            if (item.CustomColorContribution is {} CustomColorContributionitem)
            {
                hash.Add(CustomColorContributionitem);
            }
            if (item.ColorR is {} ColorRitem)
            {
                hash.Add(ColorRitem);
            }
            if (item.ColorG is {} ColorGitem)
            {
                hash.Add(ColorGitem);
            }
            if (item.ColorB is {} ColorBitem)
            {
                hash.Add(ColorBitem);
            }
            if (item.DensityContribution is {} DensityContributionitem)
            {
                hash.Add(DensityContributionitem);
            }
            if (item.DensitySize is {} DensitySizeitem)
            {
                hash.Add(DensitySizeitem);
            }
            if (item.DensityWindSpeed is {} DensityWindSpeeditem)
            {
                hash.Add(DensityWindSpeeditem);
            }
            if (item.DensityFallingSpeed is {} DensityFallingSpeeditem)
            {
                hash.Add(DensityFallingSpeeditem);
            }
            if (item.PhaseFunctionContribution is {} PhaseFunctionContributionitem)
            {
                hash.Add(PhaseFunctionContributionitem);
            }
            if (item.PhaseFunctionScattering is {} PhaseFunctionScatteringitem)
            {
                hash.Add(PhaseFunctionScatteringitem);
            }
            if (item.SamplingRepartitionRangeFactor is {} SamplingRepartitionRangeFactoritem)
            {
                hash.Add(SamplingRepartitionRangeFactoritem);
            }
            hash.Add(base.GetHashCode());
            return hash.ToHashCode();
        }
        
        public override int GetHashCode(ISkyrimMajorRecordGetter item)
        {
            return GetHashCode(item: (IVolumetricLightingGetter)item);
        }
        
        public override int GetHashCode(IMajorRecordGetter item)
        {
            return GetHashCode(item: (IVolumetricLightingGetter)item);
        }
        
        #endregion
        
        
        public override object GetNew()
        {
            return VolumetricLighting.GetNew();
        }
        
        #region Mutagen
        public IEnumerable<IFormLinkGetter> GetContainedFormLinks(IVolumetricLightingGetter obj)
        {
            foreach (var item in base.GetContainedFormLinks(obj))
            {
                yield return item;
            }
            yield break;
        }
        
        #region Duplicate
        public VolumetricLighting Duplicate(
            IVolumetricLightingGetter item,
            FormKey formKey,
            TranslationCrystal? copyMask)
        {
            var newRec = new VolumetricLighting(formKey, item.FormVersion);
            newRec.DeepCopyIn(item, default(ErrorMaskBuilder?), copyMask);
            return newRec;
        }
        
        public override SkyrimMajorRecord Duplicate(
            ISkyrimMajorRecordGetter item,
            FormKey formKey,
            TranslationCrystal? copyMask)
        {
            return this.Duplicate(
                item: (IVolumetricLightingGetter)item,
                formKey: formKey,
                copyMask: copyMask);
        }
        
        public override MajorRecord Duplicate(
            IMajorRecordGetter item,
            FormKey formKey,
            TranslationCrystal? copyMask)
        {
            return this.Duplicate(
                item: (IVolumetricLightingGetter)item,
                formKey: formKey,
                copyMask: copyMask);
        }
        
        #endregion
        
        #endregion
        
    }
    internal partial class VolumetricLightingSetterTranslationCommon : SkyrimMajorRecordSetterTranslationCommon
    {
        public new static readonly VolumetricLightingSetterTranslationCommon Instance = new VolumetricLightingSetterTranslationCommon();

        #region DeepCopyIn
        public void DeepCopyIn(
            IVolumetricLightingInternal item,
            IVolumetricLightingGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            base.DeepCopyIn(
                item,
                rhs,
                errorMask,
                copyMask,
                deepCopy: deepCopy);
        }
        
        public void DeepCopyIn(
            IVolumetricLighting item,
            IVolumetricLightingGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            base.DeepCopyIn(
                (ISkyrimMajorRecord)item,
                (ISkyrimMajorRecordGetter)rhs,
                errorMask,
                copyMask,
                deepCopy: deepCopy);
            if ((copyMask?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.Intensity) ?? true))
            {
                item.Intensity = rhs.Intensity;
            }
            if ((copyMask?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.CustomColorContribution) ?? true))
            {
                item.CustomColorContribution = rhs.CustomColorContribution;
            }
            if ((copyMask?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.ColorR) ?? true))
            {
                item.ColorR = rhs.ColorR;
            }
            if ((copyMask?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.ColorG) ?? true))
            {
                item.ColorG = rhs.ColorG;
            }
            if ((copyMask?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.ColorB) ?? true))
            {
                item.ColorB = rhs.ColorB;
            }
            if ((copyMask?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.DensityContribution) ?? true))
            {
                item.DensityContribution = rhs.DensityContribution;
            }
            if ((copyMask?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.DensitySize) ?? true))
            {
                item.DensitySize = rhs.DensitySize;
            }
            if ((copyMask?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.DensityWindSpeed) ?? true))
            {
                item.DensityWindSpeed = rhs.DensityWindSpeed;
            }
            if ((copyMask?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.DensityFallingSpeed) ?? true))
            {
                item.DensityFallingSpeed = rhs.DensityFallingSpeed;
            }
            if ((copyMask?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.PhaseFunctionContribution) ?? true))
            {
                item.PhaseFunctionContribution = rhs.PhaseFunctionContribution;
            }
            if ((copyMask?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.PhaseFunctionScattering) ?? true))
            {
                item.PhaseFunctionScattering = rhs.PhaseFunctionScattering;
            }
            if ((copyMask?.GetShouldTranslate((int)VolumetricLighting_FieldIndex.SamplingRepartitionRangeFactor) ?? true))
            {
                item.SamplingRepartitionRangeFactor = rhs.SamplingRepartitionRangeFactor;
            }
        }
        
        public override void DeepCopyIn(
            ISkyrimMajorRecordInternal item,
            ISkyrimMajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IVolumetricLightingInternal)item,
                rhs: (IVolumetricLightingGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        public override void DeepCopyIn(
            ISkyrimMajorRecord item,
            ISkyrimMajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IVolumetricLighting)item,
                rhs: (IVolumetricLightingGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        public override void DeepCopyIn(
            IMajorRecordInternal item,
            IMajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IVolumetricLightingInternal)item,
                rhs: (IVolumetricLightingGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        public override void DeepCopyIn(
            IMajorRecord item,
            IMajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IVolumetricLighting)item,
                rhs: (IVolumetricLightingGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        #endregion
        
        public VolumetricLighting DeepCopy(
            IVolumetricLightingGetter item,
            VolumetricLighting.TranslationMask? copyMask = null)
        {
            VolumetricLighting ret = (VolumetricLighting)((VolumetricLightingCommon)((IVolumetricLightingGetter)item).CommonInstance()!).GetNew();
            ((VolumetricLightingSetterTranslationCommon)((IVolumetricLightingGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: null,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            return ret;
        }
        
        public VolumetricLighting DeepCopy(
            IVolumetricLightingGetter item,
            out VolumetricLighting.ErrorMask errorMask,
            VolumetricLighting.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            VolumetricLighting ret = (VolumetricLighting)((VolumetricLightingCommon)((IVolumetricLightingGetter)item).CommonInstance()!).GetNew();
            ((VolumetricLightingSetterTranslationCommon)((IVolumetricLightingGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                ret,
                item,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            errorMask = VolumetricLighting.ErrorMask.Factory(errorMaskBuilder);
            return ret;
        }
        
        public VolumetricLighting DeepCopy(
            IVolumetricLightingGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            VolumetricLighting ret = (VolumetricLighting)((VolumetricLightingCommon)((IVolumetricLightingGetter)item).CommonInstance()!).GetNew();
            ((VolumetricLightingSetterTranslationCommon)((IVolumetricLightingGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: true);
            return ret;
        }
        
    }
    #endregion

}

namespace Mutagen.Bethesda.Skyrim
{
    public partial class VolumetricLighting
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => VolumetricLighting_Registration.Instance;
        public new static ILoquiRegistration StaticRegistration => VolumetricLighting_Registration.Instance;
        [DebuggerStepThrough]
        protected override object CommonInstance() => VolumetricLightingCommon.Instance;
        [DebuggerStepThrough]
        protected override object CommonSetterInstance()
        {
            return VolumetricLightingSetterCommon.Instance;
        }
        [DebuggerStepThrough]
        protected override object CommonSetterTranslationInstance() => VolumetricLightingSetterTranslationCommon.Instance;

        #endregion

    }
}

#region Modules
#region Binary Translation
namespace Mutagen.Bethesda.Skyrim
{
    public partial class VolumetricLightingBinaryWriteTranslation :
        SkyrimMajorRecordBinaryWriteTranslation,
        IBinaryWriteTranslator
    {
        public new readonly static VolumetricLightingBinaryWriteTranslation Instance = new VolumetricLightingBinaryWriteTranslation();

        public static void WriteRecordTypes(
            IVolumetricLightingGetter item,
            MutagenWriter writer,
            TypedWriteParams? translationParams)
        {
            MajorRecordBinaryWriteTranslation.WriteRecordTypes(
                item: item,
                writer: writer,
                translationParams: translationParams);
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.Intensity,
                header: translationParams.ConvertToCustom(RecordTypes.CNAM));
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.CustomColorContribution,
                header: translationParams.ConvertToCustom(RecordTypes.DNAM));
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.ColorR,
                header: translationParams.ConvertToCustom(RecordTypes.ENAM));
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.ColorG,
                header: translationParams.ConvertToCustom(RecordTypes.FNAM));
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.ColorB,
                header: translationParams.ConvertToCustom(RecordTypes.GNAM));
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.DensityContribution,
                header: translationParams.ConvertToCustom(RecordTypes.HNAM));
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.DensitySize,
                header: translationParams.ConvertToCustom(RecordTypes.INAM));
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.DensityWindSpeed,
                header: translationParams.ConvertToCustom(RecordTypes.JNAM));
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.DensityFallingSpeed,
                header: translationParams.ConvertToCustom(RecordTypes.KNAM));
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.PhaseFunctionContribution,
                header: translationParams.ConvertToCustom(RecordTypes.LNAM));
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.PhaseFunctionScattering,
                header: translationParams.ConvertToCustom(RecordTypes.MNAM));
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.SamplingRepartitionRangeFactor,
                header: translationParams.ConvertToCustom(RecordTypes.NNAM));
        }

        public void Write(
            MutagenWriter writer,
            IVolumetricLightingGetter item,
            TypedWriteParams? translationParams = null)
        {
            using (HeaderExport.Record(
                writer: writer,
                record: translationParams.ConvertToCustom(RecordTypes.VOLI)))
            {
                try
                {
                    SkyrimMajorRecordBinaryWriteTranslation.WriteEmbedded(
                        item: item,
                        writer: writer);
                    writer.MetaData.FormVersion = item.FormVersion;
                    WriteRecordTypes(
                        item: item,
                        writer: writer,
                        translationParams: translationParams);
                    writer.MetaData.FormVersion = null;
                }
                catch (Exception ex)
                {
                    throw RecordException.Enrich(ex, item);
                }
            }
        }

        public override void Write(
            MutagenWriter writer,
            object item,
            TypedWriteParams? translationParams = null)
        {
            Write(
                item: (IVolumetricLightingGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

        public override void Write(
            MutagenWriter writer,
            ISkyrimMajorRecordGetter item,
            TypedWriteParams? translationParams = null)
        {
            Write(
                item: (IVolumetricLightingGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

        public override void Write(
            MutagenWriter writer,
            IMajorRecordGetter item,
            TypedWriteParams? translationParams = null)
        {
            Write(
                item: (IVolumetricLightingGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

    }

    internal partial class VolumetricLightingBinaryCreateTranslation : SkyrimMajorRecordBinaryCreateTranslation
    {
        public new readonly static VolumetricLightingBinaryCreateTranslation Instance = new VolumetricLightingBinaryCreateTranslation();

        public override RecordType RecordType => RecordTypes.VOLI;
        public static void FillBinaryStructs(
            IVolumetricLightingInternal item,
            MutagenFrame frame)
        {
            SkyrimMajorRecordBinaryCreateTranslation.FillBinaryStructs(
                item: item,
                frame: frame);
        }

        public static ParseResult FillBinaryRecordTypes(
            IVolumetricLightingInternal item,
            MutagenFrame frame,
            PreviousParse lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            RecordType nextRecordType,
            int contentLength,
            TypedParseParams? translationParams = null)
        {
            nextRecordType = translationParams.ConvertToStandard(nextRecordType);
            switch (nextRecordType.TypeInt)
            {
                case RecordTypeInts.CNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Intensity = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)VolumetricLighting_FieldIndex.Intensity;
                }
                case RecordTypeInts.DNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.CustomColorContribution = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)VolumetricLighting_FieldIndex.CustomColorContribution;
                }
                case RecordTypeInts.ENAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.ColorR = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)VolumetricLighting_FieldIndex.ColorR;
                }
                case RecordTypeInts.FNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.ColorG = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)VolumetricLighting_FieldIndex.ColorG;
                }
                case RecordTypeInts.GNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.ColorB = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)VolumetricLighting_FieldIndex.ColorB;
                }
                case RecordTypeInts.HNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.DensityContribution = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)VolumetricLighting_FieldIndex.DensityContribution;
                }
                case RecordTypeInts.INAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.DensitySize = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)VolumetricLighting_FieldIndex.DensitySize;
                }
                case RecordTypeInts.JNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.DensityWindSpeed = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)VolumetricLighting_FieldIndex.DensityWindSpeed;
                }
                case RecordTypeInts.KNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.DensityFallingSpeed = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)VolumetricLighting_FieldIndex.DensityFallingSpeed;
                }
                case RecordTypeInts.LNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.PhaseFunctionContribution = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)VolumetricLighting_FieldIndex.PhaseFunctionContribution;
                }
                case RecordTypeInts.MNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.PhaseFunctionScattering = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)VolumetricLighting_FieldIndex.PhaseFunctionScattering;
                }
                case RecordTypeInts.NNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.SamplingRepartitionRangeFactor = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)VolumetricLighting_FieldIndex.SamplingRepartitionRangeFactor;
                }
                default:
                    return SkyrimMajorRecordBinaryCreateTranslation.FillBinaryRecordTypes(
                        item: item,
                        frame: frame,
                        lastParsed: lastParsed,
                        recordParseCount: recordParseCount,
                        nextRecordType: nextRecordType,
                        contentLength: contentLength);
            }
        }

    }

}
namespace Mutagen.Bethesda.Skyrim
{
    #region Binary Write Mixins
    public static class VolumetricLightingBinaryTranslationMixIn
    {
    }
    #endregion


}
namespace Mutagen.Bethesda.Skyrim
{
    internal partial class VolumetricLightingBinaryOverlay :
        SkyrimMajorRecordBinaryOverlay,
        IVolumetricLightingGetter
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => VolumetricLighting_Registration.Instance;
        public new static ILoquiRegistration StaticRegistration => VolumetricLighting_Registration.Instance;
        [DebuggerStepThrough]
        protected override object CommonInstance() => VolumetricLightingCommon.Instance;
        [DebuggerStepThrough]
        protected override object CommonSetterTranslationInstance() => VolumetricLightingSetterTranslationCommon.Instance;

        #endregion

        void IPrintable.ToString(StructuredStringBuilder sb, string? name) => this.ToString(sb, name);

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected override object BinaryWriteTranslator => VolumetricLightingBinaryWriteTranslation.Instance;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams? translationParams = null)
        {
            ((VolumetricLightingBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }
        protected override Type LinkType => typeof(IVolumetricLighting);


        #region Intensity
        private int? _IntensityLocation;
        public Single? Intensity => _IntensityLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_data, _IntensityLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        #region CustomColorContribution
        private int? _CustomColorContributionLocation;
        public Single? CustomColorContribution => _CustomColorContributionLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_data, _CustomColorContributionLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        #region ColorR
        private int? _ColorRLocation;
        public Single? ColorR => _ColorRLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_data, _ColorRLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        #region ColorG
        private int? _ColorGLocation;
        public Single? ColorG => _ColorGLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_data, _ColorGLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        #region ColorB
        private int? _ColorBLocation;
        public Single? ColorB => _ColorBLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_data, _ColorBLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        #region DensityContribution
        private int? _DensityContributionLocation;
        public Single? DensityContribution => _DensityContributionLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_data, _DensityContributionLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        #region DensitySize
        private int? _DensitySizeLocation;
        public Single? DensitySize => _DensitySizeLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_data, _DensitySizeLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        #region DensityWindSpeed
        private int? _DensityWindSpeedLocation;
        public Single? DensityWindSpeed => _DensityWindSpeedLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_data, _DensityWindSpeedLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        #region DensityFallingSpeed
        private int? _DensityFallingSpeedLocation;
        public Single? DensityFallingSpeed => _DensityFallingSpeedLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_data, _DensityFallingSpeedLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        #region PhaseFunctionContribution
        private int? _PhaseFunctionContributionLocation;
        public Single? PhaseFunctionContribution => _PhaseFunctionContributionLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_data, _PhaseFunctionContributionLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        #region PhaseFunctionScattering
        private int? _PhaseFunctionScatteringLocation;
        public Single? PhaseFunctionScattering => _PhaseFunctionScatteringLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_data, _PhaseFunctionScatteringLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        #region SamplingRepartitionRangeFactor
        private int? _SamplingRepartitionRangeFactorLocation;
        public Single? SamplingRepartitionRangeFactor => _SamplingRepartitionRangeFactorLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_data, _SamplingRepartitionRangeFactorLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        partial void CustomFactoryEnd(
            OverlayStream stream,
            int finalPos,
            int offset);

        partial void CustomCtor();
        protected VolumetricLightingBinaryOverlay(
            ReadOnlyMemorySlice<byte> bytes,
            BinaryOverlayFactoryPackage package)
            : base(
                bytes: bytes,
                package: package)
        {
            this.CustomCtor();
        }

        public static VolumetricLightingBinaryOverlay VolumetricLightingFactory(
            OverlayStream stream,
            BinaryOverlayFactoryPackage package,
            TypedParseParams? parseParams = null)
        {
            stream = Decompression.DecompressStream(stream);
            var ret = new VolumetricLightingBinaryOverlay(
                bytes: HeaderTranslation.ExtractRecordMemory(stream.RemainingMemory, package.MetaData.Constants),
                package: package);
            var finalPos = checked((int)(stream.Position + stream.GetMajorRecordHeader().TotalLength));
            int offset = stream.Position + package.MetaData.Constants.MajorConstants.TypeAndLengthLength;
            ret._package.FormVersion = ret;
            stream.Position += 0x10 + package.MetaData.Constants.MajorConstants.TypeAndLengthLength;
            ret.CustomFactoryEnd(
                stream: stream,
                finalPos: finalPos,
                offset: offset);
            ret.FillSubrecordTypes(
                majorReference: ret,
                stream: stream,
                finalPos: finalPos,
                offset: offset,
                parseParams: parseParams,
                fill: ret.FillRecordType);
            return ret;
        }

        public static VolumetricLightingBinaryOverlay VolumetricLightingFactory(
            ReadOnlyMemorySlice<byte> slice,
            BinaryOverlayFactoryPackage package,
            TypedParseParams? parseParams = null)
        {
            return VolumetricLightingFactory(
                stream: new OverlayStream(slice, package),
                package: package,
                parseParams: parseParams);
        }

        public override ParseResult FillRecordType(
            OverlayStream stream,
            int finalPos,
            int offset,
            RecordType type,
            PreviousParse lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            TypedParseParams? parseParams = null)
        {
            type = parseParams.ConvertToStandard(type);
            switch (type.TypeInt)
            {
                case RecordTypeInts.CNAM:
                {
                    _IntensityLocation = (stream.Position - offset);
                    return (int)VolumetricLighting_FieldIndex.Intensity;
                }
                case RecordTypeInts.DNAM:
                {
                    _CustomColorContributionLocation = (stream.Position - offset);
                    return (int)VolumetricLighting_FieldIndex.CustomColorContribution;
                }
                case RecordTypeInts.ENAM:
                {
                    _ColorRLocation = (stream.Position - offset);
                    return (int)VolumetricLighting_FieldIndex.ColorR;
                }
                case RecordTypeInts.FNAM:
                {
                    _ColorGLocation = (stream.Position - offset);
                    return (int)VolumetricLighting_FieldIndex.ColorG;
                }
                case RecordTypeInts.GNAM:
                {
                    _ColorBLocation = (stream.Position - offset);
                    return (int)VolumetricLighting_FieldIndex.ColorB;
                }
                case RecordTypeInts.HNAM:
                {
                    _DensityContributionLocation = (stream.Position - offset);
                    return (int)VolumetricLighting_FieldIndex.DensityContribution;
                }
                case RecordTypeInts.INAM:
                {
                    _DensitySizeLocation = (stream.Position - offset);
                    return (int)VolumetricLighting_FieldIndex.DensitySize;
                }
                case RecordTypeInts.JNAM:
                {
                    _DensityWindSpeedLocation = (stream.Position - offset);
                    return (int)VolumetricLighting_FieldIndex.DensityWindSpeed;
                }
                case RecordTypeInts.KNAM:
                {
                    _DensityFallingSpeedLocation = (stream.Position - offset);
                    return (int)VolumetricLighting_FieldIndex.DensityFallingSpeed;
                }
                case RecordTypeInts.LNAM:
                {
                    _PhaseFunctionContributionLocation = (stream.Position - offset);
                    return (int)VolumetricLighting_FieldIndex.PhaseFunctionContribution;
                }
                case RecordTypeInts.MNAM:
                {
                    _PhaseFunctionScatteringLocation = (stream.Position - offset);
                    return (int)VolumetricLighting_FieldIndex.PhaseFunctionScattering;
                }
                case RecordTypeInts.NNAM:
                {
                    _SamplingRepartitionRangeFactorLocation = (stream.Position - offset);
                    return (int)VolumetricLighting_FieldIndex.SamplingRepartitionRangeFactor;
                }
                default:
                    return base.FillRecordType(
                        stream: stream,
                        finalPos: finalPos,
                        offset: offset,
                        type: type,
                        lastParsed: lastParsed,
                        recordParseCount: recordParseCount);
            }
        }
        #region To String

        public override void ToString(
            StructuredStringBuilder sb,
            string? name = null)
        {
            VolumetricLightingMixIn.ToString(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        public override string ToString()
        {
            return MajorRecordPrinter<VolumetricLighting>.ToString(this);
        }

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is IFormLinkGetter formLink)
            {
                return formLink.Equals(this);
            }
            if (obj is not IVolumetricLightingGetter rhs) return false;
            return ((VolumetricLightingCommon)((IVolumetricLightingGetter)this).CommonInstance()!).Equals(this, rhs, crystal: null);
        }

        public bool Equals(IVolumetricLightingGetter? obj)
        {
            return ((VolumetricLightingCommon)((IVolumetricLightingGetter)this).CommonInstance()!).Equals(this, obj, crystal: null);
        }

        public override int GetHashCode() => ((VolumetricLightingCommon)((IVolumetricLightingGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

    }

}
#endregion

#endregion

