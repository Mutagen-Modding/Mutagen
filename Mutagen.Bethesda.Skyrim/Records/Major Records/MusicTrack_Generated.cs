/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Autogenerated by Loqui.  Do not manually change.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*/
#region Usings
using Loqui;
using Loqui.Interfaces;
using Loqui.Internal;
using Mutagen.Bethesda.Assets;
using Mutagen.Bethesda.Binary;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Assets;
using Mutagen.Bethesda.Plugins.Binary.Headers;
using Mutagen.Bethesda.Plugins.Binary.Overlay;
using Mutagen.Bethesda.Plugins.Binary.Streams;
using Mutagen.Bethesda.Plugins.Binary.Translations;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Exceptions;
using Mutagen.Bethesda.Plugins.Internals;
using Mutagen.Bethesda.Plugins.Meta;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Plugins.Records.Internals;
using Mutagen.Bethesda.Plugins.Records.Mapping;
using Mutagen.Bethesda.Plugins.Utility;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Skyrim.Assets;
using Mutagen.Bethesda.Skyrim.Internals;
using Mutagen.Bethesda.Translations.Binary;
using Noggog;
using Noggog.StructuredStrings;
using Noggog.StructuredStrings.CSharp;
using RecordTypeInts = Mutagen.Bethesda.Skyrim.Internals.RecordTypeInts;
using RecordTypes = Mutagen.Bethesda.Skyrim.Internals.RecordTypes;
using System.Buffers.Binary;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Reactive.Disposables;
using System.Reactive.Linq;
#endregion

#nullable enable
namespace Mutagen.Bethesda.Skyrim
{
    #region Class
    public partial class MusicTrack :
        SkyrimMajorRecord,
        IEquatable<IMusicTrackGetter>,
        ILoquiObjectSetter<MusicTrack>,
        IMusicTrackInternal
    {
        #region Ctor
        protected MusicTrack()
        {
            CustomCtor();
        }
        partial void CustomCtor();
        #endregion

        #region Type
        public MusicTrack.TypeEnum Type { get; set; } = default(MusicTrack.TypeEnum);
        #endregion
        #region Duration
        public Single? Duration { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? IMusicTrackGetter.Duration => this.Duration;
        #endregion
        #region FadeOut
        public Single? FadeOut { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? IMusicTrackGetter.FadeOut => this.FadeOut;
        #endregion
        #region TrackFilename
        public AssetLink<SkyrimMusicAssetType>? TrackFilename { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        AssetLinkGetter<SkyrimMusicAssetType>? IMusicTrackGetter.TrackFilename => this.TrackFilename;
        #endregion
        #region FinaleFilename
        public AssetLink<SkyrimMusicAssetType>? FinaleFilename { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        AssetLinkGetter<SkyrimMusicAssetType>? IMusicTrackGetter.FinaleFilename => this.FinaleFilename;
        #endregion
        #region LoopData
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private MusicTrackLoopData? _LoopData;
        public MusicTrackLoopData? LoopData
        {
            get => _LoopData;
            set => _LoopData = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IMusicTrackLoopDataGetter? IMusicTrackGetter.LoopData => this.LoopData;
        #endregion
        #region CuePoints
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private ExtendedList<Single>? _CuePoints;
        public ExtendedList<Single>? CuePoints
        {
            get => this._CuePoints;
            set => this._CuePoints = value;
        }
        #region Interface Members
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IReadOnlyList<Single>? IMusicTrackGetter.CuePoints => _CuePoints;
        #endregion

        #endregion
        #region Conditions
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private ExtendedList<Condition>? _Conditions;
        public ExtendedList<Condition>? Conditions
        {
            get => this._Conditions;
            set => this._Conditions = value;
        }
        #region Interface Members
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IReadOnlyList<IConditionGetter>? IMusicTrackGetter.Conditions => _Conditions;
        #endregion

        #endregion
        #region Tracks
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private ExtendedList<IFormLinkGetter<IMusicTrackGetter>>? _Tracks;
        public ExtendedList<IFormLinkGetter<IMusicTrackGetter>>? Tracks
        {
            get => this._Tracks;
            set => this._Tracks = value;
        }
        #region Interface Members
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IReadOnlyList<IFormLinkGetter<IMusicTrackGetter>>? IMusicTrackGetter.Tracks => _Tracks;
        #endregion

        #endregion

        #region To String

        public override void Print(
            StructuredStringBuilder sb,
            string? name = null)
        {
            MusicTrackMixIn.Print(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        #region Mask
        public new class Mask<TItem> :
            SkyrimMajorRecord.Mask<TItem>,
            IEquatable<Mask<TItem>>,
            IMask<TItem>
        {
            #region Ctors
            public Mask(TItem initialValue)
            : base(initialValue)
            {
                this.Type = initialValue;
                this.Duration = initialValue;
                this.FadeOut = initialValue;
                this.TrackFilename = initialValue;
                this.FinaleFilename = initialValue;
                this.LoopData = new MaskItem<TItem, MusicTrackLoopData.Mask<TItem>?>(initialValue, new MusicTrackLoopData.Mask<TItem>(initialValue));
                this.CuePoints = new MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>(initialValue, Enumerable.Empty<(int Index, TItem Value)>());
                this.Conditions = new MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, Condition.Mask<TItem>?>>?>(initialValue, Enumerable.Empty<MaskItemIndexed<TItem, Condition.Mask<TItem>?>>());
                this.Tracks = new MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>(initialValue, Enumerable.Empty<(int Index, TItem Value)>());
            }

            public Mask(
                TItem MajorRecordFlagsRaw,
                TItem FormKey,
                TItem VersionControl,
                TItem EditorID,
                TItem FormVersion,
                TItem Version2,
                TItem SkyrimMajorRecordFlags,
                TItem Type,
                TItem Duration,
                TItem FadeOut,
                TItem TrackFilename,
                TItem FinaleFilename,
                TItem LoopData,
                TItem CuePoints,
                TItem Conditions,
                TItem Tracks)
            : base(
                MajorRecordFlagsRaw: MajorRecordFlagsRaw,
                FormKey: FormKey,
                VersionControl: VersionControl,
                EditorID: EditorID,
                FormVersion: FormVersion,
                Version2: Version2,
                SkyrimMajorRecordFlags: SkyrimMajorRecordFlags)
            {
                this.Type = Type;
                this.Duration = Duration;
                this.FadeOut = FadeOut;
                this.TrackFilename = TrackFilename;
                this.FinaleFilename = FinaleFilename;
                this.LoopData = new MaskItem<TItem, MusicTrackLoopData.Mask<TItem>?>(LoopData, new MusicTrackLoopData.Mask<TItem>(LoopData));
                this.CuePoints = new MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>(CuePoints, Enumerable.Empty<(int Index, TItem Value)>());
                this.Conditions = new MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, Condition.Mask<TItem>?>>?>(Conditions, Enumerable.Empty<MaskItemIndexed<TItem, Condition.Mask<TItem>?>>());
                this.Tracks = new MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>(Tracks, Enumerable.Empty<(int Index, TItem Value)>());
            }

            #pragma warning disable CS8618
            protected Mask()
            {
            }
            #pragma warning restore CS8618

            #endregion

            #region Members
            public TItem Type;
            public TItem Duration;
            public TItem FadeOut;
            public TItem TrackFilename;
            public TItem FinaleFilename;
            public MaskItem<TItem, MusicTrackLoopData.Mask<TItem>?>? LoopData { get; set; }
            public MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>? CuePoints;
            public MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, Condition.Mask<TItem>?>>?>? Conditions;
            public MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>? Tracks;
            #endregion

            #region Equals
            public override bool Equals(object? obj)
            {
                if (!(obj is Mask<TItem> rhs)) return false;
                return Equals(rhs);
            }

            public bool Equals(Mask<TItem>? rhs)
            {
                if (rhs == null) return false;
                if (!base.Equals(rhs)) return false;
                if (!object.Equals(this.Type, rhs.Type)) return false;
                if (!object.Equals(this.Duration, rhs.Duration)) return false;
                if (!object.Equals(this.FadeOut, rhs.FadeOut)) return false;
                if (!object.Equals(this.TrackFilename, rhs.TrackFilename)) return false;
                if (!object.Equals(this.FinaleFilename, rhs.FinaleFilename)) return false;
                if (!object.Equals(this.LoopData, rhs.LoopData)) return false;
                if (!object.Equals(this.CuePoints, rhs.CuePoints)) return false;
                if (!object.Equals(this.Conditions, rhs.Conditions)) return false;
                if (!object.Equals(this.Tracks, rhs.Tracks)) return false;
                return true;
            }
            public override int GetHashCode()
            {
                var hash = new HashCode();
                hash.Add(this.Type);
                hash.Add(this.Duration);
                hash.Add(this.FadeOut);
                hash.Add(this.TrackFilename);
                hash.Add(this.FinaleFilename);
                hash.Add(this.LoopData);
                hash.Add(this.CuePoints);
                hash.Add(this.Conditions);
                hash.Add(this.Tracks);
                hash.Add(base.GetHashCode());
                return hash.ToHashCode();
            }

            #endregion

            #region All
            public override bool All(Func<TItem, bool> eval)
            {
                if (!base.All(eval)) return false;
                if (!eval(this.Type)) return false;
                if (!eval(this.Duration)) return false;
                if (!eval(this.FadeOut)) return false;
                if (!eval(this.TrackFilename)) return false;
                if (!eval(this.FinaleFilename)) return false;
                if (LoopData != null)
                {
                    if (!eval(this.LoopData.Overall)) return false;
                    if (this.LoopData.Specific != null && !this.LoopData.Specific.All(eval)) return false;
                }
                if (this.CuePoints != null)
                {
                    if (!eval(this.CuePoints.Overall)) return false;
                    if (this.CuePoints.Specific != null)
                    {
                        foreach (var item in this.CuePoints.Specific)
                        {
                            if (!eval(item.Value)) return false;
                        }
                    }
                }
                if (this.Conditions != null)
                {
                    if (!eval(this.Conditions.Overall)) return false;
                    if (this.Conditions.Specific != null)
                    {
                        foreach (var item in this.Conditions.Specific)
                        {
                            if (!eval(item.Overall)) return false;
                            if (item.Specific != null && !item.Specific.All(eval)) return false;
                        }
                    }
                }
                if (this.Tracks != null)
                {
                    if (!eval(this.Tracks.Overall)) return false;
                    if (this.Tracks.Specific != null)
                    {
                        foreach (var item in this.Tracks.Specific)
                        {
                            if (!eval(item.Value)) return false;
                        }
                    }
                }
                return true;
            }
            #endregion

            #region Any
            public override bool Any(Func<TItem, bool> eval)
            {
                if (base.Any(eval)) return true;
                if (eval(this.Type)) return true;
                if (eval(this.Duration)) return true;
                if (eval(this.FadeOut)) return true;
                if (eval(this.TrackFilename)) return true;
                if (eval(this.FinaleFilename)) return true;
                if (LoopData != null)
                {
                    if (eval(this.LoopData.Overall)) return true;
                    if (this.LoopData.Specific != null && this.LoopData.Specific.Any(eval)) return true;
                }
                if (this.CuePoints != null)
                {
                    if (eval(this.CuePoints.Overall)) return true;
                    if (this.CuePoints.Specific != null)
                    {
                        foreach (var item in this.CuePoints.Specific)
                        {
                            if (!eval(item.Value)) return false;
                        }
                    }
                }
                if (this.Conditions != null)
                {
                    if (eval(this.Conditions.Overall)) return true;
                    if (this.Conditions.Specific != null)
                    {
                        foreach (var item in this.Conditions.Specific)
                        {
                            if (!eval(item.Overall)) return false;
                            if (item.Specific != null && !item.Specific.All(eval)) return false;
                        }
                    }
                }
                if (this.Tracks != null)
                {
                    if (eval(this.Tracks.Overall)) return true;
                    if (this.Tracks.Specific != null)
                    {
                        foreach (var item in this.Tracks.Specific)
                        {
                            if (!eval(item.Value)) return false;
                        }
                    }
                }
                return false;
            }
            #endregion

            #region Translate
            public new Mask<R> Translate<R>(Func<TItem, R> eval)
            {
                var ret = new MusicTrack.Mask<R>();
                this.Translate_InternalFill(ret, eval);
                return ret;
            }

            protected void Translate_InternalFill<R>(Mask<R> obj, Func<TItem, R> eval)
            {
                base.Translate_InternalFill(obj, eval);
                obj.Type = eval(this.Type);
                obj.Duration = eval(this.Duration);
                obj.FadeOut = eval(this.FadeOut);
                obj.TrackFilename = eval(this.TrackFilename);
                obj.FinaleFilename = eval(this.FinaleFilename);
                obj.LoopData = this.LoopData == null ? null : new MaskItem<R, MusicTrackLoopData.Mask<R>?>(eval(this.LoopData.Overall), this.LoopData.Specific?.Translate(eval));
                if (CuePoints != null)
                {
                    obj.CuePoints = new MaskItem<R, IEnumerable<(int Index, R Value)>?>(eval(this.CuePoints.Overall), Enumerable.Empty<(int Index, R Value)>());
                    if (CuePoints.Specific != null)
                    {
                        var l = new List<(int Index, R Item)>();
                        obj.CuePoints.Specific = l;
                        foreach (var item in CuePoints.Specific)
                        {
                            R mask = eval(item.Value);
                            l.Add((item.Index, mask));
                        }
                    }
                }
                if (Conditions != null)
                {
                    obj.Conditions = new MaskItem<R, IEnumerable<MaskItemIndexed<R, Condition.Mask<R>?>>?>(eval(this.Conditions.Overall), Enumerable.Empty<MaskItemIndexed<R, Condition.Mask<R>?>>());
                    if (Conditions.Specific != null)
                    {
                        var l = new List<MaskItemIndexed<R, Condition.Mask<R>?>>();
                        obj.Conditions.Specific = l;
                        foreach (var item in Conditions.Specific)
                        {
                            MaskItemIndexed<R, Condition.Mask<R>?>? mask = item == null ? null : new MaskItemIndexed<R, Condition.Mask<R>?>(item.Index, eval(item.Overall), item.Specific?.Translate(eval));
                            if (mask == null) continue;
                            l.Add(mask);
                        }
                    }
                }
                if (Tracks != null)
                {
                    obj.Tracks = new MaskItem<R, IEnumerable<(int Index, R Value)>?>(eval(this.Tracks.Overall), Enumerable.Empty<(int Index, R Value)>());
                    if (Tracks.Specific != null)
                    {
                        var l = new List<(int Index, R Item)>();
                        obj.Tracks.Specific = l;
                        foreach (var item in Tracks.Specific)
                        {
                            R mask = eval(item.Value);
                            l.Add((item.Index, mask));
                        }
                    }
                }
            }
            #endregion

            #region To String
            public override string ToString() => this.Print();

            public string Print(MusicTrack.Mask<bool>? printMask = null)
            {
                var sb = new StructuredStringBuilder();
                Print(sb, printMask);
                return sb.ToString();
            }

            public void Print(StructuredStringBuilder sb, MusicTrack.Mask<bool>? printMask = null)
            {
                sb.AppendLine($"{nameof(MusicTrack.Mask<TItem>)} =>");
                using (sb.Brace())
                {
                    if (printMask?.Type ?? true)
                    {
                        sb.AppendItem(Type, "Type");
                    }
                    if (printMask?.Duration ?? true)
                    {
                        sb.AppendItem(Duration, "Duration");
                    }
                    if (printMask?.FadeOut ?? true)
                    {
                        sb.AppendItem(FadeOut, "FadeOut");
                    }
                    if (printMask?.TrackFilename ?? true)
                    {
                        sb.AppendItem(TrackFilename, "TrackFilename");
                    }
                    if (printMask?.FinaleFilename ?? true)
                    {
                        sb.AppendItem(FinaleFilename, "FinaleFilename");
                    }
                    if (printMask?.LoopData?.Overall ?? true)
                    {
                        LoopData?.Print(sb);
                    }
                    if ((printMask?.CuePoints?.Overall ?? true)
                        && CuePoints is {} CuePointsItem)
                    {
                        sb.AppendLine("CuePoints =>");
                        using (sb.Brace())
                        {
                            sb.AppendItem(CuePointsItem.Overall);
                            if (CuePointsItem.Specific != null)
                            {
                                foreach (var subItem in CuePointsItem.Specific)
                                {
                                    using (sb.Brace())
                                    {
                                        {
                                            sb.AppendItem(subItem);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if ((printMask?.Conditions?.Overall ?? true)
                        && Conditions is {} ConditionsItem)
                    {
                        sb.AppendLine("Conditions =>");
                        using (sb.Brace())
                        {
                            sb.AppendItem(ConditionsItem.Overall);
                            if (ConditionsItem.Specific != null)
                            {
                                foreach (var subItem in ConditionsItem.Specific)
                                {
                                    using (sb.Brace())
                                    {
                                        subItem?.Print(sb);
                                    }
                                }
                            }
                        }
                    }
                    if ((printMask?.Tracks?.Overall ?? true)
                        && Tracks is {} TracksItem)
                    {
                        sb.AppendLine("Tracks =>");
                        using (sb.Brace())
                        {
                            sb.AppendItem(TracksItem.Overall);
                            if (TracksItem.Specific != null)
                            {
                                foreach (var subItem in TracksItem.Specific)
                                {
                                    using (sb.Brace())
                                    {
                                        {
                                            sb.AppendItem(subItem);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            #endregion

        }

        public new class ErrorMask :
            SkyrimMajorRecord.ErrorMask,
            IErrorMask<ErrorMask>
        {
            #region Members
            public Exception? Type;
            public Exception? Duration;
            public Exception? FadeOut;
            public Exception? TrackFilename;
            public Exception? FinaleFilename;
            public MaskItem<Exception?, MusicTrackLoopData.ErrorMask?>? LoopData;
            public MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>? CuePoints;
            public MaskItem<Exception?, IEnumerable<MaskItem<Exception?, Condition.ErrorMask?>>?>? Conditions;
            public MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>? Tracks;
            #endregion

            #region IErrorMask
            public override object? GetNthMask(int index)
            {
                MusicTrack_FieldIndex enu = (MusicTrack_FieldIndex)index;
                switch (enu)
                {
                    case MusicTrack_FieldIndex.Type:
                        return Type;
                    case MusicTrack_FieldIndex.Duration:
                        return Duration;
                    case MusicTrack_FieldIndex.FadeOut:
                        return FadeOut;
                    case MusicTrack_FieldIndex.TrackFilename:
                        return TrackFilename;
                    case MusicTrack_FieldIndex.FinaleFilename:
                        return FinaleFilename;
                    case MusicTrack_FieldIndex.LoopData:
                        return LoopData;
                    case MusicTrack_FieldIndex.CuePoints:
                        return CuePoints;
                    case MusicTrack_FieldIndex.Conditions:
                        return Conditions;
                    case MusicTrack_FieldIndex.Tracks:
                        return Tracks;
                    default:
                        return base.GetNthMask(index);
                }
            }

            public override void SetNthException(int index, Exception ex)
            {
                MusicTrack_FieldIndex enu = (MusicTrack_FieldIndex)index;
                switch (enu)
                {
                    case MusicTrack_FieldIndex.Type:
                        this.Type = ex;
                        break;
                    case MusicTrack_FieldIndex.Duration:
                        this.Duration = ex;
                        break;
                    case MusicTrack_FieldIndex.FadeOut:
                        this.FadeOut = ex;
                        break;
                    case MusicTrack_FieldIndex.TrackFilename:
                        this.TrackFilename = ex;
                        break;
                    case MusicTrack_FieldIndex.FinaleFilename:
                        this.FinaleFilename = ex;
                        break;
                    case MusicTrack_FieldIndex.LoopData:
                        this.LoopData = new MaskItem<Exception?, MusicTrackLoopData.ErrorMask?>(ex, null);
                        break;
                    case MusicTrack_FieldIndex.CuePoints:
                        this.CuePoints = new MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>(ex, null);
                        break;
                    case MusicTrack_FieldIndex.Conditions:
                        this.Conditions = new MaskItem<Exception?, IEnumerable<MaskItem<Exception?, Condition.ErrorMask?>>?>(ex, null);
                        break;
                    case MusicTrack_FieldIndex.Tracks:
                        this.Tracks = new MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>(ex, null);
                        break;
                    default:
                        base.SetNthException(index, ex);
                        break;
                }
            }

            public override void SetNthMask(int index, object obj)
            {
                MusicTrack_FieldIndex enu = (MusicTrack_FieldIndex)index;
                switch (enu)
                {
                    case MusicTrack_FieldIndex.Type:
                        this.Type = (Exception?)obj;
                        break;
                    case MusicTrack_FieldIndex.Duration:
                        this.Duration = (Exception?)obj;
                        break;
                    case MusicTrack_FieldIndex.FadeOut:
                        this.FadeOut = (Exception?)obj;
                        break;
                    case MusicTrack_FieldIndex.TrackFilename:
                        this.TrackFilename = (Exception?)obj;
                        break;
                    case MusicTrack_FieldIndex.FinaleFilename:
                        this.FinaleFilename = (Exception?)obj;
                        break;
                    case MusicTrack_FieldIndex.LoopData:
                        this.LoopData = (MaskItem<Exception?, MusicTrackLoopData.ErrorMask?>?)obj;
                        break;
                    case MusicTrack_FieldIndex.CuePoints:
                        this.CuePoints = (MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>)obj;
                        break;
                    case MusicTrack_FieldIndex.Conditions:
                        this.Conditions = (MaskItem<Exception?, IEnumerable<MaskItem<Exception?, Condition.ErrorMask?>>?>)obj;
                        break;
                    case MusicTrack_FieldIndex.Tracks:
                        this.Tracks = (MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>)obj;
                        break;
                    default:
                        base.SetNthMask(index, obj);
                        break;
                }
            }

            public override bool IsInError()
            {
                if (Overall != null) return true;
                if (Type != null) return true;
                if (Duration != null) return true;
                if (FadeOut != null) return true;
                if (TrackFilename != null) return true;
                if (FinaleFilename != null) return true;
                if (LoopData != null) return true;
                if (CuePoints != null) return true;
                if (Conditions != null) return true;
                if (Tracks != null) return true;
                return false;
            }
            #endregion

            #region To String
            public override string ToString() => this.Print();

            public override void Print(StructuredStringBuilder sb, string? name = null)
            {
                sb.AppendLine($"{(name ?? "ErrorMask")} =>");
                using (sb.Brace())
                {
                    if (this.Overall != null)
                    {
                        sb.AppendLine("Overall =>");
                        using (sb.Brace())
                        {
                            sb.AppendLine($"{this.Overall}");
                        }
                    }
                    PrintFillInternal(sb);
                }
            }
            protected override void PrintFillInternal(StructuredStringBuilder sb)
            {
                base.PrintFillInternal(sb);
                {
                    sb.AppendItem(Type, "Type");
                }
                {
                    sb.AppendItem(Duration, "Duration");
                }
                {
                    sb.AppendItem(FadeOut, "FadeOut");
                }
                {
                    sb.AppendItem(TrackFilename, "TrackFilename");
                }
                {
                    sb.AppendItem(FinaleFilename, "FinaleFilename");
                }
                LoopData?.Print(sb);
                if (CuePoints is {} CuePointsItem)
                {
                    sb.AppendLine("CuePoints =>");
                    using (sb.Brace())
                    {
                        sb.AppendItem(CuePointsItem.Overall);
                        if (CuePointsItem.Specific != null)
                        {
                            foreach (var subItem in CuePointsItem.Specific)
                            {
                                using (sb.Brace())
                                {
                                    {
                                        sb.AppendItem(subItem);
                                    }
                                }
                            }
                        }
                    }
                }
                if (Conditions is {} ConditionsItem)
                {
                    sb.AppendLine("Conditions =>");
                    using (sb.Brace())
                    {
                        sb.AppendItem(ConditionsItem.Overall);
                        if (ConditionsItem.Specific != null)
                        {
                            foreach (var subItem in ConditionsItem.Specific)
                            {
                                using (sb.Brace())
                                {
                                    subItem?.Print(sb);
                                }
                            }
                        }
                    }
                }
                if (Tracks is {} TracksItem)
                {
                    sb.AppendLine("Tracks =>");
                    using (sb.Brace())
                    {
                        sb.AppendItem(TracksItem.Overall);
                        if (TracksItem.Specific != null)
                        {
                            foreach (var subItem in TracksItem.Specific)
                            {
                                using (sb.Brace())
                                {
                                    {
                                        sb.AppendItem(subItem);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            #endregion

            #region Combine
            public ErrorMask Combine(ErrorMask? rhs)
            {
                if (rhs == null) return this;
                var ret = new ErrorMask();
                ret.Type = this.Type.Combine(rhs.Type);
                ret.Duration = this.Duration.Combine(rhs.Duration);
                ret.FadeOut = this.FadeOut.Combine(rhs.FadeOut);
                ret.TrackFilename = this.TrackFilename.Combine(rhs.TrackFilename);
                ret.FinaleFilename = this.FinaleFilename.Combine(rhs.FinaleFilename);
                ret.LoopData = this.LoopData.Combine(rhs.LoopData, (l, r) => l.Combine(r));
                ret.CuePoints = new MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>(Noggog.ExceptionExt.Combine(this.CuePoints?.Overall, rhs.CuePoints?.Overall), Noggog.ExceptionExt.Combine(this.CuePoints?.Specific, rhs.CuePoints?.Specific));
                ret.Conditions = new MaskItem<Exception?, IEnumerable<MaskItem<Exception?, Condition.ErrorMask?>>?>(Noggog.ExceptionExt.Combine(this.Conditions?.Overall, rhs.Conditions?.Overall), Noggog.ExceptionExt.Combine(this.Conditions?.Specific, rhs.Conditions?.Specific));
                ret.Tracks = new MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>(Noggog.ExceptionExt.Combine(this.Tracks?.Overall, rhs.Tracks?.Overall), Noggog.ExceptionExt.Combine(this.Tracks?.Specific, rhs.Tracks?.Specific));
                return ret;
            }
            public static ErrorMask? Combine(ErrorMask? lhs, ErrorMask? rhs)
            {
                if (lhs != null && rhs != null) return lhs.Combine(rhs);
                return lhs ?? rhs;
            }
            #endregion

            #region Factory
            public static new ErrorMask Factory(ErrorMaskBuilder errorMask)
            {
                return new ErrorMask();
            }
            #endregion

        }
        public new class TranslationMask :
            SkyrimMajorRecord.TranslationMask,
            ITranslationMask
        {
            #region Members
            public bool Type;
            public bool Duration;
            public bool FadeOut;
            public bool TrackFilename;
            public bool FinaleFilename;
            public MusicTrackLoopData.TranslationMask? LoopData;
            public bool CuePoints;
            public Condition.TranslationMask? Conditions;
            public bool Tracks;
            #endregion

            #region Ctors
            public TranslationMask(
                bool defaultOn,
                bool onOverall = true)
                : base(defaultOn, onOverall)
            {
                this.Type = defaultOn;
                this.Duration = defaultOn;
                this.FadeOut = defaultOn;
                this.TrackFilename = defaultOn;
                this.FinaleFilename = defaultOn;
                this.CuePoints = defaultOn;
                this.Tracks = defaultOn;
            }

            #endregion

            protected override void GetCrystal(List<(bool On, TranslationCrystal? SubCrystal)> ret)
            {
                base.GetCrystal(ret);
                ret.Add((Type, null));
                ret.Add((Duration, null));
                ret.Add((FadeOut, null));
                ret.Add((TrackFilename, null));
                ret.Add((FinaleFilename, null));
                ret.Add((LoopData != null ? LoopData.OnOverall : DefaultOn, LoopData?.GetCrystal()));
                ret.Add((CuePoints, null));
                ret.Add((Conditions == null ? DefaultOn : !Conditions.GetCrystal().CopyNothing, Conditions?.GetCrystal()));
                ret.Add((Tracks, null));
            }

            public static implicit operator TranslationMask(bool defaultOn)
            {
                return new TranslationMask(defaultOn: defaultOn, onOverall: defaultOn);
            }

        }
        #endregion

        #region Mutagen
        public static readonly RecordType GrupRecordType = MusicTrack_Registration.TriggeringRecordType;
        public override IEnumerable<IFormLinkGetter> EnumerateFormLinks() => MusicTrackCommon.Instance.EnumerateFormLinks(this);
        public override void RemapLinks(IReadOnlyDictionary<FormKey, FormKey> mapping) => MusicTrackSetterCommon.Instance.RemapLinks(this, mapping);
        public MusicTrack(
            FormKey formKey,
            SkyrimRelease gameRelease)
        {
            this.FormKey = formKey;
            this.FormVersion = GameConstants.Get(gameRelease.ToGameRelease()).DefaultFormVersion!.Value;
            CustomCtor();
        }

        private MusicTrack(
            FormKey formKey,
            GameRelease gameRelease)
        {
            this.FormKey = formKey;
            this.FormVersion = GameConstants.Get(gameRelease).DefaultFormVersion!.Value;
            CustomCtor();
        }

        internal MusicTrack(
            FormKey formKey,
            ushort formVersion)
        {
            this.FormKey = formKey;
            this.FormVersion = formVersion;
            CustomCtor();
        }

        public MusicTrack(ISkyrimMod mod)
            : this(
                mod.GetNextFormKey(),
                mod.SkyrimRelease)
        {
        }

        public MusicTrack(ISkyrimMod mod, string editorID)
            : this(
                mod.GetNextFormKey(editorID),
                mod.SkyrimRelease)
        {
            this.EditorID = editorID;
        }

        public override string ToString()
        {
            return MajorRecordPrinter<MusicTrack>.ToString(this);
        }

        protected override Type LinkType => typeof(IMusicTrack);

        public override IEnumerable<IAssetLinkGetter> EnumerateAssetLinks(AssetLinkQuery queryCategories, IAssetLinkCache? linkCache, Type? assetType) => MusicTrackCommon.Instance.EnumerateAssetLinks(this, queryCategories, linkCache, assetType);
        public override IEnumerable<IAssetLink> EnumerateListedAssetLinks() => MusicTrackSetterCommon.Instance.EnumerateListedAssetLinks(this);
        public override void RemapAssetLinks(IReadOnlyDictionary<IAssetLinkGetter, string> mapping, AssetLinkQuery queryCategories, IAssetLinkCache? linkCache) => MusicTrackSetterCommon.Instance.RemapAssetLinks(this, mapping, linkCache, queryCategories);
        public override void RemapListedAssetLinks(IReadOnlyDictionary<IAssetLinkGetter, string> mapping) => MusicTrackSetterCommon.Instance.RemapAssetLinks(this, mapping, null, AssetLinkQuery.Listed);
        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is IFormLinkGetter formLink)
            {
                return formLink.Equals(this);
            }
            if (obj is not IMusicTrackGetter rhs) return false;
            return ((MusicTrackCommon)((IMusicTrackGetter)this).CommonInstance()!).Equals(this, rhs, equalsMask: null);
        }

        public bool Equals(IMusicTrackGetter? obj)
        {
            return ((MusicTrackCommon)((IMusicTrackGetter)this).CommonInstance()!).Equals(this, obj, equalsMask: null);
        }

        public override int GetHashCode() => ((MusicTrackCommon)((IMusicTrackGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        #endregion

        #region Binary Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected override object BinaryWriteTranslator => MusicTrackBinaryWriteTranslation.Instance;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((MusicTrackBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }
        #region Binary Create
        public new static MusicTrack CreateFromBinary(
            MutagenFrame frame,
            TypedParseParams translationParams = default)
        {
            var ret = new MusicTrack();
            ((MusicTrackSetterCommon)((IMusicTrackGetter)ret).CommonSetterInstance()!).CopyInFromBinary(
                item: ret,
                frame: frame,
                translationParams: translationParams);
            return ret;
        }

        #endregion

        public static bool TryCreateFromBinary(
            MutagenFrame frame,
            out MusicTrack item,
            TypedParseParams translationParams = default)
        {
            var startPos = frame.Position;
            item = CreateFromBinary(
                frame: frame,
                translationParams: translationParams);
            return startPos != frame.Position;
        }
        #endregion

        void IPrintable.Print(StructuredStringBuilder sb, string? name) => this.Print(sb, name);

        void IClearable.Clear()
        {
            ((MusicTrackSetterCommon)((IMusicTrackGetter)this).CommonSetterInstance()!).Clear(this);
        }

        internal static new MusicTrack GetNew()
        {
            return new MusicTrack();
        }

    }
    #endregion

    #region Interface
    public partial interface IMusicTrack :
        IAssetLinkContainer,
        IFormLinkContainer,
        ILoquiObjectSetter<IMusicTrackInternal>,
        IMusicTrackGetter,
        ISkyrimMajorRecordInternal
    {
        new MusicTrack.TypeEnum Type { get; set; }
        new Single? Duration { get; set; }
        new Single? FadeOut { get; set; }
        new AssetLink<SkyrimMusicAssetType>? TrackFilename { get; set; }
        new AssetLink<SkyrimMusicAssetType>? FinaleFilename { get; set; }
        new MusicTrackLoopData? LoopData { get; set; }
        new ExtendedList<Single>? CuePoints { get; set; }
        new ExtendedList<Condition>? Conditions { get; set; }
        new ExtendedList<IFormLinkGetter<IMusicTrackGetter>>? Tracks { get; set; }
    }

    public partial interface IMusicTrackInternal :
        ISkyrimMajorRecordInternal,
        IMusicTrack,
        IMusicTrackGetter
    {
    }

    [AssociatedRecordTypesAttribute(Mutagen.Bethesda.Skyrim.Internals.RecordTypeInts.MUST)]
    public partial interface IMusicTrackGetter :
        ISkyrimMajorRecordGetter,
        IAssetLinkContainerGetter,
        IBinaryItem,
        IFormLinkContainerGetter,
        ILoquiObject<IMusicTrackGetter>,
        IMapsToGetter<IMusicTrackGetter>
    {
        static new ILoquiRegistration StaticRegistration => MusicTrack_Registration.Instance;
        MusicTrack.TypeEnum Type { get; }
        Single? Duration { get; }
        Single? FadeOut { get; }
        AssetLinkGetter<SkyrimMusicAssetType>? TrackFilename { get; }
        AssetLinkGetter<SkyrimMusicAssetType>? FinaleFilename { get; }
        IMusicTrackLoopDataGetter? LoopData { get; }
        IReadOnlyList<Single>? CuePoints { get; }
        IReadOnlyList<IConditionGetter>? Conditions { get; }
        IReadOnlyList<IFormLinkGetter<IMusicTrackGetter>>? Tracks { get; }

    }

    #endregion

    #region Common MixIn
    public static partial class MusicTrackMixIn
    {
        public static void Clear(this IMusicTrackInternal item)
        {
            ((MusicTrackSetterCommon)((IMusicTrackGetter)item).CommonSetterInstance()!).Clear(item: item);
        }

        public static MusicTrack.Mask<bool> GetEqualsMask(
            this IMusicTrackGetter item,
            IMusicTrackGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            return ((MusicTrackCommon)((IMusicTrackGetter)item).CommonInstance()!).GetEqualsMask(
                item: item,
                rhs: rhs,
                include: include);
        }

        public static string Print(
            this IMusicTrackGetter item,
            string? name = null,
            MusicTrack.Mask<bool>? printMask = null)
        {
            return ((MusicTrackCommon)((IMusicTrackGetter)item).CommonInstance()!).Print(
                item: item,
                name: name,
                printMask: printMask);
        }

        public static void Print(
            this IMusicTrackGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            MusicTrack.Mask<bool>? printMask = null)
        {
            ((MusicTrackCommon)((IMusicTrackGetter)item).CommonInstance()!).Print(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
        }

        public static bool Equals(
            this IMusicTrackGetter item,
            IMusicTrackGetter rhs,
            MusicTrack.TranslationMask? equalsMask = null)
        {
            return ((MusicTrackCommon)((IMusicTrackGetter)item).CommonInstance()!).Equals(
                lhs: item,
                rhs: rhs,
                equalsMask: equalsMask?.GetCrystal());
        }

        public static void DeepCopyIn(
            this IMusicTrackInternal lhs,
            IMusicTrackGetter rhs,
            out MusicTrack.ErrorMask errorMask,
            MusicTrack.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            ((MusicTrackSetterTranslationCommon)((IMusicTrackGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
            errorMask = MusicTrack.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void DeepCopyIn(
            this IMusicTrackInternal lhs,
            IMusicTrackGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            ((MusicTrackSetterTranslationCommon)((IMusicTrackGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: false);
        }

        public static MusicTrack DeepCopy(
            this IMusicTrackGetter item,
            MusicTrack.TranslationMask? copyMask = null)
        {
            return ((MusicTrackSetterTranslationCommon)((IMusicTrackGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask);
        }

        public static MusicTrack DeepCopy(
            this IMusicTrackGetter item,
            out MusicTrack.ErrorMask errorMask,
            MusicTrack.TranslationMask? copyMask = null)
        {
            return ((MusicTrackSetterTranslationCommon)((IMusicTrackGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: out errorMask);
        }

        public static MusicTrack DeepCopy(
            this IMusicTrackGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            return ((MusicTrackSetterTranslationCommon)((IMusicTrackGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: errorMask);
        }

        #region Mutagen
        public static MusicTrack Duplicate(
            this IMusicTrackGetter item,
            FormKey formKey,
            MusicTrack.TranslationMask? copyMask = null)
        {
            return ((MusicTrackCommon)((IMusicTrackGetter)item).CommonInstance()!).Duplicate(
                item: item,
                formKey: formKey,
                copyMask: copyMask?.GetCrystal());
        }

        public static MusicTrack Duplicate(
            this IMusicTrackGetter item,
            FormKey formKey,
            TranslationCrystal? copyMask)
        {
            return ((MusicTrackCommon)((IMusicTrackGetter)item).CommonInstance()!).Duplicate(
                item: item,
                formKey: formKey,
                copyMask: copyMask);
        }

        #endregion

        #region Binary Translation
        public static void CopyInFromBinary(
            this IMusicTrackInternal item,
            MutagenFrame frame,
            TypedParseParams translationParams = default)
        {
            ((MusicTrackSetterCommon)((IMusicTrackGetter)item).CommonSetterInstance()!).CopyInFromBinary(
                item: item,
                frame: frame,
                translationParams: translationParams);
        }

        #endregion

    }
    #endregion

}

namespace Mutagen.Bethesda.Skyrim
{
    #region Field Index
    internal enum MusicTrack_FieldIndex
    {
        MajorRecordFlagsRaw = 0,
        FormKey = 1,
        VersionControl = 2,
        EditorID = 3,
        FormVersion = 4,
        Version2 = 5,
        SkyrimMajorRecordFlags = 6,
        Type = 7,
        Duration = 8,
        FadeOut = 9,
        TrackFilename = 10,
        FinaleFilename = 11,
        LoopData = 12,
        CuePoints = 13,
        Conditions = 14,
        Tracks = 15,
    }
    #endregion

    #region Registration
    internal partial class MusicTrack_Registration : ILoquiRegistration
    {
        public static readonly MusicTrack_Registration Instance = new MusicTrack_Registration();

        public static ProtocolKey ProtocolKey => ProtocolDefinition_Skyrim.ProtocolKey;

        public const ushort AdditionalFieldCount = 9;

        public const ushort FieldCount = 16;

        public static readonly Type MaskType = typeof(MusicTrack.Mask<>);

        public static readonly Type ErrorMaskType = typeof(MusicTrack.ErrorMask);

        public static readonly Type ClassType = typeof(MusicTrack);

        public static readonly Type GetterType = typeof(IMusicTrackGetter);

        public static readonly Type? InternalGetterType = null;

        public static readonly Type SetterType = typeof(IMusicTrack);

        public static readonly Type? InternalSetterType = typeof(IMusicTrackInternal);

        public const string FullName = "Mutagen.Bethesda.Skyrim.MusicTrack";

        public const string Name = "MusicTrack";

        public const string Namespace = "Mutagen.Bethesda.Skyrim";

        public const byte GenericCount = 0;

        public static readonly Type? GenericRegistrationType = null;

        public static readonly RecordType TriggeringRecordType = RecordTypes.MUST;
        public static RecordTriggerSpecs TriggerSpecs => _recordSpecs.Value;
        private static readonly Lazy<RecordTriggerSpecs> _recordSpecs = new Lazy<RecordTriggerSpecs>(() =>
        {
            var triggers = RecordCollection.Factory(RecordTypes.MUST);
            var all = RecordCollection.Factory(
                RecordTypes.MUST,
                RecordTypes.CNAM,
                RecordTypes.FLTV,
                RecordTypes.DNAM,
                RecordTypes.ANAM,
                RecordTypes.BNAM,
                RecordTypes.LNAM,
                RecordTypes.FNAM,
                RecordTypes.CTDA,
                RecordTypes.CITC,
                RecordTypes.CIS1,
                RecordTypes.CIS2,
                RecordTypes.SNAM);
            return new RecordTriggerSpecs(
                allRecordTypes: all,
                triggeringRecordTypes: triggers);
        });
        public static readonly Type BinaryWriteTranslation = typeof(MusicTrackBinaryWriteTranslation);
        #region Interface
        ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;
        ushort ILoquiRegistration.FieldCount => FieldCount;
        ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;
        Type ILoquiRegistration.MaskType => MaskType;
        Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;
        Type ILoquiRegistration.ClassType => ClassType;
        Type ILoquiRegistration.SetterType => SetterType;
        Type? ILoquiRegistration.InternalSetterType => InternalSetterType;
        Type ILoquiRegistration.GetterType => GetterType;
        Type? ILoquiRegistration.InternalGetterType => InternalGetterType;
        string ILoquiRegistration.FullName => FullName;
        string ILoquiRegistration.Name => Name;
        string ILoquiRegistration.Namespace => Namespace;
        byte ILoquiRegistration.GenericCount => GenericCount;
        Type? ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;
        ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsLoqui(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsSingleton(ushort index) => throw new NotImplementedException();
        string ILoquiRegistration.GetNthName(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsNthDerivative(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsProtected(ushort index) => throw new NotImplementedException();
        Type ILoquiRegistration.GetNthType(ushort index) => throw new NotImplementedException();
        #endregion

    }
    #endregion

    #region Common
    internal partial class MusicTrackSetterCommon : SkyrimMajorRecordSetterCommon
    {
        public new static readonly MusicTrackSetterCommon Instance = new MusicTrackSetterCommon();

        partial void ClearPartial();
        
        public void Clear(IMusicTrackInternal item)
        {
            ClearPartial();
            item.Type = default(MusicTrack.TypeEnum);
            item.Duration = default;
            item.FadeOut = default;
            item.TrackFilename = default;
            item.FinaleFilename = default;
            item.LoopData = null;
            item.CuePoints = null;
            item.Conditions = null;
            item.Tracks = null;
            base.Clear(item);
        }
        
        public override void Clear(ISkyrimMajorRecordInternal item)
        {
            Clear(item: (IMusicTrackInternal)item);
        }
        
        public override void Clear(IMajorRecordInternal item)
        {
            Clear(item: (IMusicTrackInternal)item);
        }
        
        #region Mutagen
        public void RemapLinks(IMusicTrack obj, IReadOnlyDictionary<FormKey, FormKey> mapping)
        {
            base.RemapLinks(obj, mapping);
            obj.Conditions?.RemapLinks(mapping);
            obj.Tracks?.RemapLinks(mapping);
        }
        
        public IEnumerable<IAssetLink> EnumerateListedAssetLinks(IMusicTrack obj)
        {
            foreach (var item in base.EnumerateListedAssetLinks(obj))
            {
                yield return item;
            }
            if (obj.TrackFilename != null)
            {
                yield return obj.TrackFilename;
            }
            if (obj.FinaleFilename != null)
            {
                yield return obj.FinaleFilename;
            }
            yield break;
        }
        
        public void RemapAssetLinks(
            IMusicTrack obj,
            IReadOnlyDictionary<IAssetLinkGetter, string> mapping,
            IAssetLinkCache? linkCache,
            AssetLinkQuery queryCategories)
        {
            base.RemapAssetLinks(obj, mapping, linkCache, queryCategories);
            if (queryCategories.HasFlag(AssetLinkQuery.Listed))
            {
                obj.TrackFilename?.Relink(mapping);
                obj.FinaleFilename?.Relink(mapping);
            }
        }
        
        #endregion
        
        #region Binary Translation
        public virtual void CopyInFromBinary(
            IMusicTrackInternal item,
            MutagenFrame frame,
            TypedParseParams translationParams)
        {
            PluginUtilityTranslation.MajorRecordParse<IMusicTrackInternal>(
                record: item,
                frame: frame,
                translationParams: translationParams,
                fillStructs: MusicTrackBinaryCreateTranslation.FillBinaryStructs,
                fillTyped: MusicTrackBinaryCreateTranslation.FillBinaryRecordTypes);
        }
        
        public override void CopyInFromBinary(
            ISkyrimMajorRecordInternal item,
            MutagenFrame frame,
            TypedParseParams translationParams)
        {
            CopyInFromBinary(
                item: (MusicTrack)item,
                frame: frame,
                translationParams: translationParams);
        }
        
        public override void CopyInFromBinary(
            IMajorRecordInternal item,
            MutagenFrame frame,
            TypedParseParams translationParams)
        {
            CopyInFromBinary(
                item: (MusicTrack)item,
                frame: frame,
                translationParams: translationParams);
        }
        
        #endregion
        
    }
    internal partial class MusicTrackCommon : SkyrimMajorRecordCommon
    {
        public new static readonly MusicTrackCommon Instance = new MusicTrackCommon();

        public MusicTrack.Mask<bool> GetEqualsMask(
            IMusicTrackGetter item,
            IMusicTrackGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            var ret = new MusicTrack.Mask<bool>(false);
            ((MusicTrackCommon)((IMusicTrackGetter)item).CommonInstance()!).FillEqualsMask(
                item: item,
                rhs: rhs,
                ret: ret,
                include: include);
            return ret;
        }
        
        public void FillEqualsMask(
            IMusicTrackGetter item,
            IMusicTrackGetter rhs,
            MusicTrack.Mask<bool> ret,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            ret.Type = item.Type == rhs.Type;
            ret.Duration = item.Duration.EqualsWithin(rhs.Duration);
            ret.FadeOut = item.FadeOut.EqualsWithin(rhs.FadeOut);
            ret.TrackFilename = object.Equals(item.TrackFilename, rhs.TrackFilename);
            ret.FinaleFilename = object.Equals(item.FinaleFilename, rhs.FinaleFilename);
            ret.LoopData = EqualsMaskHelper.EqualsHelper(
                item.LoopData,
                rhs.LoopData,
                (loqLhs, loqRhs, incl) => loqLhs.GetEqualsMask(loqRhs, incl),
                include);
            ret.CuePoints = item.CuePoints.CollectionEqualsHelper(
                rhs.CuePoints,
                (l, r) => l.EqualsWithin(r),
                include);
            ret.Conditions = item.Conditions.CollectionEqualsHelper(
                rhs.Conditions,
                (loqLhs, loqRhs) => loqLhs.GetEqualsMask(loqRhs, include),
                include);
            ret.Tracks = item.Tracks.CollectionEqualsHelper(
                rhs.Tracks,
                (l, r) => object.Equals(l, r),
                include);
            base.FillEqualsMask(item, rhs, ret, include);
        }
        
        public string Print(
            IMusicTrackGetter item,
            string? name = null,
            MusicTrack.Mask<bool>? printMask = null)
        {
            var sb = new StructuredStringBuilder();
            Print(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
            return sb.ToString();
        }
        
        public void Print(
            IMusicTrackGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            MusicTrack.Mask<bool>? printMask = null)
        {
            if (name == null)
            {
                sb.AppendLine($"MusicTrack =>");
            }
            else
            {
                sb.AppendLine($"{name} (MusicTrack) =>");
            }
            using (sb.Brace())
            {
                ToStringFields(
                    item: item,
                    sb: sb,
                    printMask: printMask);
            }
        }
        
        protected static void ToStringFields(
            IMusicTrackGetter item,
            StructuredStringBuilder sb,
            MusicTrack.Mask<bool>? printMask = null)
        {
            SkyrimMajorRecordCommon.ToStringFields(
                item: item,
                sb: sb,
                printMask: printMask);
            if (printMask?.Type ?? true)
            {
                sb.AppendItem(item.Type, "Type");
            }
            if ((printMask?.Duration ?? true)
                && item.Duration is {} DurationItem)
            {
                sb.AppendItem(DurationItem, "Duration");
            }
            if ((printMask?.FadeOut ?? true)
                && item.FadeOut is {} FadeOutItem)
            {
                sb.AppendItem(FadeOutItem, "FadeOut");
            }
            if ((printMask?.TrackFilename ?? true)
                && item.TrackFilename is {} TrackFilenameItem)
            {
                sb.AppendItem(TrackFilenameItem, "TrackFilename");
            }
            if ((printMask?.FinaleFilename ?? true)
                && item.FinaleFilename is {} FinaleFilenameItem)
            {
                sb.AppendItem(FinaleFilenameItem, "FinaleFilename");
            }
            if ((printMask?.LoopData?.Overall ?? true)
                && item.LoopData is {} LoopDataItem)
            {
                LoopDataItem?.Print(sb, "LoopData");
            }
            if ((printMask?.CuePoints?.Overall ?? true)
                && item.CuePoints is {} CuePointsItem)
            {
                sb.AppendLine("CuePoints =>");
                using (sb.Brace())
                {
                    foreach (var subItem in CuePointsItem)
                    {
                        using (sb.Brace())
                        {
                            sb.AppendItem(subItem);
                        }
                    }
                }
            }
            if ((printMask?.Conditions?.Overall ?? true)
                && item.Conditions is {} ConditionsItem)
            {
                sb.AppendLine("Conditions =>");
                using (sb.Brace())
                {
                    foreach (var subItem in ConditionsItem)
                    {
                        using (sb.Brace())
                        {
                            subItem?.Print(sb, "Item");
                        }
                    }
                }
            }
            if ((printMask?.Tracks?.Overall ?? true)
                && item.Tracks is {} TracksItem)
            {
                sb.AppendLine("Tracks =>");
                using (sb.Brace())
                {
                    foreach (var subItem in TracksItem)
                    {
                        using (sb.Brace())
                        {
                            sb.AppendItem(subItem.FormKey);
                        }
                    }
                }
            }
        }
        
        public static MusicTrack_FieldIndex ConvertFieldIndex(SkyrimMajorRecord_FieldIndex index)
        {
            switch (index)
            {
                case SkyrimMajorRecord_FieldIndex.MajorRecordFlagsRaw:
                    return (MusicTrack_FieldIndex)((int)index);
                case SkyrimMajorRecord_FieldIndex.FormKey:
                    return (MusicTrack_FieldIndex)((int)index);
                case SkyrimMajorRecord_FieldIndex.VersionControl:
                    return (MusicTrack_FieldIndex)((int)index);
                case SkyrimMajorRecord_FieldIndex.EditorID:
                    return (MusicTrack_FieldIndex)((int)index);
                case SkyrimMajorRecord_FieldIndex.FormVersion:
                    return (MusicTrack_FieldIndex)((int)index);
                case SkyrimMajorRecord_FieldIndex.Version2:
                    return (MusicTrack_FieldIndex)((int)index);
                case SkyrimMajorRecord_FieldIndex.SkyrimMajorRecordFlags:
                    return (MusicTrack_FieldIndex)((int)index);
                default:
                    throw new ArgumentException($"Index is out of range: {index.ToStringFast()}");
            }
        }
        
        public static new MusicTrack_FieldIndex ConvertFieldIndex(MajorRecord_FieldIndex index)
        {
            switch (index)
            {
                case MajorRecord_FieldIndex.MajorRecordFlagsRaw:
                    return (MusicTrack_FieldIndex)((int)index);
                case MajorRecord_FieldIndex.FormKey:
                    return (MusicTrack_FieldIndex)((int)index);
                case MajorRecord_FieldIndex.VersionControl:
                    return (MusicTrack_FieldIndex)((int)index);
                case MajorRecord_FieldIndex.EditorID:
                    return (MusicTrack_FieldIndex)((int)index);
                default:
                    throw new ArgumentException($"Index is out of range: {index.ToStringFast()}");
            }
        }
        
        #region Equals and Hash
        public virtual bool Equals(
            IMusicTrackGetter? lhs,
            IMusicTrackGetter? rhs,
            TranslationCrystal? equalsMask)
        {
            if (!EqualsMaskHelper.RefEquality(lhs, rhs, out var isEqual)) return isEqual;
            if (!base.Equals((ISkyrimMajorRecordGetter)lhs, (ISkyrimMajorRecordGetter)rhs, equalsMask)) return false;
            if ((equalsMask?.GetShouldTranslate((int)MusicTrack_FieldIndex.Type) ?? true))
            {
                if (lhs.Type != rhs.Type) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MusicTrack_FieldIndex.Duration) ?? true))
            {
                if (!lhs.Duration.EqualsWithin(rhs.Duration)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MusicTrack_FieldIndex.FadeOut) ?? true))
            {
                if (!lhs.FadeOut.EqualsWithin(rhs.FadeOut)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MusicTrack_FieldIndex.TrackFilename) ?? true))
            {
                if (!object.Equals(lhs.TrackFilename, rhs.TrackFilename)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MusicTrack_FieldIndex.FinaleFilename) ?? true))
            {
                if (!object.Equals(lhs.FinaleFilename, rhs.FinaleFilename)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MusicTrack_FieldIndex.LoopData) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.LoopData, rhs.LoopData, out var lhsLoopData, out var rhsLoopData, out var isLoopDataEqual))
                {
                    if (!((MusicTrackLoopDataCommon)((IMusicTrackLoopDataGetter)lhsLoopData).CommonInstance()!).Equals(lhsLoopData, rhsLoopData, equalsMask?.GetSubCrystal((int)MusicTrack_FieldIndex.LoopData))) return false;
                }
                else if (!isLoopDataEqual) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MusicTrack_FieldIndex.CuePoints) ?? true))
            {
                if (!lhs.CuePoints.SequenceEqualNullable(rhs.CuePoints)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MusicTrack_FieldIndex.Conditions) ?? true))
            {
                if (!lhs.Conditions.SequenceEqualNullable(rhs.Conditions, (l, r) => ((ConditionCommon)((IConditionGetter)l).CommonInstance()!).Equals(l, r, equalsMask?.GetSubCrystal((int)MusicTrack_FieldIndex.Conditions)))) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MusicTrack_FieldIndex.Tracks) ?? true))
            {
                if (!lhs.Tracks.SequenceEqualNullable(rhs.Tracks)) return false;
            }
            return true;
        }
        
        public override bool Equals(
            ISkyrimMajorRecordGetter? lhs,
            ISkyrimMajorRecordGetter? rhs,
            TranslationCrystal? equalsMask)
        {
            return Equals(
                lhs: (IMusicTrackGetter?)lhs,
                rhs: rhs as IMusicTrackGetter,
                equalsMask: equalsMask);
        }
        
        public override bool Equals(
            IMajorRecordGetter? lhs,
            IMajorRecordGetter? rhs,
            TranslationCrystal? equalsMask)
        {
            return Equals(
                lhs: (IMusicTrackGetter?)lhs,
                rhs: rhs as IMusicTrackGetter,
                equalsMask: equalsMask);
        }
        
        public virtual int GetHashCode(IMusicTrackGetter item)
        {
            var hash = new HashCode();
            hash.Add(item.Type);
            if (item.Duration is {} Durationitem)
            {
                hash.Add(Durationitem);
            }
            if (item.FadeOut is {} FadeOutitem)
            {
                hash.Add(FadeOutitem);
            }
            if (item.TrackFilename is {} TrackFilenameitem)
            {
                hash.Add(TrackFilenameitem);
            }
            if (item.FinaleFilename is {} FinaleFilenameitem)
            {
                hash.Add(FinaleFilenameitem);
            }
            if (item.LoopData is {} LoopDataitem)
            {
                hash.Add(LoopDataitem);
            }
            hash.Add(item.CuePoints);
            hash.Add(item.Conditions);
            hash.Add(item.Tracks);
            hash.Add(base.GetHashCode());
            return hash.ToHashCode();
        }
        
        public override int GetHashCode(ISkyrimMajorRecordGetter item)
        {
            return GetHashCode(item: (IMusicTrackGetter)item);
        }
        
        public override int GetHashCode(IMajorRecordGetter item)
        {
            return GetHashCode(item: (IMusicTrackGetter)item);
        }
        
        #endregion
        
        
        public override object GetNew()
        {
            return MusicTrack.GetNew();
        }
        
        #region Mutagen
        public IEnumerable<IFormLinkGetter> EnumerateFormLinks(IMusicTrackGetter obj)
        {
            foreach (var item in base.EnumerateFormLinks(obj))
            {
                yield return item;
            }
            if (obj.Conditions is {} ConditionsItem)
            {
                foreach (var item in ConditionsItem.SelectMany(f => f.EnumerateFormLinks()))
                {
                    yield return FormLinkInformation.Factory(item);
                }
            }
            if (obj.Tracks is {} TracksItem)
            {
                foreach (var item in TracksItem)
                {
                    yield return FormLinkInformation.Factory(item);
                }
            }
            yield break;
        }
        
        public IEnumerable<IAssetLinkGetter> EnumerateAssetLinks(IMusicTrackGetter obj, AssetLinkQuery queryCategories, IAssetLinkCache? linkCache, Type? assetType)
        {
            foreach (var item in base.EnumerateAssetLinks(obj, queryCategories, linkCache, assetType))
            {
                yield return item;
            }
            if (queryCategories.HasFlag(AssetLinkQuery.Listed))
            {
                if (obj.TrackFilename != null)
                {
                    yield return obj.TrackFilename;
                }
                if (obj.FinaleFilename != null)
                {
                    yield return obj.FinaleFilename;
                }
            }
            yield break;
        }
        
        #region Duplicate
        public MusicTrack Duplicate(
            IMusicTrackGetter item,
            FormKey formKey,
            TranslationCrystal? copyMask)
        {
            var newRec = new MusicTrack(formKey, item.FormVersion);
            newRec.DeepCopyIn(item, default(ErrorMaskBuilder?), copyMask);
            return newRec;
        }
        
        public override SkyrimMajorRecord Duplicate(
            ISkyrimMajorRecordGetter item,
            FormKey formKey,
            TranslationCrystal? copyMask)
        {
            return this.Duplicate(
                item: (IMusicTrackGetter)item,
                formKey: formKey,
                copyMask: copyMask);
        }
        
        public override MajorRecord Duplicate(
            IMajorRecordGetter item,
            FormKey formKey,
            TranslationCrystal? copyMask)
        {
            return this.Duplicate(
                item: (IMusicTrackGetter)item,
                formKey: formKey,
                copyMask: copyMask);
        }
        
        #endregion
        
        #endregion
        
    }
    internal partial class MusicTrackSetterTranslationCommon : SkyrimMajorRecordSetterTranslationCommon
    {
        public new static readonly MusicTrackSetterTranslationCommon Instance = new MusicTrackSetterTranslationCommon();

        #region DeepCopyIn
        public void DeepCopyIn(
            IMusicTrackInternal item,
            IMusicTrackGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            base.DeepCopyIn(
                item,
                rhs,
                errorMask,
                copyMask,
                deepCopy: deepCopy);
        }
        
        public void DeepCopyIn(
            IMusicTrack item,
            IMusicTrackGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            base.DeepCopyIn(
                (ISkyrimMajorRecord)item,
                (ISkyrimMajorRecordGetter)rhs,
                errorMask,
                copyMask,
                deepCopy: deepCopy);
            if ((copyMask?.GetShouldTranslate((int)MusicTrack_FieldIndex.Type) ?? true))
            {
                item.Type = rhs.Type;
            }
            if ((copyMask?.GetShouldTranslate((int)MusicTrack_FieldIndex.Duration) ?? true))
            {
                item.Duration = rhs.Duration;
            }
            if ((copyMask?.GetShouldTranslate((int)MusicTrack_FieldIndex.FadeOut) ?? true))
            {
                item.FadeOut = rhs.FadeOut;
            }
            item.TrackFilename = PluginUtilityTranslation.AssetNullableDeepCopyIn(item.TrackFilename, rhs.TrackFilename);
            item.FinaleFilename = PluginUtilityTranslation.AssetNullableDeepCopyIn(item.FinaleFilename, rhs.FinaleFilename);
            if ((copyMask?.GetShouldTranslate((int)MusicTrack_FieldIndex.LoopData) ?? true))
            {
                errorMask?.PushIndex((int)MusicTrack_FieldIndex.LoopData);
                try
                {
                    if(rhs.LoopData is {} rhsLoopData)
                    {
                        item.LoopData = rhsLoopData.DeepCopy(
                            errorMask: errorMask,
                            copyMask?.GetSubCrystal((int)MusicTrack_FieldIndex.LoopData));
                    }
                    else
                    {
                        item.LoopData = default;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)MusicTrack_FieldIndex.CuePoints) ?? true))
            {
                errorMask?.PushIndex((int)MusicTrack_FieldIndex.CuePoints);
                try
                {
                    if ((rhs.CuePoints != null))
                    {
                        item.CuePoints = 
                            rhs.CuePoints
                            .ToExtendedList<Single>();
                    }
                    else
                    {
                        item.CuePoints = null;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)MusicTrack_FieldIndex.Conditions) ?? true))
            {
                errorMask?.PushIndex((int)MusicTrack_FieldIndex.Conditions);
                try
                {
                    if ((rhs.Conditions != null))
                    {
                        item.Conditions = 
                            rhs.Conditions
                            .Select(r =>
                            {
                                return r.DeepCopy(
                                    errorMask: errorMask,
                                    default(TranslationCrystal));
                            })
                            .ToExtendedList<Condition>();
                    }
                    else
                    {
                        item.Conditions = null;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)MusicTrack_FieldIndex.Tracks) ?? true))
            {
                errorMask?.PushIndex((int)MusicTrack_FieldIndex.Tracks);
                try
                {
                    if ((rhs.Tracks != null))
                    {
                        item.Tracks = 
                            rhs.Tracks
                                .Select(b => (IFormLinkGetter<IMusicTrackGetter>)new FormLink<IMusicTrackGetter>(b.FormKey))
                            .ToExtendedList<IFormLinkGetter<IMusicTrackGetter>>();
                    }
                    else
                    {
                        item.Tracks = null;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            DeepCopyInCustom(
                item: item,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        partial void DeepCopyInCustom(
            IMusicTrack item,
            IMusicTrackGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy);
        public override void DeepCopyIn(
            ISkyrimMajorRecordInternal item,
            ISkyrimMajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IMusicTrackInternal)item,
                rhs: (IMusicTrackGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        public override void DeepCopyIn(
            ISkyrimMajorRecord item,
            ISkyrimMajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IMusicTrack)item,
                rhs: (IMusicTrackGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        public override void DeepCopyIn(
            IMajorRecordInternal item,
            IMajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IMusicTrackInternal)item,
                rhs: (IMusicTrackGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        public override void DeepCopyIn(
            IMajorRecord item,
            IMajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IMusicTrack)item,
                rhs: (IMusicTrackGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        #endregion
        
        public MusicTrack DeepCopy(
            IMusicTrackGetter item,
            MusicTrack.TranslationMask? copyMask = null)
        {
            MusicTrack ret = (MusicTrack)((MusicTrackCommon)((IMusicTrackGetter)item).CommonInstance()!).GetNew();
            ((MusicTrackSetterTranslationCommon)((IMusicTrackGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: null,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            return ret;
        }
        
        public MusicTrack DeepCopy(
            IMusicTrackGetter item,
            out MusicTrack.ErrorMask errorMask,
            MusicTrack.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            MusicTrack ret = (MusicTrack)((MusicTrackCommon)((IMusicTrackGetter)item).CommonInstance()!).GetNew();
            ((MusicTrackSetterTranslationCommon)((IMusicTrackGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                ret,
                item,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            errorMask = MusicTrack.ErrorMask.Factory(errorMaskBuilder);
            return ret;
        }
        
        public MusicTrack DeepCopy(
            IMusicTrackGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            MusicTrack ret = (MusicTrack)((MusicTrackCommon)((IMusicTrackGetter)item).CommonInstance()!).GetNew();
            ((MusicTrackSetterTranslationCommon)((IMusicTrackGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: true);
            return ret;
        }
        
    }
    #endregion

}

namespace Mutagen.Bethesda.Skyrim
{
    public partial class MusicTrack
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => MusicTrack_Registration.Instance;
        public new static ILoquiRegistration StaticRegistration => MusicTrack_Registration.Instance;
        [DebuggerStepThrough]
        protected override object CommonInstance() => MusicTrackCommon.Instance;
        [DebuggerStepThrough]
        protected override object CommonSetterInstance()
        {
            return MusicTrackSetterCommon.Instance;
        }
        [DebuggerStepThrough]
        protected override object CommonSetterTranslationInstance() => MusicTrackSetterTranslationCommon.Instance;

        #endregion

    }
}

#region Modules
#region Binary Translation
namespace Mutagen.Bethesda.Skyrim
{
    public partial class MusicTrackBinaryWriteTranslation :
        SkyrimMajorRecordBinaryWriteTranslation,
        IBinaryWriteTranslator
    {
        public new static readonly MusicTrackBinaryWriteTranslation Instance = new();

        public static void WriteRecordTypes(
            IMusicTrackGetter item,
            MutagenWriter writer,
            TypedWriteParams translationParams)
        {
            MajorRecordBinaryWriteTranslation.WriteRecordTypes(
                item: item,
                writer: writer,
                translationParams: translationParams);
            EnumBinaryTranslation<MusicTrack.TypeEnum, MutagenFrame, MutagenWriter>.Instance.Write(
                writer,
                item.Type,
                length: 4,
                header: translationParams.ConvertToCustom(RecordTypes.CNAM));
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.Duration,
                header: translationParams.ConvertToCustom(RecordTypes.FLTV));
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.FadeOut,
                header: translationParams.ConvertToCustom(RecordTypes.DNAM));
            StringBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.TrackFilename?.GivenPath,
                header: translationParams.ConvertToCustom(RecordTypes.ANAM),
                binaryType: StringBinaryType.NullTerminate);
            StringBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.FinaleFilename?.GivenPath,
                header: translationParams.ConvertToCustom(RecordTypes.BNAM),
                binaryType: StringBinaryType.NullTerminate);
            if (item.LoopData is {} LoopDataItem)
            {
                ((MusicTrackLoopDataBinaryWriteTranslation)((IBinaryItem)LoopDataItem).BinaryWriteTranslator).Write(
                    item: LoopDataItem,
                    writer: writer,
                    translationParams: translationParams);
            }
            Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<Single>.Instance.Write(
                writer: writer,
                items: item.CuePoints,
                recordType: translationParams.ConvertToCustom(RecordTypes.FNAM),
                transl: FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write);
            Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<IConditionGetter>.Instance.WriteWithCounter(
                writer: writer,
                items: item.Conditions,
                counterType: RecordTypes.CITC,
                counterLength: 4,
                transl: (MutagenWriter subWriter, IConditionGetter subItem, TypedWriteParams conv) =>
                {
                    var Item = subItem;
                    ((ConditionBinaryWriteTranslation)((IBinaryItem)Item).BinaryWriteTranslator).Write(
                        item: Item,
                        writer: subWriter,
                        translationParams: conv);
                });
            Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<IFormLinkGetter<IMusicTrackGetter>>.Instance.Write(
                writer: writer,
                items: item.Tracks,
                recordType: translationParams.ConvertToCustom(RecordTypes.SNAM),
                transl: (MutagenWriter subWriter, IFormLinkGetter<IMusicTrackGetter> subItem, TypedWriteParams conv) =>
                {
                    FormLinkBinaryTranslation.Instance.Write(
                        writer: subWriter,
                        item: subItem);
                });
        }

        public void Write(
            MutagenWriter writer,
            IMusicTrackGetter item,
            TypedWriteParams translationParams)
        {
            PluginUtilityTranslation.WriteMajorRecord(
                writer: writer,
                item: item,
                translationParams: translationParams,
                type: RecordTypes.MUST,
                writeEmbedded: SkyrimMajorRecordBinaryWriteTranslation.WriteEmbedded,
                writeRecordTypes: WriteRecordTypes);
        }

        public override void Write(
            MutagenWriter writer,
            object item,
            TypedWriteParams translationParams = default)
        {
            Write(
                item: (IMusicTrackGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

        public override void Write(
            MutagenWriter writer,
            ISkyrimMajorRecordGetter item,
            TypedWriteParams translationParams)
        {
            Write(
                item: (IMusicTrackGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

        public override void Write(
            MutagenWriter writer,
            IMajorRecordGetter item,
            TypedWriteParams translationParams)
        {
            Write(
                item: (IMusicTrackGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

    }

    internal partial class MusicTrackBinaryCreateTranslation : SkyrimMajorRecordBinaryCreateTranslation
    {
        public new static readonly MusicTrackBinaryCreateTranslation Instance = new MusicTrackBinaryCreateTranslation();

        public override RecordType RecordType => RecordTypes.MUST;
        public static ParseResult FillBinaryRecordTypes(
            IMusicTrackInternal item,
            MutagenFrame frame,
            PreviousParse lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            RecordType nextRecordType,
            int contentLength,
            TypedParseParams translationParams = default)
        {
            nextRecordType = translationParams.ConvertToStandard(nextRecordType);
            switch (nextRecordType.TypeInt)
            {
                case RecordTypeInts.CNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Type = EnumBinaryTranslation<MusicTrack.TypeEnum, MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: frame,
                        length: contentLength);
                    return (int)MusicTrack_FieldIndex.Type;
                }
                case RecordTypeInts.FLTV:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Duration = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)MusicTrack_FieldIndex.Duration;
                }
                case RecordTypeInts.DNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.FadeOut = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)MusicTrack_FieldIndex.FadeOut;
                }
                case RecordTypeInts.ANAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.TrackFilename = AssetLinkBinaryTranslation.Instance.Parse<SkyrimMusicAssetType>(reader: frame.SpawnWithLength(contentLength));
                    return (int)MusicTrack_FieldIndex.TrackFilename;
                }
                case RecordTypeInts.BNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.FinaleFilename = AssetLinkBinaryTranslation.Instance.Parse<SkyrimMusicAssetType>(reader: frame.SpawnWithLength(contentLength));
                    return (int)MusicTrack_FieldIndex.FinaleFilename;
                }
                case RecordTypeInts.LNAM:
                {
                    item.LoopData = Mutagen.Bethesda.Skyrim.MusicTrackLoopData.CreateFromBinary(frame: frame);
                    return (int)MusicTrack_FieldIndex.LoopData;
                }
                case RecordTypeInts.FNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.CuePoints = 
                        Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<Single>.Instance.Parse(
                            reader: frame.SpawnWithLength(contentLength),
                            transl: FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse)
                        .CastExtendedList<Single>();
                    return (int)MusicTrack_FieldIndex.CuePoints;
                }
                case RecordTypeInts.CTDA:
                case RecordTypeInts.CITC:
                {
                    item.Conditions = 
                        Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<Condition>.Instance.ParsePerItem(
                            reader: frame,
                            countLengthLength: 4,
                            countRecord: RecordTypes.CITC,
                            triggeringRecord: Condition_Registration.TriggerSpecs,
                            translationParams: translationParams,
                            transl: Condition.TryCreateFromBinary)
                        .CastExtendedList<Condition>();
                    return (int)MusicTrack_FieldIndex.Conditions;
                }
                case RecordTypeInts.SNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Tracks = 
                        Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<IFormLinkGetter<IMusicTrackGetter>>.Instance.Parse(
                            reader: frame.SpawnWithLength(contentLength),
                            transl: FormLinkBinaryTranslation.Instance.Parse)
                        .CastExtendedList<IFormLinkGetter<IMusicTrackGetter>>();
                    return (int)MusicTrack_FieldIndex.Tracks;
                }
                default:
                    return SkyrimMajorRecordBinaryCreateTranslation.FillBinaryRecordTypes(
                        item: item,
                        frame: frame,
                        lastParsed: lastParsed,
                        recordParseCount: recordParseCount,
                        nextRecordType: nextRecordType,
                        contentLength: contentLength,
                        translationParams: translationParams.WithNoConverter());
            }
        }

    }

}
namespace Mutagen.Bethesda.Skyrim
{
    #region Binary Write Mixins
    public static class MusicTrackBinaryTranslationMixIn
    {
    }
    #endregion


}
namespace Mutagen.Bethesda.Skyrim
{
    internal partial class MusicTrackBinaryOverlay :
        SkyrimMajorRecordBinaryOverlay,
        IMusicTrackGetter
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => MusicTrack_Registration.Instance;
        public new static ILoquiRegistration StaticRegistration => MusicTrack_Registration.Instance;
        [DebuggerStepThrough]
        protected override object CommonInstance() => MusicTrackCommon.Instance;
        [DebuggerStepThrough]
        protected override object CommonSetterTranslationInstance() => MusicTrackSetterTranslationCommon.Instance;

        #endregion

        void IPrintable.Print(StructuredStringBuilder sb, string? name) => this.Print(sb, name);

        public override IEnumerable<IFormLinkGetter> EnumerateFormLinks() => MusicTrackCommon.Instance.EnumerateFormLinks(this);
        public override IEnumerable<IAssetLinkGetter> EnumerateAssetLinks(AssetLinkQuery queryCategories, IAssetLinkCache? linkCache, Type? assetType) => MusicTrackCommon.Instance.EnumerateAssetLinks(this, queryCategories, linkCache, assetType);
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected override object BinaryWriteTranslator => MusicTrackBinaryWriteTranslation.Instance;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((MusicTrackBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }
        protected override Type LinkType => typeof(IMusicTrack);


        #region Type
        private int? _TypeLocation;
        public MusicTrack.TypeEnum Type => _TypeLocation.HasValue ? (MusicTrack.TypeEnum)BinaryPrimitives.ReadInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_recordData, _TypeLocation!.Value, _package.MetaData.Constants)) : default(MusicTrack.TypeEnum);
        #endregion
        #region Duration
        private int? _DurationLocation;
        public Single? Duration => _DurationLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_recordData, _DurationLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        #region FadeOut
        private int? _FadeOutLocation;
        public Single? FadeOut => _FadeOutLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_recordData, _FadeOutLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        #region TrackFilename
        private int? _TrackFilenameLocation;
        public AssetLinkGetter<SkyrimMusicAssetType>? TrackFilename => _TrackFilenameLocation.HasValue ? new AssetLinkGetter<SkyrimMusicAssetType>(BinaryStringUtility.ProcessWholeToZString(HeaderTranslation.ExtractSubrecordMemory(_recordData, _TrackFilenameLocation.Value, _package.MetaData.Constants), encoding: _package.MetaData.Encodings.NonTranslated)) : default(AssetLinkGetter<SkyrimMusicAssetType>?);
        #endregion
        #region FinaleFilename
        private int? _FinaleFilenameLocation;
        public AssetLinkGetter<SkyrimMusicAssetType>? FinaleFilename => _FinaleFilenameLocation.HasValue ? new AssetLinkGetter<SkyrimMusicAssetType>(BinaryStringUtility.ProcessWholeToZString(HeaderTranslation.ExtractSubrecordMemory(_recordData, _FinaleFilenameLocation.Value, _package.MetaData.Constants), encoding: _package.MetaData.Encodings.NonTranslated)) : default(AssetLinkGetter<SkyrimMusicAssetType>?);
        #endregion
        #region LoopData
        private RangeInt32? _LoopDataLocation;
        public IMusicTrackLoopDataGetter? LoopData => _LoopDataLocation.HasValue ? MusicTrackLoopDataBinaryOverlay.MusicTrackLoopDataFactory(_recordData.Slice(_LoopDataLocation!.Value.Min), _package) : default;
        #endregion
        public IReadOnlyList<Single>? CuePoints { get; private set; }
        public IReadOnlyList<IConditionGetter>? Conditions { get; private set; }
        public IReadOnlyList<IFormLinkGetter<IMusicTrackGetter>>? Tracks { get; private set; }
        partial void CustomFactoryEnd(
            OverlayStream stream,
            int finalPos,
            int offset);

        partial void CustomCtor();
        protected MusicTrackBinaryOverlay(
            MemoryPair memoryPair,
            BinaryOverlayFactoryPackage package)
            : base(
                memoryPair: memoryPair,
                package: package)
        {
            this.CustomCtor();
        }

        public static IMusicTrackGetter MusicTrackFactory(
            OverlayStream stream,
            BinaryOverlayFactoryPackage package,
            TypedParseParams translationParams = default)
        {
            stream = Decompression.DecompressStream(stream);
            stream = ExtractRecordMemory(
                stream: stream,
                meta: package.MetaData.Constants,
                memoryPair: out var memoryPair,
                offset: out var offset,
                finalPos: out var finalPos);
            var ret = new MusicTrackBinaryOverlay(
                memoryPair: memoryPair,
                package: package);
            ret._package.FormVersion = ret;
            ret.CustomFactoryEnd(
                stream: stream,
                finalPos: finalPos,
                offset: offset);
            ret.FillSubrecordTypes(
                majorReference: ret,
                stream: stream,
                finalPos: finalPos,
                offset: offset,
                translationParams: translationParams,
                fill: ret.FillRecordType);
            return ret;
        }

        public static IMusicTrackGetter MusicTrackFactory(
            ReadOnlyMemorySlice<byte> slice,
            BinaryOverlayFactoryPackage package,
            TypedParseParams translationParams = default)
        {
            return MusicTrackFactory(
                stream: new OverlayStream(slice, package),
                package: package,
                translationParams: translationParams);
        }

        public override ParseResult FillRecordType(
            OverlayStream stream,
            int finalPos,
            int offset,
            RecordType type,
            PreviousParse lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            TypedParseParams translationParams = default)
        {
            type = translationParams.ConvertToStandard(type);
            switch (type.TypeInt)
            {
                case RecordTypeInts.CNAM:
                {
                    _TypeLocation = (stream.Position - offset);
                    return (int)MusicTrack_FieldIndex.Type;
                }
                case RecordTypeInts.FLTV:
                {
                    _DurationLocation = (stream.Position - offset);
                    return (int)MusicTrack_FieldIndex.Duration;
                }
                case RecordTypeInts.DNAM:
                {
                    _FadeOutLocation = (stream.Position - offset);
                    return (int)MusicTrack_FieldIndex.FadeOut;
                }
                case RecordTypeInts.ANAM:
                {
                    _TrackFilenameLocation = (stream.Position - offset);
                    return (int)MusicTrack_FieldIndex.TrackFilename;
                }
                case RecordTypeInts.BNAM:
                {
                    _FinaleFilenameLocation = (stream.Position - offset);
                    return (int)MusicTrack_FieldIndex.FinaleFilename;
                }
                case RecordTypeInts.LNAM:
                {
                    _LoopDataLocation = new RangeInt32((stream.Position - offset), finalPos - offset);
                    return (int)MusicTrack_FieldIndex.LoopData;
                }
                case RecordTypeInts.FNAM:
                {
                    this.CuePoints = BinaryOverlayList.FactoryByStartIndexWithTrigger<Single>(
                        stream: stream,
                        package: _package,
                        finalPos: finalPos,
                        itemLength: 4,
                        getter: (s, p) => s.Float());
                    return (int)MusicTrack_FieldIndex.CuePoints;
                }
                case RecordTypeInts.CTDA:
                case RecordTypeInts.CITC:
                {
                    this.Conditions = BinaryOverlayList.FactoryByCountPerItem<IConditionGetter>(
                        stream: stream,
                        package: _package,
                        countLength: 4,
                        trigger: Condition_Registration.TriggerSpecs,
                        countType: RecordTypes.CITC,
                        translationParams: translationParams,
                        getter: (s, p, recConv) => ConditionBinaryOverlay.ConditionFactory(new OverlayStream(s, p), p, recConv),
                        skipHeader: false);
                    return (int)MusicTrack_FieldIndex.Conditions;
                }
                case RecordTypeInts.SNAM:
                {
                    this.Tracks = BinaryOverlayList.FactoryByStartIndexWithTrigger<IFormLinkGetter<IMusicTrackGetter>>(
                        stream: stream,
                        package: _package,
                        finalPos: finalPos,
                        itemLength: 4,
                        getter: (s, p) => FormLinkBinaryTranslation.Instance.OverlayFactory<IMusicTrackGetter>(p, s));
                    return (int)MusicTrack_FieldIndex.Tracks;
                }
                default:
                    return base.FillRecordType(
                        stream: stream,
                        finalPos: finalPos,
                        offset: offset,
                        type: type,
                        lastParsed: lastParsed,
                        recordParseCount: recordParseCount,
                        translationParams: translationParams.WithNoConverter());
            }
        }
        #region To String

        public override void Print(
            StructuredStringBuilder sb,
            string? name = null)
        {
            MusicTrackMixIn.Print(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        public override string ToString()
        {
            return MajorRecordPrinter<MusicTrack>.ToString(this);
        }

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is IFormLinkGetter formLink)
            {
                return formLink.Equals(this);
            }
            if (obj is not IMusicTrackGetter rhs) return false;
            return ((MusicTrackCommon)((IMusicTrackGetter)this).CommonInstance()!).Equals(this, rhs, equalsMask: null);
        }

        public bool Equals(IMusicTrackGetter? obj)
        {
            return ((MusicTrackCommon)((IMusicTrackGetter)this).CommonInstance()!).Equals(this, obj, equalsMask: null);
        }

        public override int GetHashCode() => ((MusicTrackCommon)((IMusicTrackGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

    }

}
#endregion

#endregion

