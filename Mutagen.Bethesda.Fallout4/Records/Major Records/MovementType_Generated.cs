/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Autogenerated by Loqui.  Do not manually change.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*/
#region Usings
using Loqui;
using Loqui.Interfaces;
using Loqui.Internal;
using Mutagen.Bethesda.Binary;
using Mutagen.Bethesda.Fallout4;
using Mutagen.Bethesda.Fallout4.Internals;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Aspects;
using Mutagen.Bethesda.Plugins.Binary.Headers;
using Mutagen.Bethesda.Plugins.Binary.Overlay;
using Mutagen.Bethesda.Plugins.Binary.Streams;
using Mutagen.Bethesda.Plugins.Binary.Translations;
using Mutagen.Bethesda.Plugins.Exceptions;
using Mutagen.Bethesda.Plugins.Internals;
using Mutagen.Bethesda.Plugins.Meta;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Plugins.Records.Internals;
using Mutagen.Bethesda.Plugins.Records.Mapping;
using Mutagen.Bethesda.Plugins.Utility;
using Mutagen.Bethesda.Translations.Binary;
using Noggog;
using Noggog.StructuredStrings;
using Noggog.StructuredStrings.CSharp;
using RecordTypeInts = Mutagen.Bethesda.Fallout4.Internals.RecordTypeInts;
using RecordTypes = Mutagen.Bethesda.Fallout4.Internals.RecordTypes;
using System.Buffers.Binary;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Reactive.Disposables;
using System.Reactive.Linq;
#endregion

#nullable enable
namespace Mutagen.Bethesda.Fallout4
{
    #region Class
    public partial class MovementType :
        Fallout4MajorRecord,
        IEquatable<IMovementTypeGetter>,
        ILoquiObjectSetter<MovementType>,
        IMovementTypeInternal
    {
        #region Ctor
        protected MovementType()
        {
            CustomCtor();
        }
        partial void CustomCtor();
        #endregion

        #region Name
        /// <summary>
        /// Aspects: INamed, INamedRequired
        /// </summary>
        public String? Name { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        String? IMovementTypeGetter.Name => this.Name;
        #region Aspects
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        string INamedRequiredGetter.Name => this.Name ?? string.Empty;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        string INamedRequired.Name
        {
            get => this.Name ?? string.Empty;
            set => this.Name = value;
        }
        #endregion
        #endregion
        #region LeftStanding
        public Single LeftStanding { get; set; } = default(Single);
        #endregion
        #region LeftWalk
        public Single LeftWalk { get; set; } = default(Single);
        #endregion
        #region LeftRun
        public Single LeftRun { get; set; } = default(Single);
        #endregion
        #region LeftSprint
        public Single LeftSprint { get; set; } = default(Single);
        #endregion
        #region RightStanding
        public Single RightStanding { get; set; } = default(Single);
        #endregion
        #region RightWalk
        public Single RightWalk { get; set; } = default(Single);
        #endregion
        #region RightRun
        public Single RightRun { get; set; } = default(Single);
        #endregion
        #region RightSprint
        public Single RightSprint { get; set; } = default(Single);
        #endregion
        #region ForwardStanding
        public Single ForwardStanding { get; set; } = default(Single);
        #endregion
        #region ForwardWalk
        public Single ForwardWalk { get; set; } = default(Single);
        #endregion
        #region ForwardRun
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Single _ForwardRun;
        public Single ForwardRun
        {
            get => this._ForwardRun;
            set
            {
                this.SPEDDataTypeState &= ~SPEDDataType.Break0;
                this._ForwardRun = value;
            }
        }
        #endregion
        #region ForwardSprint
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Single _ForwardSprint;
        public Single ForwardSprint
        {
            get => this._ForwardSprint;
            set
            {
                this.SPEDDataTypeState &= ~SPEDDataType.Break0;
                this.SPEDDataTypeState &= ~SPEDDataType.Break1;
                this._ForwardSprint = value;
            }
        }
        #endregion
        #region BackStanding
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Single _BackStanding;
        public Single BackStanding
        {
            get => this._BackStanding;
            set
            {
                this.SPEDDataTypeState &= ~SPEDDataType.Break0;
                this.SPEDDataTypeState &= ~SPEDDataType.Break1;
                this._BackStanding = value;
            }
        }
        #endregion
        #region BackWalk
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Single _BackWalk;
        public Single BackWalk
        {
            get => this._BackWalk;
            set
            {
                this.SPEDDataTypeState &= ~SPEDDataType.Break0;
                this.SPEDDataTypeState &= ~SPEDDataType.Break1;
                this._BackWalk = value;
            }
        }
        #endregion
        #region BackRun
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Single _BackRun;
        public Single BackRun
        {
            get => this._BackRun;
            set
            {
                this.SPEDDataTypeState &= ~SPEDDataType.Break0;
                this.SPEDDataTypeState &= ~SPEDDataType.Break1;
                this._BackRun = value;
            }
        }
        #endregion
        #region BackSprint
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Single _BackSprint;
        public Single BackSprint
        {
            get => this._BackSprint;
            set
            {
                this.SPEDDataTypeState &= ~SPEDDataType.Break0;
                this.SPEDDataTypeState &= ~SPEDDataType.Break1;
                this._BackSprint = value;
            }
        }
        #endregion
        #region PitchStanding
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Single _PitchStanding;
        public Single PitchStanding
        {
            get => this._PitchStanding;
            set
            {
                this.SPEDDataTypeState &= ~SPEDDataType.Break0;
                this.SPEDDataTypeState &= ~SPEDDataType.Break1;
                this._PitchStanding = value;
            }
        }
        #endregion
        #region PitchWalk
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Single _PitchWalk;
        public Single PitchWalk
        {
            get => this._PitchWalk;
            set
            {
                this.SPEDDataTypeState &= ~SPEDDataType.Break0;
                this.SPEDDataTypeState &= ~SPEDDataType.Break1;
                this.SPEDDataTypeState &= ~SPEDDataType.Break2;
                this._PitchWalk = value;
            }
        }
        #endregion
        #region PitchRun
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Single _PitchRun;
        public Single PitchRun
        {
            get => this._PitchRun;
            set
            {
                this.SPEDDataTypeState &= ~SPEDDataType.Break0;
                this.SPEDDataTypeState &= ~SPEDDataType.Break1;
                this.SPEDDataTypeState &= ~SPEDDataType.Break2;
                this._PitchRun = value;
            }
        }
        #endregion
        #region PitchSprint
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Single _PitchSprint;
        public Single PitchSprint
        {
            get => this._PitchSprint;
            set
            {
                this.SPEDDataTypeState &= ~SPEDDataType.Break0;
                this.SPEDDataTypeState &= ~SPEDDataType.Break1;
                this.SPEDDataTypeState &= ~SPEDDataType.Break2;
                this._PitchSprint = value;
            }
        }
        #endregion
        #region RollStanding
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Single _RollStanding;
        public Single RollStanding
        {
            get => this._RollStanding;
            set
            {
                this.SPEDDataTypeState &= ~SPEDDataType.Break0;
                this.SPEDDataTypeState &= ~SPEDDataType.Break1;
                this.SPEDDataTypeState &= ~SPEDDataType.Break2;
                this._RollStanding = value;
            }
        }
        #endregion
        #region RollWalk
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Single _RollWalk;
        public Single RollWalk
        {
            get => this._RollWalk;
            set
            {
                this.SPEDDataTypeState &= ~SPEDDataType.Break0;
                this.SPEDDataTypeState &= ~SPEDDataType.Break1;
                this.SPEDDataTypeState &= ~SPEDDataType.Break2;
                this._RollWalk = value;
            }
        }
        #endregion
        #region RollRun
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Single _RollRun;
        public Single RollRun
        {
            get => this._RollRun;
            set
            {
                this.SPEDDataTypeState &= ~SPEDDataType.Break0;
                this.SPEDDataTypeState &= ~SPEDDataType.Break1;
                this.SPEDDataTypeState &= ~SPEDDataType.Break2;
                this._RollRun = value;
            }
        }
        #endregion
        #region RollSprint
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Single _RollSprint;
        public Single RollSprint
        {
            get => this._RollSprint;
            set
            {
                this.SPEDDataTypeState &= ~SPEDDataType.Break0;
                this.SPEDDataTypeState &= ~SPEDDataType.Break1;
                this.SPEDDataTypeState &= ~SPEDDataType.Break2;
                this._RollSprint = value;
            }
        }
        #endregion
        #region YawStanding
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Single _YawStanding;
        public Single YawStanding
        {
            get => this._YawStanding;
            set
            {
                this.SPEDDataTypeState &= ~SPEDDataType.Break0;
                this.SPEDDataTypeState &= ~SPEDDataType.Break1;
                this.SPEDDataTypeState &= ~SPEDDataType.Break2;
                this._YawStanding = value;
            }
        }
        #endregion
        #region YawWalk
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Single _YawWalk;
        public Single YawWalk
        {
            get => this._YawWalk;
            set
            {
                this.SPEDDataTypeState &= ~SPEDDataType.Break0;
                this.SPEDDataTypeState &= ~SPEDDataType.Break1;
                this.SPEDDataTypeState &= ~SPEDDataType.Break2;
                this._YawWalk = value;
            }
        }
        #endregion
        #region YawRun
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Single _YawRun;
        public Single YawRun
        {
            get => this._YawRun;
            set
            {
                this.SPEDDataTypeState &= ~SPEDDataType.Break0;
                this.SPEDDataTypeState &= ~SPEDDataType.Break1;
                this.SPEDDataTypeState &= ~SPEDDataType.Break2;
                this._YawRun = value;
            }
        }
        #endregion
        #region YawSprint
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Single _YawSprint;
        public Single YawSprint
        {
            get => this._YawSprint;
            set
            {
                this.SPEDDataTypeState &= ~SPEDDataType.Break0;
                this.SPEDDataTypeState &= ~SPEDDataType.Break1;
                this.SPEDDataTypeState &= ~SPEDDataType.Break2;
                this._YawSprint = value;
            }
        }
        #endregion
        #region AnimationChangeThresholds
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private AnimationChangeThresholds? _AnimationChangeThresholds;
        public AnimationChangeThresholds? AnimationChangeThresholds
        {
            get => _AnimationChangeThresholds;
            set => _AnimationChangeThresholds = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IAnimationChangeThresholdsGetter? IMovementTypeGetter.AnimationChangeThresholds => this.AnimationChangeThresholds;
        #endregion
        #region FloatHeight
        public Single? FloatHeight { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? IMovementTypeGetter.FloatHeight => this.FloatHeight;
        #endregion
        #region FlightAngleGain
        public Single? FlightAngleGain { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? IMovementTypeGetter.FlightAngleGain => this.FlightAngleGain;
        #endregion
        #region SPEDDataTypeState
        public MovementType.SPEDDataType SPEDDataTypeState { get; set; } = default(MovementType.SPEDDataType);
        #endregion

        #region To String

        public override void Print(
            StructuredStringBuilder sb,
            string? name = null)
        {
            MovementTypeMixIn.Print(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        #region Mask
        public new class Mask<TItem> :
            Fallout4MajorRecord.Mask<TItem>,
            IEquatable<Mask<TItem>>,
            IMask<TItem>
        {
            #region Ctors
            public Mask(TItem initialValue)
            : base(initialValue)
            {
                this.Name = initialValue;
                this.LeftStanding = initialValue;
                this.LeftWalk = initialValue;
                this.LeftRun = initialValue;
                this.LeftSprint = initialValue;
                this.RightStanding = initialValue;
                this.RightWalk = initialValue;
                this.RightRun = initialValue;
                this.RightSprint = initialValue;
                this.ForwardStanding = initialValue;
                this.ForwardWalk = initialValue;
                this.ForwardRun = initialValue;
                this.ForwardSprint = initialValue;
                this.BackStanding = initialValue;
                this.BackWalk = initialValue;
                this.BackRun = initialValue;
                this.BackSprint = initialValue;
                this.PitchStanding = initialValue;
                this.PitchWalk = initialValue;
                this.PitchRun = initialValue;
                this.PitchSprint = initialValue;
                this.RollStanding = initialValue;
                this.RollWalk = initialValue;
                this.RollRun = initialValue;
                this.RollSprint = initialValue;
                this.YawStanding = initialValue;
                this.YawWalk = initialValue;
                this.YawRun = initialValue;
                this.YawSprint = initialValue;
                this.AnimationChangeThresholds = new MaskItem<TItem, AnimationChangeThresholds.Mask<TItem>?>(initialValue, new AnimationChangeThresholds.Mask<TItem>(initialValue));
                this.FloatHeight = initialValue;
                this.FlightAngleGain = initialValue;
                this.SPEDDataTypeState = initialValue;
            }

            public Mask(
                TItem MajorRecordFlagsRaw,
                TItem FormKey,
                TItem VersionControl,
                TItem EditorID,
                TItem FormVersion,
                TItem Version2,
                TItem Fallout4MajorRecordFlags,
                TItem Name,
                TItem LeftStanding,
                TItem LeftWalk,
                TItem LeftRun,
                TItem LeftSprint,
                TItem RightStanding,
                TItem RightWalk,
                TItem RightRun,
                TItem RightSprint,
                TItem ForwardStanding,
                TItem ForwardWalk,
                TItem ForwardRun,
                TItem ForwardSprint,
                TItem BackStanding,
                TItem BackWalk,
                TItem BackRun,
                TItem BackSprint,
                TItem PitchStanding,
                TItem PitchWalk,
                TItem PitchRun,
                TItem PitchSprint,
                TItem RollStanding,
                TItem RollWalk,
                TItem RollRun,
                TItem RollSprint,
                TItem YawStanding,
                TItem YawWalk,
                TItem YawRun,
                TItem YawSprint,
                TItem AnimationChangeThresholds,
                TItem FloatHeight,
                TItem FlightAngleGain,
                TItem SPEDDataTypeState)
            : base(
                MajorRecordFlagsRaw: MajorRecordFlagsRaw,
                FormKey: FormKey,
                VersionControl: VersionControl,
                EditorID: EditorID,
                FormVersion: FormVersion,
                Version2: Version2,
                Fallout4MajorRecordFlags: Fallout4MajorRecordFlags)
            {
                this.Name = Name;
                this.LeftStanding = LeftStanding;
                this.LeftWalk = LeftWalk;
                this.LeftRun = LeftRun;
                this.LeftSprint = LeftSprint;
                this.RightStanding = RightStanding;
                this.RightWalk = RightWalk;
                this.RightRun = RightRun;
                this.RightSprint = RightSprint;
                this.ForwardStanding = ForwardStanding;
                this.ForwardWalk = ForwardWalk;
                this.ForwardRun = ForwardRun;
                this.ForwardSprint = ForwardSprint;
                this.BackStanding = BackStanding;
                this.BackWalk = BackWalk;
                this.BackRun = BackRun;
                this.BackSprint = BackSprint;
                this.PitchStanding = PitchStanding;
                this.PitchWalk = PitchWalk;
                this.PitchRun = PitchRun;
                this.PitchSprint = PitchSprint;
                this.RollStanding = RollStanding;
                this.RollWalk = RollWalk;
                this.RollRun = RollRun;
                this.RollSprint = RollSprint;
                this.YawStanding = YawStanding;
                this.YawWalk = YawWalk;
                this.YawRun = YawRun;
                this.YawSprint = YawSprint;
                this.AnimationChangeThresholds = new MaskItem<TItem, AnimationChangeThresholds.Mask<TItem>?>(AnimationChangeThresholds, new AnimationChangeThresholds.Mask<TItem>(AnimationChangeThresholds));
                this.FloatHeight = FloatHeight;
                this.FlightAngleGain = FlightAngleGain;
                this.SPEDDataTypeState = SPEDDataTypeState;
            }

            #pragma warning disable CS8618
            protected Mask()
            {
            }
            #pragma warning restore CS8618

            #endregion

            #region Members
            public TItem Name;
            public TItem LeftStanding;
            public TItem LeftWalk;
            public TItem LeftRun;
            public TItem LeftSprint;
            public TItem RightStanding;
            public TItem RightWalk;
            public TItem RightRun;
            public TItem RightSprint;
            public TItem ForwardStanding;
            public TItem ForwardWalk;
            public TItem ForwardRun;
            public TItem ForwardSprint;
            public TItem BackStanding;
            public TItem BackWalk;
            public TItem BackRun;
            public TItem BackSprint;
            public TItem PitchStanding;
            public TItem PitchWalk;
            public TItem PitchRun;
            public TItem PitchSprint;
            public TItem RollStanding;
            public TItem RollWalk;
            public TItem RollRun;
            public TItem RollSprint;
            public TItem YawStanding;
            public TItem YawWalk;
            public TItem YawRun;
            public TItem YawSprint;
            public MaskItem<TItem, AnimationChangeThresholds.Mask<TItem>?>? AnimationChangeThresholds { get; set; }
            public TItem FloatHeight;
            public TItem FlightAngleGain;
            public TItem SPEDDataTypeState;
            #endregion

            #region Equals
            public override bool Equals(object? obj)
            {
                if (!(obj is Mask<TItem> rhs)) return false;
                return Equals(rhs);
            }

            public bool Equals(Mask<TItem>? rhs)
            {
                if (rhs == null) return false;
                if (!base.Equals(rhs)) return false;
                if (!object.Equals(this.Name, rhs.Name)) return false;
                if (!object.Equals(this.LeftStanding, rhs.LeftStanding)) return false;
                if (!object.Equals(this.LeftWalk, rhs.LeftWalk)) return false;
                if (!object.Equals(this.LeftRun, rhs.LeftRun)) return false;
                if (!object.Equals(this.LeftSprint, rhs.LeftSprint)) return false;
                if (!object.Equals(this.RightStanding, rhs.RightStanding)) return false;
                if (!object.Equals(this.RightWalk, rhs.RightWalk)) return false;
                if (!object.Equals(this.RightRun, rhs.RightRun)) return false;
                if (!object.Equals(this.RightSprint, rhs.RightSprint)) return false;
                if (!object.Equals(this.ForwardStanding, rhs.ForwardStanding)) return false;
                if (!object.Equals(this.ForwardWalk, rhs.ForwardWalk)) return false;
                if (!object.Equals(this.ForwardRun, rhs.ForwardRun)) return false;
                if (!object.Equals(this.ForwardSprint, rhs.ForwardSprint)) return false;
                if (!object.Equals(this.BackStanding, rhs.BackStanding)) return false;
                if (!object.Equals(this.BackWalk, rhs.BackWalk)) return false;
                if (!object.Equals(this.BackRun, rhs.BackRun)) return false;
                if (!object.Equals(this.BackSprint, rhs.BackSprint)) return false;
                if (!object.Equals(this.PitchStanding, rhs.PitchStanding)) return false;
                if (!object.Equals(this.PitchWalk, rhs.PitchWalk)) return false;
                if (!object.Equals(this.PitchRun, rhs.PitchRun)) return false;
                if (!object.Equals(this.PitchSprint, rhs.PitchSprint)) return false;
                if (!object.Equals(this.RollStanding, rhs.RollStanding)) return false;
                if (!object.Equals(this.RollWalk, rhs.RollWalk)) return false;
                if (!object.Equals(this.RollRun, rhs.RollRun)) return false;
                if (!object.Equals(this.RollSprint, rhs.RollSprint)) return false;
                if (!object.Equals(this.YawStanding, rhs.YawStanding)) return false;
                if (!object.Equals(this.YawWalk, rhs.YawWalk)) return false;
                if (!object.Equals(this.YawRun, rhs.YawRun)) return false;
                if (!object.Equals(this.YawSprint, rhs.YawSprint)) return false;
                if (!object.Equals(this.AnimationChangeThresholds, rhs.AnimationChangeThresholds)) return false;
                if (!object.Equals(this.FloatHeight, rhs.FloatHeight)) return false;
                if (!object.Equals(this.FlightAngleGain, rhs.FlightAngleGain)) return false;
                if (!object.Equals(this.SPEDDataTypeState, rhs.SPEDDataTypeState)) return false;
                return true;
            }
            public override int GetHashCode()
            {
                var hash = new HashCode();
                hash.Add(this.Name);
                hash.Add(this.LeftStanding);
                hash.Add(this.LeftWalk);
                hash.Add(this.LeftRun);
                hash.Add(this.LeftSprint);
                hash.Add(this.RightStanding);
                hash.Add(this.RightWalk);
                hash.Add(this.RightRun);
                hash.Add(this.RightSprint);
                hash.Add(this.ForwardStanding);
                hash.Add(this.ForwardWalk);
                hash.Add(this.ForwardRun);
                hash.Add(this.ForwardSprint);
                hash.Add(this.BackStanding);
                hash.Add(this.BackWalk);
                hash.Add(this.BackRun);
                hash.Add(this.BackSprint);
                hash.Add(this.PitchStanding);
                hash.Add(this.PitchWalk);
                hash.Add(this.PitchRun);
                hash.Add(this.PitchSprint);
                hash.Add(this.RollStanding);
                hash.Add(this.RollWalk);
                hash.Add(this.RollRun);
                hash.Add(this.RollSprint);
                hash.Add(this.YawStanding);
                hash.Add(this.YawWalk);
                hash.Add(this.YawRun);
                hash.Add(this.YawSprint);
                hash.Add(this.AnimationChangeThresholds);
                hash.Add(this.FloatHeight);
                hash.Add(this.FlightAngleGain);
                hash.Add(this.SPEDDataTypeState);
                hash.Add(base.GetHashCode());
                return hash.ToHashCode();
            }

            #endregion

            #region All
            public override bool All(Func<TItem, bool> eval)
            {
                if (!base.All(eval)) return false;
                if (!eval(this.Name)) return false;
                if (!eval(this.LeftStanding)) return false;
                if (!eval(this.LeftWalk)) return false;
                if (!eval(this.LeftRun)) return false;
                if (!eval(this.LeftSprint)) return false;
                if (!eval(this.RightStanding)) return false;
                if (!eval(this.RightWalk)) return false;
                if (!eval(this.RightRun)) return false;
                if (!eval(this.RightSprint)) return false;
                if (!eval(this.ForwardStanding)) return false;
                if (!eval(this.ForwardWalk)) return false;
                if (!eval(this.ForwardRun)) return false;
                if (!eval(this.ForwardSprint)) return false;
                if (!eval(this.BackStanding)) return false;
                if (!eval(this.BackWalk)) return false;
                if (!eval(this.BackRun)) return false;
                if (!eval(this.BackSprint)) return false;
                if (!eval(this.PitchStanding)) return false;
                if (!eval(this.PitchWalk)) return false;
                if (!eval(this.PitchRun)) return false;
                if (!eval(this.PitchSprint)) return false;
                if (!eval(this.RollStanding)) return false;
                if (!eval(this.RollWalk)) return false;
                if (!eval(this.RollRun)) return false;
                if (!eval(this.RollSprint)) return false;
                if (!eval(this.YawStanding)) return false;
                if (!eval(this.YawWalk)) return false;
                if (!eval(this.YawRun)) return false;
                if (!eval(this.YawSprint)) return false;
                if (AnimationChangeThresholds != null)
                {
                    if (!eval(this.AnimationChangeThresholds.Overall)) return false;
                    if (this.AnimationChangeThresholds.Specific != null && !this.AnimationChangeThresholds.Specific.All(eval)) return false;
                }
                if (!eval(this.FloatHeight)) return false;
                if (!eval(this.FlightAngleGain)) return false;
                if (!eval(this.SPEDDataTypeState)) return false;
                return true;
            }
            #endregion

            #region Any
            public override bool Any(Func<TItem, bool> eval)
            {
                if (base.Any(eval)) return true;
                if (eval(this.Name)) return true;
                if (eval(this.LeftStanding)) return true;
                if (eval(this.LeftWalk)) return true;
                if (eval(this.LeftRun)) return true;
                if (eval(this.LeftSprint)) return true;
                if (eval(this.RightStanding)) return true;
                if (eval(this.RightWalk)) return true;
                if (eval(this.RightRun)) return true;
                if (eval(this.RightSprint)) return true;
                if (eval(this.ForwardStanding)) return true;
                if (eval(this.ForwardWalk)) return true;
                if (eval(this.ForwardRun)) return true;
                if (eval(this.ForwardSprint)) return true;
                if (eval(this.BackStanding)) return true;
                if (eval(this.BackWalk)) return true;
                if (eval(this.BackRun)) return true;
                if (eval(this.BackSprint)) return true;
                if (eval(this.PitchStanding)) return true;
                if (eval(this.PitchWalk)) return true;
                if (eval(this.PitchRun)) return true;
                if (eval(this.PitchSprint)) return true;
                if (eval(this.RollStanding)) return true;
                if (eval(this.RollWalk)) return true;
                if (eval(this.RollRun)) return true;
                if (eval(this.RollSprint)) return true;
                if (eval(this.YawStanding)) return true;
                if (eval(this.YawWalk)) return true;
                if (eval(this.YawRun)) return true;
                if (eval(this.YawSprint)) return true;
                if (AnimationChangeThresholds != null)
                {
                    if (eval(this.AnimationChangeThresholds.Overall)) return true;
                    if (this.AnimationChangeThresholds.Specific != null && this.AnimationChangeThresholds.Specific.Any(eval)) return true;
                }
                if (eval(this.FloatHeight)) return true;
                if (eval(this.FlightAngleGain)) return true;
                if (eval(this.SPEDDataTypeState)) return true;
                return false;
            }
            #endregion

            #region Translate
            public new Mask<R> Translate<R>(Func<TItem, R> eval)
            {
                var ret = new MovementType.Mask<R>();
                this.Translate_InternalFill(ret, eval);
                return ret;
            }

            protected void Translate_InternalFill<R>(Mask<R> obj, Func<TItem, R> eval)
            {
                base.Translate_InternalFill(obj, eval);
                obj.Name = eval(this.Name);
                obj.LeftStanding = eval(this.LeftStanding);
                obj.LeftWalk = eval(this.LeftWalk);
                obj.LeftRun = eval(this.LeftRun);
                obj.LeftSprint = eval(this.LeftSprint);
                obj.RightStanding = eval(this.RightStanding);
                obj.RightWalk = eval(this.RightWalk);
                obj.RightRun = eval(this.RightRun);
                obj.RightSprint = eval(this.RightSprint);
                obj.ForwardStanding = eval(this.ForwardStanding);
                obj.ForwardWalk = eval(this.ForwardWalk);
                obj.ForwardRun = eval(this.ForwardRun);
                obj.ForwardSprint = eval(this.ForwardSprint);
                obj.BackStanding = eval(this.BackStanding);
                obj.BackWalk = eval(this.BackWalk);
                obj.BackRun = eval(this.BackRun);
                obj.BackSprint = eval(this.BackSprint);
                obj.PitchStanding = eval(this.PitchStanding);
                obj.PitchWalk = eval(this.PitchWalk);
                obj.PitchRun = eval(this.PitchRun);
                obj.PitchSprint = eval(this.PitchSprint);
                obj.RollStanding = eval(this.RollStanding);
                obj.RollWalk = eval(this.RollWalk);
                obj.RollRun = eval(this.RollRun);
                obj.RollSprint = eval(this.RollSprint);
                obj.YawStanding = eval(this.YawStanding);
                obj.YawWalk = eval(this.YawWalk);
                obj.YawRun = eval(this.YawRun);
                obj.YawSprint = eval(this.YawSprint);
                obj.AnimationChangeThresholds = this.AnimationChangeThresholds == null ? null : new MaskItem<R, AnimationChangeThresholds.Mask<R>?>(eval(this.AnimationChangeThresholds.Overall), this.AnimationChangeThresholds.Specific?.Translate(eval));
                obj.FloatHeight = eval(this.FloatHeight);
                obj.FlightAngleGain = eval(this.FlightAngleGain);
                obj.SPEDDataTypeState = eval(this.SPEDDataTypeState);
            }
            #endregion

            #region To String
            public override string ToString() => this.Print();

            public string Print(MovementType.Mask<bool>? printMask = null)
            {
                var sb = new StructuredStringBuilder();
                Print(sb, printMask);
                return sb.ToString();
            }

            public void Print(StructuredStringBuilder sb, MovementType.Mask<bool>? printMask = null)
            {
                sb.AppendLine($"{nameof(MovementType.Mask<TItem>)} =>");
                using (sb.Brace())
                {
                    if (printMask?.Name ?? true)
                    {
                        sb.AppendItem(Name, "Name");
                    }
                    if (printMask?.LeftStanding ?? true)
                    {
                        sb.AppendItem(LeftStanding, "LeftStanding");
                    }
                    if (printMask?.LeftWalk ?? true)
                    {
                        sb.AppendItem(LeftWalk, "LeftWalk");
                    }
                    if (printMask?.LeftRun ?? true)
                    {
                        sb.AppendItem(LeftRun, "LeftRun");
                    }
                    if (printMask?.LeftSprint ?? true)
                    {
                        sb.AppendItem(LeftSprint, "LeftSprint");
                    }
                    if (printMask?.RightStanding ?? true)
                    {
                        sb.AppendItem(RightStanding, "RightStanding");
                    }
                    if (printMask?.RightWalk ?? true)
                    {
                        sb.AppendItem(RightWalk, "RightWalk");
                    }
                    if (printMask?.RightRun ?? true)
                    {
                        sb.AppendItem(RightRun, "RightRun");
                    }
                    if (printMask?.RightSprint ?? true)
                    {
                        sb.AppendItem(RightSprint, "RightSprint");
                    }
                    if (printMask?.ForwardStanding ?? true)
                    {
                        sb.AppendItem(ForwardStanding, "ForwardStanding");
                    }
                    if (printMask?.ForwardWalk ?? true)
                    {
                        sb.AppendItem(ForwardWalk, "ForwardWalk");
                    }
                    if (printMask?.ForwardRun ?? true)
                    {
                        sb.AppendItem(ForwardRun, "ForwardRun");
                    }
                    if (printMask?.ForwardSprint ?? true)
                    {
                        sb.AppendItem(ForwardSprint, "ForwardSprint");
                    }
                    if (printMask?.BackStanding ?? true)
                    {
                        sb.AppendItem(BackStanding, "BackStanding");
                    }
                    if (printMask?.BackWalk ?? true)
                    {
                        sb.AppendItem(BackWalk, "BackWalk");
                    }
                    if (printMask?.BackRun ?? true)
                    {
                        sb.AppendItem(BackRun, "BackRun");
                    }
                    if (printMask?.BackSprint ?? true)
                    {
                        sb.AppendItem(BackSprint, "BackSprint");
                    }
                    if (printMask?.PitchStanding ?? true)
                    {
                        sb.AppendItem(PitchStanding, "PitchStanding");
                    }
                    if (printMask?.PitchWalk ?? true)
                    {
                        sb.AppendItem(PitchWalk, "PitchWalk");
                    }
                    if (printMask?.PitchRun ?? true)
                    {
                        sb.AppendItem(PitchRun, "PitchRun");
                    }
                    if (printMask?.PitchSprint ?? true)
                    {
                        sb.AppendItem(PitchSprint, "PitchSprint");
                    }
                    if (printMask?.RollStanding ?? true)
                    {
                        sb.AppendItem(RollStanding, "RollStanding");
                    }
                    if (printMask?.RollWalk ?? true)
                    {
                        sb.AppendItem(RollWalk, "RollWalk");
                    }
                    if (printMask?.RollRun ?? true)
                    {
                        sb.AppendItem(RollRun, "RollRun");
                    }
                    if (printMask?.RollSprint ?? true)
                    {
                        sb.AppendItem(RollSprint, "RollSprint");
                    }
                    if (printMask?.YawStanding ?? true)
                    {
                        sb.AppendItem(YawStanding, "YawStanding");
                    }
                    if (printMask?.YawWalk ?? true)
                    {
                        sb.AppendItem(YawWalk, "YawWalk");
                    }
                    if (printMask?.YawRun ?? true)
                    {
                        sb.AppendItem(YawRun, "YawRun");
                    }
                    if (printMask?.YawSprint ?? true)
                    {
                        sb.AppendItem(YawSprint, "YawSprint");
                    }
                    if (printMask?.AnimationChangeThresholds?.Overall ?? true)
                    {
                        AnimationChangeThresholds?.Print(sb);
                    }
                    if (printMask?.FloatHeight ?? true)
                    {
                        sb.AppendItem(FloatHeight, "FloatHeight");
                    }
                    if (printMask?.FlightAngleGain ?? true)
                    {
                        sb.AppendItem(FlightAngleGain, "FlightAngleGain");
                    }
                    if (printMask?.SPEDDataTypeState ?? true)
                    {
                        sb.AppendItem(SPEDDataTypeState, "SPEDDataTypeState");
                    }
                }
            }
            #endregion

        }

        public new class ErrorMask :
            Fallout4MajorRecord.ErrorMask,
            IErrorMask<ErrorMask>
        {
            #region Members
            public Exception? Name;
            public Exception? LeftStanding;
            public Exception? LeftWalk;
            public Exception? LeftRun;
            public Exception? LeftSprint;
            public Exception? RightStanding;
            public Exception? RightWalk;
            public Exception? RightRun;
            public Exception? RightSprint;
            public Exception? ForwardStanding;
            public Exception? ForwardWalk;
            public Exception? ForwardRun;
            public Exception? ForwardSprint;
            public Exception? BackStanding;
            public Exception? BackWalk;
            public Exception? BackRun;
            public Exception? BackSprint;
            public Exception? PitchStanding;
            public Exception? PitchWalk;
            public Exception? PitchRun;
            public Exception? PitchSprint;
            public Exception? RollStanding;
            public Exception? RollWalk;
            public Exception? RollRun;
            public Exception? RollSprint;
            public Exception? YawStanding;
            public Exception? YawWalk;
            public Exception? YawRun;
            public Exception? YawSprint;
            public MaskItem<Exception?, AnimationChangeThresholds.ErrorMask?>? AnimationChangeThresholds;
            public Exception? FloatHeight;
            public Exception? FlightAngleGain;
            public Exception? SPEDDataTypeState;
            #endregion

            #region IErrorMask
            public override object? GetNthMask(int index)
            {
                MovementType_FieldIndex enu = (MovementType_FieldIndex)index;
                switch (enu)
                {
                    case MovementType_FieldIndex.Name:
                        return Name;
                    case MovementType_FieldIndex.LeftStanding:
                        return LeftStanding;
                    case MovementType_FieldIndex.LeftWalk:
                        return LeftWalk;
                    case MovementType_FieldIndex.LeftRun:
                        return LeftRun;
                    case MovementType_FieldIndex.LeftSprint:
                        return LeftSprint;
                    case MovementType_FieldIndex.RightStanding:
                        return RightStanding;
                    case MovementType_FieldIndex.RightWalk:
                        return RightWalk;
                    case MovementType_FieldIndex.RightRun:
                        return RightRun;
                    case MovementType_FieldIndex.RightSprint:
                        return RightSprint;
                    case MovementType_FieldIndex.ForwardStanding:
                        return ForwardStanding;
                    case MovementType_FieldIndex.ForwardWalk:
                        return ForwardWalk;
                    case MovementType_FieldIndex.ForwardRun:
                        return ForwardRun;
                    case MovementType_FieldIndex.ForwardSprint:
                        return ForwardSprint;
                    case MovementType_FieldIndex.BackStanding:
                        return BackStanding;
                    case MovementType_FieldIndex.BackWalk:
                        return BackWalk;
                    case MovementType_FieldIndex.BackRun:
                        return BackRun;
                    case MovementType_FieldIndex.BackSprint:
                        return BackSprint;
                    case MovementType_FieldIndex.PitchStanding:
                        return PitchStanding;
                    case MovementType_FieldIndex.PitchWalk:
                        return PitchWalk;
                    case MovementType_FieldIndex.PitchRun:
                        return PitchRun;
                    case MovementType_FieldIndex.PitchSprint:
                        return PitchSprint;
                    case MovementType_FieldIndex.RollStanding:
                        return RollStanding;
                    case MovementType_FieldIndex.RollWalk:
                        return RollWalk;
                    case MovementType_FieldIndex.RollRun:
                        return RollRun;
                    case MovementType_FieldIndex.RollSprint:
                        return RollSprint;
                    case MovementType_FieldIndex.YawStanding:
                        return YawStanding;
                    case MovementType_FieldIndex.YawWalk:
                        return YawWalk;
                    case MovementType_FieldIndex.YawRun:
                        return YawRun;
                    case MovementType_FieldIndex.YawSprint:
                        return YawSprint;
                    case MovementType_FieldIndex.AnimationChangeThresholds:
                        return AnimationChangeThresholds;
                    case MovementType_FieldIndex.FloatHeight:
                        return FloatHeight;
                    case MovementType_FieldIndex.FlightAngleGain:
                        return FlightAngleGain;
                    case MovementType_FieldIndex.SPEDDataTypeState:
                        return SPEDDataTypeState;
                    default:
                        return base.GetNthMask(index);
                }
            }

            public override void SetNthException(int index, Exception ex)
            {
                MovementType_FieldIndex enu = (MovementType_FieldIndex)index;
                switch (enu)
                {
                    case MovementType_FieldIndex.Name:
                        this.Name = ex;
                        break;
                    case MovementType_FieldIndex.LeftStanding:
                        this.LeftStanding = ex;
                        break;
                    case MovementType_FieldIndex.LeftWalk:
                        this.LeftWalk = ex;
                        break;
                    case MovementType_FieldIndex.LeftRun:
                        this.LeftRun = ex;
                        break;
                    case MovementType_FieldIndex.LeftSprint:
                        this.LeftSprint = ex;
                        break;
                    case MovementType_FieldIndex.RightStanding:
                        this.RightStanding = ex;
                        break;
                    case MovementType_FieldIndex.RightWalk:
                        this.RightWalk = ex;
                        break;
                    case MovementType_FieldIndex.RightRun:
                        this.RightRun = ex;
                        break;
                    case MovementType_FieldIndex.RightSprint:
                        this.RightSprint = ex;
                        break;
                    case MovementType_FieldIndex.ForwardStanding:
                        this.ForwardStanding = ex;
                        break;
                    case MovementType_FieldIndex.ForwardWalk:
                        this.ForwardWalk = ex;
                        break;
                    case MovementType_FieldIndex.ForwardRun:
                        this.ForwardRun = ex;
                        break;
                    case MovementType_FieldIndex.ForwardSprint:
                        this.ForwardSprint = ex;
                        break;
                    case MovementType_FieldIndex.BackStanding:
                        this.BackStanding = ex;
                        break;
                    case MovementType_FieldIndex.BackWalk:
                        this.BackWalk = ex;
                        break;
                    case MovementType_FieldIndex.BackRun:
                        this.BackRun = ex;
                        break;
                    case MovementType_FieldIndex.BackSprint:
                        this.BackSprint = ex;
                        break;
                    case MovementType_FieldIndex.PitchStanding:
                        this.PitchStanding = ex;
                        break;
                    case MovementType_FieldIndex.PitchWalk:
                        this.PitchWalk = ex;
                        break;
                    case MovementType_FieldIndex.PitchRun:
                        this.PitchRun = ex;
                        break;
                    case MovementType_FieldIndex.PitchSprint:
                        this.PitchSprint = ex;
                        break;
                    case MovementType_FieldIndex.RollStanding:
                        this.RollStanding = ex;
                        break;
                    case MovementType_FieldIndex.RollWalk:
                        this.RollWalk = ex;
                        break;
                    case MovementType_FieldIndex.RollRun:
                        this.RollRun = ex;
                        break;
                    case MovementType_FieldIndex.RollSprint:
                        this.RollSprint = ex;
                        break;
                    case MovementType_FieldIndex.YawStanding:
                        this.YawStanding = ex;
                        break;
                    case MovementType_FieldIndex.YawWalk:
                        this.YawWalk = ex;
                        break;
                    case MovementType_FieldIndex.YawRun:
                        this.YawRun = ex;
                        break;
                    case MovementType_FieldIndex.YawSprint:
                        this.YawSprint = ex;
                        break;
                    case MovementType_FieldIndex.AnimationChangeThresholds:
                        this.AnimationChangeThresholds = new MaskItem<Exception?, AnimationChangeThresholds.ErrorMask?>(ex, null);
                        break;
                    case MovementType_FieldIndex.FloatHeight:
                        this.FloatHeight = ex;
                        break;
                    case MovementType_FieldIndex.FlightAngleGain:
                        this.FlightAngleGain = ex;
                        break;
                    case MovementType_FieldIndex.SPEDDataTypeState:
                        this.SPEDDataTypeState = ex;
                        break;
                    default:
                        base.SetNthException(index, ex);
                        break;
                }
            }

            public override void SetNthMask(int index, object obj)
            {
                MovementType_FieldIndex enu = (MovementType_FieldIndex)index;
                switch (enu)
                {
                    case MovementType_FieldIndex.Name:
                        this.Name = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.LeftStanding:
                        this.LeftStanding = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.LeftWalk:
                        this.LeftWalk = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.LeftRun:
                        this.LeftRun = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.LeftSprint:
                        this.LeftSprint = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.RightStanding:
                        this.RightStanding = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.RightWalk:
                        this.RightWalk = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.RightRun:
                        this.RightRun = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.RightSprint:
                        this.RightSprint = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.ForwardStanding:
                        this.ForwardStanding = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.ForwardWalk:
                        this.ForwardWalk = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.ForwardRun:
                        this.ForwardRun = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.ForwardSprint:
                        this.ForwardSprint = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.BackStanding:
                        this.BackStanding = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.BackWalk:
                        this.BackWalk = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.BackRun:
                        this.BackRun = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.BackSprint:
                        this.BackSprint = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.PitchStanding:
                        this.PitchStanding = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.PitchWalk:
                        this.PitchWalk = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.PitchRun:
                        this.PitchRun = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.PitchSprint:
                        this.PitchSprint = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.RollStanding:
                        this.RollStanding = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.RollWalk:
                        this.RollWalk = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.RollRun:
                        this.RollRun = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.RollSprint:
                        this.RollSprint = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.YawStanding:
                        this.YawStanding = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.YawWalk:
                        this.YawWalk = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.YawRun:
                        this.YawRun = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.YawSprint:
                        this.YawSprint = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.AnimationChangeThresholds:
                        this.AnimationChangeThresholds = (MaskItem<Exception?, AnimationChangeThresholds.ErrorMask?>?)obj;
                        break;
                    case MovementType_FieldIndex.FloatHeight:
                        this.FloatHeight = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.FlightAngleGain:
                        this.FlightAngleGain = (Exception?)obj;
                        break;
                    case MovementType_FieldIndex.SPEDDataTypeState:
                        this.SPEDDataTypeState = (Exception?)obj;
                        break;
                    default:
                        base.SetNthMask(index, obj);
                        break;
                }
            }

            public override bool IsInError()
            {
                if (Overall != null) return true;
                if (Name != null) return true;
                if (LeftStanding != null) return true;
                if (LeftWalk != null) return true;
                if (LeftRun != null) return true;
                if (LeftSprint != null) return true;
                if (RightStanding != null) return true;
                if (RightWalk != null) return true;
                if (RightRun != null) return true;
                if (RightSprint != null) return true;
                if (ForwardStanding != null) return true;
                if (ForwardWalk != null) return true;
                if (ForwardRun != null) return true;
                if (ForwardSprint != null) return true;
                if (BackStanding != null) return true;
                if (BackWalk != null) return true;
                if (BackRun != null) return true;
                if (BackSprint != null) return true;
                if (PitchStanding != null) return true;
                if (PitchWalk != null) return true;
                if (PitchRun != null) return true;
                if (PitchSprint != null) return true;
                if (RollStanding != null) return true;
                if (RollWalk != null) return true;
                if (RollRun != null) return true;
                if (RollSprint != null) return true;
                if (YawStanding != null) return true;
                if (YawWalk != null) return true;
                if (YawRun != null) return true;
                if (YawSprint != null) return true;
                if (AnimationChangeThresholds != null) return true;
                if (FloatHeight != null) return true;
                if (FlightAngleGain != null) return true;
                if (SPEDDataTypeState != null) return true;
                return false;
            }
            #endregion

            #region To String
            public override string ToString() => this.Print();

            public override void Print(StructuredStringBuilder sb, string? name = null)
            {
                sb.AppendLine($"{(name ?? "ErrorMask")} =>");
                using (sb.Brace())
                {
                    if (this.Overall != null)
                    {
                        sb.AppendLine("Overall =>");
                        using (sb.Brace())
                        {
                            sb.AppendLine($"{this.Overall}");
                        }
                    }
                    PrintFillInternal(sb);
                }
            }
            protected override void PrintFillInternal(StructuredStringBuilder sb)
            {
                base.PrintFillInternal(sb);
                {
                    sb.AppendItem(Name, "Name");
                }
                {
                    sb.AppendItem(LeftStanding, "LeftStanding");
                }
                {
                    sb.AppendItem(LeftWalk, "LeftWalk");
                }
                {
                    sb.AppendItem(LeftRun, "LeftRun");
                }
                {
                    sb.AppendItem(LeftSprint, "LeftSprint");
                }
                {
                    sb.AppendItem(RightStanding, "RightStanding");
                }
                {
                    sb.AppendItem(RightWalk, "RightWalk");
                }
                {
                    sb.AppendItem(RightRun, "RightRun");
                }
                {
                    sb.AppendItem(RightSprint, "RightSprint");
                }
                {
                    sb.AppendItem(ForwardStanding, "ForwardStanding");
                }
                {
                    sb.AppendItem(ForwardWalk, "ForwardWalk");
                }
                {
                    sb.AppendItem(ForwardRun, "ForwardRun");
                }
                {
                    sb.AppendItem(ForwardSprint, "ForwardSprint");
                }
                {
                    sb.AppendItem(BackStanding, "BackStanding");
                }
                {
                    sb.AppendItem(BackWalk, "BackWalk");
                }
                {
                    sb.AppendItem(BackRun, "BackRun");
                }
                {
                    sb.AppendItem(BackSprint, "BackSprint");
                }
                {
                    sb.AppendItem(PitchStanding, "PitchStanding");
                }
                {
                    sb.AppendItem(PitchWalk, "PitchWalk");
                }
                {
                    sb.AppendItem(PitchRun, "PitchRun");
                }
                {
                    sb.AppendItem(PitchSprint, "PitchSprint");
                }
                {
                    sb.AppendItem(RollStanding, "RollStanding");
                }
                {
                    sb.AppendItem(RollWalk, "RollWalk");
                }
                {
                    sb.AppendItem(RollRun, "RollRun");
                }
                {
                    sb.AppendItem(RollSprint, "RollSprint");
                }
                {
                    sb.AppendItem(YawStanding, "YawStanding");
                }
                {
                    sb.AppendItem(YawWalk, "YawWalk");
                }
                {
                    sb.AppendItem(YawRun, "YawRun");
                }
                {
                    sb.AppendItem(YawSprint, "YawSprint");
                }
                AnimationChangeThresholds?.Print(sb);
                {
                    sb.AppendItem(FloatHeight, "FloatHeight");
                }
                {
                    sb.AppendItem(FlightAngleGain, "FlightAngleGain");
                }
                {
                    sb.AppendItem(SPEDDataTypeState, "SPEDDataTypeState");
                }
            }
            #endregion

            #region Combine
            public ErrorMask Combine(ErrorMask? rhs)
            {
                if (rhs == null) return this;
                var ret = new ErrorMask();
                ret.Name = this.Name.Combine(rhs.Name);
                ret.LeftStanding = this.LeftStanding.Combine(rhs.LeftStanding);
                ret.LeftWalk = this.LeftWalk.Combine(rhs.LeftWalk);
                ret.LeftRun = this.LeftRun.Combine(rhs.LeftRun);
                ret.LeftSprint = this.LeftSprint.Combine(rhs.LeftSprint);
                ret.RightStanding = this.RightStanding.Combine(rhs.RightStanding);
                ret.RightWalk = this.RightWalk.Combine(rhs.RightWalk);
                ret.RightRun = this.RightRun.Combine(rhs.RightRun);
                ret.RightSprint = this.RightSprint.Combine(rhs.RightSprint);
                ret.ForwardStanding = this.ForwardStanding.Combine(rhs.ForwardStanding);
                ret.ForwardWalk = this.ForwardWalk.Combine(rhs.ForwardWalk);
                ret.ForwardRun = this.ForwardRun.Combine(rhs.ForwardRun);
                ret.ForwardSprint = this.ForwardSprint.Combine(rhs.ForwardSprint);
                ret.BackStanding = this.BackStanding.Combine(rhs.BackStanding);
                ret.BackWalk = this.BackWalk.Combine(rhs.BackWalk);
                ret.BackRun = this.BackRun.Combine(rhs.BackRun);
                ret.BackSprint = this.BackSprint.Combine(rhs.BackSprint);
                ret.PitchStanding = this.PitchStanding.Combine(rhs.PitchStanding);
                ret.PitchWalk = this.PitchWalk.Combine(rhs.PitchWalk);
                ret.PitchRun = this.PitchRun.Combine(rhs.PitchRun);
                ret.PitchSprint = this.PitchSprint.Combine(rhs.PitchSprint);
                ret.RollStanding = this.RollStanding.Combine(rhs.RollStanding);
                ret.RollWalk = this.RollWalk.Combine(rhs.RollWalk);
                ret.RollRun = this.RollRun.Combine(rhs.RollRun);
                ret.RollSprint = this.RollSprint.Combine(rhs.RollSprint);
                ret.YawStanding = this.YawStanding.Combine(rhs.YawStanding);
                ret.YawWalk = this.YawWalk.Combine(rhs.YawWalk);
                ret.YawRun = this.YawRun.Combine(rhs.YawRun);
                ret.YawSprint = this.YawSprint.Combine(rhs.YawSprint);
                ret.AnimationChangeThresholds = this.AnimationChangeThresholds.Combine(rhs.AnimationChangeThresholds, (l, r) => l.Combine(r));
                ret.FloatHeight = this.FloatHeight.Combine(rhs.FloatHeight);
                ret.FlightAngleGain = this.FlightAngleGain.Combine(rhs.FlightAngleGain);
                ret.SPEDDataTypeState = this.SPEDDataTypeState.Combine(rhs.SPEDDataTypeState);
                return ret;
            }
            public static ErrorMask? Combine(ErrorMask? lhs, ErrorMask? rhs)
            {
                if (lhs != null && rhs != null) return lhs.Combine(rhs);
                return lhs ?? rhs;
            }
            #endregion

            #region Factory
            public static new ErrorMask Factory(ErrorMaskBuilder errorMask)
            {
                return new ErrorMask();
            }
            #endregion

        }
        public new class TranslationMask :
            Fallout4MajorRecord.TranslationMask,
            ITranslationMask
        {
            #region Members
            public bool Name;
            public bool LeftStanding;
            public bool LeftWalk;
            public bool LeftRun;
            public bool LeftSprint;
            public bool RightStanding;
            public bool RightWalk;
            public bool RightRun;
            public bool RightSprint;
            public bool ForwardStanding;
            public bool ForwardWalk;
            public bool ForwardRun;
            public bool ForwardSprint;
            public bool BackStanding;
            public bool BackWalk;
            public bool BackRun;
            public bool BackSprint;
            public bool PitchStanding;
            public bool PitchWalk;
            public bool PitchRun;
            public bool PitchSprint;
            public bool RollStanding;
            public bool RollWalk;
            public bool RollRun;
            public bool RollSprint;
            public bool YawStanding;
            public bool YawWalk;
            public bool YawRun;
            public bool YawSprint;
            public AnimationChangeThresholds.TranslationMask? AnimationChangeThresholds;
            public bool FloatHeight;
            public bool FlightAngleGain;
            public bool SPEDDataTypeState;
            #endregion

            #region Ctors
            public TranslationMask(
                bool defaultOn,
                bool onOverall = true)
                : base(defaultOn, onOverall)
            {
                this.Name = defaultOn;
                this.LeftStanding = defaultOn;
                this.LeftWalk = defaultOn;
                this.LeftRun = defaultOn;
                this.LeftSprint = defaultOn;
                this.RightStanding = defaultOn;
                this.RightWalk = defaultOn;
                this.RightRun = defaultOn;
                this.RightSprint = defaultOn;
                this.ForwardStanding = defaultOn;
                this.ForwardWalk = defaultOn;
                this.ForwardRun = defaultOn;
                this.ForwardSprint = defaultOn;
                this.BackStanding = defaultOn;
                this.BackWalk = defaultOn;
                this.BackRun = defaultOn;
                this.BackSprint = defaultOn;
                this.PitchStanding = defaultOn;
                this.PitchWalk = defaultOn;
                this.PitchRun = defaultOn;
                this.PitchSprint = defaultOn;
                this.RollStanding = defaultOn;
                this.RollWalk = defaultOn;
                this.RollRun = defaultOn;
                this.RollSprint = defaultOn;
                this.YawStanding = defaultOn;
                this.YawWalk = defaultOn;
                this.YawRun = defaultOn;
                this.YawSprint = defaultOn;
                this.FloatHeight = defaultOn;
                this.FlightAngleGain = defaultOn;
                this.SPEDDataTypeState = defaultOn;
            }

            #endregion

            protected override void GetCrystal(List<(bool On, TranslationCrystal? SubCrystal)> ret)
            {
                base.GetCrystal(ret);
                ret.Add((Name, null));
                ret.Add((LeftStanding, null));
                ret.Add((LeftWalk, null));
                ret.Add((LeftRun, null));
                ret.Add((LeftSprint, null));
                ret.Add((RightStanding, null));
                ret.Add((RightWalk, null));
                ret.Add((RightRun, null));
                ret.Add((RightSprint, null));
                ret.Add((ForwardStanding, null));
                ret.Add((ForwardWalk, null));
                ret.Add((ForwardRun, null));
                ret.Add((ForwardSprint, null));
                ret.Add((BackStanding, null));
                ret.Add((BackWalk, null));
                ret.Add((BackRun, null));
                ret.Add((BackSprint, null));
                ret.Add((PitchStanding, null));
                ret.Add((PitchWalk, null));
                ret.Add((PitchRun, null));
                ret.Add((PitchSprint, null));
                ret.Add((RollStanding, null));
                ret.Add((RollWalk, null));
                ret.Add((RollRun, null));
                ret.Add((RollSprint, null));
                ret.Add((YawStanding, null));
                ret.Add((YawWalk, null));
                ret.Add((YawRun, null));
                ret.Add((YawSprint, null));
                ret.Add((AnimationChangeThresholds != null ? AnimationChangeThresholds.OnOverall : DefaultOn, AnimationChangeThresholds?.GetCrystal()));
                ret.Add((FloatHeight, null));
                ret.Add((FlightAngleGain, null));
                ret.Add((SPEDDataTypeState, null));
            }

            public static implicit operator TranslationMask(bool defaultOn)
            {
                return new TranslationMask(defaultOn: defaultOn, onOverall: defaultOn);
            }

        }
        #endregion

        #region Mutagen
        public static readonly RecordType GrupRecordType = MovementType_Registration.TriggeringRecordType;
        public MovementType(
            FormKey formKey,
            Fallout4Release gameRelease)
        {
            this.FormKey = formKey;
            this.FormVersion = GameConstants.Get(gameRelease.ToGameRelease()).DefaultFormVersion!.Value;
            CustomCtor();
        }

        private MovementType(
            FormKey formKey,
            GameRelease gameRelease)
        {
            this.FormKey = formKey;
            this.FormVersion = GameConstants.Get(gameRelease).DefaultFormVersion!.Value;
            CustomCtor();
        }

        internal MovementType(
            FormKey formKey,
            ushort formVersion)
        {
            this.FormKey = formKey;
            this.FormVersion = formVersion;
            CustomCtor();
        }

        public MovementType(IFallout4Mod mod)
            : this(
                mod.GetNextFormKey(),
                mod.Fallout4Release)
        {
        }

        public MovementType(IFallout4Mod mod, string editorID)
            : this(
                mod.GetNextFormKey(editorID),
                mod.Fallout4Release)
        {
            this.EditorID = editorID;
        }

        public override string ToString()
        {
            return MajorRecordPrinter<MovementType>.ToString(this);
        }

        protected override Type LinkType => typeof(IMovementType);

        [Flags]
        public enum SPEDDataType
        {
            Break0 = 1,
            Break1 = 2,
            Break2 = 4
        }
        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is IFormLinkGetter formLink)
            {
                return formLink.Equals(this);
            }
            if (obj is not IMovementTypeGetter rhs) return false;
            return ((MovementTypeCommon)((IMovementTypeGetter)this).CommonInstance()!).Equals(this, rhs, equalsMask: null);
        }

        public bool Equals(IMovementTypeGetter? obj)
        {
            return ((MovementTypeCommon)((IMovementTypeGetter)this).CommonInstance()!).Equals(this, obj, equalsMask: null);
        }

        public override int GetHashCode() => ((MovementTypeCommon)((IMovementTypeGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        #endregion

        #region Binary Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected override object BinaryWriteTranslator => MovementTypeBinaryWriteTranslation.Instance;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((MovementTypeBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }
        #region Binary Create
        public new static MovementType CreateFromBinary(
            MutagenFrame frame,
            TypedParseParams translationParams = default)
        {
            var ret = new MovementType();
            ((MovementTypeSetterCommon)((IMovementTypeGetter)ret).CommonSetterInstance()!).CopyInFromBinary(
                item: ret,
                frame: frame,
                translationParams: translationParams);
            return ret;
        }

        #endregion

        public static bool TryCreateFromBinary(
            MutagenFrame frame,
            out MovementType item,
            TypedParseParams translationParams = default)
        {
            var startPos = frame.Position;
            item = CreateFromBinary(
                frame: frame,
                translationParams: translationParams);
            return startPos != frame.Position;
        }
        #endregion

        void IPrintable.Print(StructuredStringBuilder sb, string? name) => this.Print(sb, name);

        void IClearable.Clear()
        {
            ((MovementTypeSetterCommon)((IMovementTypeGetter)this).CommonSetterInstance()!).Clear(this);
        }

        internal static new MovementType GetNew()
        {
            return new MovementType();
        }

    }
    #endregion

    #region Interface
    public partial interface IMovementType :
        IFallout4MajorRecordInternal,
        ILoquiObjectSetter<IMovementTypeInternal>,
        IMovementTypeGetter,
        INamed,
        INamedRequired
    {
        /// <summary>
        /// Aspects: INamed, INamedRequired
        /// </summary>
        new String? Name { get; set; }
        new Single LeftStanding { get; set; }
        new Single LeftWalk { get; set; }
        new Single LeftRun { get; set; }
        new Single LeftSprint { get; set; }
        new Single RightStanding { get; set; }
        new Single RightWalk { get; set; }
        new Single RightRun { get; set; }
        new Single RightSprint { get; set; }
        new Single ForwardStanding { get; set; }
        new Single ForwardWalk { get; set; }
        new Single ForwardRun { get; set; }
        new Single ForwardSprint { get; set; }
        new Single BackStanding { get; set; }
        new Single BackWalk { get; set; }
        new Single BackRun { get; set; }
        new Single BackSprint { get; set; }
        new Single PitchStanding { get; set; }
        new Single PitchWalk { get; set; }
        new Single PitchRun { get; set; }
        new Single PitchSprint { get; set; }
        new Single RollStanding { get; set; }
        new Single RollWalk { get; set; }
        new Single RollRun { get; set; }
        new Single RollSprint { get; set; }
        new Single YawStanding { get; set; }
        new Single YawWalk { get; set; }
        new Single YawRun { get; set; }
        new Single YawSprint { get; set; }
        new AnimationChangeThresholds? AnimationChangeThresholds { get; set; }
        new Single? FloatHeight { get; set; }
        new Single? FlightAngleGain { get; set; }
        new MovementType.SPEDDataType SPEDDataTypeState { get; set; }
    }

    public partial interface IMovementTypeInternal :
        IFallout4MajorRecordInternal,
        IMovementType,
        IMovementTypeGetter
    {
    }

    [AssociatedRecordTypesAttribute(Mutagen.Bethesda.Fallout4.Internals.RecordTypeInts.MOVT)]
    public partial interface IMovementTypeGetter :
        IFallout4MajorRecordGetter,
        IBinaryItem,
        ILoquiObject<IMovementTypeGetter>,
        IMapsToGetter<IMovementTypeGetter>,
        INamedGetter,
        INamedRequiredGetter
    {
        static new ILoquiRegistration StaticRegistration => MovementType_Registration.Instance;
        #region Name
        /// <summary>
        /// Aspects: INamedGetter, INamedRequiredGetter
        /// </summary>
        String? Name { get; }
        #endregion
        Single LeftStanding { get; }
        Single LeftWalk { get; }
        Single LeftRun { get; }
        Single LeftSprint { get; }
        Single RightStanding { get; }
        Single RightWalk { get; }
        Single RightRun { get; }
        Single RightSprint { get; }
        Single ForwardStanding { get; }
        Single ForwardWalk { get; }
        Single ForwardRun { get; }
        Single ForwardSprint { get; }
        Single BackStanding { get; }
        Single BackWalk { get; }
        Single BackRun { get; }
        Single BackSprint { get; }
        Single PitchStanding { get; }
        Single PitchWalk { get; }
        Single PitchRun { get; }
        Single PitchSprint { get; }
        Single RollStanding { get; }
        Single RollWalk { get; }
        Single RollRun { get; }
        Single RollSprint { get; }
        Single YawStanding { get; }
        Single YawWalk { get; }
        Single YawRun { get; }
        Single YawSprint { get; }
        IAnimationChangeThresholdsGetter? AnimationChangeThresholds { get; }
        Single? FloatHeight { get; }
        Single? FlightAngleGain { get; }
        MovementType.SPEDDataType SPEDDataTypeState { get; }

    }

    #endregion

    #region Common MixIn
    public static partial class MovementTypeMixIn
    {
        public static void Clear(this IMovementTypeInternal item)
        {
            ((MovementTypeSetterCommon)((IMovementTypeGetter)item).CommonSetterInstance()!).Clear(item: item);
        }

        public static MovementType.Mask<bool> GetEqualsMask(
            this IMovementTypeGetter item,
            IMovementTypeGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            return ((MovementTypeCommon)((IMovementTypeGetter)item).CommonInstance()!).GetEqualsMask(
                item: item,
                rhs: rhs,
                include: include);
        }

        public static string Print(
            this IMovementTypeGetter item,
            string? name = null,
            MovementType.Mask<bool>? printMask = null)
        {
            return ((MovementTypeCommon)((IMovementTypeGetter)item).CommonInstance()!).Print(
                item: item,
                name: name,
                printMask: printMask);
        }

        public static void Print(
            this IMovementTypeGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            MovementType.Mask<bool>? printMask = null)
        {
            ((MovementTypeCommon)((IMovementTypeGetter)item).CommonInstance()!).Print(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
        }

        public static bool Equals(
            this IMovementTypeGetter item,
            IMovementTypeGetter rhs,
            MovementType.TranslationMask? equalsMask = null)
        {
            return ((MovementTypeCommon)((IMovementTypeGetter)item).CommonInstance()!).Equals(
                lhs: item,
                rhs: rhs,
                equalsMask: equalsMask?.GetCrystal());
        }

        public static void DeepCopyIn(
            this IMovementTypeInternal lhs,
            IMovementTypeGetter rhs,
            out MovementType.ErrorMask errorMask,
            MovementType.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            ((MovementTypeSetterTranslationCommon)((IMovementTypeGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
            errorMask = MovementType.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void DeepCopyIn(
            this IMovementTypeInternal lhs,
            IMovementTypeGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            ((MovementTypeSetterTranslationCommon)((IMovementTypeGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: false);
        }

        public static MovementType DeepCopy(
            this IMovementTypeGetter item,
            MovementType.TranslationMask? copyMask = null)
        {
            return ((MovementTypeSetterTranslationCommon)((IMovementTypeGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask);
        }

        public static MovementType DeepCopy(
            this IMovementTypeGetter item,
            out MovementType.ErrorMask errorMask,
            MovementType.TranslationMask? copyMask = null)
        {
            return ((MovementTypeSetterTranslationCommon)((IMovementTypeGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: out errorMask);
        }

        public static MovementType DeepCopy(
            this IMovementTypeGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            return ((MovementTypeSetterTranslationCommon)((IMovementTypeGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: errorMask);
        }

        #region Mutagen
        public static MovementType Duplicate(
            this IMovementTypeGetter item,
            FormKey formKey,
            MovementType.TranslationMask? copyMask = null)
        {
            return ((MovementTypeCommon)((IMovementTypeGetter)item).CommonInstance()!).Duplicate(
                item: item,
                formKey: formKey,
                copyMask: copyMask?.GetCrystal());
        }

        public static MovementType Duplicate(
            this IMovementTypeGetter item,
            FormKey formKey,
            TranslationCrystal? copyMask)
        {
            return ((MovementTypeCommon)((IMovementTypeGetter)item).CommonInstance()!).Duplicate(
                item: item,
                formKey: formKey,
                copyMask: copyMask);
        }

        #endregion

        #region Binary Translation
        public static void CopyInFromBinary(
            this IMovementTypeInternal item,
            MutagenFrame frame,
            TypedParseParams translationParams = default)
        {
            ((MovementTypeSetterCommon)((IMovementTypeGetter)item).CommonSetterInstance()!).CopyInFromBinary(
                item: item,
                frame: frame,
                translationParams: translationParams);
        }

        #endregion

    }
    #endregion

}

namespace Mutagen.Bethesda.Fallout4
{
    #region Field Index
    internal enum MovementType_FieldIndex
    {
        MajorRecordFlagsRaw = 0,
        FormKey = 1,
        VersionControl = 2,
        EditorID = 3,
        FormVersion = 4,
        Version2 = 5,
        Fallout4MajorRecordFlags = 6,
        Name = 7,
        LeftStanding = 8,
        LeftWalk = 9,
        LeftRun = 10,
        LeftSprint = 11,
        RightStanding = 12,
        RightWalk = 13,
        RightRun = 14,
        RightSprint = 15,
        ForwardStanding = 16,
        ForwardWalk = 17,
        ForwardRun = 18,
        ForwardSprint = 19,
        BackStanding = 20,
        BackWalk = 21,
        BackRun = 22,
        BackSprint = 23,
        PitchStanding = 24,
        PitchWalk = 25,
        PitchRun = 26,
        PitchSprint = 27,
        RollStanding = 28,
        RollWalk = 29,
        RollRun = 30,
        RollSprint = 31,
        YawStanding = 32,
        YawWalk = 33,
        YawRun = 34,
        YawSprint = 35,
        AnimationChangeThresholds = 36,
        FloatHeight = 37,
        FlightAngleGain = 38,
        SPEDDataTypeState = 39,
    }
    #endregion

    #region Registration
    internal partial class MovementType_Registration : ILoquiRegistration
    {
        public static readonly MovementType_Registration Instance = new MovementType_Registration();

        public static ProtocolKey ProtocolKey => ProtocolDefinition_Fallout4.ProtocolKey;

        public const ushort AdditionalFieldCount = 33;

        public const ushort FieldCount = 40;

        public static readonly Type MaskType = typeof(MovementType.Mask<>);

        public static readonly Type ErrorMaskType = typeof(MovementType.ErrorMask);

        public static readonly Type ClassType = typeof(MovementType);

        public static readonly Type GetterType = typeof(IMovementTypeGetter);

        public static readonly Type? InternalGetterType = null;

        public static readonly Type SetterType = typeof(IMovementType);

        public static readonly Type? InternalSetterType = typeof(IMovementTypeInternal);

        public const string FullName = "Mutagen.Bethesda.Fallout4.MovementType";

        public const string Name = "MovementType";

        public const string Namespace = "Mutagen.Bethesda.Fallout4";

        public const byte GenericCount = 0;

        public static readonly Type? GenericRegistrationType = null;

        public static readonly RecordType TriggeringRecordType = RecordTypes.MOVT;
        public static RecordTriggerSpecs TriggerSpecs => _recordSpecs.Value;
        private static readonly Lazy<RecordTriggerSpecs> _recordSpecs = new Lazy<RecordTriggerSpecs>(() =>
        {
            var triggers = RecordCollection.Factory(RecordTypes.MOVT);
            var all = RecordCollection.Factory(
                RecordTypes.MOVT,
                RecordTypes.MNAM,
                RecordTypes.SPED,
                RecordTypes.INAM,
                RecordTypes.JNAM,
                RecordTypes.LNAM);
            return new RecordTriggerSpecs(
                allRecordTypes: all,
                triggeringRecordTypes: triggers);
        });
        public static readonly Type BinaryWriteTranslation = typeof(MovementTypeBinaryWriteTranslation);
        #region Interface
        ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;
        ushort ILoquiRegistration.FieldCount => FieldCount;
        ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;
        Type ILoquiRegistration.MaskType => MaskType;
        Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;
        Type ILoquiRegistration.ClassType => ClassType;
        Type ILoquiRegistration.SetterType => SetterType;
        Type? ILoquiRegistration.InternalSetterType => InternalSetterType;
        Type ILoquiRegistration.GetterType => GetterType;
        Type? ILoquiRegistration.InternalGetterType => InternalGetterType;
        string ILoquiRegistration.FullName => FullName;
        string ILoquiRegistration.Name => Name;
        string ILoquiRegistration.Namespace => Namespace;
        byte ILoquiRegistration.GenericCount => GenericCount;
        Type? ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;
        ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsLoqui(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsSingleton(ushort index) => throw new NotImplementedException();
        string ILoquiRegistration.GetNthName(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsNthDerivative(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsProtected(ushort index) => throw new NotImplementedException();
        Type ILoquiRegistration.GetNthType(ushort index) => throw new NotImplementedException();
        #endregion

    }
    #endregion

    #region Common
    internal partial class MovementTypeSetterCommon : Fallout4MajorRecordSetterCommon
    {
        public new static readonly MovementTypeSetterCommon Instance = new MovementTypeSetterCommon();

        partial void ClearPartial();
        
        public void Clear(IMovementTypeInternal item)
        {
            ClearPartial();
            item.Name = default;
            item.LeftStanding = default(Single);
            item.LeftWalk = default(Single);
            item.LeftRun = default(Single);
            item.LeftSprint = default(Single);
            item.RightStanding = default(Single);
            item.RightWalk = default(Single);
            item.RightRun = default(Single);
            item.RightSprint = default(Single);
            item.ForwardStanding = default(Single);
            item.ForwardWalk = default(Single);
            item.ForwardRun = default(Single);
            item.ForwardSprint = default(Single);
            item.BackStanding = default(Single);
            item.BackWalk = default(Single);
            item.BackRun = default(Single);
            item.BackSprint = default(Single);
            item.PitchStanding = default(Single);
            item.PitchWalk = default(Single);
            item.PitchRun = default(Single);
            item.PitchSprint = default(Single);
            item.RollStanding = default(Single);
            item.RollWalk = default(Single);
            item.RollRun = default(Single);
            item.RollSprint = default(Single);
            item.YawStanding = default(Single);
            item.YawWalk = default(Single);
            item.YawRun = default(Single);
            item.YawSprint = default(Single);
            item.AnimationChangeThresholds = null;
            item.FloatHeight = default;
            item.FlightAngleGain = default;
            item.SPEDDataTypeState = default(MovementType.SPEDDataType);
            base.Clear(item);
        }
        
        public override void Clear(IFallout4MajorRecordInternal item)
        {
            Clear(item: (IMovementTypeInternal)item);
        }
        
        public override void Clear(IMajorRecordInternal item)
        {
            Clear(item: (IMovementTypeInternal)item);
        }
        
        #region Mutagen
        public void RemapLinks(IMovementType obj, IReadOnlyDictionary<FormKey, FormKey> mapping)
        {
            base.RemapLinks(obj, mapping);
        }
        
        #endregion
        
        #region Binary Translation
        public virtual void CopyInFromBinary(
            IMovementTypeInternal item,
            MutagenFrame frame,
            TypedParseParams translationParams)
        {
            PluginUtilityTranslation.MajorRecordParse<IMovementTypeInternal>(
                record: item,
                frame: frame,
                translationParams: translationParams,
                fillStructs: MovementTypeBinaryCreateTranslation.FillBinaryStructs,
                fillTyped: MovementTypeBinaryCreateTranslation.FillBinaryRecordTypes);
        }
        
        public override void CopyInFromBinary(
            IFallout4MajorRecordInternal item,
            MutagenFrame frame,
            TypedParseParams translationParams)
        {
            CopyInFromBinary(
                item: (MovementType)item,
                frame: frame,
                translationParams: translationParams);
        }
        
        public override void CopyInFromBinary(
            IMajorRecordInternal item,
            MutagenFrame frame,
            TypedParseParams translationParams)
        {
            CopyInFromBinary(
                item: (MovementType)item,
                frame: frame,
                translationParams: translationParams);
        }
        
        #endregion
        
    }
    internal partial class MovementTypeCommon : Fallout4MajorRecordCommon
    {
        public new static readonly MovementTypeCommon Instance = new MovementTypeCommon();

        public MovementType.Mask<bool> GetEqualsMask(
            IMovementTypeGetter item,
            IMovementTypeGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            var ret = new MovementType.Mask<bool>(false);
            ((MovementTypeCommon)((IMovementTypeGetter)item).CommonInstance()!).FillEqualsMask(
                item: item,
                rhs: rhs,
                ret: ret,
                include: include);
            return ret;
        }
        
        public void FillEqualsMask(
            IMovementTypeGetter item,
            IMovementTypeGetter rhs,
            MovementType.Mask<bool> ret,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            ret.Name = string.Equals(item.Name, rhs.Name);
            ret.LeftStanding = item.LeftStanding.EqualsWithin(rhs.LeftStanding);
            ret.LeftWalk = item.LeftWalk.EqualsWithin(rhs.LeftWalk);
            ret.LeftRun = item.LeftRun.EqualsWithin(rhs.LeftRun);
            ret.LeftSprint = item.LeftSprint.EqualsWithin(rhs.LeftSprint);
            ret.RightStanding = item.RightStanding.EqualsWithin(rhs.RightStanding);
            ret.RightWalk = item.RightWalk.EqualsWithin(rhs.RightWalk);
            ret.RightRun = item.RightRun.EqualsWithin(rhs.RightRun);
            ret.RightSprint = item.RightSprint.EqualsWithin(rhs.RightSprint);
            ret.ForwardStanding = item.ForwardStanding.EqualsWithin(rhs.ForwardStanding);
            ret.ForwardWalk = item.ForwardWalk.EqualsWithin(rhs.ForwardWalk);
            ret.ForwardRun = item.ForwardRun.EqualsWithin(rhs.ForwardRun);
            ret.ForwardSprint = item.ForwardSprint.EqualsWithin(rhs.ForwardSprint);
            ret.BackStanding = item.BackStanding.EqualsWithin(rhs.BackStanding);
            ret.BackWalk = item.BackWalk.EqualsWithin(rhs.BackWalk);
            ret.BackRun = item.BackRun.EqualsWithin(rhs.BackRun);
            ret.BackSprint = item.BackSprint.EqualsWithin(rhs.BackSprint);
            ret.PitchStanding = item.PitchStanding.EqualsWithin(rhs.PitchStanding);
            ret.PitchWalk = item.PitchWalk.EqualsWithin(rhs.PitchWalk);
            ret.PitchRun = item.PitchRun.EqualsWithin(rhs.PitchRun);
            ret.PitchSprint = item.PitchSprint.EqualsWithin(rhs.PitchSprint);
            ret.RollStanding = item.RollStanding.EqualsWithin(rhs.RollStanding);
            ret.RollWalk = item.RollWalk.EqualsWithin(rhs.RollWalk);
            ret.RollRun = item.RollRun.EqualsWithin(rhs.RollRun);
            ret.RollSprint = item.RollSprint.EqualsWithin(rhs.RollSprint);
            ret.YawStanding = item.YawStanding.EqualsWithin(rhs.YawStanding);
            ret.YawWalk = item.YawWalk.EqualsWithin(rhs.YawWalk);
            ret.YawRun = item.YawRun.EqualsWithin(rhs.YawRun);
            ret.YawSprint = item.YawSprint.EqualsWithin(rhs.YawSprint);
            ret.AnimationChangeThresholds = EqualsMaskHelper.EqualsHelper(
                item.AnimationChangeThresholds,
                rhs.AnimationChangeThresholds,
                (loqLhs, loqRhs, incl) => loqLhs.GetEqualsMask(loqRhs, incl),
                include);
            ret.FloatHeight = item.FloatHeight.EqualsWithin(rhs.FloatHeight);
            ret.FlightAngleGain = item.FlightAngleGain.EqualsWithin(rhs.FlightAngleGain);
            ret.SPEDDataTypeState = item.SPEDDataTypeState == rhs.SPEDDataTypeState;
            base.FillEqualsMask(item, rhs, ret, include);
        }
        
        public string Print(
            IMovementTypeGetter item,
            string? name = null,
            MovementType.Mask<bool>? printMask = null)
        {
            var sb = new StructuredStringBuilder();
            Print(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
            return sb.ToString();
        }
        
        public void Print(
            IMovementTypeGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            MovementType.Mask<bool>? printMask = null)
        {
            if (name == null)
            {
                sb.AppendLine($"MovementType =>");
            }
            else
            {
                sb.AppendLine($"{name} (MovementType) =>");
            }
            using (sb.Brace())
            {
                ToStringFields(
                    item: item,
                    sb: sb,
                    printMask: printMask);
            }
        }
        
        protected static void ToStringFields(
            IMovementTypeGetter item,
            StructuredStringBuilder sb,
            MovementType.Mask<bool>? printMask = null)
        {
            Fallout4MajorRecordCommon.ToStringFields(
                item: item,
                sb: sb,
                printMask: printMask);
            if ((printMask?.Name ?? true)
                && item.Name is {} NameItem)
            {
                sb.AppendItem(NameItem, "Name");
            }
            if (printMask?.LeftStanding ?? true)
            {
                sb.AppendItem(item.LeftStanding, "LeftStanding");
            }
            if (printMask?.LeftWalk ?? true)
            {
                sb.AppendItem(item.LeftWalk, "LeftWalk");
            }
            if (printMask?.LeftRun ?? true)
            {
                sb.AppendItem(item.LeftRun, "LeftRun");
            }
            if (printMask?.LeftSprint ?? true)
            {
                sb.AppendItem(item.LeftSprint, "LeftSprint");
            }
            if (printMask?.RightStanding ?? true)
            {
                sb.AppendItem(item.RightStanding, "RightStanding");
            }
            if (printMask?.RightWalk ?? true)
            {
                sb.AppendItem(item.RightWalk, "RightWalk");
            }
            if (printMask?.RightRun ?? true)
            {
                sb.AppendItem(item.RightRun, "RightRun");
            }
            if (printMask?.RightSprint ?? true)
            {
                sb.AppendItem(item.RightSprint, "RightSprint");
            }
            if (printMask?.ForwardStanding ?? true)
            {
                sb.AppendItem(item.ForwardStanding, "ForwardStanding");
            }
            if (printMask?.ForwardWalk ?? true)
            {
                sb.AppendItem(item.ForwardWalk, "ForwardWalk");
            }
            if (printMask?.ForwardRun ?? true)
            {
                sb.AppendItem(item.ForwardRun, "ForwardRun");
            }
            if (printMask?.ForwardSprint ?? true)
            {
                sb.AppendItem(item.ForwardSprint, "ForwardSprint");
            }
            if (printMask?.BackStanding ?? true)
            {
                sb.AppendItem(item.BackStanding, "BackStanding");
            }
            if (printMask?.BackWalk ?? true)
            {
                sb.AppendItem(item.BackWalk, "BackWalk");
            }
            if (printMask?.BackRun ?? true)
            {
                sb.AppendItem(item.BackRun, "BackRun");
            }
            if (printMask?.BackSprint ?? true)
            {
                sb.AppendItem(item.BackSprint, "BackSprint");
            }
            if (printMask?.PitchStanding ?? true)
            {
                sb.AppendItem(item.PitchStanding, "PitchStanding");
            }
            if (printMask?.PitchWalk ?? true)
            {
                sb.AppendItem(item.PitchWalk, "PitchWalk");
            }
            if (printMask?.PitchRun ?? true)
            {
                sb.AppendItem(item.PitchRun, "PitchRun");
            }
            if (printMask?.PitchSprint ?? true)
            {
                sb.AppendItem(item.PitchSprint, "PitchSprint");
            }
            if (printMask?.RollStanding ?? true)
            {
                sb.AppendItem(item.RollStanding, "RollStanding");
            }
            if (printMask?.RollWalk ?? true)
            {
                sb.AppendItem(item.RollWalk, "RollWalk");
            }
            if (printMask?.RollRun ?? true)
            {
                sb.AppendItem(item.RollRun, "RollRun");
            }
            if (printMask?.RollSprint ?? true)
            {
                sb.AppendItem(item.RollSprint, "RollSprint");
            }
            if (printMask?.YawStanding ?? true)
            {
                sb.AppendItem(item.YawStanding, "YawStanding");
            }
            if (printMask?.YawWalk ?? true)
            {
                sb.AppendItem(item.YawWalk, "YawWalk");
            }
            if (printMask?.YawRun ?? true)
            {
                sb.AppendItem(item.YawRun, "YawRun");
            }
            if (printMask?.YawSprint ?? true)
            {
                sb.AppendItem(item.YawSprint, "YawSprint");
            }
            if ((printMask?.AnimationChangeThresholds?.Overall ?? true)
                && item.AnimationChangeThresholds is {} AnimationChangeThresholdsItem)
            {
                AnimationChangeThresholdsItem?.Print(sb, "AnimationChangeThresholds");
            }
            if ((printMask?.FloatHeight ?? true)
                && item.FloatHeight is {} FloatHeightItem)
            {
                sb.AppendItem(FloatHeightItem, "FloatHeight");
            }
            if ((printMask?.FlightAngleGain ?? true)
                && item.FlightAngleGain is {} FlightAngleGainItem)
            {
                sb.AppendItem(FlightAngleGainItem, "FlightAngleGain");
            }
            if (printMask?.SPEDDataTypeState ?? true)
            {
                sb.AppendItem(item.SPEDDataTypeState, "SPEDDataTypeState");
            }
        }
        
        public static MovementType_FieldIndex ConvertFieldIndex(Fallout4MajorRecord_FieldIndex index)
        {
            switch (index)
            {
                case Fallout4MajorRecord_FieldIndex.MajorRecordFlagsRaw:
                    return (MovementType_FieldIndex)((int)index);
                case Fallout4MajorRecord_FieldIndex.FormKey:
                    return (MovementType_FieldIndex)((int)index);
                case Fallout4MajorRecord_FieldIndex.VersionControl:
                    return (MovementType_FieldIndex)((int)index);
                case Fallout4MajorRecord_FieldIndex.EditorID:
                    return (MovementType_FieldIndex)((int)index);
                case Fallout4MajorRecord_FieldIndex.FormVersion:
                    return (MovementType_FieldIndex)((int)index);
                case Fallout4MajorRecord_FieldIndex.Version2:
                    return (MovementType_FieldIndex)((int)index);
                case Fallout4MajorRecord_FieldIndex.Fallout4MajorRecordFlags:
                    return (MovementType_FieldIndex)((int)index);
                default:
                    throw new ArgumentException($"Index is out of range: {index.ToStringFast()}");
            }
        }
        
        public static new MovementType_FieldIndex ConvertFieldIndex(MajorRecord_FieldIndex index)
        {
            switch (index)
            {
                case MajorRecord_FieldIndex.MajorRecordFlagsRaw:
                    return (MovementType_FieldIndex)((int)index);
                case MajorRecord_FieldIndex.FormKey:
                    return (MovementType_FieldIndex)((int)index);
                case MajorRecord_FieldIndex.VersionControl:
                    return (MovementType_FieldIndex)((int)index);
                case MajorRecord_FieldIndex.EditorID:
                    return (MovementType_FieldIndex)((int)index);
                default:
                    throw new ArgumentException($"Index is out of range: {index.ToStringFast()}");
            }
        }
        
        #region Equals and Hash
        public virtual bool Equals(
            IMovementTypeGetter? lhs,
            IMovementTypeGetter? rhs,
            TranslationCrystal? equalsMask)
        {
            if (!EqualsMaskHelper.RefEquality(lhs, rhs, out var isEqual)) return isEqual;
            if (!base.Equals((IFallout4MajorRecordGetter)lhs, (IFallout4MajorRecordGetter)rhs, equalsMask)) return false;
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.Name) ?? true))
            {
                if (!string.Equals(lhs.Name, rhs.Name)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.LeftStanding) ?? true))
            {
                if (!lhs.LeftStanding.EqualsWithin(rhs.LeftStanding)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.LeftWalk) ?? true))
            {
                if (!lhs.LeftWalk.EqualsWithin(rhs.LeftWalk)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.LeftRun) ?? true))
            {
                if (!lhs.LeftRun.EqualsWithin(rhs.LeftRun)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.LeftSprint) ?? true))
            {
                if (!lhs.LeftSprint.EqualsWithin(rhs.LeftSprint)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.RightStanding) ?? true))
            {
                if (!lhs.RightStanding.EqualsWithin(rhs.RightStanding)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.RightWalk) ?? true))
            {
                if (!lhs.RightWalk.EqualsWithin(rhs.RightWalk)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.RightRun) ?? true))
            {
                if (!lhs.RightRun.EqualsWithin(rhs.RightRun)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.RightSprint) ?? true))
            {
                if (!lhs.RightSprint.EqualsWithin(rhs.RightSprint)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.ForwardStanding) ?? true))
            {
                if (!lhs.ForwardStanding.EqualsWithin(rhs.ForwardStanding)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.ForwardWalk) ?? true))
            {
                if (!lhs.ForwardWalk.EqualsWithin(rhs.ForwardWalk)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.ForwardRun) ?? true))
            {
                if (!lhs.ForwardRun.EqualsWithin(rhs.ForwardRun)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.ForwardSprint) ?? true))
            {
                if (!lhs.ForwardSprint.EqualsWithin(rhs.ForwardSprint)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.BackStanding) ?? true))
            {
                if (!lhs.BackStanding.EqualsWithin(rhs.BackStanding)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.BackWalk) ?? true))
            {
                if (!lhs.BackWalk.EqualsWithin(rhs.BackWalk)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.BackRun) ?? true))
            {
                if (!lhs.BackRun.EqualsWithin(rhs.BackRun)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.BackSprint) ?? true))
            {
                if (!lhs.BackSprint.EqualsWithin(rhs.BackSprint)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.PitchStanding) ?? true))
            {
                if (!lhs.PitchStanding.EqualsWithin(rhs.PitchStanding)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.PitchWalk) ?? true))
            {
                if (!lhs.PitchWalk.EqualsWithin(rhs.PitchWalk)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.PitchRun) ?? true))
            {
                if (!lhs.PitchRun.EqualsWithin(rhs.PitchRun)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.PitchSprint) ?? true))
            {
                if (!lhs.PitchSprint.EqualsWithin(rhs.PitchSprint)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.RollStanding) ?? true))
            {
                if (!lhs.RollStanding.EqualsWithin(rhs.RollStanding)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.RollWalk) ?? true))
            {
                if (!lhs.RollWalk.EqualsWithin(rhs.RollWalk)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.RollRun) ?? true))
            {
                if (!lhs.RollRun.EqualsWithin(rhs.RollRun)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.RollSprint) ?? true))
            {
                if (!lhs.RollSprint.EqualsWithin(rhs.RollSprint)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.YawStanding) ?? true))
            {
                if (!lhs.YawStanding.EqualsWithin(rhs.YawStanding)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.YawWalk) ?? true))
            {
                if (!lhs.YawWalk.EqualsWithin(rhs.YawWalk)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.YawRun) ?? true))
            {
                if (!lhs.YawRun.EqualsWithin(rhs.YawRun)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.YawSprint) ?? true))
            {
                if (!lhs.YawSprint.EqualsWithin(rhs.YawSprint)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.AnimationChangeThresholds) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.AnimationChangeThresholds, rhs.AnimationChangeThresholds, out var lhsAnimationChangeThresholds, out var rhsAnimationChangeThresholds, out var isAnimationChangeThresholdsEqual))
                {
                    if (!((AnimationChangeThresholdsCommon)((IAnimationChangeThresholdsGetter)lhsAnimationChangeThresholds).CommonInstance()!).Equals(lhsAnimationChangeThresholds, rhsAnimationChangeThresholds, equalsMask?.GetSubCrystal((int)MovementType_FieldIndex.AnimationChangeThresholds))) return false;
                }
                else if (!isAnimationChangeThresholdsEqual) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.FloatHeight) ?? true))
            {
                if (!lhs.FloatHeight.EqualsWithin(rhs.FloatHeight)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.FlightAngleGain) ?? true))
            {
                if (!lhs.FlightAngleGain.EqualsWithin(rhs.FlightAngleGain)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)MovementType_FieldIndex.SPEDDataTypeState) ?? true))
            {
                if (lhs.SPEDDataTypeState != rhs.SPEDDataTypeState) return false;
            }
            return true;
        }
        
        public override bool Equals(
            IFallout4MajorRecordGetter? lhs,
            IFallout4MajorRecordGetter? rhs,
            TranslationCrystal? equalsMask)
        {
            return Equals(
                lhs: (IMovementTypeGetter?)lhs,
                rhs: rhs as IMovementTypeGetter,
                equalsMask: equalsMask);
        }
        
        public override bool Equals(
            IMajorRecordGetter? lhs,
            IMajorRecordGetter? rhs,
            TranslationCrystal? equalsMask)
        {
            return Equals(
                lhs: (IMovementTypeGetter?)lhs,
                rhs: rhs as IMovementTypeGetter,
                equalsMask: equalsMask);
        }
        
        public virtual int GetHashCode(IMovementTypeGetter item)
        {
            var hash = new HashCode();
            if (item.Name is {} Nameitem)
            {
                hash.Add(Nameitem);
            }
            hash.Add(item.LeftStanding);
            hash.Add(item.LeftWalk);
            hash.Add(item.LeftRun);
            hash.Add(item.LeftSprint);
            hash.Add(item.RightStanding);
            hash.Add(item.RightWalk);
            hash.Add(item.RightRun);
            hash.Add(item.RightSprint);
            hash.Add(item.ForwardStanding);
            hash.Add(item.ForwardWalk);
            hash.Add(item.ForwardRun);
            hash.Add(item.ForwardSprint);
            hash.Add(item.BackStanding);
            hash.Add(item.BackWalk);
            hash.Add(item.BackRun);
            hash.Add(item.BackSprint);
            hash.Add(item.PitchStanding);
            hash.Add(item.PitchWalk);
            hash.Add(item.PitchRun);
            hash.Add(item.PitchSprint);
            hash.Add(item.RollStanding);
            hash.Add(item.RollWalk);
            hash.Add(item.RollRun);
            hash.Add(item.RollSprint);
            hash.Add(item.YawStanding);
            hash.Add(item.YawWalk);
            hash.Add(item.YawRun);
            hash.Add(item.YawSprint);
            if (item.AnimationChangeThresholds is {} AnimationChangeThresholdsitem)
            {
                hash.Add(AnimationChangeThresholdsitem);
            }
            if (item.FloatHeight is {} FloatHeightitem)
            {
                hash.Add(FloatHeightitem);
            }
            if (item.FlightAngleGain is {} FlightAngleGainitem)
            {
                hash.Add(FlightAngleGainitem);
            }
            hash.Add(item.SPEDDataTypeState);
            hash.Add(base.GetHashCode());
            return hash.ToHashCode();
        }
        
        public override int GetHashCode(IFallout4MajorRecordGetter item)
        {
            return GetHashCode(item: (IMovementTypeGetter)item);
        }
        
        public override int GetHashCode(IMajorRecordGetter item)
        {
            return GetHashCode(item: (IMovementTypeGetter)item);
        }
        
        #endregion
        
        
        public override object GetNew()
        {
            return MovementType.GetNew();
        }
        
        #region Mutagen
        public IEnumerable<IFormLinkGetter> EnumerateFormLinks(IMovementTypeGetter obj)
        {
            foreach (var item in base.EnumerateFormLinks(obj))
            {
                yield return item;
            }
            yield break;
        }
        
        #region Duplicate
        public MovementType Duplicate(
            IMovementTypeGetter item,
            FormKey formKey,
            TranslationCrystal? copyMask)
        {
            var newRec = new MovementType(formKey, item.FormVersion);
            newRec.DeepCopyIn(item, default(ErrorMaskBuilder?), copyMask);
            return newRec;
        }
        
        public override Fallout4MajorRecord Duplicate(
            IFallout4MajorRecordGetter item,
            FormKey formKey,
            TranslationCrystal? copyMask)
        {
            return this.Duplicate(
                item: (IMovementTypeGetter)item,
                formKey: formKey,
                copyMask: copyMask);
        }
        
        public override MajorRecord Duplicate(
            IMajorRecordGetter item,
            FormKey formKey,
            TranslationCrystal? copyMask)
        {
            return this.Duplicate(
                item: (IMovementTypeGetter)item,
                formKey: formKey,
                copyMask: copyMask);
        }
        
        #endregion
        
        #endregion
        
    }
    internal partial class MovementTypeSetterTranslationCommon : Fallout4MajorRecordSetterTranslationCommon
    {
        public new static readonly MovementTypeSetterTranslationCommon Instance = new MovementTypeSetterTranslationCommon();

        #region DeepCopyIn
        public void DeepCopyIn(
            IMovementTypeInternal item,
            IMovementTypeGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            base.DeepCopyIn(
                item,
                rhs,
                errorMask,
                copyMask,
                deepCopy: deepCopy);
        }
        
        public void DeepCopyIn(
            IMovementType item,
            IMovementTypeGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            base.DeepCopyIn(
                (IFallout4MajorRecord)item,
                (IFallout4MajorRecordGetter)rhs,
                errorMask,
                copyMask,
                deepCopy: deepCopy);
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.Name) ?? true))
            {
                item.Name = rhs.Name;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.LeftStanding) ?? true))
            {
                item.LeftStanding = rhs.LeftStanding;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.LeftWalk) ?? true))
            {
                item.LeftWalk = rhs.LeftWalk;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.LeftRun) ?? true))
            {
                item.LeftRun = rhs.LeftRun;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.LeftSprint) ?? true))
            {
                item.LeftSprint = rhs.LeftSprint;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.RightStanding) ?? true))
            {
                item.RightStanding = rhs.RightStanding;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.RightWalk) ?? true))
            {
                item.RightWalk = rhs.RightWalk;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.RightRun) ?? true))
            {
                item.RightRun = rhs.RightRun;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.RightSprint) ?? true))
            {
                item.RightSprint = rhs.RightSprint;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.ForwardStanding) ?? true))
            {
                item.ForwardStanding = rhs.ForwardStanding;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.ForwardWalk) ?? true))
            {
                item.ForwardWalk = rhs.ForwardWalk;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.ForwardRun) ?? true))
            {
                item.ForwardRun = rhs.ForwardRun;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.ForwardSprint) ?? true))
            {
                item.ForwardSprint = rhs.ForwardSprint;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.BackStanding) ?? true))
            {
                item.BackStanding = rhs.BackStanding;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.BackWalk) ?? true))
            {
                item.BackWalk = rhs.BackWalk;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.BackRun) ?? true))
            {
                item.BackRun = rhs.BackRun;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.BackSprint) ?? true))
            {
                item.BackSprint = rhs.BackSprint;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.PitchStanding) ?? true))
            {
                item.PitchStanding = rhs.PitchStanding;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.PitchWalk) ?? true))
            {
                item.PitchWalk = rhs.PitchWalk;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.PitchRun) ?? true))
            {
                item.PitchRun = rhs.PitchRun;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.PitchSprint) ?? true))
            {
                item.PitchSprint = rhs.PitchSprint;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.RollStanding) ?? true))
            {
                item.RollStanding = rhs.RollStanding;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.RollWalk) ?? true))
            {
                item.RollWalk = rhs.RollWalk;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.RollRun) ?? true))
            {
                item.RollRun = rhs.RollRun;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.RollSprint) ?? true))
            {
                item.RollSprint = rhs.RollSprint;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.YawStanding) ?? true))
            {
                item.YawStanding = rhs.YawStanding;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.YawWalk) ?? true))
            {
                item.YawWalk = rhs.YawWalk;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.YawRun) ?? true))
            {
                item.YawRun = rhs.YawRun;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.YawSprint) ?? true))
            {
                item.YawSprint = rhs.YawSprint;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.AnimationChangeThresholds) ?? true))
            {
                errorMask?.PushIndex((int)MovementType_FieldIndex.AnimationChangeThresholds);
                try
                {
                    if(rhs.AnimationChangeThresholds is {} rhsAnimationChangeThresholds)
                    {
                        item.AnimationChangeThresholds = rhsAnimationChangeThresholds.DeepCopy(
                            errorMask: errorMask,
                            copyMask?.GetSubCrystal((int)MovementType_FieldIndex.AnimationChangeThresholds));
                    }
                    else
                    {
                        item.AnimationChangeThresholds = default;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.FloatHeight) ?? true))
            {
                item.FloatHeight = rhs.FloatHeight;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.FlightAngleGain) ?? true))
            {
                item.FlightAngleGain = rhs.FlightAngleGain;
            }
            if ((copyMask?.GetShouldTranslate((int)MovementType_FieldIndex.SPEDDataTypeState) ?? true))
            {
                item.SPEDDataTypeState = rhs.SPEDDataTypeState;
            }
            DeepCopyInCustom(
                item: item,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        partial void DeepCopyInCustom(
            IMovementType item,
            IMovementTypeGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy);
        public override void DeepCopyIn(
            IFallout4MajorRecordInternal item,
            IFallout4MajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IMovementTypeInternal)item,
                rhs: (IMovementTypeGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        public override void DeepCopyIn(
            IFallout4MajorRecord item,
            IFallout4MajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IMovementType)item,
                rhs: (IMovementTypeGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        public override void DeepCopyIn(
            IMajorRecordInternal item,
            IMajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IMovementTypeInternal)item,
                rhs: (IMovementTypeGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        public override void DeepCopyIn(
            IMajorRecord item,
            IMajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IMovementType)item,
                rhs: (IMovementTypeGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        #endregion
        
        public MovementType DeepCopy(
            IMovementTypeGetter item,
            MovementType.TranslationMask? copyMask = null)
        {
            MovementType ret = (MovementType)((MovementTypeCommon)((IMovementTypeGetter)item).CommonInstance()!).GetNew();
            ((MovementTypeSetterTranslationCommon)((IMovementTypeGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: null,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            return ret;
        }
        
        public MovementType DeepCopy(
            IMovementTypeGetter item,
            out MovementType.ErrorMask errorMask,
            MovementType.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            MovementType ret = (MovementType)((MovementTypeCommon)((IMovementTypeGetter)item).CommonInstance()!).GetNew();
            ((MovementTypeSetterTranslationCommon)((IMovementTypeGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                ret,
                item,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            errorMask = MovementType.ErrorMask.Factory(errorMaskBuilder);
            return ret;
        }
        
        public MovementType DeepCopy(
            IMovementTypeGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            MovementType ret = (MovementType)((MovementTypeCommon)((IMovementTypeGetter)item).CommonInstance()!).GetNew();
            ((MovementTypeSetterTranslationCommon)((IMovementTypeGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: true);
            return ret;
        }
        
    }
    #endregion

}

namespace Mutagen.Bethesda.Fallout4
{
    public partial class MovementType
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => MovementType_Registration.Instance;
        public new static ILoquiRegistration StaticRegistration => MovementType_Registration.Instance;
        [DebuggerStepThrough]
        protected override object CommonInstance() => MovementTypeCommon.Instance;
        [DebuggerStepThrough]
        protected override object CommonSetterInstance()
        {
            return MovementTypeSetterCommon.Instance;
        }
        [DebuggerStepThrough]
        protected override object CommonSetterTranslationInstance() => MovementTypeSetterTranslationCommon.Instance;

        #endregion

    }
}

#region Modules
#region Binary Translation
namespace Mutagen.Bethesda.Fallout4
{
    public partial class MovementTypeBinaryWriteTranslation :
        Fallout4MajorRecordBinaryWriteTranslation,
        IBinaryWriteTranslator
    {
        public new static readonly MovementTypeBinaryWriteTranslation Instance = new();

        public static void WriteEmbedded(
            IMovementTypeGetter item,
            MutagenWriter writer)
        {
            Fallout4MajorRecordBinaryWriteTranslation.WriteEmbedded(
                item: item,
                writer: writer);
        }

        public static void WriteRecordTypes(
            IMovementTypeGetter item,
            MutagenWriter writer,
            TypedWriteParams translationParams)
        {
            MajorRecordBinaryWriteTranslation.WriteRecordTypes(
                item: item,
                writer: writer,
                translationParams: translationParams);
            StringBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.Name,
                header: translationParams.ConvertToCustom(RecordTypes.MNAM),
                binaryType: StringBinaryType.NullTerminate);
            using (HeaderExport.Subrecord(writer, translationParams.ConvertToCustom(RecordTypes.SPED)))
            {
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.LeftStanding);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.LeftWalk);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.LeftRun);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.LeftSprint);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.RightStanding);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.RightWalk);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.RightRun);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.RightSprint);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.ForwardStanding);
                FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                    writer: writer,
                    item: item.ForwardWalk);
                if (!item.SPEDDataTypeState.HasFlag(MovementType.SPEDDataType.Break0))
                {
                    FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                        writer: writer,
                        item: item.ForwardRun);
                    if (!item.SPEDDataTypeState.HasFlag(MovementType.SPEDDataType.Break1))
                    {
                        FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                            writer: writer,
                            item: item.ForwardSprint);
                        FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                            writer: writer,
                            item: item.BackStanding);
                        FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                            writer: writer,
                            item: item.BackWalk);
                        FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                            writer: writer,
                            item: item.BackRun);
                        FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                            writer: writer,
                            item: item.BackSprint);
                        FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                            writer: writer,
                            item: item.PitchStanding,
                            divisor: 57.295799255371094f,
                            multiplier: null);
                        if (!item.SPEDDataTypeState.HasFlag(MovementType.SPEDDataType.Break2))
                        {
                            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                                writer: writer,
                                item: item.PitchWalk,
                                divisor: 57.295799255371094f,
                                multiplier: null);
                            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                                writer: writer,
                                item: item.PitchRun,
                                divisor: 57.295799255371094f,
                                multiplier: null);
                            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                                writer: writer,
                                item: item.PitchSprint,
                                divisor: 57.295799255371094f,
                                multiplier: null);
                            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                                writer: writer,
                                item: item.RollStanding,
                                divisor: 57.295799255371094f,
                                multiplier: null);
                            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                                writer: writer,
                                item: item.RollWalk,
                                divisor: 57.295799255371094f,
                                multiplier: null);
                            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                                writer: writer,
                                item: item.RollRun,
                                divisor: 57.295799255371094f,
                                multiplier: null);
                            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                                writer: writer,
                                item: item.RollSprint,
                                divisor: 57.295799255371094f,
                                multiplier: null);
                            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                                writer: writer,
                                item: item.YawStanding,
                                divisor: 57.295799255371094f,
                                multiplier: null);
                            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                                writer: writer,
                                item: item.YawWalk,
                                divisor: 57.295799255371094f,
                                multiplier: null);
                            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                                writer: writer,
                                item: item.YawRun,
                                divisor: 57.295799255371094f,
                                multiplier: null);
                            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                                writer: writer,
                                item: item.YawSprint,
                                divisor: 57.295799255371094f,
                                multiplier: null);
                        }
                    }
                }
            }
            if (item.AnimationChangeThresholds is {} AnimationChangeThresholdsItem)
            {
                ((AnimationChangeThresholdsBinaryWriteTranslation)((IBinaryItem)AnimationChangeThresholdsItem).BinaryWriteTranslator).Write(
                    item: AnimationChangeThresholdsItem,
                    writer: writer,
                    translationParams: translationParams);
            }
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.FloatHeight,
                header: translationParams.ConvertToCustom(RecordTypes.JNAM));
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.FlightAngleGain,
                header: translationParams.ConvertToCustom(RecordTypes.LNAM));
        }

        public void Write(
            MutagenWriter writer,
            IMovementTypeGetter item,
            TypedWriteParams translationParams)
        {
            PluginUtilityTranslation.WriteMajorRecord(
                writer: writer,
                item: item,
                translationParams: translationParams,
                type: RecordTypes.MOVT,
                writeEmbedded: Fallout4MajorRecordBinaryWriteTranslation.WriteEmbedded,
                writeRecordTypes: WriteRecordTypes);
        }

        public override void Write(
            MutagenWriter writer,
            object item,
            TypedWriteParams translationParams = default)
        {
            Write(
                item: (IMovementTypeGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

        public override void Write(
            MutagenWriter writer,
            IFallout4MajorRecordGetter item,
            TypedWriteParams translationParams)
        {
            Write(
                item: (IMovementTypeGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

        public override void Write(
            MutagenWriter writer,
            IMajorRecordGetter item,
            TypedWriteParams translationParams)
        {
            Write(
                item: (IMovementTypeGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

    }

    internal partial class MovementTypeBinaryCreateTranslation : Fallout4MajorRecordBinaryCreateTranslation
    {
        public new static readonly MovementTypeBinaryCreateTranslation Instance = new MovementTypeBinaryCreateTranslation();

        public override RecordType RecordType => RecordTypes.MOVT;
        public static void FillBinaryStructs(
            IMovementTypeInternal item,
            MutagenFrame frame)
        {
            Fallout4MajorRecordBinaryCreateTranslation.FillBinaryStructs(
                item: item,
                frame: frame);
        }

        public static ParseResult FillBinaryRecordTypes(
            IMovementTypeInternal item,
            MutagenFrame frame,
            PreviousParse lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            RecordType nextRecordType,
            int contentLength,
            TypedParseParams translationParams = default)
        {
            nextRecordType = translationParams.ConvertToStandard(nextRecordType);
            switch (nextRecordType.TypeInt)
            {
                case RecordTypeInts.MNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Name = StringBinaryTranslation.Instance.Parse(
                        reader: frame.SpawnWithLength(contentLength),
                        stringBinaryType: StringBinaryType.NullTerminate,
                        parseWhole: true);
                    return (int)MovementType_FieldIndex.Name;
                }
                case RecordTypeInts.SPED:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    var dataFrame = frame.SpawnWithLength(contentLength);
                    if (dataFrame.Remaining < 4) return null;
                    item.LeftStanding = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    if (dataFrame.Remaining < 4) return null;
                    item.LeftWalk = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    if (dataFrame.Remaining < 4) return null;
                    item.LeftRun = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    if (dataFrame.Remaining < 4) return null;
                    item.LeftSprint = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    if (dataFrame.Remaining < 4) return null;
                    item.RightStanding = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    if (dataFrame.Remaining < 4) return null;
                    item.RightWalk = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    if (dataFrame.Remaining < 4) return null;
                    item.RightRun = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    if (dataFrame.Remaining < 4) return null;
                    item.RightSprint = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    if (dataFrame.Remaining < 4) return null;
                    item.ForwardStanding = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    if (dataFrame.Remaining < 4) return null;
                    item.ForwardWalk = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    if (dataFrame.Complete)
                    {
                        item.SPEDDataTypeState |= MovementType.SPEDDataType.Break0;
                        return (int)MovementType_FieldIndex.ForwardWalk;
                    }
                    if (dataFrame.Remaining < 4) return null;
                    item.ForwardRun = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    if (dataFrame.Complete)
                    {
                        item.SPEDDataTypeState |= MovementType.SPEDDataType.Break1;
                        return (int)MovementType_FieldIndex.ForwardRun;
                    }
                    if (dataFrame.Remaining < 4) return null;
                    item.ForwardSprint = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    if (dataFrame.Remaining < 4) return null;
                    item.BackStanding = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    if (dataFrame.Remaining < 4) return null;
                    item.BackWalk = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    if (dataFrame.Remaining < 4) return null;
                    item.BackRun = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    if (dataFrame.Remaining < 4) return null;
                    item.BackSprint = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: dataFrame);
                    if (dataFrame.Remaining < 4) return null;
                    item.PitchStanding = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: dataFrame,
                        multiplier: 57.295799255371094f,
                        divisor: null);
                    if (dataFrame.Complete)
                    {
                        item.SPEDDataTypeState |= MovementType.SPEDDataType.Break2;
                        return (int)MovementType_FieldIndex.PitchStanding;
                    }
                    if (dataFrame.Remaining < 4) return null;
                    item.PitchWalk = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: dataFrame,
                        multiplier: 57.295799255371094f,
                        divisor: null);
                    if (dataFrame.Remaining < 4) return null;
                    item.PitchRun = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: dataFrame,
                        multiplier: 57.295799255371094f,
                        divisor: null);
                    if (dataFrame.Remaining < 4) return null;
                    item.PitchSprint = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: dataFrame,
                        multiplier: 57.295799255371094f,
                        divisor: null);
                    if (dataFrame.Remaining < 4) return null;
                    item.RollStanding = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: dataFrame,
                        multiplier: 57.295799255371094f,
                        divisor: null);
                    if (dataFrame.Remaining < 4) return null;
                    item.RollWalk = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: dataFrame,
                        multiplier: 57.295799255371094f,
                        divisor: null);
                    if (dataFrame.Remaining < 4) return null;
                    item.RollRun = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: dataFrame,
                        multiplier: 57.295799255371094f,
                        divisor: null);
                    if (dataFrame.Remaining < 4) return null;
                    item.RollSprint = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: dataFrame,
                        multiplier: 57.295799255371094f,
                        divisor: null);
                    if (dataFrame.Remaining < 4) return null;
                    item.YawStanding = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: dataFrame,
                        multiplier: 57.295799255371094f,
                        divisor: null);
                    if (dataFrame.Remaining < 4) return null;
                    item.YawWalk = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: dataFrame,
                        multiplier: 57.295799255371094f,
                        divisor: null);
                    if (dataFrame.Remaining < 4) return null;
                    item.YawRun = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: dataFrame,
                        multiplier: 57.295799255371094f,
                        divisor: null);
                    if (dataFrame.Remaining < 4) return null;
                    item.YawSprint = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: dataFrame,
                        multiplier: 57.295799255371094f,
                        divisor: null);
                    return (int)MovementType_FieldIndex.YawSprint;
                }
                case RecordTypeInts.INAM:
                {
                    item.AnimationChangeThresholds = Mutagen.Bethesda.Fallout4.AnimationChangeThresholds.CreateFromBinary(frame: frame);
                    return (int)MovementType_FieldIndex.AnimationChangeThresholds;
                }
                case RecordTypeInts.JNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.FloatHeight = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)MovementType_FieldIndex.FloatHeight;
                }
                case RecordTypeInts.LNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.FlightAngleGain = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)MovementType_FieldIndex.FlightAngleGain;
                }
                default:
                    return Fallout4MajorRecordBinaryCreateTranslation.FillBinaryRecordTypes(
                        item: item,
                        frame: frame,
                        lastParsed: lastParsed,
                        recordParseCount: recordParseCount,
                        nextRecordType: nextRecordType,
                        contentLength: contentLength,
                        translationParams: translationParams.WithNoConverter());
            }
        }

    }

}
namespace Mutagen.Bethesda.Fallout4
{
    #region Binary Write Mixins
    public static class MovementTypeBinaryTranslationMixIn
    {
    }
    #endregion


}
namespace Mutagen.Bethesda.Fallout4
{
    internal partial class MovementTypeBinaryOverlay :
        Fallout4MajorRecordBinaryOverlay,
        IMovementTypeGetter
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => MovementType_Registration.Instance;
        public new static ILoquiRegistration StaticRegistration => MovementType_Registration.Instance;
        [DebuggerStepThrough]
        protected override object CommonInstance() => MovementTypeCommon.Instance;
        [DebuggerStepThrough]
        protected override object CommonSetterTranslationInstance() => MovementTypeSetterTranslationCommon.Instance;

        #endregion

        void IPrintable.Print(StructuredStringBuilder sb, string? name) => this.Print(sb, name);

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected override object BinaryWriteTranslator => MovementTypeBinaryWriteTranslation.Instance;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((MovementTypeBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }
        protected override Type LinkType => typeof(IMovementType);


        #region Name
        private int? _NameLocation;
        public String? Name => _NameLocation.HasValue ? BinaryStringUtility.ProcessWholeToZString(HeaderTranslation.ExtractSubrecordMemory(_recordData, _NameLocation.Value, _package.MetaData.Constants), encoding: _package.MetaData.Encodings.NonTranslated) : default(string?);
        #region Aspects
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        string INamedRequiredGetter.Name => this.Name ?? string.Empty;
        #endregion
        #endregion
        private RangeInt32? _SPEDLocation;
        public MovementType.SPEDDataType SPEDDataTypeState { get; private set; }
        #region LeftStanding
        private int _LeftStandingLocation => _SPEDLocation!.Value.Min;
        private bool _LeftStanding_IsSet => _SPEDLocation.HasValue;
        public Single LeftStanding => _LeftStanding_IsSet ? _recordData.Slice(_LeftStandingLocation, 4).Float() : default(Single);
        #endregion
        #region LeftWalk
        private int _LeftWalkLocation => _SPEDLocation!.Value.Min + 0x4;
        private bool _LeftWalk_IsSet => _SPEDLocation.HasValue;
        public Single LeftWalk => _LeftWalk_IsSet ? _recordData.Slice(_LeftWalkLocation, 4).Float() : default(Single);
        #endregion
        #region LeftRun
        private int _LeftRunLocation => _SPEDLocation!.Value.Min + 0x8;
        private bool _LeftRun_IsSet => _SPEDLocation.HasValue;
        public Single LeftRun => _LeftRun_IsSet ? _recordData.Slice(_LeftRunLocation, 4).Float() : default(Single);
        #endregion
        #region LeftSprint
        private int _LeftSprintLocation => _SPEDLocation!.Value.Min + 0xC;
        private bool _LeftSprint_IsSet => _SPEDLocation.HasValue;
        public Single LeftSprint => _LeftSprint_IsSet ? _recordData.Slice(_LeftSprintLocation, 4).Float() : default(Single);
        #endregion
        #region RightStanding
        private int _RightStandingLocation => _SPEDLocation!.Value.Min + 0x10;
        private bool _RightStanding_IsSet => _SPEDLocation.HasValue;
        public Single RightStanding => _RightStanding_IsSet ? _recordData.Slice(_RightStandingLocation, 4).Float() : default(Single);
        #endregion
        #region RightWalk
        private int _RightWalkLocation => _SPEDLocation!.Value.Min + 0x14;
        private bool _RightWalk_IsSet => _SPEDLocation.HasValue;
        public Single RightWalk => _RightWalk_IsSet ? _recordData.Slice(_RightWalkLocation, 4).Float() : default(Single);
        #endregion
        #region RightRun
        private int _RightRunLocation => _SPEDLocation!.Value.Min + 0x18;
        private bool _RightRun_IsSet => _SPEDLocation.HasValue;
        public Single RightRun => _RightRun_IsSet ? _recordData.Slice(_RightRunLocation, 4).Float() : default(Single);
        #endregion
        #region RightSprint
        private int _RightSprintLocation => _SPEDLocation!.Value.Min + 0x1C;
        private bool _RightSprint_IsSet => _SPEDLocation.HasValue;
        public Single RightSprint => _RightSprint_IsSet ? _recordData.Slice(_RightSprintLocation, 4).Float() : default(Single);
        #endregion
        #region ForwardStanding
        private int _ForwardStandingLocation => _SPEDLocation!.Value.Min + 0x20;
        private bool _ForwardStanding_IsSet => _SPEDLocation.HasValue;
        public Single ForwardStanding => _ForwardStanding_IsSet ? _recordData.Slice(_ForwardStandingLocation, 4).Float() : default(Single);
        #endregion
        #region ForwardWalk
        private int _ForwardWalkLocation => _SPEDLocation!.Value.Min + 0x24;
        private bool _ForwardWalk_IsSet => _SPEDLocation.HasValue;
        public Single ForwardWalk => _ForwardWalk_IsSet ? _recordData.Slice(_ForwardWalkLocation, 4).Float() : default(Single);
        #endregion
        #region ForwardRun
        private int _ForwardRunLocation => _SPEDLocation!.Value.Min + 0x28;
        private bool _ForwardRun_IsSet => _SPEDLocation.HasValue && !SPEDDataTypeState.HasFlag(MovementType.SPEDDataType.Break0);
        public Single ForwardRun => _ForwardRun_IsSet ? _recordData.Slice(_ForwardRunLocation, 4).Float() : default(Single);
        #endregion
        #region ForwardSprint
        private int _ForwardSprintLocation => _SPEDLocation!.Value.Min + 0x2C;
        private bool _ForwardSprint_IsSet => _SPEDLocation.HasValue && !SPEDDataTypeState.HasFlag(MovementType.SPEDDataType.Break1);
        public Single ForwardSprint => _ForwardSprint_IsSet ? _recordData.Slice(_ForwardSprintLocation, 4).Float() : default(Single);
        #endregion
        #region BackStanding
        private int _BackStandingLocation => _SPEDLocation!.Value.Min + 0x30;
        private bool _BackStanding_IsSet => _SPEDLocation.HasValue && !SPEDDataTypeState.HasFlag(MovementType.SPEDDataType.Break1);
        public Single BackStanding => _BackStanding_IsSet ? _recordData.Slice(_BackStandingLocation, 4).Float() : default(Single);
        #endregion
        #region BackWalk
        private int _BackWalkLocation => _SPEDLocation!.Value.Min + 0x34;
        private bool _BackWalk_IsSet => _SPEDLocation.HasValue && !SPEDDataTypeState.HasFlag(MovementType.SPEDDataType.Break1);
        public Single BackWalk => _BackWalk_IsSet ? _recordData.Slice(_BackWalkLocation, 4).Float() : default(Single);
        #endregion
        #region BackRun
        private int _BackRunLocation => _SPEDLocation!.Value.Min + 0x38;
        private bool _BackRun_IsSet => _SPEDLocation.HasValue && !SPEDDataTypeState.HasFlag(MovementType.SPEDDataType.Break1);
        public Single BackRun => _BackRun_IsSet ? _recordData.Slice(_BackRunLocation, 4).Float() : default(Single);
        #endregion
        #region BackSprint
        private int _BackSprintLocation => _SPEDLocation!.Value.Min + 0x3C;
        private bool _BackSprint_IsSet => _SPEDLocation.HasValue && !SPEDDataTypeState.HasFlag(MovementType.SPEDDataType.Break1);
        public Single BackSprint => _BackSprint_IsSet ? _recordData.Slice(_BackSprintLocation, 4).Float() : default(Single);
        #endregion
        #region PitchStanding
        private int _PitchStandingLocation => _SPEDLocation!.Value.Min + 0x40;
        private bool _PitchStanding_IsSet => _SPEDLocation.HasValue && !SPEDDataTypeState.HasFlag(MovementType.SPEDDataType.Break1);
        public Single PitchStanding => _PitchStanding_IsSet ? _recordData.Slice(_PitchStandingLocation, 4).Float() * 57.2958f : default(Single);
        #endregion
        #region PitchWalk
        private int _PitchWalkLocation => _SPEDLocation!.Value.Min + 0x44;
        private bool _PitchWalk_IsSet => _SPEDLocation.HasValue && !SPEDDataTypeState.HasFlag(MovementType.SPEDDataType.Break2);
        public Single PitchWalk => _PitchWalk_IsSet ? _recordData.Slice(_PitchWalkLocation, 4).Float() * 57.2958f : default(Single);
        #endregion
        #region PitchRun
        private int _PitchRunLocation => _SPEDLocation!.Value.Min + 0x48;
        private bool _PitchRun_IsSet => _SPEDLocation.HasValue && !SPEDDataTypeState.HasFlag(MovementType.SPEDDataType.Break2);
        public Single PitchRun => _PitchRun_IsSet ? _recordData.Slice(_PitchRunLocation, 4).Float() * 57.2958f : default(Single);
        #endregion
        #region PitchSprint
        private int _PitchSprintLocation => _SPEDLocation!.Value.Min + 0x4C;
        private bool _PitchSprint_IsSet => _SPEDLocation.HasValue && !SPEDDataTypeState.HasFlag(MovementType.SPEDDataType.Break2);
        public Single PitchSprint => _PitchSprint_IsSet ? _recordData.Slice(_PitchSprintLocation, 4).Float() * 57.2958f : default(Single);
        #endregion
        #region RollStanding
        private int _RollStandingLocation => _SPEDLocation!.Value.Min + 0x50;
        private bool _RollStanding_IsSet => _SPEDLocation.HasValue && !SPEDDataTypeState.HasFlag(MovementType.SPEDDataType.Break2);
        public Single RollStanding => _RollStanding_IsSet ? _recordData.Slice(_RollStandingLocation, 4).Float() * 57.2958f : default(Single);
        #endregion
        #region RollWalk
        private int _RollWalkLocation => _SPEDLocation!.Value.Min + 0x54;
        private bool _RollWalk_IsSet => _SPEDLocation.HasValue && !SPEDDataTypeState.HasFlag(MovementType.SPEDDataType.Break2);
        public Single RollWalk => _RollWalk_IsSet ? _recordData.Slice(_RollWalkLocation, 4).Float() * 57.2958f : default(Single);
        #endregion
        #region RollRun
        private int _RollRunLocation => _SPEDLocation!.Value.Min + 0x58;
        private bool _RollRun_IsSet => _SPEDLocation.HasValue && !SPEDDataTypeState.HasFlag(MovementType.SPEDDataType.Break2);
        public Single RollRun => _RollRun_IsSet ? _recordData.Slice(_RollRunLocation, 4).Float() * 57.2958f : default(Single);
        #endregion
        #region RollSprint
        private int _RollSprintLocation => _SPEDLocation!.Value.Min + 0x5C;
        private bool _RollSprint_IsSet => _SPEDLocation.HasValue && !SPEDDataTypeState.HasFlag(MovementType.SPEDDataType.Break2);
        public Single RollSprint => _RollSprint_IsSet ? _recordData.Slice(_RollSprintLocation, 4).Float() * 57.2958f : default(Single);
        #endregion
        #region YawStanding
        private int _YawStandingLocation => _SPEDLocation!.Value.Min + 0x60;
        private bool _YawStanding_IsSet => _SPEDLocation.HasValue && !SPEDDataTypeState.HasFlag(MovementType.SPEDDataType.Break2);
        public Single YawStanding => _YawStanding_IsSet ? _recordData.Slice(_YawStandingLocation, 4).Float() * 57.2958f : default(Single);
        #endregion
        #region YawWalk
        private int _YawWalkLocation => _SPEDLocation!.Value.Min + 0x64;
        private bool _YawWalk_IsSet => _SPEDLocation.HasValue && !SPEDDataTypeState.HasFlag(MovementType.SPEDDataType.Break2);
        public Single YawWalk => _YawWalk_IsSet ? _recordData.Slice(_YawWalkLocation, 4).Float() * 57.2958f : default(Single);
        #endregion
        #region YawRun
        private int _YawRunLocation => _SPEDLocation!.Value.Min + 0x68;
        private bool _YawRun_IsSet => _SPEDLocation.HasValue && !SPEDDataTypeState.HasFlag(MovementType.SPEDDataType.Break2);
        public Single YawRun => _YawRun_IsSet ? _recordData.Slice(_YawRunLocation, 4).Float() * 57.2958f : default(Single);
        #endregion
        #region YawSprint
        private int _YawSprintLocation => _SPEDLocation!.Value.Min + 0x6C;
        private bool _YawSprint_IsSet => _SPEDLocation.HasValue && !SPEDDataTypeState.HasFlag(MovementType.SPEDDataType.Break2);
        public Single YawSprint => _YawSprint_IsSet ? _recordData.Slice(_YawSprintLocation, 4).Float() * 57.2958f : default(Single);
        #endregion
        #region AnimationChangeThresholds
        private RangeInt32? _AnimationChangeThresholdsLocation;
        public IAnimationChangeThresholdsGetter? AnimationChangeThresholds => _AnimationChangeThresholdsLocation.HasValue ? AnimationChangeThresholdsBinaryOverlay.AnimationChangeThresholdsFactory(_recordData.Slice(_AnimationChangeThresholdsLocation!.Value.Min), _package) : default;
        #endregion
        #region FloatHeight
        private int? _FloatHeightLocation;
        public Single? FloatHeight => _FloatHeightLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_recordData, _FloatHeightLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        #region FlightAngleGain
        private int? _FlightAngleGainLocation;
        public Single? FlightAngleGain => _FlightAngleGainLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_recordData, _FlightAngleGainLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        partial void CustomFactoryEnd(
            OverlayStream stream,
            int finalPos,
            int offset);

        partial void CustomCtor();
        protected MovementTypeBinaryOverlay(
            MemoryPair memoryPair,
            BinaryOverlayFactoryPackage package)
            : base(
                memoryPair: memoryPair,
                package: package)
        {
            this.CustomCtor();
        }

        public static IMovementTypeGetter MovementTypeFactory(
            OverlayStream stream,
            BinaryOverlayFactoryPackage package,
            TypedParseParams translationParams = default)
        {
            stream = Decompression.DecompressStream(stream);
            stream = ExtractRecordMemory(
                stream: stream,
                meta: package.MetaData.Constants,
                memoryPair: out var memoryPair,
                offset: out var offset,
                finalPos: out var finalPos);
            var ret = new MovementTypeBinaryOverlay(
                memoryPair: memoryPair,
                package: package);
            ret._package.FormVersion = ret;
            ret.CustomFactoryEnd(
                stream: stream,
                finalPos: finalPos,
                offset: offset);
            ret.FillSubrecordTypes(
                majorReference: ret,
                stream: stream,
                finalPos: finalPos,
                offset: offset,
                translationParams: translationParams,
                fill: ret.FillRecordType);
            return ret;
        }

        public static IMovementTypeGetter MovementTypeFactory(
            ReadOnlyMemorySlice<byte> slice,
            BinaryOverlayFactoryPackage package,
            TypedParseParams translationParams = default)
        {
            return MovementTypeFactory(
                stream: new OverlayStream(slice, package),
                package: package,
                translationParams: translationParams);
        }

        public override ParseResult FillRecordType(
            OverlayStream stream,
            int finalPos,
            int offset,
            RecordType type,
            PreviousParse lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            TypedParseParams translationParams = default)
        {
            type = translationParams.ConvertToStandard(type);
            switch (type.TypeInt)
            {
                case RecordTypeInts.MNAM:
                {
                    _NameLocation = (stream.Position - offset);
                    return (int)MovementType_FieldIndex.Name;
                }
                case RecordTypeInts.SPED:
                {
                    _SPEDLocation = new((stream.Position - offset) + _package.MetaData.Constants.SubConstants.TypeAndLengthLength, finalPos - offset - 1);
                    var subLen = _package.MetaData.Constants.SubrecordHeader(_recordData.Slice((stream.Position - offset))).ContentLength;
                    if (subLen <= 0x28)
                    {
                        this.SPEDDataTypeState |= MovementType.SPEDDataType.Break0;
                    }
                    if (subLen <= 0x2C)
                    {
                        this.SPEDDataTypeState |= MovementType.SPEDDataType.Break1;
                    }
                    if (subLen <= 0x44)
                    {
                        this.SPEDDataTypeState |= MovementType.SPEDDataType.Break2;
                    }
                    return (int)MovementType_FieldIndex.YawSprint;
                }
                case RecordTypeInts.INAM:
                {
                    _AnimationChangeThresholdsLocation = new RangeInt32((stream.Position - offset), finalPos - offset);
                    return (int)MovementType_FieldIndex.AnimationChangeThresholds;
                }
                case RecordTypeInts.JNAM:
                {
                    _FloatHeightLocation = (stream.Position - offset);
                    return (int)MovementType_FieldIndex.FloatHeight;
                }
                case RecordTypeInts.LNAM:
                {
                    _FlightAngleGainLocation = (stream.Position - offset);
                    return (int)MovementType_FieldIndex.FlightAngleGain;
                }
                default:
                    return base.FillRecordType(
                        stream: stream,
                        finalPos: finalPos,
                        offset: offset,
                        type: type,
                        lastParsed: lastParsed,
                        recordParseCount: recordParseCount,
                        translationParams: translationParams.WithNoConverter());
            }
        }
        #region To String

        public override void Print(
            StructuredStringBuilder sb,
            string? name = null)
        {
            MovementTypeMixIn.Print(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        public override string ToString()
        {
            return MajorRecordPrinter<MovementType>.ToString(this);
        }

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is IFormLinkGetter formLink)
            {
                return formLink.Equals(this);
            }
            if (obj is not IMovementTypeGetter rhs) return false;
            return ((MovementTypeCommon)((IMovementTypeGetter)this).CommonInstance()!).Equals(this, rhs, equalsMask: null);
        }

        public bool Equals(IMovementTypeGetter? obj)
        {
            return ((MovementTypeCommon)((IMovementTypeGetter)this).CommonInstance()!).Equals(this, obj, equalsMask: null);
        }

        public override int GetHashCode() => ((MovementTypeCommon)((IMovementTypeGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

    }

}
#endregion

#endregion

