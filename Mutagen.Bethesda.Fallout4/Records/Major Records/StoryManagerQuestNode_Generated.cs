/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Autogenerated by Loqui.  Do not manually change.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*/
#region Usings
using Loqui;
using Loqui.Interfaces;
using Loqui.Internal;
using Mutagen.Bethesda.Binary;
using Mutagen.Bethesda.Fallout4;
using Mutagen.Bethesda.Fallout4.Internals;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Binary.Headers;
using Mutagen.Bethesda.Plugins.Binary.Overlay;
using Mutagen.Bethesda.Plugins.Binary.Streams;
using Mutagen.Bethesda.Plugins.Binary.Translations;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Exceptions;
using Mutagen.Bethesda.Plugins.Internals;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Plugins.Records.Internals;
using Mutagen.Bethesda.Plugins.Records.Mapping;
using Mutagen.Bethesda.Plugins.RecordTypeMapping;
using Mutagen.Bethesda.Plugins.Utility;
using Mutagen.Bethesda.Translations.Binary;
using Noggog;
using Noggog.StructuredStrings;
using Noggog.StructuredStrings.CSharp;
using RecordTypeInts = Mutagen.Bethesda.Fallout4.Internals.RecordTypeInts;
using RecordTypes = Mutagen.Bethesda.Fallout4.Internals.RecordTypes;
using System.Buffers.Binary;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Reactive.Disposables;
using System.Reactive.Linq;
#endregion

#nullable enable
namespace Mutagen.Bethesda.Fallout4
{
    #region Class
    public partial class StoryManagerQuestNode :
        AStoryManagerNode,
        IEquatable<IStoryManagerQuestNodeGetter>,
        ILoquiObjectSetter<StoryManagerQuestNode>,
        IStoryManagerQuestNodeInternal
    {
        #region Ctor
        protected StoryManagerQuestNode()
        {
            CustomCtor();
        }
        partial void CustomCtor();
        #endregion

        #region Flags
        public AStoryManagerNode.Flag Flags { get; set; } = default;
        #endregion
        #region QuestFlags
        public StoryManagerQuestNode.QuestFlag QuestFlags { get; set; } = default;
        #endregion
        #region MaxConcurrentQuests
        public UInt32? MaxConcurrentQuests { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        UInt32? IStoryManagerQuestNodeGetter.MaxConcurrentQuests => this.MaxConcurrentQuests;
        #endregion
        #region MaxNumQuestsToRun
        public UInt32? MaxNumQuestsToRun { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        UInt32? IStoryManagerQuestNodeGetter.MaxNumQuestsToRun => this.MaxNumQuestsToRun;
        #endregion
        #region HoursUntilReset
        public Single? HoursUntilReset { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? IStoryManagerQuestNodeGetter.HoursUntilReset => this.HoursUntilReset;
        #endregion
        #region Quests
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private ExtendedList<StoryManagerQuest> _Quests = new ExtendedList<StoryManagerQuest>();
        public ExtendedList<StoryManagerQuest> Quests
        {
            get => this._Quests;
            init => this._Quests = value;
        }
        #region Interface Members
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IReadOnlyList<IStoryManagerQuestGetter> IStoryManagerQuestNodeGetter.Quests => _Quests;
        #endregion

        #endregion
        #region DNAMDataTypeState
        public StoryManagerQuestNode.DNAMDataType DNAMDataTypeState { get; set; } = default;
        #endregion

        #region To String

        public override void Print(
            StructuredStringBuilder sb,
            string? name = null)
        {
            StoryManagerQuestNodeMixIn.Print(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        #region Mask
        public new class Mask<TItem> :
            AStoryManagerNode.Mask<TItem>,
            IEquatable<Mask<TItem>>,
            IMask<TItem>
        {
            #region Ctors
            public Mask(TItem initialValue)
            : base(initialValue)
            {
                this.Flags = initialValue;
                this.QuestFlags = initialValue;
                this.MaxConcurrentQuests = initialValue;
                this.MaxNumQuestsToRun = initialValue;
                this.HoursUntilReset = initialValue;
                this.Quests = new MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, StoryManagerQuest.Mask<TItem>?>>?>(initialValue, Enumerable.Empty<MaskItemIndexed<TItem, StoryManagerQuest.Mask<TItem>?>>());
                this.DNAMDataTypeState = initialValue;
            }

            public Mask(
                TItem MajorRecordFlagsRaw,
                TItem FormKey,
                TItem VersionControl,
                TItem EditorID,
                TItem FormVersion,
                TItem Version2,
                TItem Parent,
                TItem PreviousSibling,
                TItem Conditions,
                TItem Flags,
                TItem QuestFlags,
                TItem MaxConcurrentQuests,
                TItem MaxNumQuestsToRun,
                TItem HoursUntilReset,
                TItem Quests,
                TItem DNAMDataTypeState)
            : base(
                MajorRecordFlagsRaw: MajorRecordFlagsRaw,
                FormKey: FormKey,
                VersionControl: VersionControl,
                EditorID: EditorID,
                FormVersion: FormVersion,
                Version2: Version2,
                Parent: Parent,
                PreviousSibling: PreviousSibling,
                Conditions: Conditions)
            {
                this.Flags = Flags;
                this.QuestFlags = QuestFlags;
                this.MaxConcurrentQuests = MaxConcurrentQuests;
                this.MaxNumQuestsToRun = MaxNumQuestsToRun;
                this.HoursUntilReset = HoursUntilReset;
                this.Quests = new MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, StoryManagerQuest.Mask<TItem>?>>?>(Quests, Enumerable.Empty<MaskItemIndexed<TItem, StoryManagerQuest.Mask<TItem>?>>());
                this.DNAMDataTypeState = DNAMDataTypeState;
            }

            #pragma warning disable CS8618
            protected Mask()
            {
            }
            #pragma warning restore CS8618

            #endregion

            #region Members
            public TItem Flags;
            public TItem QuestFlags;
            public TItem MaxConcurrentQuests;
            public TItem MaxNumQuestsToRun;
            public TItem HoursUntilReset;
            public MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, StoryManagerQuest.Mask<TItem>?>>?>? Quests;
            public TItem DNAMDataTypeState;
            #endregion

            #region Equals
            public override bool Equals(object? obj)
            {
                if (!(obj is Mask<TItem> rhs)) return false;
                return Equals(rhs);
            }

            public bool Equals(Mask<TItem>? rhs)
            {
                if (rhs == null) return false;
                if (!base.Equals(rhs)) return false;
                if (!object.Equals(this.Flags, rhs.Flags)) return false;
                if (!object.Equals(this.QuestFlags, rhs.QuestFlags)) return false;
                if (!object.Equals(this.MaxConcurrentQuests, rhs.MaxConcurrentQuests)) return false;
                if (!object.Equals(this.MaxNumQuestsToRun, rhs.MaxNumQuestsToRun)) return false;
                if (!object.Equals(this.HoursUntilReset, rhs.HoursUntilReset)) return false;
                if (!object.Equals(this.Quests, rhs.Quests)) return false;
                if (!object.Equals(this.DNAMDataTypeState, rhs.DNAMDataTypeState)) return false;
                return true;
            }
            public override int GetHashCode()
            {
                var hash = new HashCode();
                hash.Add(this.Flags);
                hash.Add(this.QuestFlags);
                hash.Add(this.MaxConcurrentQuests);
                hash.Add(this.MaxNumQuestsToRun);
                hash.Add(this.HoursUntilReset);
                hash.Add(this.Quests);
                hash.Add(this.DNAMDataTypeState);
                hash.Add(base.GetHashCode());
                return hash.ToHashCode();
            }

            #endregion

            #region All
            public override bool All(Func<TItem, bool> eval)
            {
                if (!base.All(eval)) return false;
                if (!eval(this.Flags)) return false;
                if (!eval(this.QuestFlags)) return false;
                if (!eval(this.MaxConcurrentQuests)) return false;
                if (!eval(this.MaxNumQuestsToRun)) return false;
                if (!eval(this.HoursUntilReset)) return false;
                if (this.Quests != null)
                {
                    if (!eval(this.Quests.Overall)) return false;
                    if (this.Quests.Specific != null)
                    {
                        foreach (var item in this.Quests.Specific)
                        {
                            if (!eval(item.Overall)) return false;
                            if (item.Specific != null && !item.Specific.All(eval)) return false;
                        }
                    }
                }
                if (!eval(this.DNAMDataTypeState)) return false;
                return true;
            }
            #endregion

            #region Any
            public override bool Any(Func<TItem, bool> eval)
            {
                if (base.Any(eval)) return true;
                if (eval(this.Flags)) return true;
                if (eval(this.QuestFlags)) return true;
                if (eval(this.MaxConcurrentQuests)) return true;
                if (eval(this.MaxNumQuestsToRun)) return true;
                if (eval(this.HoursUntilReset)) return true;
                if (this.Quests != null)
                {
                    if (eval(this.Quests.Overall)) return true;
                    if (this.Quests.Specific != null)
                    {
                        foreach (var item in this.Quests.Specific)
                        {
                            if (!eval(item.Overall)) return false;
                            if (item.Specific != null && !item.Specific.All(eval)) return false;
                        }
                    }
                }
                if (eval(this.DNAMDataTypeState)) return true;
                return false;
            }
            #endregion

            #region Translate
            public new Mask<R> Translate<R>(Func<TItem, R> eval)
            {
                var ret = new StoryManagerQuestNode.Mask<R>();
                this.Translate_InternalFill(ret, eval);
                return ret;
            }

            protected void Translate_InternalFill<R>(Mask<R> obj, Func<TItem, R> eval)
            {
                base.Translate_InternalFill(obj, eval);
                obj.Flags = eval(this.Flags);
                obj.QuestFlags = eval(this.QuestFlags);
                obj.MaxConcurrentQuests = eval(this.MaxConcurrentQuests);
                obj.MaxNumQuestsToRun = eval(this.MaxNumQuestsToRun);
                obj.HoursUntilReset = eval(this.HoursUntilReset);
                if (Quests != null)
                {
                    obj.Quests = new MaskItem<R, IEnumerable<MaskItemIndexed<R, StoryManagerQuest.Mask<R>?>>?>(eval(this.Quests.Overall), Enumerable.Empty<MaskItemIndexed<R, StoryManagerQuest.Mask<R>?>>());
                    if (Quests.Specific != null)
                    {
                        var l = new List<MaskItemIndexed<R, StoryManagerQuest.Mask<R>?>>();
                        obj.Quests.Specific = l;
                        foreach (var item in Quests.Specific)
                        {
                            MaskItemIndexed<R, StoryManagerQuest.Mask<R>?>? mask = item == null ? null : new MaskItemIndexed<R, StoryManagerQuest.Mask<R>?>(item.Index, eval(item.Overall), item.Specific?.Translate(eval));
                            if (mask == null) continue;
                            l.Add(mask);
                        }
                    }
                }
                obj.DNAMDataTypeState = eval(this.DNAMDataTypeState);
            }
            #endregion

            #region To String
            public override string ToString() => this.Print();

            public string Print(StoryManagerQuestNode.Mask<bool>? printMask = null)
            {
                var sb = new StructuredStringBuilder();
                Print(sb, printMask);
                return sb.ToString();
            }

            public void Print(StructuredStringBuilder sb, StoryManagerQuestNode.Mask<bool>? printMask = null)
            {
                sb.AppendLine($"{nameof(StoryManagerQuestNode.Mask<TItem>)} =>");
                using (sb.Brace())
                {
                    if (printMask?.Flags ?? true)
                    {
                        sb.AppendItem(Flags, "Flags");
                    }
                    if (printMask?.QuestFlags ?? true)
                    {
                        sb.AppendItem(QuestFlags, "QuestFlags");
                    }
                    if (printMask?.MaxConcurrentQuests ?? true)
                    {
                        sb.AppendItem(MaxConcurrentQuests, "MaxConcurrentQuests");
                    }
                    if (printMask?.MaxNumQuestsToRun ?? true)
                    {
                        sb.AppendItem(MaxNumQuestsToRun, "MaxNumQuestsToRun");
                    }
                    if (printMask?.HoursUntilReset ?? true)
                    {
                        sb.AppendItem(HoursUntilReset, "HoursUntilReset");
                    }
                    if ((printMask?.Quests?.Overall ?? true)
                        && Quests is {} QuestsItem)
                    {
                        sb.AppendLine("Quests =>");
                        using (sb.Brace())
                        {
                            sb.AppendItem(QuestsItem.Overall);
                            if (QuestsItem.Specific != null)
                            {
                                foreach (var subItem in QuestsItem.Specific)
                                {
                                    using (sb.Brace())
                                    {
                                        subItem?.Print(sb);
                                    }
                                }
                            }
                        }
                    }
                    if (printMask?.DNAMDataTypeState ?? true)
                    {
                        sb.AppendItem(DNAMDataTypeState, "DNAMDataTypeState");
                    }
                }
            }
            #endregion

        }

        public new class ErrorMask :
            AStoryManagerNode.ErrorMask,
            IErrorMask<ErrorMask>
        {
            #region Members
            public Exception? Flags;
            public Exception? QuestFlags;
            public Exception? MaxConcurrentQuests;
            public Exception? MaxNumQuestsToRun;
            public Exception? HoursUntilReset;
            public MaskItem<Exception?, IEnumerable<MaskItem<Exception?, StoryManagerQuest.ErrorMask?>>?>? Quests;
            public Exception? DNAMDataTypeState;
            #endregion

            #region IErrorMask
            public override object? GetNthMask(int index)
            {
                StoryManagerQuestNode_FieldIndex enu = (StoryManagerQuestNode_FieldIndex)index;
                switch (enu)
                {
                    case StoryManagerQuestNode_FieldIndex.Flags:
                        return Flags;
                    case StoryManagerQuestNode_FieldIndex.QuestFlags:
                        return QuestFlags;
                    case StoryManagerQuestNode_FieldIndex.MaxConcurrentQuests:
                        return MaxConcurrentQuests;
                    case StoryManagerQuestNode_FieldIndex.MaxNumQuestsToRun:
                        return MaxNumQuestsToRun;
                    case StoryManagerQuestNode_FieldIndex.HoursUntilReset:
                        return HoursUntilReset;
                    case StoryManagerQuestNode_FieldIndex.Quests:
                        return Quests;
                    case StoryManagerQuestNode_FieldIndex.DNAMDataTypeState:
                        return DNAMDataTypeState;
                    default:
                        return base.GetNthMask(index);
                }
            }

            public override void SetNthException(int index, Exception ex)
            {
                StoryManagerQuestNode_FieldIndex enu = (StoryManagerQuestNode_FieldIndex)index;
                switch (enu)
                {
                    case StoryManagerQuestNode_FieldIndex.Flags:
                        this.Flags = ex;
                        break;
                    case StoryManagerQuestNode_FieldIndex.QuestFlags:
                        this.QuestFlags = ex;
                        break;
                    case StoryManagerQuestNode_FieldIndex.MaxConcurrentQuests:
                        this.MaxConcurrentQuests = ex;
                        break;
                    case StoryManagerQuestNode_FieldIndex.MaxNumQuestsToRun:
                        this.MaxNumQuestsToRun = ex;
                        break;
                    case StoryManagerQuestNode_FieldIndex.HoursUntilReset:
                        this.HoursUntilReset = ex;
                        break;
                    case StoryManagerQuestNode_FieldIndex.Quests:
                        this.Quests = new MaskItem<Exception?, IEnumerable<MaskItem<Exception?, StoryManagerQuest.ErrorMask?>>?>(ex, null);
                        break;
                    case StoryManagerQuestNode_FieldIndex.DNAMDataTypeState:
                        this.DNAMDataTypeState = ex;
                        break;
                    default:
                        base.SetNthException(index, ex);
                        break;
                }
            }

            public override void SetNthMask(int index, object obj)
            {
                StoryManagerQuestNode_FieldIndex enu = (StoryManagerQuestNode_FieldIndex)index;
                switch (enu)
                {
                    case StoryManagerQuestNode_FieldIndex.Flags:
                        this.Flags = (Exception?)obj;
                        break;
                    case StoryManagerQuestNode_FieldIndex.QuestFlags:
                        this.QuestFlags = (Exception?)obj;
                        break;
                    case StoryManagerQuestNode_FieldIndex.MaxConcurrentQuests:
                        this.MaxConcurrentQuests = (Exception?)obj;
                        break;
                    case StoryManagerQuestNode_FieldIndex.MaxNumQuestsToRun:
                        this.MaxNumQuestsToRun = (Exception?)obj;
                        break;
                    case StoryManagerQuestNode_FieldIndex.HoursUntilReset:
                        this.HoursUntilReset = (Exception?)obj;
                        break;
                    case StoryManagerQuestNode_FieldIndex.Quests:
                        this.Quests = (MaskItem<Exception?, IEnumerable<MaskItem<Exception?, StoryManagerQuest.ErrorMask?>>?>)obj;
                        break;
                    case StoryManagerQuestNode_FieldIndex.DNAMDataTypeState:
                        this.DNAMDataTypeState = (Exception?)obj;
                        break;
                    default:
                        base.SetNthMask(index, obj);
                        break;
                }
            }

            public override bool IsInError()
            {
                if (Overall != null) return true;
                if (Flags != null) return true;
                if (QuestFlags != null) return true;
                if (MaxConcurrentQuests != null) return true;
                if (MaxNumQuestsToRun != null) return true;
                if (HoursUntilReset != null) return true;
                if (Quests != null) return true;
                if (DNAMDataTypeState != null) return true;
                return false;
            }
            #endregion

            #region To String
            public override string ToString() => this.Print();

            public override void Print(StructuredStringBuilder sb, string? name = null)
            {
                sb.AppendLine($"{(name ?? "ErrorMask")} =>");
                using (sb.Brace())
                {
                    if (this.Overall != null)
                    {
                        sb.AppendLine("Overall =>");
                        using (sb.Brace())
                        {
                            sb.AppendLine($"{this.Overall}");
                        }
                    }
                    PrintFillInternal(sb);
                }
            }
            protected override void PrintFillInternal(StructuredStringBuilder sb)
            {
                base.PrintFillInternal(sb);
                {
                    sb.AppendItem(Flags, "Flags");
                }
                {
                    sb.AppendItem(QuestFlags, "QuestFlags");
                }
                {
                    sb.AppendItem(MaxConcurrentQuests, "MaxConcurrentQuests");
                }
                {
                    sb.AppendItem(MaxNumQuestsToRun, "MaxNumQuestsToRun");
                }
                {
                    sb.AppendItem(HoursUntilReset, "HoursUntilReset");
                }
                if (Quests is {} QuestsItem)
                {
                    sb.AppendLine("Quests =>");
                    using (sb.Brace())
                    {
                        sb.AppendItem(QuestsItem.Overall);
                        if (QuestsItem.Specific != null)
                        {
                            foreach (var subItem in QuestsItem.Specific)
                            {
                                using (sb.Brace())
                                {
                                    subItem?.Print(sb);
                                }
                            }
                        }
                    }
                }
                {
                    sb.AppendItem(DNAMDataTypeState, "DNAMDataTypeState");
                }
            }
            #endregion

            #region Combine
            public ErrorMask Combine(ErrorMask? rhs)
            {
                if (rhs == null) return this;
                var ret = new ErrorMask();
                ret.Flags = this.Flags.Combine(rhs.Flags);
                ret.QuestFlags = this.QuestFlags.Combine(rhs.QuestFlags);
                ret.MaxConcurrentQuests = this.MaxConcurrentQuests.Combine(rhs.MaxConcurrentQuests);
                ret.MaxNumQuestsToRun = this.MaxNumQuestsToRun.Combine(rhs.MaxNumQuestsToRun);
                ret.HoursUntilReset = this.HoursUntilReset.Combine(rhs.HoursUntilReset);
                ret.Quests = new MaskItem<Exception?, IEnumerable<MaskItem<Exception?, StoryManagerQuest.ErrorMask?>>?>(ExceptionExt.Combine(this.Quests?.Overall, rhs.Quests?.Overall), ExceptionExt.Combine(this.Quests?.Specific, rhs.Quests?.Specific));
                ret.DNAMDataTypeState = this.DNAMDataTypeState.Combine(rhs.DNAMDataTypeState);
                return ret;
            }
            public static ErrorMask? Combine(ErrorMask? lhs, ErrorMask? rhs)
            {
                if (lhs != null && rhs != null) return lhs.Combine(rhs);
                return lhs ?? rhs;
            }
            #endregion

            #region Factory
            public static new ErrorMask Factory(ErrorMaskBuilder errorMask)
            {
                return new ErrorMask();
            }
            #endregion

        }
        public new class TranslationMask :
            AStoryManagerNode.TranslationMask,
            ITranslationMask
        {
            #region Members
            public bool Flags;
            public bool QuestFlags;
            public bool MaxConcurrentQuests;
            public bool MaxNumQuestsToRun;
            public bool HoursUntilReset;
            public StoryManagerQuest.TranslationMask? Quests;
            public bool DNAMDataTypeState;
            #endregion

            #region Ctors
            public TranslationMask(
                bool defaultOn,
                bool onOverall = true)
                : base(defaultOn, onOverall)
            {
                this.Flags = defaultOn;
                this.QuestFlags = defaultOn;
                this.MaxConcurrentQuests = defaultOn;
                this.MaxNumQuestsToRun = defaultOn;
                this.HoursUntilReset = defaultOn;
                this.DNAMDataTypeState = defaultOn;
            }

            #endregion

            protected override void GetCrystal(List<(bool On, TranslationCrystal? SubCrystal)> ret)
            {
                base.GetCrystal(ret);
                ret.Add((Flags, null));
                ret.Add((QuestFlags, null));
                ret.Add((MaxConcurrentQuests, null));
                ret.Add((MaxNumQuestsToRun, null));
                ret.Add((HoursUntilReset, null));
                ret.Add((Quests == null ? DefaultOn : !Quests.GetCrystal().CopyNothing, Quests?.GetCrystal()));
                ret.Add((DNAMDataTypeState, null));
            }

            public static implicit operator TranslationMask(bool defaultOn)
            {
                return new TranslationMask(defaultOn: defaultOn, onOverall: defaultOn);
            }

        }
        #endregion

        #region Mutagen
        public static readonly RecordType GrupRecordType = StoryManagerQuestNode_Registration.TriggeringRecordType;
        public override IEnumerable<IFormLinkGetter> EnumerateFormLinks() => StoryManagerQuestNodeCommon.Instance.EnumerateFormLinks(this);
        public override void RemapLinks(IReadOnlyDictionary<FormKey, FormKey> mapping) => StoryManagerQuestNodeSetterCommon.Instance.RemapLinks(this, mapping);
        public StoryManagerQuestNode(FormKey formKey)
        {
            this.FormKey = formKey;
            CustomCtor();
        }

        private StoryManagerQuestNode(
            FormKey formKey,
            GameRelease gameRelease)
        {
            this.FormKey = formKey;
            this.FormVersion = gameRelease.GetDefaultFormVersion()!.Value;
            CustomCtor();
        }

        internal StoryManagerQuestNode(
            FormKey formKey,
            ushort formVersion)
        {
            this.FormKey = formKey;
            this.FormVersion = formVersion;
            CustomCtor();
        }

        public StoryManagerQuestNode(IFallout4Mod mod)
            : this(mod.GetNextFormKey())
        {
        }

        public StoryManagerQuestNode(IFallout4Mod mod, string editorID)
            : this(mod.GetNextFormKey(editorID))
        {
            this.EditorID = editorID;
        }

        public override string ToString()
        {
            return MajorRecordPrinter<StoryManagerQuestNode>.ToString(this);
        }

        protected override Type LinkType => typeof(IStoryManagerQuestNode);

        [Flags]
        public enum DNAMDataType
        {
        }
        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is IFormLinkGetter formLink)
            {
                return formLink.Equals(this);
            }
            if (obj is not IStoryManagerQuestNodeGetter rhs) return false;
            return ((StoryManagerQuestNodeCommon)((IStoryManagerQuestNodeGetter)this).CommonInstance()!).Equals(this, rhs, crystal: null);
        }

        public bool Equals(IStoryManagerQuestNodeGetter? obj)
        {
            return ((StoryManagerQuestNodeCommon)((IStoryManagerQuestNodeGetter)this).CommonInstance()!).Equals(this, obj, crystal: null);
        }

        public override int GetHashCode() => ((StoryManagerQuestNodeCommon)((IStoryManagerQuestNodeGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        #endregion

        #region Binary Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected override object BinaryWriteTranslator => StoryManagerQuestNodeBinaryWriteTranslation.Instance;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((StoryManagerQuestNodeBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }
        #region Binary Create
        public new static StoryManagerQuestNode CreateFromBinary(
            MutagenFrame frame,
            TypedParseParams translationParams = default)
        {
            var ret = new StoryManagerQuestNode();
            ((StoryManagerQuestNodeSetterCommon)((IStoryManagerQuestNodeGetter)ret).CommonSetterInstance()!).CopyInFromBinary(
                item: ret,
                frame: frame,
                translationParams: translationParams);
            return ret;
        }

        #endregion

        public static bool TryCreateFromBinary(
            MutagenFrame frame,
            out StoryManagerQuestNode item,
            TypedParseParams translationParams = default)
        {
            var startPos = frame.Position;
            item = CreateFromBinary(
                frame: frame,
                translationParams: translationParams);
            return startPos != frame.Position;
        }
        #endregion

        void IPrintable.Print(StructuredStringBuilder sb, string? name) => this.Print(sb, name);

        void IClearable.Clear()
        {
            ((StoryManagerQuestNodeSetterCommon)((IStoryManagerQuestNodeGetter)this).CommonSetterInstance()!).Clear(this);
        }

        internal static new StoryManagerQuestNode GetNew()
        {
            return new StoryManagerQuestNode();
        }

    }
    #endregion

    #region Interface
    public partial interface IStoryManagerQuestNode :
        IAStoryManagerNodeInternal,
        IFormLinkContainer,
        ILoquiObjectSetter<IStoryManagerQuestNodeInternal>,
        IStoryManagerQuestNodeGetter
    {
        new AStoryManagerNode.Flag Flags { get; set; }
        new StoryManagerQuestNode.QuestFlag QuestFlags { get; set; }
        new UInt32? MaxConcurrentQuests { get; set; }
        new UInt32? MaxNumQuestsToRun { get; set; }
        new Single? HoursUntilReset { get; set; }
        new ExtendedList<StoryManagerQuest> Quests { get; }
        new StoryManagerQuestNode.DNAMDataType DNAMDataTypeState { get; set; }
    }

    public partial interface IStoryManagerQuestNodeInternal :
        IAStoryManagerNodeInternal,
        IStoryManagerQuestNode,
        IStoryManagerQuestNodeGetter
    {
    }

    [AssociatedRecordTypesAttribute(Mutagen.Bethesda.Fallout4.Internals.RecordTypeInts.SMQN)]
    public partial interface IStoryManagerQuestNodeGetter :
        IAStoryManagerNodeGetter,
        IBinaryItem,
        IFormLinkContainerGetter,
        ILoquiObject<IStoryManagerQuestNodeGetter>,
        IMapsToGetter<IStoryManagerQuestNodeGetter>
    {
        static new ILoquiRegistration StaticRegistration => StoryManagerQuestNode_Registration.Instance;
        AStoryManagerNode.Flag Flags { get; }
        StoryManagerQuestNode.QuestFlag QuestFlags { get; }
        UInt32? MaxConcurrentQuests { get; }
        UInt32? MaxNumQuestsToRun { get; }
        Single? HoursUntilReset { get; }
        IReadOnlyList<IStoryManagerQuestGetter> Quests { get; }
        StoryManagerQuestNode.DNAMDataType DNAMDataTypeState { get; }

    }

    #endregion

    #region Common MixIn
    public static partial class StoryManagerQuestNodeMixIn
    {
        public static void Clear(this IStoryManagerQuestNodeInternal item)
        {
            ((StoryManagerQuestNodeSetterCommon)((IStoryManagerQuestNodeGetter)item).CommonSetterInstance()!).Clear(item: item);
        }

        public static StoryManagerQuestNode.Mask<bool> GetEqualsMask(
            this IStoryManagerQuestNodeGetter item,
            IStoryManagerQuestNodeGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            return ((StoryManagerQuestNodeCommon)((IStoryManagerQuestNodeGetter)item).CommonInstance()!).GetEqualsMask(
                item: item,
                rhs: rhs,
                include: include);
        }

        public static string Print(
            this IStoryManagerQuestNodeGetter item,
            string? name = null,
            StoryManagerQuestNode.Mask<bool>? printMask = null)
        {
            return ((StoryManagerQuestNodeCommon)((IStoryManagerQuestNodeGetter)item).CommonInstance()!).Print(
                item: item,
                name: name,
                printMask: printMask);
        }

        public static void Print(
            this IStoryManagerQuestNodeGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            StoryManagerQuestNode.Mask<bool>? printMask = null)
        {
            ((StoryManagerQuestNodeCommon)((IStoryManagerQuestNodeGetter)item).CommonInstance()!).Print(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
        }

        public static bool Equals(
            this IStoryManagerQuestNodeGetter item,
            IStoryManagerQuestNodeGetter rhs,
            StoryManagerQuestNode.TranslationMask? equalsMask = null)
        {
            return ((StoryManagerQuestNodeCommon)((IStoryManagerQuestNodeGetter)item).CommonInstance()!).Equals(
                lhs: item,
                rhs: rhs,
                crystal: equalsMask?.GetCrystal());
        }

        public static void DeepCopyIn(
            this IStoryManagerQuestNodeInternal lhs,
            IStoryManagerQuestNodeGetter rhs,
            out StoryManagerQuestNode.ErrorMask errorMask,
            StoryManagerQuestNode.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            ((StoryManagerQuestNodeSetterTranslationCommon)((IStoryManagerQuestNodeGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
            errorMask = StoryManagerQuestNode.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void DeepCopyIn(
            this IStoryManagerQuestNodeInternal lhs,
            IStoryManagerQuestNodeGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            ((StoryManagerQuestNodeSetterTranslationCommon)((IStoryManagerQuestNodeGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: false);
        }

        public static StoryManagerQuestNode DeepCopy(
            this IStoryManagerQuestNodeGetter item,
            StoryManagerQuestNode.TranslationMask? copyMask = null)
        {
            return ((StoryManagerQuestNodeSetterTranslationCommon)((IStoryManagerQuestNodeGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask);
        }

        public static StoryManagerQuestNode DeepCopy(
            this IStoryManagerQuestNodeGetter item,
            out StoryManagerQuestNode.ErrorMask errorMask,
            StoryManagerQuestNode.TranslationMask? copyMask = null)
        {
            return ((StoryManagerQuestNodeSetterTranslationCommon)((IStoryManagerQuestNodeGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: out errorMask);
        }

        public static StoryManagerQuestNode DeepCopy(
            this IStoryManagerQuestNodeGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            return ((StoryManagerQuestNodeSetterTranslationCommon)((IStoryManagerQuestNodeGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: errorMask);
        }

        #region Mutagen
        public static StoryManagerQuestNode Duplicate(
            this IStoryManagerQuestNodeGetter item,
            FormKey formKey,
            StoryManagerQuestNode.TranslationMask? copyMask = null)
        {
            return ((StoryManagerQuestNodeCommon)((IStoryManagerQuestNodeGetter)item).CommonInstance()!).Duplicate(
                item: item,
                formKey: formKey,
                copyMask: copyMask?.GetCrystal());
        }

        #endregion

        #region Binary Translation
        public static void CopyInFromBinary(
            this IStoryManagerQuestNodeInternal item,
            MutagenFrame frame,
            TypedParseParams translationParams = default)
        {
            ((StoryManagerQuestNodeSetterCommon)((IStoryManagerQuestNodeGetter)item).CommonSetterInstance()!).CopyInFromBinary(
                item: item,
                frame: frame,
                translationParams: translationParams);
        }

        #endregion

    }
    #endregion

}

namespace Mutagen.Bethesda.Fallout4
{
    #region Field Index
    internal enum StoryManagerQuestNode_FieldIndex
    {
        MajorRecordFlagsRaw = 0,
        FormKey = 1,
        VersionControl = 2,
        EditorID = 3,
        FormVersion = 4,
        Version2 = 5,
        Parent = 6,
        PreviousSibling = 7,
        Conditions = 8,
        Flags = 9,
        QuestFlags = 10,
        MaxConcurrentQuests = 11,
        MaxNumQuestsToRun = 12,
        HoursUntilReset = 13,
        Quests = 14,
        DNAMDataTypeState = 15,
    }
    #endregion

    #region Registration
    internal partial class StoryManagerQuestNode_Registration : ILoquiRegistration
    {
        public static readonly StoryManagerQuestNode_Registration Instance = new StoryManagerQuestNode_Registration();

        public static ProtocolKey ProtocolKey => ProtocolDefinition_Fallout4.ProtocolKey;

        public static readonly ObjectKey ObjectKey = new ObjectKey(
            protocolKey: ProtocolDefinition_Fallout4.ProtocolKey,
            msgID: 627,
            version: 0);

        public const string GUID = "486db3f7-2958-47a7-9344-ac18d213f276";

        public const ushort AdditionalFieldCount = 7;

        public const ushort FieldCount = 16;

        public static readonly Type MaskType = typeof(StoryManagerQuestNode.Mask<>);

        public static readonly Type ErrorMaskType = typeof(StoryManagerQuestNode.ErrorMask);

        public static readonly Type ClassType = typeof(StoryManagerQuestNode);

        public static readonly Type GetterType = typeof(IStoryManagerQuestNodeGetter);

        public static readonly Type? InternalGetterType = null;

        public static readonly Type SetterType = typeof(IStoryManagerQuestNode);

        public static readonly Type? InternalSetterType = typeof(IStoryManagerQuestNodeInternal);

        public const string FullName = "Mutagen.Bethesda.Fallout4.StoryManagerQuestNode";

        public const string Name = "StoryManagerQuestNode";

        public const string Namespace = "Mutagen.Bethesda.Fallout4";

        public const byte GenericCount = 0;

        public static readonly Type? GenericRegistrationType = null;

        public static readonly RecordType TriggeringRecordType = RecordTypes.SMQN;
        public static RecordTriggerSpecs TriggerSpecs => _recordSpecs.Value;
        private static readonly Lazy<RecordTriggerSpecs> _recordSpecs = new Lazy<RecordTriggerSpecs>(() =>
        {
            var triggers = RecordCollection.Factory(RecordTypes.SMQN);
            var all = RecordCollection.Factory(
                RecordTypes.SMQN,
                RecordTypes.DNAM,
                RecordTypes.XNAM,
                RecordTypes.MNAM,
                RecordTypes.HNAM,
                RecordTypes.NNAM,
                RecordTypes.FNAM,
                RecordTypes.RNAM,
                RecordTypes.QNAM);
            return new RecordTriggerSpecs(allRecordTypes: all, triggeringRecordTypes: triggers);
        });
        public static readonly Type BinaryWriteTranslation = typeof(StoryManagerQuestNodeBinaryWriteTranslation);
        #region Interface
        ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;
        ObjectKey ILoquiRegistration.ObjectKey => ObjectKey;
        string ILoquiRegistration.GUID => GUID;
        ushort ILoquiRegistration.FieldCount => FieldCount;
        ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;
        Type ILoquiRegistration.MaskType => MaskType;
        Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;
        Type ILoquiRegistration.ClassType => ClassType;
        Type ILoquiRegistration.SetterType => SetterType;
        Type? ILoquiRegistration.InternalSetterType => InternalSetterType;
        Type ILoquiRegistration.GetterType => GetterType;
        Type? ILoquiRegistration.InternalGetterType => InternalGetterType;
        string ILoquiRegistration.FullName => FullName;
        string ILoquiRegistration.Name => Name;
        string ILoquiRegistration.Namespace => Namespace;
        byte ILoquiRegistration.GenericCount => GenericCount;
        Type? ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;
        ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsLoqui(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsSingleton(ushort index) => throw new NotImplementedException();
        string ILoquiRegistration.GetNthName(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsNthDerivative(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsProtected(ushort index) => throw new NotImplementedException();
        Type ILoquiRegistration.GetNthType(ushort index) => throw new NotImplementedException();
        #endregion

    }
    #endregion

    #region Common
    internal partial class StoryManagerQuestNodeSetterCommon : AStoryManagerNodeSetterCommon
    {
        public new static readonly StoryManagerQuestNodeSetterCommon Instance = new StoryManagerQuestNodeSetterCommon();

        partial void ClearPartial();
        
        public void Clear(IStoryManagerQuestNodeInternal item)
        {
            ClearPartial();
            item.Flags = default;
            item.QuestFlags = default;
            item.MaxConcurrentQuests = default;
            item.MaxNumQuestsToRun = default;
            item.HoursUntilReset = default;
            item.Quests.Clear();
            item.DNAMDataTypeState = default;
            base.Clear(item);
        }
        
        public override void Clear(IAStoryManagerNodeInternal item)
        {
            Clear(item: (IStoryManagerQuestNodeInternal)item);
        }
        
        public override void Clear(IFallout4MajorRecordInternal item)
        {
            Clear(item: (IStoryManagerQuestNodeInternal)item);
        }
        
        public override void Clear(IMajorRecordInternal item)
        {
            Clear(item: (IStoryManagerQuestNodeInternal)item);
        }
        
        #region Mutagen
        public void RemapLinks(IStoryManagerQuestNode obj, IReadOnlyDictionary<FormKey, FormKey> mapping)
        {
            base.RemapLinks(obj, mapping);
            obj.Quests.RemapLinks(mapping);
        }
        
        #endregion
        
        #region Binary Translation
        public virtual void CopyInFromBinary(
            IStoryManagerQuestNodeInternal item,
            MutagenFrame frame,
            TypedParseParams translationParams)
        {
            PluginUtilityTranslation.MajorRecordParse<IStoryManagerQuestNodeInternal>(
                record: item,
                frame: frame,
                translationParams: translationParams,
                fillStructs: StoryManagerQuestNodeBinaryCreateTranslation.FillBinaryStructs,
                fillTyped: StoryManagerQuestNodeBinaryCreateTranslation.FillBinaryRecordTypes);
        }
        
        public override void CopyInFromBinary(
            IAStoryManagerNodeInternal item,
            MutagenFrame frame,
            TypedParseParams translationParams)
        {
            CopyInFromBinary(
                item: (StoryManagerQuestNode)item,
                frame: frame,
                translationParams: translationParams);
        }
        
        public override void CopyInFromBinary(
            IFallout4MajorRecordInternal item,
            MutagenFrame frame,
            TypedParseParams translationParams)
        {
            CopyInFromBinary(
                item: (StoryManagerQuestNode)item,
                frame: frame,
                translationParams: translationParams);
        }
        
        public override void CopyInFromBinary(
            IMajorRecordInternal item,
            MutagenFrame frame,
            TypedParseParams translationParams)
        {
            CopyInFromBinary(
                item: (StoryManagerQuestNode)item,
                frame: frame,
                translationParams: translationParams);
        }
        
        #endregion
        
    }
    internal partial class StoryManagerQuestNodeCommon : AStoryManagerNodeCommon
    {
        public new static readonly StoryManagerQuestNodeCommon Instance = new StoryManagerQuestNodeCommon();

        public StoryManagerQuestNode.Mask<bool> GetEqualsMask(
            IStoryManagerQuestNodeGetter item,
            IStoryManagerQuestNodeGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            var ret = new StoryManagerQuestNode.Mask<bool>(false);
            ((StoryManagerQuestNodeCommon)((IStoryManagerQuestNodeGetter)item).CommonInstance()!).FillEqualsMask(
                item: item,
                rhs: rhs,
                ret: ret,
                include: include);
            return ret;
        }
        
        public void FillEqualsMask(
            IStoryManagerQuestNodeGetter item,
            IStoryManagerQuestNodeGetter rhs,
            StoryManagerQuestNode.Mask<bool> ret,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            ret.Flags = item.Flags == rhs.Flags;
            ret.QuestFlags = item.QuestFlags == rhs.QuestFlags;
            ret.MaxConcurrentQuests = item.MaxConcurrentQuests == rhs.MaxConcurrentQuests;
            ret.MaxNumQuestsToRun = item.MaxNumQuestsToRun == rhs.MaxNumQuestsToRun;
            ret.HoursUntilReset = item.HoursUntilReset.EqualsWithin(rhs.HoursUntilReset);
            ret.Quests = item.Quests.CollectionEqualsHelper(
                rhs.Quests,
                (loqLhs, loqRhs) => loqLhs.GetEqualsMask(loqRhs, include),
                include);
            ret.DNAMDataTypeState = item.DNAMDataTypeState == rhs.DNAMDataTypeState;
            base.FillEqualsMask(item, rhs, ret, include);
        }
        
        public string Print(
            IStoryManagerQuestNodeGetter item,
            string? name = null,
            StoryManagerQuestNode.Mask<bool>? printMask = null)
        {
            var sb = new StructuredStringBuilder();
            Print(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
            return sb.ToString();
        }
        
        public void Print(
            IStoryManagerQuestNodeGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            StoryManagerQuestNode.Mask<bool>? printMask = null)
        {
            if (name == null)
            {
                sb.AppendLine($"StoryManagerQuestNode =>");
            }
            else
            {
                sb.AppendLine($"{name} (StoryManagerQuestNode) =>");
            }
            using (sb.Brace())
            {
                ToStringFields(
                    item: item,
                    sb: sb,
                    printMask: printMask);
            }
        }
        
        protected static void ToStringFields(
            IStoryManagerQuestNodeGetter item,
            StructuredStringBuilder sb,
            StoryManagerQuestNode.Mask<bool>? printMask = null)
        {
            AStoryManagerNodeCommon.ToStringFields(
                item: item,
                sb: sb,
                printMask: printMask);
            if (printMask?.Flags ?? true)
            {
                sb.AppendItem(item.Flags, "Flags");
            }
            if (printMask?.QuestFlags ?? true)
            {
                sb.AppendItem(item.QuestFlags, "QuestFlags");
            }
            if ((printMask?.MaxConcurrentQuests ?? true)
                && item.MaxConcurrentQuests is {} MaxConcurrentQuestsItem)
            {
                sb.AppendItem(MaxConcurrentQuestsItem, "MaxConcurrentQuests");
            }
            if ((printMask?.MaxNumQuestsToRun ?? true)
                && item.MaxNumQuestsToRun is {} MaxNumQuestsToRunItem)
            {
                sb.AppendItem(MaxNumQuestsToRunItem, "MaxNumQuestsToRun");
            }
            if ((printMask?.HoursUntilReset ?? true)
                && item.HoursUntilReset is {} HoursUntilResetItem)
            {
                sb.AppendItem(HoursUntilResetItem, "HoursUntilReset");
            }
            if (printMask?.Quests?.Overall ?? true)
            {
                sb.AppendLine("Quests =>");
                using (sb.Brace())
                {
                    foreach (var subItem in item.Quests)
                    {
                        using (sb.Brace())
                        {
                            subItem?.Print(sb, "Item");
                        }
                    }
                }
            }
            if (printMask?.DNAMDataTypeState ?? true)
            {
                sb.AppendItem(item.DNAMDataTypeState, "DNAMDataTypeState");
            }
        }
        
        public static StoryManagerQuestNode_FieldIndex ConvertFieldIndex(AStoryManagerNode_FieldIndex index)
        {
            switch (index)
            {
                case AStoryManagerNode_FieldIndex.MajorRecordFlagsRaw:
                    return (StoryManagerQuestNode_FieldIndex)((int)index);
                case AStoryManagerNode_FieldIndex.FormKey:
                    return (StoryManagerQuestNode_FieldIndex)((int)index);
                case AStoryManagerNode_FieldIndex.VersionControl:
                    return (StoryManagerQuestNode_FieldIndex)((int)index);
                case AStoryManagerNode_FieldIndex.EditorID:
                    return (StoryManagerQuestNode_FieldIndex)((int)index);
                case AStoryManagerNode_FieldIndex.FormVersion:
                    return (StoryManagerQuestNode_FieldIndex)((int)index);
                case AStoryManagerNode_FieldIndex.Version2:
                    return (StoryManagerQuestNode_FieldIndex)((int)index);
                case AStoryManagerNode_FieldIndex.Parent:
                    return (StoryManagerQuestNode_FieldIndex)((int)index);
                case AStoryManagerNode_FieldIndex.PreviousSibling:
                    return (StoryManagerQuestNode_FieldIndex)((int)index);
                case AStoryManagerNode_FieldIndex.Conditions:
                    return (StoryManagerQuestNode_FieldIndex)((int)index);
                default:
                    throw new ArgumentException($"Index is out of range: {index.ToStringFast_Enum_Only()}");
            }
        }
        
        public static new StoryManagerQuestNode_FieldIndex ConvertFieldIndex(Fallout4MajorRecord_FieldIndex index)
        {
            switch (index)
            {
                case Fallout4MajorRecord_FieldIndex.MajorRecordFlagsRaw:
                    return (StoryManagerQuestNode_FieldIndex)((int)index);
                case Fallout4MajorRecord_FieldIndex.FormKey:
                    return (StoryManagerQuestNode_FieldIndex)((int)index);
                case Fallout4MajorRecord_FieldIndex.VersionControl:
                    return (StoryManagerQuestNode_FieldIndex)((int)index);
                case Fallout4MajorRecord_FieldIndex.EditorID:
                    return (StoryManagerQuestNode_FieldIndex)((int)index);
                case Fallout4MajorRecord_FieldIndex.FormVersion:
                    return (StoryManagerQuestNode_FieldIndex)((int)index);
                case Fallout4MajorRecord_FieldIndex.Version2:
                    return (StoryManagerQuestNode_FieldIndex)((int)index);
                default:
                    throw new ArgumentException($"Index is out of range: {index.ToStringFast_Enum_Only()}");
            }
        }
        
        public static new StoryManagerQuestNode_FieldIndex ConvertFieldIndex(MajorRecord_FieldIndex index)
        {
            switch (index)
            {
                case MajorRecord_FieldIndex.MajorRecordFlagsRaw:
                    return (StoryManagerQuestNode_FieldIndex)((int)index);
                case MajorRecord_FieldIndex.FormKey:
                    return (StoryManagerQuestNode_FieldIndex)((int)index);
                case MajorRecord_FieldIndex.VersionControl:
                    return (StoryManagerQuestNode_FieldIndex)((int)index);
                case MajorRecord_FieldIndex.EditorID:
                    return (StoryManagerQuestNode_FieldIndex)((int)index);
                default:
                    throw new ArgumentException($"Index is out of range: {index.ToStringFast_Enum_Only()}");
            }
        }
        
        #region Equals and Hash
        public virtual bool Equals(
            IStoryManagerQuestNodeGetter? lhs,
            IStoryManagerQuestNodeGetter? rhs,
            TranslationCrystal? crystal)
        {
            if (!EqualsMaskHelper.RefEquality(lhs, rhs, out var isEqual)) return isEqual;
            if (!base.Equals((IAStoryManagerNodeGetter)lhs, (IAStoryManagerNodeGetter)rhs, crystal)) return false;
            if ((crystal?.GetShouldTranslate((int)StoryManagerQuestNode_FieldIndex.Flags) ?? true))
            {
                if (lhs.Flags != rhs.Flags) return false;
            }
            if ((crystal?.GetShouldTranslate((int)StoryManagerQuestNode_FieldIndex.QuestFlags) ?? true))
            {
                if (lhs.QuestFlags != rhs.QuestFlags) return false;
            }
            if ((crystal?.GetShouldTranslate((int)StoryManagerQuestNode_FieldIndex.MaxConcurrentQuests) ?? true))
            {
                if (lhs.MaxConcurrentQuests != rhs.MaxConcurrentQuests) return false;
            }
            if ((crystal?.GetShouldTranslate((int)StoryManagerQuestNode_FieldIndex.MaxNumQuestsToRun) ?? true))
            {
                if (lhs.MaxNumQuestsToRun != rhs.MaxNumQuestsToRun) return false;
            }
            if ((crystal?.GetShouldTranslate((int)StoryManagerQuestNode_FieldIndex.HoursUntilReset) ?? true))
            {
                if (!lhs.HoursUntilReset.EqualsWithin(rhs.HoursUntilReset)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)StoryManagerQuestNode_FieldIndex.Quests) ?? true))
            {
                if (!lhs.Quests.SequenceEqual(rhs.Quests, (l, r) => ((StoryManagerQuestCommon)((IStoryManagerQuestGetter)l).CommonInstance()!).Equals(l, r, crystal?.GetSubCrystal((int)StoryManagerQuestNode_FieldIndex.Quests)))) return false;
            }
            if ((crystal?.GetShouldTranslate((int)StoryManagerQuestNode_FieldIndex.DNAMDataTypeState) ?? true))
            {
                if (lhs.DNAMDataTypeState != rhs.DNAMDataTypeState) return false;
            }
            return true;
        }
        
        public override bool Equals(
            IAStoryManagerNodeGetter? lhs,
            IAStoryManagerNodeGetter? rhs,
            TranslationCrystal? crystal)
        {
            return Equals(
                lhs: (IStoryManagerQuestNodeGetter?)lhs,
                rhs: rhs as IStoryManagerQuestNodeGetter,
                crystal: crystal);
        }
        
        public override bool Equals(
            IFallout4MajorRecordGetter? lhs,
            IFallout4MajorRecordGetter? rhs,
            TranslationCrystal? crystal)
        {
            return Equals(
                lhs: (IStoryManagerQuestNodeGetter?)lhs,
                rhs: rhs as IStoryManagerQuestNodeGetter,
                crystal: crystal);
        }
        
        public override bool Equals(
            IMajorRecordGetter? lhs,
            IMajorRecordGetter? rhs,
            TranslationCrystal? crystal)
        {
            return Equals(
                lhs: (IStoryManagerQuestNodeGetter?)lhs,
                rhs: rhs as IStoryManagerQuestNodeGetter,
                crystal: crystal);
        }
        
        public virtual int GetHashCode(IStoryManagerQuestNodeGetter item)
        {
            var hash = new HashCode();
            hash.Add(item.Flags);
            hash.Add(item.QuestFlags);
            if (item.MaxConcurrentQuests is {} MaxConcurrentQuestsitem)
            {
                hash.Add(MaxConcurrentQuestsitem);
            }
            if (item.MaxNumQuestsToRun is {} MaxNumQuestsToRunitem)
            {
                hash.Add(MaxNumQuestsToRunitem);
            }
            if (item.HoursUntilReset is {} HoursUntilResetitem)
            {
                hash.Add(HoursUntilResetitem);
            }
            hash.Add(item.Quests);
            hash.Add(item.DNAMDataTypeState);
            hash.Add(base.GetHashCode());
            return hash.ToHashCode();
        }
        
        public override int GetHashCode(IAStoryManagerNodeGetter item)
        {
            return GetHashCode(item: (IStoryManagerQuestNodeGetter)item);
        }
        
        public override int GetHashCode(IFallout4MajorRecordGetter item)
        {
            return GetHashCode(item: (IStoryManagerQuestNodeGetter)item);
        }
        
        public override int GetHashCode(IMajorRecordGetter item)
        {
            return GetHashCode(item: (IStoryManagerQuestNodeGetter)item);
        }
        
        #endregion
        
        
        public override object GetNew()
        {
            return StoryManagerQuestNode.GetNew();
        }
        
        #region Mutagen
        public IEnumerable<IFormLinkGetter> EnumerateFormLinks(IStoryManagerQuestNodeGetter obj)
        {
            foreach (var item in base.EnumerateFormLinks(obj))
            {
                yield return item;
            }
            foreach (var item in obj.Quests.SelectMany(f => f.EnumerateFormLinks()))
            {
                yield return FormLinkInformation.Factory(item);
            }
            yield break;
        }
        
        #region Duplicate
        public StoryManagerQuestNode Duplicate(
            IStoryManagerQuestNodeGetter item,
            FormKey formKey,
            TranslationCrystal? copyMask)
        {
            var newRec = new StoryManagerQuestNode(formKey);
            newRec.DeepCopyIn(item, default(ErrorMaskBuilder?), copyMask);
            return newRec;
        }
        
        public override AStoryManagerNode Duplicate(
            IAStoryManagerNodeGetter item,
            FormKey formKey,
            TranslationCrystal? copyMask)
        {
            return this.Duplicate(
                item: (IStoryManagerQuestNodeGetter)item,
                formKey: formKey,
                copyMask: copyMask);
        }
        
        public override Fallout4MajorRecord Duplicate(
            IFallout4MajorRecordGetter item,
            FormKey formKey,
            TranslationCrystal? copyMask)
        {
            return this.Duplicate(
                item: (IStoryManagerQuestNodeGetter)item,
                formKey: formKey,
                copyMask: copyMask);
        }
        
        public override MajorRecord Duplicate(
            IMajorRecordGetter item,
            FormKey formKey,
            TranslationCrystal? copyMask)
        {
            return this.Duplicate(
                item: (IStoryManagerQuestNodeGetter)item,
                formKey: formKey,
                copyMask: copyMask);
        }
        
        #endregion
        
        #endregion
        
    }
    internal partial class StoryManagerQuestNodeSetterTranslationCommon : AStoryManagerNodeSetterTranslationCommon
    {
        public new static readonly StoryManagerQuestNodeSetterTranslationCommon Instance = new StoryManagerQuestNodeSetterTranslationCommon();

        #region DeepCopyIn
        public void DeepCopyIn(
            IStoryManagerQuestNodeInternal item,
            IStoryManagerQuestNodeGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            base.DeepCopyIn(
                item,
                rhs,
                errorMask,
                copyMask,
                deepCopy: deepCopy);
        }
        
        public void DeepCopyIn(
            IStoryManagerQuestNode item,
            IStoryManagerQuestNodeGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            base.DeepCopyIn(
                (IAStoryManagerNode)item,
                (IAStoryManagerNodeGetter)rhs,
                errorMask,
                copyMask,
                deepCopy: deepCopy);
            if ((copyMask?.GetShouldTranslate((int)StoryManagerQuestNode_FieldIndex.Flags) ?? true))
            {
                item.Flags = rhs.Flags;
            }
            if ((copyMask?.GetShouldTranslate((int)StoryManagerQuestNode_FieldIndex.QuestFlags) ?? true))
            {
                item.QuestFlags = rhs.QuestFlags;
            }
            if ((copyMask?.GetShouldTranslate((int)StoryManagerQuestNode_FieldIndex.MaxConcurrentQuests) ?? true))
            {
                item.MaxConcurrentQuests = rhs.MaxConcurrentQuests;
            }
            if ((copyMask?.GetShouldTranslate((int)StoryManagerQuestNode_FieldIndex.MaxNumQuestsToRun) ?? true))
            {
                item.MaxNumQuestsToRun = rhs.MaxNumQuestsToRun;
            }
            if ((copyMask?.GetShouldTranslate((int)StoryManagerQuestNode_FieldIndex.HoursUntilReset) ?? true))
            {
                item.HoursUntilReset = rhs.HoursUntilReset;
            }
            if ((copyMask?.GetShouldTranslate((int)StoryManagerQuestNode_FieldIndex.Quests) ?? true))
            {
                errorMask?.PushIndex((int)StoryManagerQuestNode_FieldIndex.Quests);
                try
                {
                    item.Quests.SetTo(
                        rhs.Quests
                        .Select(r =>
                        {
                            return r.DeepCopy(
                                errorMask: errorMask,
                                default(TranslationCrystal));
                        }));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)StoryManagerQuestNode_FieldIndex.DNAMDataTypeState) ?? true))
            {
                item.DNAMDataTypeState = rhs.DNAMDataTypeState;
            }
        }
        
        public override void DeepCopyIn(
            IAStoryManagerNodeInternal item,
            IAStoryManagerNodeGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IStoryManagerQuestNodeInternal)item,
                rhs: (IStoryManagerQuestNodeGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        public override void DeepCopyIn(
            IAStoryManagerNode item,
            IAStoryManagerNodeGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IStoryManagerQuestNode)item,
                rhs: (IStoryManagerQuestNodeGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        public override void DeepCopyIn(
            IFallout4MajorRecordInternal item,
            IFallout4MajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IStoryManagerQuestNodeInternal)item,
                rhs: (IStoryManagerQuestNodeGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        public override void DeepCopyIn(
            IFallout4MajorRecord item,
            IFallout4MajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IStoryManagerQuestNode)item,
                rhs: (IStoryManagerQuestNodeGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        public override void DeepCopyIn(
            IMajorRecordInternal item,
            IMajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IStoryManagerQuestNodeInternal)item,
                rhs: (IStoryManagerQuestNodeGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        public override void DeepCopyIn(
            IMajorRecord item,
            IMajorRecordGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            this.DeepCopyIn(
                item: (IStoryManagerQuestNode)item,
                rhs: (IStoryManagerQuestNodeGetter)rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        #endregion
        
        public StoryManagerQuestNode DeepCopy(
            IStoryManagerQuestNodeGetter item,
            StoryManagerQuestNode.TranslationMask? copyMask = null)
        {
            StoryManagerQuestNode ret = (StoryManagerQuestNode)((StoryManagerQuestNodeCommon)((IStoryManagerQuestNodeGetter)item).CommonInstance()!).GetNew();
            ((StoryManagerQuestNodeSetterTranslationCommon)((IStoryManagerQuestNodeGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: null,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            return ret;
        }
        
        public StoryManagerQuestNode DeepCopy(
            IStoryManagerQuestNodeGetter item,
            out StoryManagerQuestNode.ErrorMask errorMask,
            StoryManagerQuestNode.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            StoryManagerQuestNode ret = (StoryManagerQuestNode)((StoryManagerQuestNodeCommon)((IStoryManagerQuestNodeGetter)item).CommonInstance()!).GetNew();
            ((StoryManagerQuestNodeSetterTranslationCommon)((IStoryManagerQuestNodeGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                ret,
                item,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            errorMask = StoryManagerQuestNode.ErrorMask.Factory(errorMaskBuilder);
            return ret;
        }
        
        public StoryManagerQuestNode DeepCopy(
            IStoryManagerQuestNodeGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            StoryManagerQuestNode ret = (StoryManagerQuestNode)((StoryManagerQuestNodeCommon)((IStoryManagerQuestNodeGetter)item).CommonInstance()!).GetNew();
            ((StoryManagerQuestNodeSetterTranslationCommon)((IStoryManagerQuestNodeGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: true);
            return ret;
        }
        
    }
    #endregion

}

namespace Mutagen.Bethesda.Fallout4
{
    public partial class StoryManagerQuestNode
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => StoryManagerQuestNode_Registration.Instance;
        public new static ILoquiRegistration StaticRegistration => StoryManagerQuestNode_Registration.Instance;
        [DebuggerStepThrough]
        protected override object CommonInstance() => StoryManagerQuestNodeCommon.Instance;
        [DebuggerStepThrough]
        protected override object CommonSetterInstance()
        {
            return StoryManagerQuestNodeSetterCommon.Instance;
        }
        [DebuggerStepThrough]
        protected override object CommonSetterTranslationInstance() => StoryManagerQuestNodeSetterTranslationCommon.Instance;

        #endregion

    }
}

#region Modules
#region Binary Translation
namespace Mutagen.Bethesda.Fallout4
{
    public partial class StoryManagerQuestNodeBinaryWriteTranslation :
        AStoryManagerNodeBinaryWriteTranslation,
        IBinaryWriteTranslator
    {
        public new static readonly StoryManagerQuestNodeBinaryWriteTranslation Instance = new StoryManagerQuestNodeBinaryWriteTranslation();

        public static void WriteEmbedded(
            IStoryManagerQuestNodeGetter item,
            MutagenWriter writer)
        {
            Fallout4MajorRecordBinaryWriteTranslation.WriteEmbedded(
                item: item,
                writer: writer);
        }

        public static void WriteRecordTypes(
            IStoryManagerQuestNodeGetter item,
            MutagenWriter writer,
            TypedWriteParams translationParams)
        {
            AStoryManagerNodeBinaryWriteTranslation.WriteRecordTypes(
                item: item,
                writer: writer,
                translationParams: translationParams);
            using (HeaderExport.Subrecord(writer, translationParams.ConvertToCustom(RecordTypes.DNAM)))
            {
                EnumBinaryTranslation<AStoryManagerNode.Flag, MutagenFrame, MutagenWriter>.Instance.Write(
                    writer,
                    item.Flags,
                    length: 2);
                EnumBinaryTranslation<StoryManagerQuestNode.QuestFlag, MutagenFrame, MutagenWriter>.Instance.Write(
                    writer,
                    item.QuestFlags,
                    length: 2);
            }
            UInt32BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.MaxConcurrentQuests,
                header: translationParams.ConvertToCustom(RecordTypes.XNAM));
            UInt32BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.MaxNumQuestsToRun,
                header: translationParams.ConvertToCustom(RecordTypes.MNAM));
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.HoursUntilReset,
                header: translationParams.ConvertToCustom(RecordTypes.HNAM));
            Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<IStoryManagerQuestGetter>.Instance.WriteWithCounter(
                writer: writer,
                items: item.Quests,
                counterType: RecordTypes.QNAM,
                counterLength: 4,
                transl: (MutagenWriter subWriter, IStoryManagerQuestGetter subItem, TypedWriteParams conv) =>
                {
                    var Item = subItem;
                    ((StoryManagerQuestBinaryWriteTranslation)((IBinaryItem)Item).BinaryWriteTranslator).Write(
                        item: Item,
                        writer: subWriter,
                        translationParams: conv);
                });
        }

        public void Write(
            MutagenWriter writer,
            IStoryManagerQuestNodeGetter item,
            TypedWriteParams translationParams)
        {
            using (HeaderExport.Record(
                writer: writer,
                record: translationParams.ConvertToCustom(RecordTypes.SMQN)))
            {
                try
                {
                    WriteEmbedded(
                        item: item,
                        writer: writer);
                    writer.MetaData.FormVersion = item.FormVersion;
                    WriteRecordTypes(
                        item: item,
                        writer: writer,
                        translationParams: translationParams);
                    writer.MetaData.FormVersion = null;
                }
                catch (Exception ex)
                {
                    throw RecordException.Enrich(ex, item);
                }
            }
        }

        public override void Write(
            MutagenWriter writer,
            object item,
            TypedWriteParams translationParams = default)
        {
            Write(
                item: (IStoryManagerQuestNodeGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

        public override void Write(
            MutagenWriter writer,
            IAStoryManagerNodeGetter item,
            TypedWriteParams translationParams)
        {
            Write(
                item: (IStoryManagerQuestNodeGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

        public override void Write(
            MutagenWriter writer,
            IFallout4MajorRecordGetter item,
            TypedWriteParams translationParams)
        {
            Write(
                item: (IStoryManagerQuestNodeGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

        public override void Write(
            MutagenWriter writer,
            IMajorRecordGetter item,
            TypedWriteParams translationParams)
        {
            Write(
                item: (IStoryManagerQuestNodeGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

    }

    internal partial class StoryManagerQuestNodeBinaryCreateTranslation : AStoryManagerNodeBinaryCreateTranslation
    {
        public new static readonly StoryManagerQuestNodeBinaryCreateTranslation Instance = new StoryManagerQuestNodeBinaryCreateTranslation();

        public override RecordType RecordType => RecordTypes.SMQN;
        public static void FillBinaryStructs(
            IStoryManagerQuestNodeInternal item,
            MutagenFrame frame)
        {
            AStoryManagerNodeBinaryCreateTranslation.FillBinaryStructs(
                item: item,
                frame: frame);
        }

        public static ParseResult FillBinaryRecordTypes(
            IStoryManagerQuestNodeInternal item,
            MutagenFrame frame,
            PreviousParse lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            RecordType nextRecordType,
            int contentLength,
            TypedParseParams translationParams = default)
        {
            nextRecordType = translationParams.ConvertToStandard(nextRecordType);
            switch (nextRecordType.TypeInt)
            {
                case RecordTypeInts.DNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    var dataFrame = frame.SpawnWithLength(contentLength);
                    item.Flags = EnumBinaryTranslation<AStoryManagerNode.Flag, MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: dataFrame,
                        length: 2);
                    item.QuestFlags = EnumBinaryTranslation<StoryManagerQuestNode.QuestFlag, MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: dataFrame,
                        length: 2);
                    return (int)StoryManagerQuestNode_FieldIndex.QuestFlags;
                }
                case RecordTypeInts.XNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.MaxConcurrentQuests = frame.ReadUInt32();
                    return (int)StoryManagerQuestNode_FieldIndex.MaxConcurrentQuests;
                }
                case RecordTypeInts.MNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.MaxNumQuestsToRun = frame.ReadUInt32();
                    return (int)StoryManagerQuestNode_FieldIndex.MaxNumQuestsToRun;
                }
                case RecordTypeInts.HNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.HoursUntilReset = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)StoryManagerQuestNode_FieldIndex.HoursUntilReset;
                }
                case RecordTypeInts.NNAM:
                case RecordTypeInts.FNAM:
                case RecordTypeInts.RNAM:
                case RecordTypeInts.QNAM:
                {
                    item.Quests.SetTo(
                        Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<StoryManagerQuest>.Instance.ParsePerItem(
                            reader: frame,
                            countLengthLength: 4,
                            countRecord: RecordTypes.QNAM,
                            triggeringRecord: StoryManagerQuest_Registration.TriggerSpecs,
                            translationParams: translationParams,
                            transl: StoryManagerQuest.TryCreateFromBinary));
                    return (int)StoryManagerQuestNode_FieldIndex.Quests;
                }
                default:
                    return AStoryManagerNodeBinaryCreateTranslation.FillBinaryRecordTypes(
                        item: item,
                        frame: frame,
                        lastParsed: lastParsed,
                        recordParseCount: recordParseCount,
                        nextRecordType: nextRecordType,
                        contentLength: contentLength,
                        translationParams: translationParams.WithNoConverter());
            }
        }

    }

}
namespace Mutagen.Bethesda.Fallout4
{
    #region Binary Write Mixins
    public static class StoryManagerQuestNodeBinaryTranslationMixIn
    {
    }
    #endregion


}
namespace Mutagen.Bethesda.Fallout4
{
    internal partial class StoryManagerQuestNodeBinaryOverlay :
        AStoryManagerNodeBinaryOverlay,
        IStoryManagerQuestNodeGetter
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => StoryManagerQuestNode_Registration.Instance;
        public new static ILoquiRegistration StaticRegistration => StoryManagerQuestNode_Registration.Instance;
        [DebuggerStepThrough]
        protected override object CommonInstance() => StoryManagerQuestNodeCommon.Instance;
        [DebuggerStepThrough]
        protected override object CommonSetterTranslationInstance() => StoryManagerQuestNodeSetterTranslationCommon.Instance;

        #endregion

        void IPrintable.Print(StructuredStringBuilder sb, string? name) => this.Print(sb, name);

        public override IEnumerable<IFormLinkGetter> EnumerateFormLinks() => StoryManagerQuestNodeCommon.Instance.EnumerateFormLinks(this);
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected override object BinaryWriteTranslator => StoryManagerQuestNodeBinaryWriteTranslation.Instance;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((StoryManagerQuestNodeBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }
        protected override Type LinkType => typeof(IStoryManagerQuestNode);


        private RangeInt32? _DNAMLocation;
        public StoryManagerQuestNode.DNAMDataType DNAMDataTypeState { get; private set; }
        #region Flags
        private int _FlagsLocation => _DNAMLocation!.Value.Min;
        private bool _Flags_IsSet => _DNAMLocation.HasValue;
        public AStoryManagerNode.Flag Flags => _Flags_IsSet ? (AStoryManagerNode.Flag)BinaryPrimitives.ReadUInt16LittleEndian(_data.Span.Slice(_FlagsLocation, 0x2)) : default;
        #endregion
        #region QuestFlags
        private int _QuestFlagsLocation => _DNAMLocation!.Value.Min + 0x2;
        private bool _QuestFlags_IsSet => _DNAMLocation.HasValue;
        public StoryManagerQuestNode.QuestFlag QuestFlags => _QuestFlags_IsSet ? (StoryManagerQuestNode.QuestFlag)BinaryPrimitives.ReadUInt16LittleEndian(_data.Span.Slice(_QuestFlagsLocation, 0x2)) : default;
        #endregion
        #region MaxConcurrentQuests
        private int? _MaxConcurrentQuestsLocation;
        public UInt32? MaxConcurrentQuests => _MaxConcurrentQuestsLocation.HasValue ? BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _MaxConcurrentQuestsLocation.Value, _package.MetaData.Constants)) : default(UInt32?);
        #endregion
        #region MaxNumQuestsToRun
        private int? _MaxNumQuestsToRunLocation;
        public UInt32? MaxNumQuestsToRun => _MaxNumQuestsToRunLocation.HasValue ? BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_data, _MaxNumQuestsToRunLocation.Value, _package.MetaData.Constants)) : default(UInt32?);
        #endregion
        #region HoursUntilReset
        private int? _HoursUntilResetLocation;
        public Single? HoursUntilReset => _HoursUntilResetLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_data, _HoursUntilResetLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        public IReadOnlyList<IStoryManagerQuestGetter> Quests { get; private set; } = Array.Empty<IStoryManagerQuestGetter>();
        partial void CustomFactoryEnd(
            OverlayStream stream,
            int finalPos,
            int offset);

        partial void CustomCtor();
        protected StoryManagerQuestNodeBinaryOverlay(
            ReadOnlyMemorySlice<byte> bytes,
            BinaryOverlayFactoryPackage package)
            : base(
                bytes: bytes,
                package: package)
        {
            this.CustomCtor();
        }

        public static IStoryManagerQuestNodeGetter StoryManagerQuestNodeFactory(
            OverlayStream stream,
            BinaryOverlayFactoryPackage package,
            TypedParseParams translationParams = default)
        {
            stream = Decompression.DecompressStream(stream);
            var ret = new StoryManagerQuestNodeBinaryOverlay(
                bytes: HeaderTranslation.ExtractRecordMemory(stream.RemainingMemory, package.MetaData.Constants),
                package: package);
            var finalPos = checked((int)(stream.Position + stream.GetMajorRecordHeader().TotalLength));
            int offset = stream.Position + package.MetaData.Constants.MajorConstants.TypeAndLengthLength;
            ret._package.FormVersion = ret;
            stream.Position += 0x10 + package.MetaData.Constants.MajorConstants.TypeAndLengthLength;
            ret.CustomFactoryEnd(
                stream: stream,
                finalPos: finalPos,
                offset: offset);
            ret.FillSubrecordTypes(
                majorReference: ret,
                stream: stream,
                finalPos: finalPos,
                offset: offset,
                translationParams: translationParams,
                fill: ret.FillRecordType);
            return ret;
        }

        public static IStoryManagerQuestNodeGetter StoryManagerQuestNodeFactory(
            ReadOnlyMemorySlice<byte> slice,
            BinaryOverlayFactoryPackage package,
            TypedParseParams translationParams = default)
        {
            return StoryManagerQuestNodeFactory(
                stream: new OverlayStream(slice, package),
                package: package,
                translationParams: translationParams);
        }

        public override ParseResult FillRecordType(
            OverlayStream stream,
            int finalPos,
            int offset,
            RecordType type,
            PreviousParse lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            TypedParseParams translationParams = default)
        {
            type = translationParams.ConvertToStandard(type);
            switch (type.TypeInt)
            {
                case RecordTypeInts.DNAM:
                {
                    _DNAMLocation = new((stream.Position - offset) + _package.MetaData.Constants.SubConstants.TypeAndLengthLength, finalPos - offset - 1);
                    return (int)StoryManagerQuestNode_FieldIndex.QuestFlags;
                }
                case RecordTypeInts.XNAM:
                {
                    _MaxConcurrentQuestsLocation = (stream.Position - offset);
                    return (int)StoryManagerQuestNode_FieldIndex.MaxConcurrentQuests;
                }
                case RecordTypeInts.MNAM:
                {
                    _MaxNumQuestsToRunLocation = (stream.Position - offset);
                    return (int)StoryManagerQuestNode_FieldIndex.MaxNumQuestsToRun;
                }
                case RecordTypeInts.HNAM:
                {
                    _HoursUntilResetLocation = (stream.Position - offset);
                    return (int)StoryManagerQuestNode_FieldIndex.HoursUntilReset;
                }
                case RecordTypeInts.NNAM:
                case RecordTypeInts.FNAM:
                case RecordTypeInts.RNAM:
                case RecordTypeInts.QNAM:
                {
                    this.Quests = BinaryOverlayList.FactoryByCountPerItem<IStoryManagerQuestGetter>(
                        stream: stream,
                        package: _package,
                        countLength: 4,
                        trigger: StoryManagerQuest_Registration.TriggerSpecs,
                        countType: RecordTypes.QNAM,
                        translationParams: translationParams,
                        getter: (s, p, recConv) => StoryManagerQuestBinaryOverlay.StoryManagerQuestFactory(new OverlayStream(s, p), p, recConv),
                        skipHeader: false);
                    return (int)StoryManagerQuestNode_FieldIndex.Quests;
                }
                default:
                    return base.FillRecordType(
                        stream: stream,
                        finalPos: finalPos,
                        offset: offset,
                        type: type,
                        lastParsed: lastParsed,
                        recordParseCount: recordParseCount);
            }
        }
        #region To String

        public override void Print(
            StructuredStringBuilder sb,
            string? name = null)
        {
            StoryManagerQuestNodeMixIn.Print(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        public override string ToString()
        {
            return MajorRecordPrinter<StoryManagerQuestNode>.ToString(this);
        }

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is IFormLinkGetter formLink)
            {
                return formLink.Equals(this);
            }
            if (obj is not IStoryManagerQuestNodeGetter rhs) return false;
            return ((StoryManagerQuestNodeCommon)((IStoryManagerQuestNodeGetter)this).CommonInstance()!).Equals(this, rhs, crystal: null);
        }

        public bool Equals(IStoryManagerQuestNodeGetter? obj)
        {
            return ((StoryManagerQuestNodeCommon)((IStoryManagerQuestNodeGetter)this).CommonInstance()!).Equals(this, obj, crystal: null);
        }

        public override int GetHashCode() => ((StoryManagerQuestNodeCommon)((IStoryManagerQuestNodeGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

    }

}
#endregion

#endregion

