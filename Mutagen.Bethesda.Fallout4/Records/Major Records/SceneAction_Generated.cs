/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Autogenerated by Loqui.  Do not manually change.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*/
#region Usings
using Loqui;
using Loqui.Interfaces;
using Loqui.Internal;
using Mutagen.Bethesda.Binary;
using Mutagen.Bethesda.Fallout4;
using Mutagen.Bethesda.Fallout4.Internals;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Aspects;
using Mutagen.Bethesda.Plugins.Binary.Headers;
using Mutagen.Bethesda.Plugins.Binary.Overlay;
using Mutagen.Bethesda.Plugins.Binary.Streams;
using Mutagen.Bethesda.Plugins.Binary.Translations;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Exceptions;
using Mutagen.Bethesda.Plugins.Internals;
using Mutagen.Bethesda.Plugins.Meta;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Plugins.Records.Internals;
using Mutagen.Bethesda.Plugins.Records.Mapping;
using Mutagen.Bethesda.Translations.Binary;
using Noggog;
using Noggog.StructuredStrings;
using Noggog.StructuredStrings.CSharp;
using RecordTypeInts = Mutagen.Bethesda.Fallout4.Internals.RecordTypeInts;
using RecordTypes = Mutagen.Bethesda.Fallout4.Internals.RecordTypes;
using System.Buffers.Binary;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Reactive.Disposables;
using System.Reactive.Linq;
#endregion

#nullable enable
namespace Mutagen.Bethesda.Fallout4
{
    #region Class
    public partial class SceneAction :
        IEquatable<ISceneActionGetter>,
        ILoquiObjectSetter<SceneAction>,
        ISceneAction
    {
        #region Ctor
        public SceneAction()
        {
            CustomCtor();
        }
        partial void CustomCtor();
        #endregion

        #region Type
        public ASceneActionType Type { get; set; } = new ASceneActionType();
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IASceneActionTypeGetter ISceneActionGetter.Type => Type;
        #endregion
        #region Name
        /// <summary>
        /// Aspects: INamed, INamedRequired
        /// </summary>
        public String? Name { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        String? ISceneActionGetter.Name => this.Name;
        #region Aspects
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        string INamedRequiredGetter.Name => this.Name ?? string.Empty;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        string INamedRequired.Name
        {
            get => this.Name ?? string.Empty;
            set => this.Name = value;
        }
        #endregion
        #endregion
        #region AliasID
        public Int32? AliasID { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Int32? ISceneActionGetter.AliasID => this.AliasID;
        #endregion
        #region Index
        public UInt32? Index { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        UInt32? ISceneActionGetter.Index => this.Index;
        #endregion
        #region Flags
        public SceneAction.Flag? Flags { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SceneAction.Flag? ISceneActionGetter.Flags => this.Flags;
        #endregion
        #region StartPhase
        public UInt32? StartPhase { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        UInt32? ISceneActionGetter.StartPhase => this.StartPhase;
        #endregion
        #region EndPhase
        public UInt32? EndPhase { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        UInt32? ISceneActionGetter.EndPhase => this.EndPhase;
        #endregion
        #region TimerMaxSeconds
        public Single? TimerMaxSeconds { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? ISceneActionGetter.TimerMaxSeconds => this.TimerMaxSeconds;
        #endregion
        #region SetParentQuestStage
        public Int16? SetParentQuestStage { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Int16? ISceneActionGetter.SetParentQuestStage => this.SetParentQuestStage;
        #endregion
        #region TimerMinSeconds
        public Single? TimerMinSeconds { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? ISceneActionGetter.TimerMinSeconds => this.TimerMinSeconds;
        #endregion
        #region STSC
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected MemorySlice<Byte>? _STSC;
        public MemorySlice<Byte>? STSC
        {
            get => this._STSC;
            set => this._STSC = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ReadOnlyMemorySlice<Byte>? ISceneActionGetter.STSC => this.STSC;
        #endregion
        #region StartScenes
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private ExtendedList<StartScene> _StartScenes = new ExtendedList<StartScene>();
        public ExtendedList<StartScene> StartScenes
        {
            get => this._StartScenes;
            init => this._StartScenes = value;
        }
        #region Interface Members
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IReadOnlyList<IStartSceneGetter> ISceneActionGetter.StartScenes => _StartScenes;
        #endregion

        #endregion
        #region PlayerPositiveResponse
        private readonly IFormLinkNullable<IDialogTopicGetter> _PlayerPositiveResponse = new FormLinkNullable<IDialogTopicGetter>();
        public IFormLinkNullable<IDialogTopicGetter> PlayerPositiveResponse
        {
            get => _PlayerPositiveResponse;
            set => _PlayerPositiveResponse.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IDialogTopicGetter> ISceneActionGetter.PlayerPositiveResponse => this.PlayerPositiveResponse;
        #endregion
        #region PlayerNegativeResponse
        private readonly IFormLinkNullable<IDialogTopicGetter> _PlayerNegativeResponse = new FormLinkNullable<IDialogTopicGetter>();
        public IFormLinkNullable<IDialogTopicGetter> PlayerNegativeResponse
        {
            get => _PlayerNegativeResponse;
            set => _PlayerNegativeResponse.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IDialogTopicGetter> ISceneActionGetter.PlayerNegativeResponse => this.PlayerNegativeResponse;
        #endregion
        #region PlayerNeutralResponse
        private readonly IFormLinkNullable<IDialogTopicGetter> _PlayerNeutralResponse = new FormLinkNullable<IDialogTopicGetter>();
        public IFormLinkNullable<IDialogTopicGetter> PlayerNeutralResponse
        {
            get => _PlayerNeutralResponse;
            set => _PlayerNeutralResponse.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IDialogTopicGetter> ISceneActionGetter.PlayerNeutralResponse => this.PlayerNeutralResponse;
        #endregion
        #region PlayerQuestionResponse
        private readonly IFormLinkNullable<IDialogTopicGetter> _PlayerQuestionResponse = new FormLinkNullable<IDialogTopicGetter>();
        public IFormLinkNullable<IDialogTopicGetter> PlayerQuestionResponse
        {
            get => _PlayerQuestionResponse;
            set => _PlayerQuestionResponse.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IDialogTopicGetter> ISceneActionGetter.PlayerQuestionResponse => this.PlayerQuestionResponse;
        #endregion
        #region PlayerPositiveSubtype
        private readonly IFormLinkNullable<IKeywordGetter> _PlayerPositiveSubtype = new FormLinkNullable<IKeywordGetter>();
        public IFormLinkNullable<IKeywordGetter> PlayerPositiveSubtype
        {
            get => _PlayerPositiveSubtype;
            set => _PlayerPositiveSubtype.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IKeywordGetter> ISceneActionGetter.PlayerPositiveSubtype => this.PlayerPositiveSubtype;
        #endregion
        #region PlayerNegativeSubtype
        private readonly IFormLinkNullable<IKeywordGetter> _PlayerNegativeSubtype = new FormLinkNullable<IKeywordGetter>();
        public IFormLinkNullable<IKeywordGetter> PlayerNegativeSubtype
        {
            get => _PlayerNegativeSubtype;
            set => _PlayerNegativeSubtype.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IKeywordGetter> ISceneActionGetter.PlayerNegativeSubtype => this.PlayerNegativeSubtype;
        #endregion
        #region PlayerNeutralSubtype
        private readonly IFormLinkNullable<IKeywordGetter> _PlayerNeutralSubtype = new FormLinkNullable<IKeywordGetter>();
        public IFormLinkNullable<IKeywordGetter> PlayerNeutralSubtype
        {
            get => _PlayerNeutralSubtype;
            set => _PlayerNeutralSubtype.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IKeywordGetter> ISceneActionGetter.PlayerNeutralSubtype => this.PlayerNeutralSubtype;
        #endregion
        #region PlayerQuestionSubtype
        private readonly IFormLinkNullable<IKeywordGetter> _PlayerQuestionSubtype = new FormLinkNullable<IKeywordGetter>();
        public IFormLinkNullable<IKeywordGetter> PlayerQuestionSubtype
        {
            get => _PlayerQuestionSubtype;
            set => _PlayerQuestionSubtype.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IKeywordGetter> ISceneActionGetter.PlayerQuestionSubtype => this.PlayerQuestionSubtype;
        #endregion
        #region NpcHeadtrackingActorIds
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private ExtendedList<Int32>? _NpcHeadtrackingActorIds;
        public ExtendedList<Int32>? NpcHeadtrackingActorIds
        {
            get => this._NpcHeadtrackingActorIds;
            set => this._NpcHeadtrackingActorIds = value;
        }
        #region Interface Members
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IReadOnlyList<Int32>? ISceneActionGetter.NpcHeadtrackingActorIds => _NpcHeadtrackingActorIds;
        #endregion

        #endregion
        #region NpcPositiveResponse
        private readonly IFormLinkNullable<IDialogTopicGetter> _NpcPositiveResponse = new FormLinkNullable<IDialogTopicGetter>();
        public IFormLinkNullable<IDialogTopicGetter> NpcPositiveResponse
        {
            get => _NpcPositiveResponse;
            set => _NpcPositiveResponse.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IDialogTopicGetter> ISceneActionGetter.NpcPositiveResponse => this.NpcPositiveResponse;
        #endregion
        #region NpcNegativeResponse
        private readonly IFormLinkNullable<IDialogTopicGetter> _NpcNegativeResponse = new FormLinkNullable<IDialogTopicGetter>();
        public IFormLinkNullable<IDialogTopicGetter> NpcNegativeResponse
        {
            get => _NpcNegativeResponse;
            set => _NpcNegativeResponse.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IDialogTopicGetter> ISceneActionGetter.NpcNegativeResponse => this.NpcNegativeResponse;
        #endregion
        #region NpcNeutralResponse
        private readonly IFormLinkNullable<IDialogTopicGetter> _NpcNeutralResponse = new FormLinkNullable<IDialogTopicGetter>();
        public IFormLinkNullable<IDialogTopicGetter> NpcNeutralResponse
        {
            get => _NpcNeutralResponse;
            set => _NpcNeutralResponse.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IDialogTopicGetter> ISceneActionGetter.NpcNeutralResponse => this.NpcNeutralResponse;
        #endregion
        #region NpcQuestionResponse
        private readonly IFormLinkNullable<IDialogTopicGetter> _NpcQuestionResponse = new FormLinkNullable<IDialogTopicGetter>();
        public IFormLinkNullable<IDialogTopicGetter> NpcQuestionResponse
        {
            get => _NpcQuestionResponse;
            set => _NpcQuestionResponse.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IDialogTopicGetter> ISceneActionGetter.NpcQuestionResponse => this.NpcQuestionResponse;
        #endregion
        #region NpcPositiveSubtype
        private readonly IFormLinkNullable<IKeywordGetter> _NpcPositiveSubtype = new FormLinkNullable<IKeywordGetter>();
        public IFormLinkNullable<IKeywordGetter> NpcPositiveSubtype
        {
            get => _NpcPositiveSubtype;
            set => _NpcPositiveSubtype.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IKeywordGetter> ISceneActionGetter.NpcPositiveSubtype => this.NpcPositiveSubtype;
        #endregion
        #region NpcNegativeSubtype
        private readonly IFormLinkNullable<IKeywordGetter> _NpcNegativeSubtype = new FormLinkNullable<IKeywordGetter>();
        public IFormLinkNullable<IKeywordGetter> NpcNegativeSubtype
        {
            get => _NpcNegativeSubtype;
            set => _NpcNegativeSubtype.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IKeywordGetter> ISceneActionGetter.NpcNegativeSubtype => this.NpcNegativeSubtype;
        #endregion
        #region NpcNeutralSubtype
        private readonly IFormLinkNullable<IKeywordGetter> _NpcNeutralSubtype = new FormLinkNullable<IKeywordGetter>();
        public IFormLinkNullable<IKeywordGetter> NpcNeutralSubtype
        {
            get => _NpcNeutralSubtype;
            set => _NpcNeutralSubtype.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IKeywordGetter> ISceneActionGetter.NpcNeutralSubtype => this.NpcNeutralSubtype;
        #endregion
        #region NpcQuestionSubtype
        private readonly IFormLinkNullable<IKeywordGetter> _NpcQuestionSubtype = new FormLinkNullable<IKeywordGetter>();
        public IFormLinkNullable<IKeywordGetter> NpcQuestionSubtype
        {
            get => _NpcQuestionSubtype;
            set => _NpcQuestionSubtype.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IKeywordGetter> ISceneActionGetter.NpcQuestionSubtype => this.NpcQuestionSubtype;
        #endregion
        #region DialogueTargetActorId
        public Int32? DialogueTargetActorId { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Int32? ISceneActionGetter.DialogueTargetActorId => this.DialogueTargetActorId;
        #endregion
        #region Packages
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private ExtendedList<IFormLinkGetter<IPackageGetter>> _Packages = new ExtendedList<IFormLinkGetter<IPackageGetter>>();
        public ExtendedList<IFormLinkGetter<IPackageGetter>> Packages
        {
            get => this._Packages;
            init => this._Packages = value;
        }
        #region Interface Members
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IReadOnlyList<IFormLinkGetter<IPackageGetter>> ISceneActionGetter.Packages => _Packages;
        #endregion

        #endregion
        #region Topic
        private readonly IFormLinkNullable<IDialogTopicGetter> _Topic = new FormLinkNullable<IDialogTopicGetter>();
        public IFormLinkNullable<IDialogTopicGetter> Topic
        {
            get => _Topic;
            set => _Topic.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IDialogTopicGetter> ISceneActionGetter.Topic => this.Topic;
        #endregion
        #region LoopingMax
        public Single? LoopingMax { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? ISceneActionGetter.LoopingMax => this.LoopingMax;
        #endregion
        #region LoopingMin
        public Single? LoopingMin { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Single? ISceneActionGetter.LoopingMin => this.LoopingMin;
        #endregion
        #region Camera
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SceneCamera? _Camera;
        public SceneCamera? Camera
        {
            get => _Camera;
            set => _Camera = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ISceneCameraGetter? ISceneActionGetter.Camera => this.Camera;
        #endregion
        #region Emotion
        public Emotion? Emotion { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Emotion? ISceneActionGetter.Emotion => this.Emotion;
        #endregion
        #region EmotionValue
        public UInt32? EmotionValue { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        UInt32? ISceneActionGetter.EmotionValue => this.EmotionValue;
        #endregion
        #region PlayerHeadTrackingActorIds
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private ExtendedList<Int32>? _PlayerHeadTrackingActorIds;
        public ExtendedList<Int32>? PlayerHeadTrackingActorIds
        {
            get => this._PlayerHeadTrackingActorIds;
            set => this._PlayerHeadTrackingActorIds = value;
        }
        #region Interface Members
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IReadOnlyList<Int32>? ISceneActionGetter.PlayerHeadTrackingActorIds => _PlayerHeadTrackingActorIds;
        #endregion

        #endregion
        #region DialogueSubtype
        private readonly IFormLinkNullable<IKeywordGetter> _DialogueSubtype = new FormLinkNullable<IKeywordGetter>();
        public IFormLinkNullable<IKeywordGetter> DialogueSubtype
        {
            get => _DialogueSubtype;
            set => _DialogueSubtype.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IKeywordGetter> ISceneActionGetter.DialogueSubtype => this.DialogueSubtype;
        #endregion
        #region AnimArchType
        private readonly IFormLinkNullable<IKeywordGetter> _AnimArchType = new FormLinkNullable<IKeywordGetter>();
        public IFormLinkNullable<IKeywordGetter> AnimArchType
        {
            get => _AnimArchType;
            set => _AnimArchType.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<IKeywordGetter> ISceneActionGetter.AnimArchType => this.AnimArchType;
        #endregion
        #region AudioOutputOverride
        private readonly IFormLinkNullable<ISoundOutputModelGetter> _AudioOutputOverride = new FormLinkNullable<ISoundOutputModelGetter>();
        public IFormLinkNullable<ISoundOutputModelGetter> AudioOutputOverride
        {
            get => _AudioOutputOverride;
            set => _AudioOutputOverride.SetTo(value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFormLinkNullableGetter<ISoundOutputModelGetter> ISceneActionGetter.AudioOutputOverride => this.AudioOutputOverride;
        #endregion
        #region Unused
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private ScenePhaseUnusedData? _Unused;
        public ScenePhaseUnusedData? Unused
        {
            get => _Unused;
            set => _Unused = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IScenePhaseUnusedDataGetter? ISceneActionGetter.Unused => this.Unused;
        #endregion

        #region To String

        public void Print(
            StructuredStringBuilder sb,
            string? name = null)
        {
            SceneActionMixIn.Print(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is not ISceneActionGetter rhs) return false;
            return ((SceneActionCommon)((ISceneActionGetter)this).CommonInstance()!).Equals(this, rhs, equalsMask: null);
        }

        public bool Equals(ISceneActionGetter? obj)
        {
            return ((SceneActionCommon)((ISceneActionGetter)this).CommonInstance()!).Equals(this, obj, equalsMask: null);
        }

        public override int GetHashCode() => ((SceneActionCommon)((ISceneActionGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        #region Mask
        public class Mask<TItem> :
            IEquatable<Mask<TItem>>,
            IMask<TItem>
        {
            #region Ctors
            public Mask(TItem initialValue)
            {
                this.Type = new MaskItem<TItem, ASceneActionType.Mask<TItem>?>(initialValue, new ASceneActionType.Mask<TItem>(initialValue));
                this.Name = initialValue;
                this.AliasID = initialValue;
                this.Index = initialValue;
                this.Flags = initialValue;
                this.StartPhase = initialValue;
                this.EndPhase = initialValue;
                this.TimerMaxSeconds = initialValue;
                this.SetParentQuestStage = initialValue;
                this.TimerMinSeconds = initialValue;
                this.STSC = initialValue;
                this.StartScenes = new MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, StartScene.Mask<TItem>?>>?>(initialValue, Enumerable.Empty<MaskItemIndexed<TItem, StartScene.Mask<TItem>?>>());
                this.PlayerPositiveResponse = initialValue;
                this.PlayerNegativeResponse = initialValue;
                this.PlayerNeutralResponse = initialValue;
                this.PlayerQuestionResponse = initialValue;
                this.PlayerPositiveSubtype = initialValue;
                this.PlayerNegativeSubtype = initialValue;
                this.PlayerNeutralSubtype = initialValue;
                this.PlayerQuestionSubtype = initialValue;
                this.NpcHeadtrackingActorIds = new MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>(initialValue, Enumerable.Empty<(int Index, TItem Value)>());
                this.NpcPositiveResponse = initialValue;
                this.NpcNegativeResponse = initialValue;
                this.NpcNeutralResponse = initialValue;
                this.NpcQuestionResponse = initialValue;
                this.NpcPositiveSubtype = initialValue;
                this.NpcNegativeSubtype = initialValue;
                this.NpcNeutralSubtype = initialValue;
                this.NpcQuestionSubtype = initialValue;
                this.DialogueTargetActorId = initialValue;
                this.Packages = new MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>(initialValue, Enumerable.Empty<(int Index, TItem Value)>());
                this.Topic = initialValue;
                this.LoopingMax = initialValue;
                this.LoopingMin = initialValue;
                this.Camera = new MaskItem<TItem, SceneCamera.Mask<TItem>?>(initialValue, new SceneCamera.Mask<TItem>(initialValue));
                this.Emotion = initialValue;
                this.EmotionValue = initialValue;
                this.PlayerHeadTrackingActorIds = new MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>(initialValue, Enumerable.Empty<(int Index, TItem Value)>());
                this.DialogueSubtype = initialValue;
                this.AnimArchType = initialValue;
                this.AudioOutputOverride = initialValue;
                this.Unused = new MaskItem<TItem, ScenePhaseUnusedData.Mask<TItem>?>(initialValue, new ScenePhaseUnusedData.Mask<TItem>(initialValue));
            }

            public Mask(
                TItem Type,
                TItem Name,
                TItem AliasID,
                TItem Index,
                TItem Flags,
                TItem StartPhase,
                TItem EndPhase,
                TItem TimerMaxSeconds,
                TItem SetParentQuestStage,
                TItem TimerMinSeconds,
                TItem STSC,
                TItem StartScenes,
                TItem PlayerPositiveResponse,
                TItem PlayerNegativeResponse,
                TItem PlayerNeutralResponse,
                TItem PlayerQuestionResponse,
                TItem PlayerPositiveSubtype,
                TItem PlayerNegativeSubtype,
                TItem PlayerNeutralSubtype,
                TItem PlayerQuestionSubtype,
                TItem NpcHeadtrackingActorIds,
                TItem NpcPositiveResponse,
                TItem NpcNegativeResponse,
                TItem NpcNeutralResponse,
                TItem NpcQuestionResponse,
                TItem NpcPositiveSubtype,
                TItem NpcNegativeSubtype,
                TItem NpcNeutralSubtype,
                TItem NpcQuestionSubtype,
                TItem DialogueTargetActorId,
                TItem Packages,
                TItem Topic,
                TItem LoopingMax,
                TItem LoopingMin,
                TItem Camera,
                TItem Emotion,
                TItem EmotionValue,
                TItem PlayerHeadTrackingActorIds,
                TItem DialogueSubtype,
                TItem AnimArchType,
                TItem AudioOutputOverride,
                TItem Unused)
            {
                this.Type = new MaskItem<TItem, ASceneActionType.Mask<TItem>?>(Type, new ASceneActionType.Mask<TItem>(Type));
                this.Name = Name;
                this.AliasID = AliasID;
                this.Index = Index;
                this.Flags = Flags;
                this.StartPhase = StartPhase;
                this.EndPhase = EndPhase;
                this.TimerMaxSeconds = TimerMaxSeconds;
                this.SetParentQuestStage = SetParentQuestStage;
                this.TimerMinSeconds = TimerMinSeconds;
                this.STSC = STSC;
                this.StartScenes = new MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, StartScene.Mask<TItem>?>>?>(StartScenes, Enumerable.Empty<MaskItemIndexed<TItem, StartScene.Mask<TItem>?>>());
                this.PlayerPositiveResponse = PlayerPositiveResponse;
                this.PlayerNegativeResponse = PlayerNegativeResponse;
                this.PlayerNeutralResponse = PlayerNeutralResponse;
                this.PlayerQuestionResponse = PlayerQuestionResponse;
                this.PlayerPositiveSubtype = PlayerPositiveSubtype;
                this.PlayerNegativeSubtype = PlayerNegativeSubtype;
                this.PlayerNeutralSubtype = PlayerNeutralSubtype;
                this.PlayerQuestionSubtype = PlayerQuestionSubtype;
                this.NpcHeadtrackingActorIds = new MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>(NpcHeadtrackingActorIds, Enumerable.Empty<(int Index, TItem Value)>());
                this.NpcPositiveResponse = NpcPositiveResponse;
                this.NpcNegativeResponse = NpcNegativeResponse;
                this.NpcNeutralResponse = NpcNeutralResponse;
                this.NpcQuestionResponse = NpcQuestionResponse;
                this.NpcPositiveSubtype = NpcPositiveSubtype;
                this.NpcNegativeSubtype = NpcNegativeSubtype;
                this.NpcNeutralSubtype = NpcNeutralSubtype;
                this.NpcQuestionSubtype = NpcQuestionSubtype;
                this.DialogueTargetActorId = DialogueTargetActorId;
                this.Packages = new MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>(Packages, Enumerable.Empty<(int Index, TItem Value)>());
                this.Topic = Topic;
                this.LoopingMax = LoopingMax;
                this.LoopingMin = LoopingMin;
                this.Camera = new MaskItem<TItem, SceneCamera.Mask<TItem>?>(Camera, new SceneCamera.Mask<TItem>(Camera));
                this.Emotion = Emotion;
                this.EmotionValue = EmotionValue;
                this.PlayerHeadTrackingActorIds = new MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>(PlayerHeadTrackingActorIds, Enumerable.Empty<(int Index, TItem Value)>());
                this.DialogueSubtype = DialogueSubtype;
                this.AnimArchType = AnimArchType;
                this.AudioOutputOverride = AudioOutputOverride;
                this.Unused = new MaskItem<TItem, ScenePhaseUnusedData.Mask<TItem>?>(Unused, new ScenePhaseUnusedData.Mask<TItem>(Unused));
            }

            #pragma warning disable CS8618
            protected Mask()
            {
            }
            #pragma warning restore CS8618

            #endregion

            #region Members
            public MaskItem<TItem, ASceneActionType.Mask<TItem>?>? Type { get; set; }
            public TItem Name;
            public TItem AliasID;
            public TItem Index;
            public TItem Flags;
            public TItem StartPhase;
            public TItem EndPhase;
            public TItem TimerMaxSeconds;
            public TItem SetParentQuestStage;
            public TItem TimerMinSeconds;
            public TItem STSC;
            public MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, StartScene.Mask<TItem>?>>?>? StartScenes;
            public TItem PlayerPositiveResponse;
            public TItem PlayerNegativeResponse;
            public TItem PlayerNeutralResponse;
            public TItem PlayerQuestionResponse;
            public TItem PlayerPositiveSubtype;
            public TItem PlayerNegativeSubtype;
            public TItem PlayerNeutralSubtype;
            public TItem PlayerQuestionSubtype;
            public MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>? NpcHeadtrackingActorIds;
            public TItem NpcPositiveResponse;
            public TItem NpcNegativeResponse;
            public TItem NpcNeutralResponse;
            public TItem NpcQuestionResponse;
            public TItem NpcPositiveSubtype;
            public TItem NpcNegativeSubtype;
            public TItem NpcNeutralSubtype;
            public TItem NpcQuestionSubtype;
            public TItem DialogueTargetActorId;
            public MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>? Packages;
            public TItem Topic;
            public TItem LoopingMax;
            public TItem LoopingMin;
            public MaskItem<TItem, SceneCamera.Mask<TItem>?>? Camera { get; set; }
            public TItem Emotion;
            public TItem EmotionValue;
            public MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>? PlayerHeadTrackingActorIds;
            public TItem DialogueSubtype;
            public TItem AnimArchType;
            public TItem AudioOutputOverride;
            public MaskItem<TItem, ScenePhaseUnusedData.Mask<TItem>?>? Unused { get; set; }
            #endregion

            #region Equals
            public override bool Equals(object? obj)
            {
                if (!(obj is Mask<TItem> rhs)) return false;
                return Equals(rhs);
            }

            public bool Equals(Mask<TItem>? rhs)
            {
                if (rhs == null) return false;
                if (!object.Equals(this.Type, rhs.Type)) return false;
                if (!object.Equals(this.Name, rhs.Name)) return false;
                if (!object.Equals(this.AliasID, rhs.AliasID)) return false;
                if (!object.Equals(this.Index, rhs.Index)) return false;
                if (!object.Equals(this.Flags, rhs.Flags)) return false;
                if (!object.Equals(this.StartPhase, rhs.StartPhase)) return false;
                if (!object.Equals(this.EndPhase, rhs.EndPhase)) return false;
                if (!object.Equals(this.TimerMaxSeconds, rhs.TimerMaxSeconds)) return false;
                if (!object.Equals(this.SetParentQuestStage, rhs.SetParentQuestStage)) return false;
                if (!object.Equals(this.TimerMinSeconds, rhs.TimerMinSeconds)) return false;
                if (!object.Equals(this.STSC, rhs.STSC)) return false;
                if (!object.Equals(this.StartScenes, rhs.StartScenes)) return false;
                if (!object.Equals(this.PlayerPositiveResponse, rhs.PlayerPositiveResponse)) return false;
                if (!object.Equals(this.PlayerNegativeResponse, rhs.PlayerNegativeResponse)) return false;
                if (!object.Equals(this.PlayerNeutralResponse, rhs.PlayerNeutralResponse)) return false;
                if (!object.Equals(this.PlayerQuestionResponse, rhs.PlayerQuestionResponse)) return false;
                if (!object.Equals(this.PlayerPositiveSubtype, rhs.PlayerPositiveSubtype)) return false;
                if (!object.Equals(this.PlayerNegativeSubtype, rhs.PlayerNegativeSubtype)) return false;
                if (!object.Equals(this.PlayerNeutralSubtype, rhs.PlayerNeutralSubtype)) return false;
                if (!object.Equals(this.PlayerQuestionSubtype, rhs.PlayerQuestionSubtype)) return false;
                if (!object.Equals(this.NpcHeadtrackingActorIds, rhs.NpcHeadtrackingActorIds)) return false;
                if (!object.Equals(this.NpcPositiveResponse, rhs.NpcPositiveResponse)) return false;
                if (!object.Equals(this.NpcNegativeResponse, rhs.NpcNegativeResponse)) return false;
                if (!object.Equals(this.NpcNeutralResponse, rhs.NpcNeutralResponse)) return false;
                if (!object.Equals(this.NpcQuestionResponse, rhs.NpcQuestionResponse)) return false;
                if (!object.Equals(this.NpcPositiveSubtype, rhs.NpcPositiveSubtype)) return false;
                if (!object.Equals(this.NpcNegativeSubtype, rhs.NpcNegativeSubtype)) return false;
                if (!object.Equals(this.NpcNeutralSubtype, rhs.NpcNeutralSubtype)) return false;
                if (!object.Equals(this.NpcQuestionSubtype, rhs.NpcQuestionSubtype)) return false;
                if (!object.Equals(this.DialogueTargetActorId, rhs.DialogueTargetActorId)) return false;
                if (!object.Equals(this.Packages, rhs.Packages)) return false;
                if (!object.Equals(this.Topic, rhs.Topic)) return false;
                if (!object.Equals(this.LoopingMax, rhs.LoopingMax)) return false;
                if (!object.Equals(this.LoopingMin, rhs.LoopingMin)) return false;
                if (!object.Equals(this.Camera, rhs.Camera)) return false;
                if (!object.Equals(this.Emotion, rhs.Emotion)) return false;
                if (!object.Equals(this.EmotionValue, rhs.EmotionValue)) return false;
                if (!object.Equals(this.PlayerHeadTrackingActorIds, rhs.PlayerHeadTrackingActorIds)) return false;
                if (!object.Equals(this.DialogueSubtype, rhs.DialogueSubtype)) return false;
                if (!object.Equals(this.AnimArchType, rhs.AnimArchType)) return false;
                if (!object.Equals(this.AudioOutputOverride, rhs.AudioOutputOverride)) return false;
                if (!object.Equals(this.Unused, rhs.Unused)) return false;
                return true;
            }
            public override int GetHashCode()
            {
                var hash = new HashCode();
                hash.Add(this.Type);
                hash.Add(this.Name);
                hash.Add(this.AliasID);
                hash.Add(this.Index);
                hash.Add(this.Flags);
                hash.Add(this.StartPhase);
                hash.Add(this.EndPhase);
                hash.Add(this.TimerMaxSeconds);
                hash.Add(this.SetParentQuestStage);
                hash.Add(this.TimerMinSeconds);
                hash.Add(this.STSC);
                hash.Add(this.StartScenes);
                hash.Add(this.PlayerPositiveResponse);
                hash.Add(this.PlayerNegativeResponse);
                hash.Add(this.PlayerNeutralResponse);
                hash.Add(this.PlayerQuestionResponse);
                hash.Add(this.PlayerPositiveSubtype);
                hash.Add(this.PlayerNegativeSubtype);
                hash.Add(this.PlayerNeutralSubtype);
                hash.Add(this.PlayerQuestionSubtype);
                hash.Add(this.NpcHeadtrackingActorIds);
                hash.Add(this.NpcPositiveResponse);
                hash.Add(this.NpcNegativeResponse);
                hash.Add(this.NpcNeutralResponse);
                hash.Add(this.NpcQuestionResponse);
                hash.Add(this.NpcPositiveSubtype);
                hash.Add(this.NpcNegativeSubtype);
                hash.Add(this.NpcNeutralSubtype);
                hash.Add(this.NpcQuestionSubtype);
                hash.Add(this.DialogueTargetActorId);
                hash.Add(this.Packages);
                hash.Add(this.Topic);
                hash.Add(this.LoopingMax);
                hash.Add(this.LoopingMin);
                hash.Add(this.Camera);
                hash.Add(this.Emotion);
                hash.Add(this.EmotionValue);
                hash.Add(this.PlayerHeadTrackingActorIds);
                hash.Add(this.DialogueSubtype);
                hash.Add(this.AnimArchType);
                hash.Add(this.AudioOutputOverride);
                hash.Add(this.Unused);
                return hash.ToHashCode();
            }

            #endregion

            #region All
            public bool All(Func<TItem, bool> eval)
            {
                if (Type != null)
                {
                    if (!eval(this.Type.Overall)) return false;
                    if (this.Type.Specific != null && !this.Type.Specific.All(eval)) return false;
                }
                if (!eval(this.Name)) return false;
                if (!eval(this.AliasID)) return false;
                if (!eval(this.Index)) return false;
                if (!eval(this.Flags)) return false;
                if (!eval(this.StartPhase)) return false;
                if (!eval(this.EndPhase)) return false;
                if (!eval(this.TimerMaxSeconds)) return false;
                if (!eval(this.SetParentQuestStage)) return false;
                if (!eval(this.TimerMinSeconds)) return false;
                if (!eval(this.STSC)) return false;
                if (this.StartScenes != null)
                {
                    if (!eval(this.StartScenes.Overall)) return false;
                    if (this.StartScenes.Specific != null)
                    {
                        foreach (var item in this.StartScenes.Specific)
                        {
                            if (!eval(item.Overall)) return false;
                            if (item.Specific != null && !item.Specific.All(eval)) return false;
                        }
                    }
                }
                if (!eval(this.PlayerPositiveResponse)) return false;
                if (!eval(this.PlayerNegativeResponse)) return false;
                if (!eval(this.PlayerNeutralResponse)) return false;
                if (!eval(this.PlayerQuestionResponse)) return false;
                if (!eval(this.PlayerPositiveSubtype)) return false;
                if (!eval(this.PlayerNegativeSubtype)) return false;
                if (!eval(this.PlayerNeutralSubtype)) return false;
                if (!eval(this.PlayerQuestionSubtype)) return false;
                if (this.NpcHeadtrackingActorIds != null)
                {
                    if (!eval(this.NpcHeadtrackingActorIds.Overall)) return false;
                    if (this.NpcHeadtrackingActorIds.Specific != null)
                    {
                        foreach (var item in this.NpcHeadtrackingActorIds.Specific)
                        {
                            if (!eval(item.Value)) return false;
                        }
                    }
                }
                if (!eval(this.NpcPositiveResponse)) return false;
                if (!eval(this.NpcNegativeResponse)) return false;
                if (!eval(this.NpcNeutralResponse)) return false;
                if (!eval(this.NpcQuestionResponse)) return false;
                if (!eval(this.NpcPositiveSubtype)) return false;
                if (!eval(this.NpcNegativeSubtype)) return false;
                if (!eval(this.NpcNeutralSubtype)) return false;
                if (!eval(this.NpcQuestionSubtype)) return false;
                if (!eval(this.DialogueTargetActorId)) return false;
                if (this.Packages != null)
                {
                    if (!eval(this.Packages.Overall)) return false;
                    if (this.Packages.Specific != null)
                    {
                        foreach (var item in this.Packages.Specific)
                        {
                            if (!eval(item.Value)) return false;
                        }
                    }
                }
                if (!eval(this.Topic)) return false;
                if (!eval(this.LoopingMax)) return false;
                if (!eval(this.LoopingMin)) return false;
                if (Camera != null)
                {
                    if (!eval(this.Camera.Overall)) return false;
                    if (this.Camera.Specific != null && !this.Camera.Specific.All(eval)) return false;
                }
                if (!eval(this.Emotion)) return false;
                if (!eval(this.EmotionValue)) return false;
                if (this.PlayerHeadTrackingActorIds != null)
                {
                    if (!eval(this.PlayerHeadTrackingActorIds.Overall)) return false;
                    if (this.PlayerHeadTrackingActorIds.Specific != null)
                    {
                        foreach (var item in this.PlayerHeadTrackingActorIds.Specific)
                        {
                            if (!eval(item.Value)) return false;
                        }
                    }
                }
                if (!eval(this.DialogueSubtype)) return false;
                if (!eval(this.AnimArchType)) return false;
                if (!eval(this.AudioOutputOverride)) return false;
                if (Unused != null)
                {
                    if (!eval(this.Unused.Overall)) return false;
                    if (this.Unused.Specific != null && !this.Unused.Specific.All(eval)) return false;
                }
                return true;
            }
            #endregion

            #region Any
            public bool Any(Func<TItem, bool> eval)
            {
                if (Type != null)
                {
                    if (eval(this.Type.Overall)) return true;
                    if (this.Type.Specific != null && this.Type.Specific.Any(eval)) return true;
                }
                if (eval(this.Name)) return true;
                if (eval(this.AliasID)) return true;
                if (eval(this.Index)) return true;
                if (eval(this.Flags)) return true;
                if (eval(this.StartPhase)) return true;
                if (eval(this.EndPhase)) return true;
                if (eval(this.TimerMaxSeconds)) return true;
                if (eval(this.SetParentQuestStage)) return true;
                if (eval(this.TimerMinSeconds)) return true;
                if (eval(this.STSC)) return true;
                if (this.StartScenes != null)
                {
                    if (eval(this.StartScenes.Overall)) return true;
                    if (this.StartScenes.Specific != null)
                    {
                        foreach (var item in this.StartScenes.Specific)
                        {
                            if (!eval(item.Overall)) return false;
                            if (item.Specific != null && !item.Specific.All(eval)) return false;
                        }
                    }
                }
                if (eval(this.PlayerPositiveResponse)) return true;
                if (eval(this.PlayerNegativeResponse)) return true;
                if (eval(this.PlayerNeutralResponse)) return true;
                if (eval(this.PlayerQuestionResponse)) return true;
                if (eval(this.PlayerPositiveSubtype)) return true;
                if (eval(this.PlayerNegativeSubtype)) return true;
                if (eval(this.PlayerNeutralSubtype)) return true;
                if (eval(this.PlayerQuestionSubtype)) return true;
                if (this.NpcHeadtrackingActorIds != null)
                {
                    if (eval(this.NpcHeadtrackingActorIds.Overall)) return true;
                    if (this.NpcHeadtrackingActorIds.Specific != null)
                    {
                        foreach (var item in this.NpcHeadtrackingActorIds.Specific)
                        {
                            if (!eval(item.Value)) return false;
                        }
                    }
                }
                if (eval(this.NpcPositiveResponse)) return true;
                if (eval(this.NpcNegativeResponse)) return true;
                if (eval(this.NpcNeutralResponse)) return true;
                if (eval(this.NpcQuestionResponse)) return true;
                if (eval(this.NpcPositiveSubtype)) return true;
                if (eval(this.NpcNegativeSubtype)) return true;
                if (eval(this.NpcNeutralSubtype)) return true;
                if (eval(this.NpcQuestionSubtype)) return true;
                if (eval(this.DialogueTargetActorId)) return true;
                if (this.Packages != null)
                {
                    if (eval(this.Packages.Overall)) return true;
                    if (this.Packages.Specific != null)
                    {
                        foreach (var item in this.Packages.Specific)
                        {
                            if (!eval(item.Value)) return false;
                        }
                    }
                }
                if (eval(this.Topic)) return true;
                if (eval(this.LoopingMax)) return true;
                if (eval(this.LoopingMin)) return true;
                if (Camera != null)
                {
                    if (eval(this.Camera.Overall)) return true;
                    if (this.Camera.Specific != null && this.Camera.Specific.Any(eval)) return true;
                }
                if (eval(this.Emotion)) return true;
                if (eval(this.EmotionValue)) return true;
                if (this.PlayerHeadTrackingActorIds != null)
                {
                    if (eval(this.PlayerHeadTrackingActorIds.Overall)) return true;
                    if (this.PlayerHeadTrackingActorIds.Specific != null)
                    {
                        foreach (var item in this.PlayerHeadTrackingActorIds.Specific)
                        {
                            if (!eval(item.Value)) return false;
                        }
                    }
                }
                if (eval(this.DialogueSubtype)) return true;
                if (eval(this.AnimArchType)) return true;
                if (eval(this.AudioOutputOverride)) return true;
                if (Unused != null)
                {
                    if (eval(this.Unused.Overall)) return true;
                    if (this.Unused.Specific != null && this.Unused.Specific.Any(eval)) return true;
                }
                return false;
            }
            #endregion

            #region Translate
            public Mask<R> Translate<R>(Func<TItem, R> eval)
            {
                var ret = new SceneAction.Mask<R>();
                this.Translate_InternalFill(ret, eval);
                return ret;
            }

            protected void Translate_InternalFill<R>(Mask<R> obj, Func<TItem, R> eval)
            {
                obj.Type = this.Type == null ? null : new MaskItem<R, ASceneActionType.Mask<R>?>(eval(this.Type.Overall), this.Type.Specific?.Translate(eval));
                obj.Name = eval(this.Name);
                obj.AliasID = eval(this.AliasID);
                obj.Index = eval(this.Index);
                obj.Flags = eval(this.Flags);
                obj.StartPhase = eval(this.StartPhase);
                obj.EndPhase = eval(this.EndPhase);
                obj.TimerMaxSeconds = eval(this.TimerMaxSeconds);
                obj.SetParentQuestStage = eval(this.SetParentQuestStage);
                obj.TimerMinSeconds = eval(this.TimerMinSeconds);
                obj.STSC = eval(this.STSC);
                if (StartScenes != null)
                {
                    obj.StartScenes = new MaskItem<R, IEnumerable<MaskItemIndexed<R, StartScene.Mask<R>?>>?>(eval(this.StartScenes.Overall), Enumerable.Empty<MaskItemIndexed<R, StartScene.Mask<R>?>>());
                    if (StartScenes.Specific != null)
                    {
                        var l = new List<MaskItemIndexed<R, StartScene.Mask<R>?>>();
                        obj.StartScenes.Specific = l;
                        foreach (var item in StartScenes.Specific)
                        {
                            MaskItemIndexed<R, StartScene.Mask<R>?>? mask = item == null ? null : new MaskItemIndexed<R, StartScene.Mask<R>?>(item.Index, eval(item.Overall), item.Specific?.Translate(eval));
                            if (mask == null) continue;
                            l.Add(mask);
                        }
                    }
                }
                obj.PlayerPositiveResponse = eval(this.PlayerPositiveResponse);
                obj.PlayerNegativeResponse = eval(this.PlayerNegativeResponse);
                obj.PlayerNeutralResponse = eval(this.PlayerNeutralResponse);
                obj.PlayerQuestionResponse = eval(this.PlayerQuestionResponse);
                obj.PlayerPositiveSubtype = eval(this.PlayerPositiveSubtype);
                obj.PlayerNegativeSubtype = eval(this.PlayerNegativeSubtype);
                obj.PlayerNeutralSubtype = eval(this.PlayerNeutralSubtype);
                obj.PlayerQuestionSubtype = eval(this.PlayerQuestionSubtype);
                if (NpcHeadtrackingActorIds != null)
                {
                    obj.NpcHeadtrackingActorIds = new MaskItem<R, IEnumerable<(int Index, R Value)>?>(eval(this.NpcHeadtrackingActorIds.Overall), Enumerable.Empty<(int Index, R Value)>());
                    if (NpcHeadtrackingActorIds.Specific != null)
                    {
                        var l = new List<(int Index, R Item)>();
                        obj.NpcHeadtrackingActorIds.Specific = l;
                        foreach (var item in NpcHeadtrackingActorIds.Specific)
                        {
                            R mask = eval(item.Value);
                            l.Add((item.Index, mask));
                        }
                    }
                }
                obj.NpcPositiveResponse = eval(this.NpcPositiveResponse);
                obj.NpcNegativeResponse = eval(this.NpcNegativeResponse);
                obj.NpcNeutralResponse = eval(this.NpcNeutralResponse);
                obj.NpcQuestionResponse = eval(this.NpcQuestionResponse);
                obj.NpcPositiveSubtype = eval(this.NpcPositiveSubtype);
                obj.NpcNegativeSubtype = eval(this.NpcNegativeSubtype);
                obj.NpcNeutralSubtype = eval(this.NpcNeutralSubtype);
                obj.NpcQuestionSubtype = eval(this.NpcQuestionSubtype);
                obj.DialogueTargetActorId = eval(this.DialogueTargetActorId);
                if (Packages != null)
                {
                    obj.Packages = new MaskItem<R, IEnumerable<(int Index, R Value)>?>(eval(this.Packages.Overall), Enumerable.Empty<(int Index, R Value)>());
                    if (Packages.Specific != null)
                    {
                        var l = new List<(int Index, R Item)>();
                        obj.Packages.Specific = l;
                        foreach (var item in Packages.Specific)
                        {
                            R mask = eval(item.Value);
                            l.Add((item.Index, mask));
                        }
                    }
                }
                obj.Topic = eval(this.Topic);
                obj.LoopingMax = eval(this.LoopingMax);
                obj.LoopingMin = eval(this.LoopingMin);
                obj.Camera = this.Camera == null ? null : new MaskItem<R, SceneCamera.Mask<R>?>(eval(this.Camera.Overall), this.Camera.Specific?.Translate(eval));
                obj.Emotion = eval(this.Emotion);
                obj.EmotionValue = eval(this.EmotionValue);
                if (PlayerHeadTrackingActorIds != null)
                {
                    obj.PlayerHeadTrackingActorIds = new MaskItem<R, IEnumerable<(int Index, R Value)>?>(eval(this.PlayerHeadTrackingActorIds.Overall), Enumerable.Empty<(int Index, R Value)>());
                    if (PlayerHeadTrackingActorIds.Specific != null)
                    {
                        var l = new List<(int Index, R Item)>();
                        obj.PlayerHeadTrackingActorIds.Specific = l;
                        foreach (var item in PlayerHeadTrackingActorIds.Specific)
                        {
                            R mask = eval(item.Value);
                            l.Add((item.Index, mask));
                        }
                    }
                }
                obj.DialogueSubtype = eval(this.DialogueSubtype);
                obj.AnimArchType = eval(this.AnimArchType);
                obj.AudioOutputOverride = eval(this.AudioOutputOverride);
                obj.Unused = this.Unused == null ? null : new MaskItem<R, ScenePhaseUnusedData.Mask<R>?>(eval(this.Unused.Overall), this.Unused.Specific?.Translate(eval));
            }
            #endregion

            #region To String
            public override string ToString() => this.Print();

            public string Print(SceneAction.Mask<bool>? printMask = null)
            {
                var sb = new StructuredStringBuilder();
                Print(sb, printMask);
                return sb.ToString();
            }

            public void Print(StructuredStringBuilder sb, SceneAction.Mask<bool>? printMask = null)
            {
                sb.AppendLine($"{nameof(SceneAction.Mask<TItem>)} =>");
                using (sb.Brace())
                {
                    if (printMask?.Type?.Overall ?? true)
                    {
                        Type?.Print(sb);
                    }
                    if (printMask?.Name ?? true)
                    {
                        sb.AppendItem(Name, "Name");
                    }
                    if (printMask?.AliasID ?? true)
                    {
                        sb.AppendItem(AliasID, "AliasID");
                    }
                    if (printMask?.Index ?? true)
                    {
                        sb.AppendItem(Index, "Index");
                    }
                    if (printMask?.Flags ?? true)
                    {
                        sb.AppendItem(Flags, "Flags");
                    }
                    if (printMask?.StartPhase ?? true)
                    {
                        sb.AppendItem(StartPhase, "StartPhase");
                    }
                    if (printMask?.EndPhase ?? true)
                    {
                        sb.AppendItem(EndPhase, "EndPhase");
                    }
                    if (printMask?.TimerMaxSeconds ?? true)
                    {
                        sb.AppendItem(TimerMaxSeconds, "TimerMaxSeconds");
                    }
                    if (printMask?.SetParentQuestStage ?? true)
                    {
                        sb.AppendItem(SetParentQuestStage, "SetParentQuestStage");
                    }
                    if (printMask?.TimerMinSeconds ?? true)
                    {
                        sb.AppendItem(TimerMinSeconds, "TimerMinSeconds");
                    }
                    if (printMask?.STSC ?? true)
                    {
                        sb.AppendItem(STSC, "STSC");
                    }
                    if ((printMask?.StartScenes?.Overall ?? true)
                        && StartScenes is {} StartScenesItem)
                    {
                        sb.AppendLine("StartScenes =>");
                        using (sb.Brace())
                        {
                            sb.AppendItem(StartScenesItem.Overall);
                            if (StartScenesItem.Specific != null)
                            {
                                foreach (var subItem in StartScenesItem.Specific)
                                {
                                    using (sb.Brace())
                                    {
                                        subItem?.Print(sb);
                                    }
                                }
                            }
                        }
                    }
                    if (printMask?.PlayerPositiveResponse ?? true)
                    {
                        sb.AppendItem(PlayerPositiveResponse, "PlayerPositiveResponse");
                    }
                    if (printMask?.PlayerNegativeResponse ?? true)
                    {
                        sb.AppendItem(PlayerNegativeResponse, "PlayerNegativeResponse");
                    }
                    if (printMask?.PlayerNeutralResponse ?? true)
                    {
                        sb.AppendItem(PlayerNeutralResponse, "PlayerNeutralResponse");
                    }
                    if (printMask?.PlayerQuestionResponse ?? true)
                    {
                        sb.AppendItem(PlayerQuestionResponse, "PlayerQuestionResponse");
                    }
                    if (printMask?.PlayerPositiveSubtype ?? true)
                    {
                        sb.AppendItem(PlayerPositiveSubtype, "PlayerPositiveSubtype");
                    }
                    if (printMask?.PlayerNegativeSubtype ?? true)
                    {
                        sb.AppendItem(PlayerNegativeSubtype, "PlayerNegativeSubtype");
                    }
                    if (printMask?.PlayerNeutralSubtype ?? true)
                    {
                        sb.AppendItem(PlayerNeutralSubtype, "PlayerNeutralSubtype");
                    }
                    if (printMask?.PlayerQuestionSubtype ?? true)
                    {
                        sb.AppendItem(PlayerQuestionSubtype, "PlayerQuestionSubtype");
                    }
                    if ((printMask?.NpcHeadtrackingActorIds?.Overall ?? true)
                        && NpcHeadtrackingActorIds is {} NpcHeadtrackingActorIdsItem)
                    {
                        sb.AppendLine("NpcHeadtrackingActorIds =>");
                        using (sb.Brace())
                        {
                            sb.AppendItem(NpcHeadtrackingActorIdsItem.Overall);
                            if (NpcHeadtrackingActorIdsItem.Specific != null)
                            {
                                foreach (var subItem in NpcHeadtrackingActorIdsItem.Specific)
                                {
                                    using (sb.Brace())
                                    {
                                        {
                                            sb.AppendItem(subItem);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (printMask?.NpcPositiveResponse ?? true)
                    {
                        sb.AppendItem(NpcPositiveResponse, "NpcPositiveResponse");
                    }
                    if (printMask?.NpcNegativeResponse ?? true)
                    {
                        sb.AppendItem(NpcNegativeResponse, "NpcNegativeResponse");
                    }
                    if (printMask?.NpcNeutralResponse ?? true)
                    {
                        sb.AppendItem(NpcNeutralResponse, "NpcNeutralResponse");
                    }
                    if (printMask?.NpcQuestionResponse ?? true)
                    {
                        sb.AppendItem(NpcQuestionResponse, "NpcQuestionResponse");
                    }
                    if (printMask?.NpcPositiveSubtype ?? true)
                    {
                        sb.AppendItem(NpcPositiveSubtype, "NpcPositiveSubtype");
                    }
                    if (printMask?.NpcNegativeSubtype ?? true)
                    {
                        sb.AppendItem(NpcNegativeSubtype, "NpcNegativeSubtype");
                    }
                    if (printMask?.NpcNeutralSubtype ?? true)
                    {
                        sb.AppendItem(NpcNeutralSubtype, "NpcNeutralSubtype");
                    }
                    if (printMask?.NpcQuestionSubtype ?? true)
                    {
                        sb.AppendItem(NpcQuestionSubtype, "NpcQuestionSubtype");
                    }
                    if (printMask?.DialogueTargetActorId ?? true)
                    {
                        sb.AppendItem(DialogueTargetActorId, "DialogueTargetActorId");
                    }
                    if ((printMask?.Packages?.Overall ?? true)
                        && Packages is {} PackagesItem)
                    {
                        sb.AppendLine("Packages =>");
                        using (sb.Brace())
                        {
                            sb.AppendItem(PackagesItem.Overall);
                            if (PackagesItem.Specific != null)
                            {
                                foreach (var subItem in PackagesItem.Specific)
                                {
                                    using (sb.Brace())
                                    {
                                        {
                                            sb.AppendItem(subItem);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (printMask?.Topic ?? true)
                    {
                        sb.AppendItem(Topic, "Topic");
                    }
                    if (printMask?.LoopingMax ?? true)
                    {
                        sb.AppendItem(LoopingMax, "LoopingMax");
                    }
                    if (printMask?.LoopingMin ?? true)
                    {
                        sb.AppendItem(LoopingMin, "LoopingMin");
                    }
                    if (printMask?.Camera?.Overall ?? true)
                    {
                        Camera?.Print(sb);
                    }
                    if (printMask?.Emotion ?? true)
                    {
                        sb.AppendItem(Emotion, "Emotion");
                    }
                    if (printMask?.EmotionValue ?? true)
                    {
                        sb.AppendItem(EmotionValue, "EmotionValue");
                    }
                    if ((printMask?.PlayerHeadTrackingActorIds?.Overall ?? true)
                        && PlayerHeadTrackingActorIds is {} PlayerHeadTrackingActorIdsItem)
                    {
                        sb.AppendLine("PlayerHeadTrackingActorIds =>");
                        using (sb.Brace())
                        {
                            sb.AppendItem(PlayerHeadTrackingActorIdsItem.Overall);
                            if (PlayerHeadTrackingActorIdsItem.Specific != null)
                            {
                                foreach (var subItem in PlayerHeadTrackingActorIdsItem.Specific)
                                {
                                    using (sb.Brace())
                                    {
                                        {
                                            sb.AppendItem(subItem);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (printMask?.DialogueSubtype ?? true)
                    {
                        sb.AppendItem(DialogueSubtype, "DialogueSubtype");
                    }
                    if (printMask?.AnimArchType ?? true)
                    {
                        sb.AppendItem(AnimArchType, "AnimArchType");
                    }
                    if (printMask?.AudioOutputOverride ?? true)
                    {
                        sb.AppendItem(AudioOutputOverride, "AudioOutputOverride");
                    }
                    if (printMask?.Unused?.Overall ?? true)
                    {
                        Unused?.Print(sb);
                    }
                }
            }
            #endregion

        }

        public class ErrorMask :
            IErrorMask,
            IErrorMask<ErrorMask>
        {
            #region Members
            public Exception? Overall { get; set; }
            private List<string>? _warnings;
            public List<string> Warnings
            {
                get
                {
                    if (_warnings == null)
                    {
                        _warnings = new List<string>();
                    }
                    return _warnings;
                }
            }
            public MaskItem<Exception?, ASceneActionType.ErrorMask?>? Type;
            public Exception? Name;
            public Exception? AliasID;
            public Exception? Index;
            public Exception? Flags;
            public Exception? StartPhase;
            public Exception? EndPhase;
            public Exception? TimerMaxSeconds;
            public Exception? SetParentQuestStage;
            public Exception? TimerMinSeconds;
            public Exception? STSC;
            public MaskItem<Exception?, IEnumerable<MaskItem<Exception?, StartScene.ErrorMask?>>?>? StartScenes;
            public Exception? PlayerPositiveResponse;
            public Exception? PlayerNegativeResponse;
            public Exception? PlayerNeutralResponse;
            public Exception? PlayerQuestionResponse;
            public Exception? PlayerPositiveSubtype;
            public Exception? PlayerNegativeSubtype;
            public Exception? PlayerNeutralSubtype;
            public Exception? PlayerQuestionSubtype;
            public MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>? NpcHeadtrackingActorIds;
            public Exception? NpcPositiveResponse;
            public Exception? NpcNegativeResponse;
            public Exception? NpcNeutralResponse;
            public Exception? NpcQuestionResponse;
            public Exception? NpcPositiveSubtype;
            public Exception? NpcNegativeSubtype;
            public Exception? NpcNeutralSubtype;
            public Exception? NpcQuestionSubtype;
            public Exception? DialogueTargetActorId;
            public MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>? Packages;
            public Exception? Topic;
            public Exception? LoopingMax;
            public Exception? LoopingMin;
            public MaskItem<Exception?, SceneCamera.ErrorMask?>? Camera;
            public Exception? Emotion;
            public Exception? EmotionValue;
            public MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>? PlayerHeadTrackingActorIds;
            public Exception? DialogueSubtype;
            public Exception? AnimArchType;
            public Exception? AudioOutputOverride;
            public MaskItem<Exception?, ScenePhaseUnusedData.ErrorMask?>? Unused;
            #endregion

            #region IErrorMask
            public object? GetNthMask(int index)
            {
                SceneAction_FieldIndex enu = (SceneAction_FieldIndex)index;
                switch (enu)
                {
                    case SceneAction_FieldIndex.Type:
                        return Type;
                    case SceneAction_FieldIndex.Name:
                        return Name;
                    case SceneAction_FieldIndex.AliasID:
                        return AliasID;
                    case SceneAction_FieldIndex.Index:
                        return Index;
                    case SceneAction_FieldIndex.Flags:
                        return Flags;
                    case SceneAction_FieldIndex.StartPhase:
                        return StartPhase;
                    case SceneAction_FieldIndex.EndPhase:
                        return EndPhase;
                    case SceneAction_FieldIndex.TimerMaxSeconds:
                        return TimerMaxSeconds;
                    case SceneAction_FieldIndex.SetParentQuestStage:
                        return SetParentQuestStage;
                    case SceneAction_FieldIndex.TimerMinSeconds:
                        return TimerMinSeconds;
                    case SceneAction_FieldIndex.STSC:
                        return STSC;
                    case SceneAction_FieldIndex.StartScenes:
                        return StartScenes;
                    case SceneAction_FieldIndex.PlayerPositiveResponse:
                        return PlayerPositiveResponse;
                    case SceneAction_FieldIndex.PlayerNegativeResponse:
                        return PlayerNegativeResponse;
                    case SceneAction_FieldIndex.PlayerNeutralResponse:
                        return PlayerNeutralResponse;
                    case SceneAction_FieldIndex.PlayerQuestionResponse:
                        return PlayerQuestionResponse;
                    case SceneAction_FieldIndex.PlayerPositiveSubtype:
                        return PlayerPositiveSubtype;
                    case SceneAction_FieldIndex.PlayerNegativeSubtype:
                        return PlayerNegativeSubtype;
                    case SceneAction_FieldIndex.PlayerNeutralSubtype:
                        return PlayerNeutralSubtype;
                    case SceneAction_FieldIndex.PlayerQuestionSubtype:
                        return PlayerQuestionSubtype;
                    case SceneAction_FieldIndex.NpcHeadtrackingActorIds:
                        return NpcHeadtrackingActorIds;
                    case SceneAction_FieldIndex.NpcPositiveResponse:
                        return NpcPositiveResponse;
                    case SceneAction_FieldIndex.NpcNegativeResponse:
                        return NpcNegativeResponse;
                    case SceneAction_FieldIndex.NpcNeutralResponse:
                        return NpcNeutralResponse;
                    case SceneAction_FieldIndex.NpcQuestionResponse:
                        return NpcQuestionResponse;
                    case SceneAction_FieldIndex.NpcPositiveSubtype:
                        return NpcPositiveSubtype;
                    case SceneAction_FieldIndex.NpcNegativeSubtype:
                        return NpcNegativeSubtype;
                    case SceneAction_FieldIndex.NpcNeutralSubtype:
                        return NpcNeutralSubtype;
                    case SceneAction_FieldIndex.NpcQuestionSubtype:
                        return NpcQuestionSubtype;
                    case SceneAction_FieldIndex.DialogueTargetActorId:
                        return DialogueTargetActorId;
                    case SceneAction_FieldIndex.Packages:
                        return Packages;
                    case SceneAction_FieldIndex.Topic:
                        return Topic;
                    case SceneAction_FieldIndex.LoopingMax:
                        return LoopingMax;
                    case SceneAction_FieldIndex.LoopingMin:
                        return LoopingMin;
                    case SceneAction_FieldIndex.Camera:
                        return Camera;
                    case SceneAction_FieldIndex.Emotion:
                        return Emotion;
                    case SceneAction_FieldIndex.EmotionValue:
                        return EmotionValue;
                    case SceneAction_FieldIndex.PlayerHeadTrackingActorIds:
                        return PlayerHeadTrackingActorIds;
                    case SceneAction_FieldIndex.DialogueSubtype:
                        return DialogueSubtype;
                    case SceneAction_FieldIndex.AnimArchType:
                        return AnimArchType;
                    case SceneAction_FieldIndex.AudioOutputOverride:
                        return AudioOutputOverride;
                    case SceneAction_FieldIndex.Unused:
                        return Unused;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthException(int index, Exception ex)
            {
                SceneAction_FieldIndex enu = (SceneAction_FieldIndex)index;
                switch (enu)
                {
                    case SceneAction_FieldIndex.Type:
                        this.Type = new MaskItem<Exception?, ASceneActionType.ErrorMask?>(ex, null);
                        break;
                    case SceneAction_FieldIndex.Name:
                        this.Name = ex;
                        break;
                    case SceneAction_FieldIndex.AliasID:
                        this.AliasID = ex;
                        break;
                    case SceneAction_FieldIndex.Index:
                        this.Index = ex;
                        break;
                    case SceneAction_FieldIndex.Flags:
                        this.Flags = ex;
                        break;
                    case SceneAction_FieldIndex.StartPhase:
                        this.StartPhase = ex;
                        break;
                    case SceneAction_FieldIndex.EndPhase:
                        this.EndPhase = ex;
                        break;
                    case SceneAction_FieldIndex.TimerMaxSeconds:
                        this.TimerMaxSeconds = ex;
                        break;
                    case SceneAction_FieldIndex.SetParentQuestStage:
                        this.SetParentQuestStage = ex;
                        break;
                    case SceneAction_FieldIndex.TimerMinSeconds:
                        this.TimerMinSeconds = ex;
                        break;
                    case SceneAction_FieldIndex.STSC:
                        this.STSC = ex;
                        break;
                    case SceneAction_FieldIndex.StartScenes:
                        this.StartScenes = new MaskItem<Exception?, IEnumerable<MaskItem<Exception?, StartScene.ErrorMask?>>?>(ex, null);
                        break;
                    case SceneAction_FieldIndex.PlayerPositiveResponse:
                        this.PlayerPositiveResponse = ex;
                        break;
                    case SceneAction_FieldIndex.PlayerNegativeResponse:
                        this.PlayerNegativeResponse = ex;
                        break;
                    case SceneAction_FieldIndex.PlayerNeutralResponse:
                        this.PlayerNeutralResponse = ex;
                        break;
                    case SceneAction_FieldIndex.PlayerQuestionResponse:
                        this.PlayerQuestionResponse = ex;
                        break;
                    case SceneAction_FieldIndex.PlayerPositiveSubtype:
                        this.PlayerPositiveSubtype = ex;
                        break;
                    case SceneAction_FieldIndex.PlayerNegativeSubtype:
                        this.PlayerNegativeSubtype = ex;
                        break;
                    case SceneAction_FieldIndex.PlayerNeutralSubtype:
                        this.PlayerNeutralSubtype = ex;
                        break;
                    case SceneAction_FieldIndex.PlayerQuestionSubtype:
                        this.PlayerQuestionSubtype = ex;
                        break;
                    case SceneAction_FieldIndex.NpcHeadtrackingActorIds:
                        this.NpcHeadtrackingActorIds = new MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>(ex, null);
                        break;
                    case SceneAction_FieldIndex.NpcPositiveResponse:
                        this.NpcPositiveResponse = ex;
                        break;
                    case SceneAction_FieldIndex.NpcNegativeResponse:
                        this.NpcNegativeResponse = ex;
                        break;
                    case SceneAction_FieldIndex.NpcNeutralResponse:
                        this.NpcNeutralResponse = ex;
                        break;
                    case SceneAction_FieldIndex.NpcQuestionResponse:
                        this.NpcQuestionResponse = ex;
                        break;
                    case SceneAction_FieldIndex.NpcPositiveSubtype:
                        this.NpcPositiveSubtype = ex;
                        break;
                    case SceneAction_FieldIndex.NpcNegativeSubtype:
                        this.NpcNegativeSubtype = ex;
                        break;
                    case SceneAction_FieldIndex.NpcNeutralSubtype:
                        this.NpcNeutralSubtype = ex;
                        break;
                    case SceneAction_FieldIndex.NpcQuestionSubtype:
                        this.NpcQuestionSubtype = ex;
                        break;
                    case SceneAction_FieldIndex.DialogueTargetActorId:
                        this.DialogueTargetActorId = ex;
                        break;
                    case SceneAction_FieldIndex.Packages:
                        this.Packages = new MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>(ex, null);
                        break;
                    case SceneAction_FieldIndex.Topic:
                        this.Topic = ex;
                        break;
                    case SceneAction_FieldIndex.LoopingMax:
                        this.LoopingMax = ex;
                        break;
                    case SceneAction_FieldIndex.LoopingMin:
                        this.LoopingMin = ex;
                        break;
                    case SceneAction_FieldIndex.Camera:
                        this.Camera = new MaskItem<Exception?, SceneCamera.ErrorMask?>(ex, null);
                        break;
                    case SceneAction_FieldIndex.Emotion:
                        this.Emotion = ex;
                        break;
                    case SceneAction_FieldIndex.EmotionValue:
                        this.EmotionValue = ex;
                        break;
                    case SceneAction_FieldIndex.PlayerHeadTrackingActorIds:
                        this.PlayerHeadTrackingActorIds = new MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>(ex, null);
                        break;
                    case SceneAction_FieldIndex.DialogueSubtype:
                        this.DialogueSubtype = ex;
                        break;
                    case SceneAction_FieldIndex.AnimArchType:
                        this.AnimArchType = ex;
                        break;
                    case SceneAction_FieldIndex.AudioOutputOverride:
                        this.AudioOutputOverride = ex;
                        break;
                    case SceneAction_FieldIndex.Unused:
                        this.Unused = new MaskItem<Exception?, ScenePhaseUnusedData.ErrorMask?>(ex, null);
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthMask(int index, object obj)
            {
                SceneAction_FieldIndex enu = (SceneAction_FieldIndex)index;
                switch (enu)
                {
                    case SceneAction_FieldIndex.Type:
                        this.Type = (MaskItem<Exception?, ASceneActionType.ErrorMask?>?)obj;
                        break;
                    case SceneAction_FieldIndex.Name:
                        this.Name = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.AliasID:
                        this.AliasID = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.Index:
                        this.Index = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.Flags:
                        this.Flags = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.StartPhase:
                        this.StartPhase = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.EndPhase:
                        this.EndPhase = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.TimerMaxSeconds:
                        this.TimerMaxSeconds = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.SetParentQuestStage:
                        this.SetParentQuestStage = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.TimerMinSeconds:
                        this.TimerMinSeconds = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.STSC:
                        this.STSC = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.StartScenes:
                        this.StartScenes = (MaskItem<Exception?, IEnumerable<MaskItem<Exception?, StartScene.ErrorMask?>>?>)obj;
                        break;
                    case SceneAction_FieldIndex.PlayerPositiveResponse:
                        this.PlayerPositiveResponse = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.PlayerNegativeResponse:
                        this.PlayerNegativeResponse = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.PlayerNeutralResponse:
                        this.PlayerNeutralResponse = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.PlayerQuestionResponse:
                        this.PlayerQuestionResponse = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.PlayerPositiveSubtype:
                        this.PlayerPositiveSubtype = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.PlayerNegativeSubtype:
                        this.PlayerNegativeSubtype = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.PlayerNeutralSubtype:
                        this.PlayerNeutralSubtype = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.PlayerQuestionSubtype:
                        this.PlayerQuestionSubtype = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.NpcHeadtrackingActorIds:
                        this.NpcHeadtrackingActorIds = (MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>)obj;
                        break;
                    case SceneAction_FieldIndex.NpcPositiveResponse:
                        this.NpcPositiveResponse = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.NpcNegativeResponse:
                        this.NpcNegativeResponse = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.NpcNeutralResponse:
                        this.NpcNeutralResponse = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.NpcQuestionResponse:
                        this.NpcQuestionResponse = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.NpcPositiveSubtype:
                        this.NpcPositiveSubtype = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.NpcNegativeSubtype:
                        this.NpcNegativeSubtype = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.NpcNeutralSubtype:
                        this.NpcNeutralSubtype = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.NpcQuestionSubtype:
                        this.NpcQuestionSubtype = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.DialogueTargetActorId:
                        this.DialogueTargetActorId = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.Packages:
                        this.Packages = (MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>)obj;
                        break;
                    case SceneAction_FieldIndex.Topic:
                        this.Topic = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.LoopingMax:
                        this.LoopingMax = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.LoopingMin:
                        this.LoopingMin = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.Camera:
                        this.Camera = (MaskItem<Exception?, SceneCamera.ErrorMask?>?)obj;
                        break;
                    case SceneAction_FieldIndex.Emotion:
                        this.Emotion = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.EmotionValue:
                        this.EmotionValue = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.PlayerHeadTrackingActorIds:
                        this.PlayerHeadTrackingActorIds = (MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>)obj;
                        break;
                    case SceneAction_FieldIndex.DialogueSubtype:
                        this.DialogueSubtype = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.AnimArchType:
                        this.AnimArchType = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.AudioOutputOverride:
                        this.AudioOutputOverride = (Exception?)obj;
                        break;
                    case SceneAction_FieldIndex.Unused:
                        this.Unused = (MaskItem<Exception?, ScenePhaseUnusedData.ErrorMask?>?)obj;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public bool IsInError()
            {
                if (Overall != null) return true;
                if (Type != null) return true;
                if (Name != null) return true;
                if (AliasID != null) return true;
                if (Index != null) return true;
                if (Flags != null) return true;
                if (StartPhase != null) return true;
                if (EndPhase != null) return true;
                if (TimerMaxSeconds != null) return true;
                if (SetParentQuestStage != null) return true;
                if (TimerMinSeconds != null) return true;
                if (STSC != null) return true;
                if (StartScenes != null) return true;
                if (PlayerPositiveResponse != null) return true;
                if (PlayerNegativeResponse != null) return true;
                if (PlayerNeutralResponse != null) return true;
                if (PlayerQuestionResponse != null) return true;
                if (PlayerPositiveSubtype != null) return true;
                if (PlayerNegativeSubtype != null) return true;
                if (PlayerNeutralSubtype != null) return true;
                if (PlayerQuestionSubtype != null) return true;
                if (NpcHeadtrackingActorIds != null) return true;
                if (NpcPositiveResponse != null) return true;
                if (NpcNegativeResponse != null) return true;
                if (NpcNeutralResponse != null) return true;
                if (NpcQuestionResponse != null) return true;
                if (NpcPositiveSubtype != null) return true;
                if (NpcNegativeSubtype != null) return true;
                if (NpcNeutralSubtype != null) return true;
                if (NpcQuestionSubtype != null) return true;
                if (DialogueTargetActorId != null) return true;
                if (Packages != null) return true;
                if (Topic != null) return true;
                if (LoopingMax != null) return true;
                if (LoopingMin != null) return true;
                if (Camera != null) return true;
                if (Emotion != null) return true;
                if (EmotionValue != null) return true;
                if (PlayerHeadTrackingActorIds != null) return true;
                if (DialogueSubtype != null) return true;
                if (AnimArchType != null) return true;
                if (AudioOutputOverride != null) return true;
                if (Unused != null) return true;
                return false;
            }
            #endregion

            #region To String
            public override string ToString() => this.Print();

            public void Print(StructuredStringBuilder sb, string? name = null)
            {
                sb.AppendLine($"{(name ?? "ErrorMask")} =>");
                using (sb.Brace())
                {
                    if (this.Overall != null)
                    {
                        sb.AppendLine("Overall =>");
                        using (sb.Brace())
                        {
                            sb.AppendLine($"{this.Overall}");
                        }
                    }
                    PrintFillInternal(sb);
                }
            }
            protected void PrintFillInternal(StructuredStringBuilder sb)
            {
                Type?.Print(sb);
                {
                    sb.AppendItem(Name, "Name");
                }
                {
                    sb.AppendItem(AliasID, "AliasID");
                }
                {
                    sb.AppendItem(Index, "Index");
                }
                {
                    sb.AppendItem(Flags, "Flags");
                }
                {
                    sb.AppendItem(StartPhase, "StartPhase");
                }
                {
                    sb.AppendItem(EndPhase, "EndPhase");
                }
                {
                    sb.AppendItem(TimerMaxSeconds, "TimerMaxSeconds");
                }
                {
                    sb.AppendItem(SetParentQuestStage, "SetParentQuestStage");
                }
                {
                    sb.AppendItem(TimerMinSeconds, "TimerMinSeconds");
                }
                {
                    sb.AppendItem(STSC, "STSC");
                }
                if (StartScenes is {} StartScenesItem)
                {
                    sb.AppendLine("StartScenes =>");
                    using (sb.Brace())
                    {
                        sb.AppendItem(StartScenesItem.Overall);
                        if (StartScenesItem.Specific != null)
                        {
                            foreach (var subItem in StartScenesItem.Specific)
                            {
                                using (sb.Brace())
                                {
                                    subItem?.Print(sb);
                                }
                            }
                        }
                    }
                }
                {
                    sb.AppendItem(PlayerPositiveResponse, "PlayerPositiveResponse");
                }
                {
                    sb.AppendItem(PlayerNegativeResponse, "PlayerNegativeResponse");
                }
                {
                    sb.AppendItem(PlayerNeutralResponse, "PlayerNeutralResponse");
                }
                {
                    sb.AppendItem(PlayerQuestionResponse, "PlayerQuestionResponse");
                }
                {
                    sb.AppendItem(PlayerPositiveSubtype, "PlayerPositiveSubtype");
                }
                {
                    sb.AppendItem(PlayerNegativeSubtype, "PlayerNegativeSubtype");
                }
                {
                    sb.AppendItem(PlayerNeutralSubtype, "PlayerNeutralSubtype");
                }
                {
                    sb.AppendItem(PlayerQuestionSubtype, "PlayerQuestionSubtype");
                }
                if (NpcHeadtrackingActorIds is {} NpcHeadtrackingActorIdsItem)
                {
                    sb.AppendLine("NpcHeadtrackingActorIds =>");
                    using (sb.Brace())
                    {
                        sb.AppendItem(NpcHeadtrackingActorIdsItem.Overall);
                        if (NpcHeadtrackingActorIdsItem.Specific != null)
                        {
                            foreach (var subItem in NpcHeadtrackingActorIdsItem.Specific)
                            {
                                using (sb.Brace())
                                {
                                    {
                                        sb.AppendItem(subItem);
                                    }
                                }
                            }
                        }
                    }
                }
                {
                    sb.AppendItem(NpcPositiveResponse, "NpcPositiveResponse");
                }
                {
                    sb.AppendItem(NpcNegativeResponse, "NpcNegativeResponse");
                }
                {
                    sb.AppendItem(NpcNeutralResponse, "NpcNeutralResponse");
                }
                {
                    sb.AppendItem(NpcQuestionResponse, "NpcQuestionResponse");
                }
                {
                    sb.AppendItem(NpcPositiveSubtype, "NpcPositiveSubtype");
                }
                {
                    sb.AppendItem(NpcNegativeSubtype, "NpcNegativeSubtype");
                }
                {
                    sb.AppendItem(NpcNeutralSubtype, "NpcNeutralSubtype");
                }
                {
                    sb.AppendItem(NpcQuestionSubtype, "NpcQuestionSubtype");
                }
                {
                    sb.AppendItem(DialogueTargetActorId, "DialogueTargetActorId");
                }
                if (Packages is {} PackagesItem)
                {
                    sb.AppendLine("Packages =>");
                    using (sb.Brace())
                    {
                        sb.AppendItem(PackagesItem.Overall);
                        if (PackagesItem.Specific != null)
                        {
                            foreach (var subItem in PackagesItem.Specific)
                            {
                                using (sb.Brace())
                                {
                                    {
                                        sb.AppendItem(subItem);
                                    }
                                }
                            }
                        }
                    }
                }
                {
                    sb.AppendItem(Topic, "Topic");
                }
                {
                    sb.AppendItem(LoopingMax, "LoopingMax");
                }
                {
                    sb.AppendItem(LoopingMin, "LoopingMin");
                }
                Camera?.Print(sb);
                {
                    sb.AppendItem(Emotion, "Emotion");
                }
                {
                    sb.AppendItem(EmotionValue, "EmotionValue");
                }
                if (PlayerHeadTrackingActorIds is {} PlayerHeadTrackingActorIdsItem)
                {
                    sb.AppendLine("PlayerHeadTrackingActorIds =>");
                    using (sb.Brace())
                    {
                        sb.AppendItem(PlayerHeadTrackingActorIdsItem.Overall);
                        if (PlayerHeadTrackingActorIdsItem.Specific != null)
                        {
                            foreach (var subItem in PlayerHeadTrackingActorIdsItem.Specific)
                            {
                                using (sb.Brace())
                                {
                                    {
                                        sb.AppendItem(subItem);
                                    }
                                }
                            }
                        }
                    }
                }
                {
                    sb.AppendItem(DialogueSubtype, "DialogueSubtype");
                }
                {
                    sb.AppendItem(AnimArchType, "AnimArchType");
                }
                {
                    sb.AppendItem(AudioOutputOverride, "AudioOutputOverride");
                }
                Unused?.Print(sb);
            }
            #endregion

            #region Combine
            public ErrorMask Combine(ErrorMask? rhs)
            {
                if (rhs == null) return this;
                var ret = new ErrorMask();
                ret.Type = this.Type.Combine(rhs.Type, (l, r) => l.Combine(r));
                ret.Name = this.Name.Combine(rhs.Name);
                ret.AliasID = this.AliasID.Combine(rhs.AliasID);
                ret.Index = this.Index.Combine(rhs.Index);
                ret.Flags = this.Flags.Combine(rhs.Flags);
                ret.StartPhase = this.StartPhase.Combine(rhs.StartPhase);
                ret.EndPhase = this.EndPhase.Combine(rhs.EndPhase);
                ret.TimerMaxSeconds = this.TimerMaxSeconds.Combine(rhs.TimerMaxSeconds);
                ret.SetParentQuestStage = this.SetParentQuestStage.Combine(rhs.SetParentQuestStage);
                ret.TimerMinSeconds = this.TimerMinSeconds.Combine(rhs.TimerMinSeconds);
                ret.STSC = this.STSC.Combine(rhs.STSC);
                ret.StartScenes = new MaskItem<Exception?, IEnumerable<MaskItem<Exception?, StartScene.ErrorMask?>>?>(Noggog.ExceptionExt.Combine(this.StartScenes?.Overall, rhs.StartScenes?.Overall), Noggog.ExceptionExt.Combine(this.StartScenes?.Specific, rhs.StartScenes?.Specific));
                ret.PlayerPositiveResponse = this.PlayerPositiveResponse.Combine(rhs.PlayerPositiveResponse);
                ret.PlayerNegativeResponse = this.PlayerNegativeResponse.Combine(rhs.PlayerNegativeResponse);
                ret.PlayerNeutralResponse = this.PlayerNeutralResponse.Combine(rhs.PlayerNeutralResponse);
                ret.PlayerQuestionResponse = this.PlayerQuestionResponse.Combine(rhs.PlayerQuestionResponse);
                ret.PlayerPositiveSubtype = this.PlayerPositiveSubtype.Combine(rhs.PlayerPositiveSubtype);
                ret.PlayerNegativeSubtype = this.PlayerNegativeSubtype.Combine(rhs.PlayerNegativeSubtype);
                ret.PlayerNeutralSubtype = this.PlayerNeutralSubtype.Combine(rhs.PlayerNeutralSubtype);
                ret.PlayerQuestionSubtype = this.PlayerQuestionSubtype.Combine(rhs.PlayerQuestionSubtype);
                ret.NpcHeadtrackingActorIds = new MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>(Noggog.ExceptionExt.Combine(this.NpcHeadtrackingActorIds?.Overall, rhs.NpcHeadtrackingActorIds?.Overall), Noggog.ExceptionExt.Combine(this.NpcHeadtrackingActorIds?.Specific, rhs.NpcHeadtrackingActorIds?.Specific));
                ret.NpcPositiveResponse = this.NpcPositiveResponse.Combine(rhs.NpcPositiveResponse);
                ret.NpcNegativeResponse = this.NpcNegativeResponse.Combine(rhs.NpcNegativeResponse);
                ret.NpcNeutralResponse = this.NpcNeutralResponse.Combine(rhs.NpcNeutralResponse);
                ret.NpcQuestionResponse = this.NpcQuestionResponse.Combine(rhs.NpcQuestionResponse);
                ret.NpcPositiveSubtype = this.NpcPositiveSubtype.Combine(rhs.NpcPositiveSubtype);
                ret.NpcNegativeSubtype = this.NpcNegativeSubtype.Combine(rhs.NpcNegativeSubtype);
                ret.NpcNeutralSubtype = this.NpcNeutralSubtype.Combine(rhs.NpcNeutralSubtype);
                ret.NpcQuestionSubtype = this.NpcQuestionSubtype.Combine(rhs.NpcQuestionSubtype);
                ret.DialogueTargetActorId = this.DialogueTargetActorId.Combine(rhs.DialogueTargetActorId);
                ret.Packages = new MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>(Noggog.ExceptionExt.Combine(this.Packages?.Overall, rhs.Packages?.Overall), Noggog.ExceptionExt.Combine(this.Packages?.Specific, rhs.Packages?.Specific));
                ret.Topic = this.Topic.Combine(rhs.Topic);
                ret.LoopingMax = this.LoopingMax.Combine(rhs.LoopingMax);
                ret.LoopingMin = this.LoopingMin.Combine(rhs.LoopingMin);
                ret.Camera = this.Camera.Combine(rhs.Camera, (l, r) => l.Combine(r));
                ret.Emotion = this.Emotion.Combine(rhs.Emotion);
                ret.EmotionValue = this.EmotionValue.Combine(rhs.EmotionValue);
                ret.PlayerHeadTrackingActorIds = new MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>(Noggog.ExceptionExt.Combine(this.PlayerHeadTrackingActorIds?.Overall, rhs.PlayerHeadTrackingActorIds?.Overall), Noggog.ExceptionExt.Combine(this.PlayerHeadTrackingActorIds?.Specific, rhs.PlayerHeadTrackingActorIds?.Specific));
                ret.DialogueSubtype = this.DialogueSubtype.Combine(rhs.DialogueSubtype);
                ret.AnimArchType = this.AnimArchType.Combine(rhs.AnimArchType);
                ret.AudioOutputOverride = this.AudioOutputOverride.Combine(rhs.AudioOutputOverride);
                ret.Unused = this.Unused.Combine(rhs.Unused, (l, r) => l.Combine(r));
                return ret;
            }
            public static ErrorMask? Combine(ErrorMask? lhs, ErrorMask? rhs)
            {
                if (lhs != null && rhs != null) return lhs.Combine(rhs);
                return lhs ?? rhs;
            }
            #endregion

            #region Factory
            public static ErrorMask Factory(ErrorMaskBuilder errorMask)
            {
                return new ErrorMask();
            }
            #endregion

        }
        public class TranslationMask : ITranslationMask
        {
            #region Members
            private TranslationCrystal? _crystal;
            public readonly bool DefaultOn;
            public bool OnOverall;
            public ASceneActionType.TranslationMask? Type;
            public bool Name;
            public bool AliasID;
            public bool Index;
            public bool Flags;
            public bool StartPhase;
            public bool EndPhase;
            public bool TimerMaxSeconds;
            public bool SetParentQuestStage;
            public bool TimerMinSeconds;
            public bool STSC;
            public StartScene.TranslationMask? StartScenes;
            public bool PlayerPositiveResponse;
            public bool PlayerNegativeResponse;
            public bool PlayerNeutralResponse;
            public bool PlayerQuestionResponse;
            public bool PlayerPositiveSubtype;
            public bool PlayerNegativeSubtype;
            public bool PlayerNeutralSubtype;
            public bool PlayerQuestionSubtype;
            public bool NpcHeadtrackingActorIds;
            public bool NpcPositiveResponse;
            public bool NpcNegativeResponse;
            public bool NpcNeutralResponse;
            public bool NpcQuestionResponse;
            public bool NpcPositiveSubtype;
            public bool NpcNegativeSubtype;
            public bool NpcNeutralSubtype;
            public bool NpcQuestionSubtype;
            public bool DialogueTargetActorId;
            public bool Packages;
            public bool Topic;
            public bool LoopingMax;
            public bool LoopingMin;
            public SceneCamera.TranslationMask? Camera;
            public bool Emotion;
            public bool EmotionValue;
            public bool PlayerHeadTrackingActorIds;
            public bool DialogueSubtype;
            public bool AnimArchType;
            public bool AudioOutputOverride;
            public ScenePhaseUnusedData.TranslationMask? Unused;
            #endregion

            #region Ctors
            public TranslationMask(
                bool defaultOn,
                bool onOverall = true)
            {
                this.DefaultOn = defaultOn;
                this.OnOverall = onOverall;
                this.Name = defaultOn;
                this.AliasID = defaultOn;
                this.Index = defaultOn;
                this.Flags = defaultOn;
                this.StartPhase = defaultOn;
                this.EndPhase = defaultOn;
                this.TimerMaxSeconds = defaultOn;
                this.SetParentQuestStage = defaultOn;
                this.TimerMinSeconds = defaultOn;
                this.STSC = defaultOn;
                this.PlayerPositiveResponse = defaultOn;
                this.PlayerNegativeResponse = defaultOn;
                this.PlayerNeutralResponse = defaultOn;
                this.PlayerQuestionResponse = defaultOn;
                this.PlayerPositiveSubtype = defaultOn;
                this.PlayerNegativeSubtype = defaultOn;
                this.PlayerNeutralSubtype = defaultOn;
                this.PlayerQuestionSubtype = defaultOn;
                this.NpcHeadtrackingActorIds = defaultOn;
                this.NpcPositiveResponse = defaultOn;
                this.NpcNegativeResponse = defaultOn;
                this.NpcNeutralResponse = defaultOn;
                this.NpcQuestionResponse = defaultOn;
                this.NpcPositiveSubtype = defaultOn;
                this.NpcNegativeSubtype = defaultOn;
                this.NpcNeutralSubtype = defaultOn;
                this.NpcQuestionSubtype = defaultOn;
                this.DialogueTargetActorId = defaultOn;
                this.Packages = defaultOn;
                this.Topic = defaultOn;
                this.LoopingMax = defaultOn;
                this.LoopingMin = defaultOn;
                this.Emotion = defaultOn;
                this.EmotionValue = defaultOn;
                this.PlayerHeadTrackingActorIds = defaultOn;
                this.DialogueSubtype = defaultOn;
                this.AnimArchType = defaultOn;
                this.AudioOutputOverride = defaultOn;
            }

            #endregion

            public TranslationCrystal GetCrystal()
            {
                if (_crystal != null) return _crystal;
                var ret = new List<(bool On, TranslationCrystal? SubCrystal)>();
                GetCrystal(ret);
                _crystal = new TranslationCrystal(ret.ToArray());
                return _crystal;
            }

            protected void GetCrystal(List<(bool On, TranslationCrystal? SubCrystal)> ret)
            {
                ret.Add((Type != null ? Type.OnOverall : DefaultOn, Type?.GetCrystal()));
                ret.Add((Name, null));
                ret.Add((AliasID, null));
                ret.Add((Index, null));
                ret.Add((Flags, null));
                ret.Add((StartPhase, null));
                ret.Add((EndPhase, null));
                ret.Add((TimerMaxSeconds, null));
                ret.Add((SetParentQuestStage, null));
                ret.Add((TimerMinSeconds, null));
                ret.Add((STSC, null));
                ret.Add((StartScenes == null ? DefaultOn : !StartScenes.GetCrystal().CopyNothing, StartScenes?.GetCrystal()));
                ret.Add((PlayerPositiveResponse, null));
                ret.Add((PlayerNegativeResponse, null));
                ret.Add((PlayerNeutralResponse, null));
                ret.Add((PlayerQuestionResponse, null));
                ret.Add((PlayerPositiveSubtype, null));
                ret.Add((PlayerNegativeSubtype, null));
                ret.Add((PlayerNeutralSubtype, null));
                ret.Add((PlayerQuestionSubtype, null));
                ret.Add((NpcHeadtrackingActorIds, null));
                ret.Add((NpcPositiveResponse, null));
                ret.Add((NpcNegativeResponse, null));
                ret.Add((NpcNeutralResponse, null));
                ret.Add((NpcQuestionResponse, null));
                ret.Add((NpcPositiveSubtype, null));
                ret.Add((NpcNegativeSubtype, null));
                ret.Add((NpcNeutralSubtype, null));
                ret.Add((NpcQuestionSubtype, null));
                ret.Add((DialogueTargetActorId, null));
                ret.Add((Packages, null));
                ret.Add((Topic, null));
                ret.Add((LoopingMax, null));
                ret.Add((LoopingMin, null));
                ret.Add((Camera != null ? Camera.OnOverall : DefaultOn, Camera?.GetCrystal()));
                ret.Add((Emotion, null));
                ret.Add((EmotionValue, null));
                ret.Add((PlayerHeadTrackingActorIds, null));
                ret.Add((DialogueSubtype, null));
                ret.Add((AnimArchType, null));
                ret.Add((AudioOutputOverride, null));
                ret.Add((Unused != null ? Unused.OnOverall : DefaultOn, Unused?.GetCrystal()));
            }

            public static implicit operator TranslationMask(bool defaultOn)
            {
                return new TranslationMask(defaultOn: defaultOn, onOverall: defaultOn);
            }

        }
        #endregion

        #region Mutagen
        public IEnumerable<IFormLinkGetter> EnumerateFormLinks() => SceneActionCommon.Instance.EnumerateFormLinks(this);
        public void RemapLinks(IReadOnlyDictionary<FormKey, FormKey> mapping) => SceneActionSetterCommon.Instance.RemapLinks(this, mapping);
        #endregion

        #region Binary Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => SceneActionBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((SceneActionBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }
        #region Binary Create
        public static SceneAction CreateFromBinary(
            MutagenFrame frame,
            TypedParseParams translationParams = default)
        {
            var ret = new SceneAction();
            ((SceneActionSetterCommon)((ISceneActionGetter)ret).CommonSetterInstance()!).CopyInFromBinary(
                item: ret,
                frame: frame,
                translationParams: translationParams);
            return ret;
        }

        #endregion

        public static bool TryCreateFromBinary(
            MutagenFrame frame,
            out SceneAction item,
            TypedParseParams translationParams = default)
        {
            var startPos = frame.Position;
            item = CreateFromBinary(
                frame: frame,
                translationParams: translationParams);
            return startPos != frame.Position;
        }
        #endregion

        void IPrintable.Print(StructuredStringBuilder sb, string? name) => this.Print(sb, name);

        void IClearable.Clear()
        {
            ((SceneActionSetterCommon)((ISceneActionGetter)this).CommonSetterInstance()!).Clear(this);
        }

        internal static SceneAction GetNew()
        {
            return new SceneAction();
        }

    }
    #endregion

    #region Interface
    public partial interface ISceneAction :
        IFormLinkContainer,
        ILoquiObjectSetter<ISceneAction>,
        INamed,
        INamedRequired,
        ISceneActionGetter
    {
        new ASceneActionType Type { get; set; }
        /// <summary>
        /// Aspects: INamed, INamedRequired
        /// </summary>
        new String? Name { get; set; }
        new Int32? AliasID { get; set; }
        new UInt32? Index { get; set; }
        new SceneAction.Flag? Flags { get; set; }
        new UInt32? StartPhase { get; set; }
        new UInt32? EndPhase { get; set; }
        new Single? TimerMaxSeconds { get; set; }
        new Int16? SetParentQuestStage { get; set; }
        new Single? TimerMinSeconds { get; set; }
        new MemorySlice<Byte>? STSC { get; set; }
        new ExtendedList<StartScene> StartScenes { get; }
        new IFormLinkNullable<IDialogTopicGetter> PlayerPositiveResponse { get; set; }
        new IFormLinkNullable<IDialogTopicGetter> PlayerNegativeResponse { get; set; }
        new IFormLinkNullable<IDialogTopicGetter> PlayerNeutralResponse { get; set; }
        new IFormLinkNullable<IDialogTopicGetter> PlayerQuestionResponse { get; set; }
        new IFormLinkNullable<IKeywordGetter> PlayerPositiveSubtype { get; set; }
        new IFormLinkNullable<IKeywordGetter> PlayerNegativeSubtype { get; set; }
        new IFormLinkNullable<IKeywordGetter> PlayerNeutralSubtype { get; set; }
        new IFormLinkNullable<IKeywordGetter> PlayerQuestionSubtype { get; set; }
        new ExtendedList<Int32>? NpcHeadtrackingActorIds { get; set; }
        new IFormLinkNullable<IDialogTopicGetter> NpcPositiveResponse { get; set; }
        new IFormLinkNullable<IDialogTopicGetter> NpcNegativeResponse { get; set; }
        new IFormLinkNullable<IDialogTopicGetter> NpcNeutralResponse { get; set; }
        new IFormLinkNullable<IDialogTopicGetter> NpcQuestionResponse { get; set; }
        new IFormLinkNullable<IKeywordGetter> NpcPositiveSubtype { get; set; }
        new IFormLinkNullable<IKeywordGetter> NpcNegativeSubtype { get; set; }
        new IFormLinkNullable<IKeywordGetter> NpcNeutralSubtype { get; set; }
        new IFormLinkNullable<IKeywordGetter> NpcQuestionSubtype { get; set; }
        new Int32? DialogueTargetActorId { get; set; }
        new ExtendedList<IFormLinkGetter<IPackageGetter>> Packages { get; }
        new IFormLinkNullable<IDialogTopicGetter> Topic { get; set; }
        new Single? LoopingMax { get; set; }
        new Single? LoopingMin { get; set; }
        new SceneCamera? Camera { get; set; }
        new Emotion? Emotion { get; set; }
        new UInt32? EmotionValue { get; set; }
        new ExtendedList<Int32>? PlayerHeadTrackingActorIds { get; set; }
        new IFormLinkNullable<IKeywordGetter> DialogueSubtype { get; set; }
        new IFormLinkNullable<IKeywordGetter> AnimArchType { get; set; }
        new IFormLinkNullable<ISoundOutputModelGetter> AudioOutputOverride { get; set; }
        new ScenePhaseUnusedData? Unused { get; set; }
    }

    public partial interface ISceneActionGetter :
        ILoquiObject,
        IBinaryItem,
        IFormLinkContainerGetter,
        ILoquiObject<ISceneActionGetter>,
        INamedGetter,
        INamedRequiredGetter
    {
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object? CommonSetterInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonSetterTranslationInstance();
        static ILoquiRegistration StaticRegistration => SceneAction_Registration.Instance;
        IASceneActionTypeGetter Type { get; }
        #region Name
        /// <summary>
        /// Aspects: INamedGetter, INamedRequiredGetter
        /// </summary>
        String? Name { get; }
        #endregion
        Int32? AliasID { get; }
        UInt32? Index { get; }
        SceneAction.Flag? Flags { get; }
        UInt32? StartPhase { get; }
        UInt32? EndPhase { get; }
        Single? TimerMaxSeconds { get; }
        Int16? SetParentQuestStage { get; }
        Single? TimerMinSeconds { get; }
        ReadOnlyMemorySlice<Byte>? STSC { get; }
        IReadOnlyList<IStartSceneGetter> StartScenes { get; }
        IFormLinkNullableGetter<IDialogTopicGetter> PlayerPositiveResponse { get; }
        IFormLinkNullableGetter<IDialogTopicGetter> PlayerNegativeResponse { get; }
        IFormLinkNullableGetter<IDialogTopicGetter> PlayerNeutralResponse { get; }
        IFormLinkNullableGetter<IDialogTopicGetter> PlayerQuestionResponse { get; }
        IFormLinkNullableGetter<IKeywordGetter> PlayerPositiveSubtype { get; }
        IFormLinkNullableGetter<IKeywordGetter> PlayerNegativeSubtype { get; }
        IFormLinkNullableGetter<IKeywordGetter> PlayerNeutralSubtype { get; }
        IFormLinkNullableGetter<IKeywordGetter> PlayerQuestionSubtype { get; }
        IReadOnlyList<Int32>? NpcHeadtrackingActorIds { get; }
        IFormLinkNullableGetter<IDialogTopicGetter> NpcPositiveResponse { get; }
        IFormLinkNullableGetter<IDialogTopicGetter> NpcNegativeResponse { get; }
        IFormLinkNullableGetter<IDialogTopicGetter> NpcNeutralResponse { get; }
        IFormLinkNullableGetter<IDialogTopicGetter> NpcQuestionResponse { get; }
        IFormLinkNullableGetter<IKeywordGetter> NpcPositiveSubtype { get; }
        IFormLinkNullableGetter<IKeywordGetter> NpcNegativeSubtype { get; }
        IFormLinkNullableGetter<IKeywordGetter> NpcNeutralSubtype { get; }
        IFormLinkNullableGetter<IKeywordGetter> NpcQuestionSubtype { get; }
        Int32? DialogueTargetActorId { get; }
        IReadOnlyList<IFormLinkGetter<IPackageGetter>> Packages { get; }
        IFormLinkNullableGetter<IDialogTopicGetter> Topic { get; }
        Single? LoopingMax { get; }
        Single? LoopingMin { get; }
        ISceneCameraGetter? Camera { get; }
        Emotion? Emotion { get; }
        UInt32? EmotionValue { get; }
        IReadOnlyList<Int32>? PlayerHeadTrackingActorIds { get; }
        IFormLinkNullableGetter<IKeywordGetter> DialogueSubtype { get; }
        IFormLinkNullableGetter<IKeywordGetter> AnimArchType { get; }
        IFormLinkNullableGetter<ISoundOutputModelGetter> AudioOutputOverride { get; }
        IScenePhaseUnusedDataGetter? Unused { get; }

    }

    #endregion

    #region Common MixIn
    public static partial class SceneActionMixIn
    {
        public static void Clear(this ISceneAction item)
        {
            ((SceneActionSetterCommon)((ISceneActionGetter)item).CommonSetterInstance()!).Clear(item: item);
        }

        public static SceneAction.Mask<bool> GetEqualsMask(
            this ISceneActionGetter item,
            ISceneActionGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            return ((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).GetEqualsMask(
                item: item,
                rhs: rhs,
                include: include);
        }

        public static string Print(
            this ISceneActionGetter item,
            string? name = null,
            SceneAction.Mask<bool>? printMask = null)
        {
            return ((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).Print(
                item: item,
                name: name,
                printMask: printMask);
        }

        public static void Print(
            this ISceneActionGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            SceneAction.Mask<bool>? printMask = null)
        {
            ((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).Print(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
        }

        public static bool Equals(
            this ISceneActionGetter item,
            ISceneActionGetter rhs,
            SceneAction.TranslationMask? equalsMask = null)
        {
            return ((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).Equals(
                lhs: item,
                rhs: rhs,
                equalsMask: equalsMask?.GetCrystal());
        }

        public static void DeepCopyIn(
            this ISceneAction lhs,
            ISceneActionGetter rhs)
        {
            ((SceneActionSetterTranslationCommon)((ISceneActionGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: default,
                deepCopy: false);
        }

        public static void DeepCopyIn(
            this ISceneAction lhs,
            ISceneActionGetter rhs,
            SceneAction.TranslationMask? copyMask = null)
        {
            ((SceneActionSetterTranslationCommon)((ISceneActionGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
        }

        public static void DeepCopyIn(
            this ISceneAction lhs,
            ISceneActionGetter rhs,
            out SceneAction.ErrorMask errorMask,
            SceneAction.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            ((SceneActionSetterTranslationCommon)((ISceneActionGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
            errorMask = SceneAction.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void DeepCopyIn(
            this ISceneAction lhs,
            ISceneActionGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            ((SceneActionSetterTranslationCommon)((ISceneActionGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: false);
        }

        public static SceneAction DeepCopy(
            this ISceneActionGetter item,
            SceneAction.TranslationMask? copyMask = null)
        {
            return ((SceneActionSetterTranslationCommon)((ISceneActionGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask);
        }

        public static SceneAction DeepCopy(
            this ISceneActionGetter item,
            out SceneAction.ErrorMask errorMask,
            SceneAction.TranslationMask? copyMask = null)
        {
            return ((SceneActionSetterTranslationCommon)((ISceneActionGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: out errorMask);
        }

        public static SceneAction DeepCopy(
            this ISceneActionGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            return ((SceneActionSetterTranslationCommon)((ISceneActionGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: errorMask);
        }

        #region Binary Translation
        public static void CopyInFromBinary(
            this ISceneAction item,
            MutagenFrame frame,
            TypedParseParams translationParams = default)
        {
            ((SceneActionSetterCommon)((ISceneActionGetter)item).CommonSetterInstance()!).CopyInFromBinary(
                item: item,
                frame: frame,
                translationParams: translationParams);
        }

        #endregion

    }
    #endregion

}

namespace Mutagen.Bethesda.Fallout4
{
    #region Field Index
    internal enum SceneAction_FieldIndex
    {
        Type = 0,
        Name = 1,
        AliasID = 2,
        Index = 3,
        Flags = 4,
        StartPhase = 5,
        EndPhase = 6,
        TimerMaxSeconds = 7,
        SetParentQuestStage = 8,
        TimerMinSeconds = 9,
        STSC = 10,
        StartScenes = 11,
        PlayerPositiveResponse = 12,
        PlayerNegativeResponse = 13,
        PlayerNeutralResponse = 14,
        PlayerQuestionResponse = 15,
        PlayerPositiveSubtype = 16,
        PlayerNegativeSubtype = 17,
        PlayerNeutralSubtype = 18,
        PlayerQuestionSubtype = 19,
        NpcHeadtrackingActorIds = 20,
        NpcPositiveResponse = 21,
        NpcNegativeResponse = 22,
        NpcNeutralResponse = 23,
        NpcQuestionResponse = 24,
        NpcPositiveSubtype = 25,
        NpcNegativeSubtype = 26,
        NpcNeutralSubtype = 27,
        NpcQuestionSubtype = 28,
        DialogueTargetActorId = 29,
        Packages = 30,
        Topic = 31,
        LoopingMax = 32,
        LoopingMin = 33,
        Camera = 34,
        Emotion = 35,
        EmotionValue = 36,
        PlayerHeadTrackingActorIds = 37,
        DialogueSubtype = 38,
        AnimArchType = 39,
        AudioOutputOverride = 40,
        Unused = 41,
    }
    #endregion

    #region Registration
    internal partial class SceneAction_Registration : ILoquiRegistration
    {
        public static readonly SceneAction_Registration Instance = new SceneAction_Registration();

        public static ProtocolKey ProtocolKey => ProtocolDefinition_Fallout4.ProtocolKey;

        public const ushort AdditionalFieldCount = 42;

        public const ushort FieldCount = 42;

        public static readonly Type MaskType = typeof(SceneAction.Mask<>);

        public static readonly Type ErrorMaskType = typeof(SceneAction.ErrorMask);

        public static readonly Type ClassType = typeof(SceneAction);

        public static readonly Type GetterType = typeof(ISceneActionGetter);

        public static readonly Type? InternalGetterType = null;

        public static readonly Type SetterType = typeof(ISceneAction);

        public static readonly Type? InternalSetterType = null;

        public const string FullName = "Mutagen.Bethesda.Fallout4.SceneAction";

        public const string Name = "SceneAction";

        public const string Namespace = "Mutagen.Bethesda.Fallout4";

        public const byte GenericCount = 0;

        public static readonly Type? GenericRegistrationType = null;

        public static readonly RecordType TriggeringRecordType = RecordTypes.ANAM;
        public static RecordTriggerSpecs TriggerSpecs => _recordSpecs.Value;
        private static readonly Lazy<RecordTriggerSpecs> _recordSpecs = new Lazy<RecordTriggerSpecs>(() =>
        {
            var triggers = RecordCollection.Factory(RecordTypes.ANAM);
            var all = RecordCollection.Factory(
                RecordTypes.ANAM,
                RecordTypes.NAM0,
                RecordTypes.ALID,
                RecordTypes.INAM,
                RecordTypes.FNAM,
                RecordTypes.SNAM,
                RecordTypes.ENAM,
                RecordTypes.SCQS,
                RecordTypes.TNAM,
                RecordTypes.STSC,
                RecordTypes.LCEP,
                RecordTypes.INTT,
                RecordTypes.SSPN,
                RecordTypes.CTDA,
                RecordTypes.CITC,
                RecordTypes.CIS1,
                RecordTypes.CIS2,
                RecordTypes.PTOP,
                RecordTypes.NTOP,
                RecordTypes.NETO,
                RecordTypes.QTOP,
                RecordTypes.VENC,
                RecordTypes.PLVD,
                RecordTypes.JOUT,
                RecordTypes.DALC,
                RecordTypes.DTID,
                RecordTypes.NPOT,
                RecordTypes.NNGT,
                RecordTypes.NNUT,
                RecordTypes.NQUT,
                RecordTypes.NPOS,
                RecordTypes.NNGS,
                RecordTypes.NNUS,
                RecordTypes.NQUS,
                RecordTypes.DTGT,
                RecordTypes.PNAM,
                RecordTypes.DATA,
                RecordTypes.HTID,
                RecordTypes.DMAX,
                RecordTypes.DMIN,
                RecordTypes.CRIS,
                RecordTypes.DEMO,
                RecordTypes.DEVA,
                RecordTypes.ONAM,
                RecordTypes.SCHR,
                RecordTypes.SCDA,
                RecordTypes.SCTX,
                RecordTypes.QNAM,
                RecordTypes.SCRO);
            return new RecordTriggerSpecs(
                allRecordTypes: all,
                triggeringRecordTypes: triggers);
        });
        public static readonly Type BinaryWriteTranslation = typeof(SceneActionBinaryWriteTranslation);
        #region Interface
        ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;
        ushort ILoquiRegistration.FieldCount => FieldCount;
        ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;
        Type ILoquiRegistration.MaskType => MaskType;
        Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;
        Type ILoquiRegistration.ClassType => ClassType;
        Type ILoquiRegistration.SetterType => SetterType;
        Type? ILoquiRegistration.InternalSetterType => InternalSetterType;
        Type ILoquiRegistration.GetterType => GetterType;
        Type? ILoquiRegistration.InternalGetterType => InternalGetterType;
        string ILoquiRegistration.FullName => FullName;
        string ILoquiRegistration.Name => Name;
        string ILoquiRegistration.Namespace => Namespace;
        byte ILoquiRegistration.GenericCount => GenericCount;
        Type? ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;
        ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsLoqui(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsSingleton(ushort index) => throw new NotImplementedException();
        string ILoquiRegistration.GetNthName(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsNthDerivative(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsProtected(ushort index) => throw new NotImplementedException();
        Type ILoquiRegistration.GetNthType(ushort index) => throw new NotImplementedException();
        #endregion

    }
    #endregion

    #region Common
    internal partial class SceneActionSetterCommon
    {
        public static readonly SceneActionSetterCommon Instance = new SceneActionSetterCommon();

        partial void ClearPartial();
        
        public void Clear(ISceneAction item)
        {
            ClearPartial();
            item.Type.Clear();
            item.Name = default;
            item.AliasID = default;
            item.Index = default;
            item.Flags = default;
            item.StartPhase = default;
            item.EndPhase = default;
            item.TimerMaxSeconds = default;
            item.SetParentQuestStage = default;
            item.TimerMinSeconds = default;
            item.STSC = default;
            item.StartScenes.Clear();
            item.PlayerPositiveResponse.Clear();
            item.PlayerNegativeResponse.Clear();
            item.PlayerNeutralResponse.Clear();
            item.PlayerQuestionResponse.Clear();
            item.PlayerPositiveSubtype.Clear();
            item.PlayerNegativeSubtype.Clear();
            item.PlayerNeutralSubtype.Clear();
            item.PlayerQuestionSubtype.Clear();
            item.NpcHeadtrackingActorIds = null;
            item.NpcPositiveResponse.Clear();
            item.NpcNegativeResponse.Clear();
            item.NpcNeutralResponse.Clear();
            item.NpcQuestionResponse.Clear();
            item.NpcPositiveSubtype.Clear();
            item.NpcNegativeSubtype.Clear();
            item.NpcNeutralSubtype.Clear();
            item.NpcQuestionSubtype.Clear();
            item.DialogueTargetActorId = default;
            item.Packages.Clear();
            item.Topic.Clear();
            item.LoopingMax = default;
            item.LoopingMin = default;
            item.Camera = null;
            item.Emotion = default;
            item.EmotionValue = default;
            item.PlayerHeadTrackingActorIds = null;
            item.DialogueSubtype.Clear();
            item.AnimArchType.Clear();
            item.AudioOutputOverride.Clear();
            item.Unused = null;
        }
        
        #region Mutagen
        public void RemapLinks(ISceneAction obj, IReadOnlyDictionary<FormKey, FormKey> mapping)
        {
            obj.Type.RemapLinks(mapping);
            obj.StartScenes.RemapLinks(mapping);
            obj.PlayerPositiveResponse.Relink(mapping);
            obj.PlayerNegativeResponse.Relink(mapping);
            obj.PlayerNeutralResponse.Relink(mapping);
            obj.PlayerQuestionResponse.Relink(mapping);
            obj.PlayerPositiveSubtype.Relink(mapping);
            obj.PlayerNegativeSubtype.Relink(mapping);
            obj.PlayerNeutralSubtype.Relink(mapping);
            obj.PlayerQuestionSubtype.Relink(mapping);
            obj.NpcPositiveResponse.Relink(mapping);
            obj.NpcNegativeResponse.Relink(mapping);
            obj.NpcNeutralResponse.Relink(mapping);
            obj.NpcQuestionResponse.Relink(mapping);
            obj.NpcPositiveSubtype.Relink(mapping);
            obj.NpcNegativeSubtype.Relink(mapping);
            obj.NpcNeutralSubtype.Relink(mapping);
            obj.NpcQuestionSubtype.Relink(mapping);
            obj.Packages.RemapLinks(mapping);
            obj.Topic.Relink(mapping);
            obj.DialogueSubtype.Relink(mapping);
            obj.AnimArchType.Relink(mapping);
            obj.AudioOutputOverride.Relink(mapping);
        }
        
        #endregion
        
        #region Binary Translation
        public virtual void CopyInFromBinary(
            ISceneAction item,
            MutagenFrame frame,
            TypedParseParams translationParams)
        {
            PluginUtilityTranslation.SubrecordParse(
                record: item,
                frame: frame,
                translationParams: translationParams,
                fillTyped: SceneActionBinaryCreateTranslation.FillBinaryRecordTypes);
        }
        
        #endregion
        
    }
    internal partial class SceneActionCommon
    {
        public static readonly SceneActionCommon Instance = new SceneActionCommon();

        public SceneAction.Mask<bool> GetEqualsMask(
            ISceneActionGetter item,
            ISceneActionGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            var ret = new SceneAction.Mask<bool>(false);
            ((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).FillEqualsMask(
                item: item,
                rhs: rhs,
                ret: ret,
                include: include);
            return ret;
        }
        
        public void FillEqualsMask(
            ISceneActionGetter item,
            ISceneActionGetter rhs,
            SceneAction.Mask<bool> ret,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            ret.Type = MaskItemExt.Factory(item.Type.GetEqualsMask(rhs.Type, include), include);
            ret.Name = string.Equals(item.Name, rhs.Name);
            ret.AliasID = item.AliasID == rhs.AliasID;
            ret.Index = item.Index == rhs.Index;
            ret.Flags = item.Flags == rhs.Flags;
            ret.StartPhase = item.StartPhase == rhs.StartPhase;
            ret.EndPhase = item.EndPhase == rhs.EndPhase;
            ret.TimerMaxSeconds = item.TimerMaxSeconds.EqualsWithin(rhs.TimerMaxSeconds);
            ret.SetParentQuestStage = item.SetParentQuestStage == rhs.SetParentQuestStage;
            ret.TimerMinSeconds = item.TimerMinSeconds.EqualsWithin(rhs.TimerMinSeconds);
            ret.STSC = MemorySliceExt.SequenceEqual(item.STSC, rhs.STSC);
            ret.StartScenes = item.StartScenes.CollectionEqualsHelper(
                rhs.StartScenes,
                (loqLhs, loqRhs) => loqLhs.GetEqualsMask(loqRhs, include),
                include);
            ret.PlayerPositiveResponse = item.PlayerPositiveResponse.Equals(rhs.PlayerPositiveResponse);
            ret.PlayerNegativeResponse = item.PlayerNegativeResponse.Equals(rhs.PlayerNegativeResponse);
            ret.PlayerNeutralResponse = item.PlayerNeutralResponse.Equals(rhs.PlayerNeutralResponse);
            ret.PlayerQuestionResponse = item.PlayerQuestionResponse.Equals(rhs.PlayerQuestionResponse);
            ret.PlayerPositiveSubtype = item.PlayerPositiveSubtype.Equals(rhs.PlayerPositiveSubtype);
            ret.PlayerNegativeSubtype = item.PlayerNegativeSubtype.Equals(rhs.PlayerNegativeSubtype);
            ret.PlayerNeutralSubtype = item.PlayerNeutralSubtype.Equals(rhs.PlayerNeutralSubtype);
            ret.PlayerQuestionSubtype = item.PlayerQuestionSubtype.Equals(rhs.PlayerQuestionSubtype);
            ret.NpcHeadtrackingActorIds = item.NpcHeadtrackingActorIds.CollectionEqualsHelper(
                rhs.NpcHeadtrackingActorIds,
                (l, r) => l == r,
                include);
            ret.NpcPositiveResponse = item.NpcPositiveResponse.Equals(rhs.NpcPositiveResponse);
            ret.NpcNegativeResponse = item.NpcNegativeResponse.Equals(rhs.NpcNegativeResponse);
            ret.NpcNeutralResponse = item.NpcNeutralResponse.Equals(rhs.NpcNeutralResponse);
            ret.NpcQuestionResponse = item.NpcQuestionResponse.Equals(rhs.NpcQuestionResponse);
            ret.NpcPositiveSubtype = item.NpcPositiveSubtype.Equals(rhs.NpcPositiveSubtype);
            ret.NpcNegativeSubtype = item.NpcNegativeSubtype.Equals(rhs.NpcNegativeSubtype);
            ret.NpcNeutralSubtype = item.NpcNeutralSubtype.Equals(rhs.NpcNeutralSubtype);
            ret.NpcQuestionSubtype = item.NpcQuestionSubtype.Equals(rhs.NpcQuestionSubtype);
            ret.DialogueTargetActorId = item.DialogueTargetActorId == rhs.DialogueTargetActorId;
            ret.Packages = item.Packages.CollectionEqualsHelper(
                rhs.Packages,
                (l, r) => object.Equals(l, r),
                include);
            ret.Topic = item.Topic.Equals(rhs.Topic);
            ret.LoopingMax = item.LoopingMax.EqualsWithin(rhs.LoopingMax);
            ret.LoopingMin = item.LoopingMin.EqualsWithin(rhs.LoopingMin);
            ret.Camera = EqualsMaskHelper.EqualsHelper(
                item.Camera,
                rhs.Camera,
                (loqLhs, loqRhs, incl) => loqLhs.GetEqualsMask(loqRhs, incl),
                include);
            ret.Emotion = item.Emotion == rhs.Emotion;
            ret.EmotionValue = item.EmotionValue == rhs.EmotionValue;
            ret.PlayerHeadTrackingActorIds = item.PlayerHeadTrackingActorIds.CollectionEqualsHelper(
                rhs.PlayerHeadTrackingActorIds,
                (l, r) => l == r,
                include);
            ret.DialogueSubtype = item.DialogueSubtype.Equals(rhs.DialogueSubtype);
            ret.AnimArchType = item.AnimArchType.Equals(rhs.AnimArchType);
            ret.AudioOutputOverride = item.AudioOutputOverride.Equals(rhs.AudioOutputOverride);
            ret.Unused = EqualsMaskHelper.EqualsHelper(
                item.Unused,
                rhs.Unused,
                (loqLhs, loqRhs, incl) => loqLhs.GetEqualsMask(loqRhs, incl),
                include);
        }
        
        public string Print(
            ISceneActionGetter item,
            string? name = null,
            SceneAction.Mask<bool>? printMask = null)
        {
            var sb = new StructuredStringBuilder();
            Print(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
            return sb.ToString();
        }
        
        public void Print(
            ISceneActionGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            SceneAction.Mask<bool>? printMask = null)
        {
            if (name == null)
            {
                sb.AppendLine($"SceneAction =>");
            }
            else
            {
                sb.AppendLine($"{name} (SceneAction) =>");
            }
            using (sb.Brace())
            {
                ToStringFields(
                    item: item,
                    sb: sb,
                    printMask: printMask);
            }
        }
        
        protected static void ToStringFields(
            ISceneActionGetter item,
            StructuredStringBuilder sb,
            SceneAction.Mask<bool>? printMask = null)
        {
            if (printMask?.Type?.Overall ?? true)
            {
                item.Type?.Print(sb, "Type");
            }
            if ((printMask?.Name ?? true)
                && item.Name is {} NameItem)
            {
                sb.AppendItem(NameItem, "Name");
            }
            if ((printMask?.AliasID ?? true)
                && item.AliasID is {} AliasIDItem)
            {
                sb.AppendItem(AliasIDItem, "AliasID");
            }
            if ((printMask?.Index ?? true)
                && item.Index is {} IndexItem)
            {
                sb.AppendItem(IndexItem, "Index");
            }
            if ((printMask?.Flags ?? true)
                && item.Flags is {} FlagsItem)
            {
                sb.AppendItem(FlagsItem, "Flags");
            }
            if ((printMask?.StartPhase ?? true)
                && item.StartPhase is {} StartPhaseItem)
            {
                sb.AppendItem(StartPhaseItem, "StartPhase");
            }
            if ((printMask?.EndPhase ?? true)
                && item.EndPhase is {} EndPhaseItem)
            {
                sb.AppendItem(EndPhaseItem, "EndPhase");
            }
            if ((printMask?.TimerMaxSeconds ?? true)
                && item.TimerMaxSeconds is {} TimerMaxSecondsItem)
            {
                sb.AppendItem(TimerMaxSecondsItem, "TimerMaxSeconds");
            }
            if ((printMask?.SetParentQuestStage ?? true)
                && item.SetParentQuestStage is {} SetParentQuestStageItem)
            {
                sb.AppendItem(SetParentQuestStageItem, "SetParentQuestStage");
            }
            if ((printMask?.TimerMinSeconds ?? true)
                && item.TimerMinSeconds is {} TimerMinSecondsItem)
            {
                sb.AppendItem(TimerMinSecondsItem, "TimerMinSeconds");
            }
            if ((printMask?.STSC ?? true)
                && item.STSC is {} STSCItem)
            {
                sb.AppendLine($"STSC => {SpanExt.ToHexString(STSCItem)}");
            }
            if (printMask?.StartScenes?.Overall ?? true)
            {
                sb.AppendLine("StartScenes =>");
                using (sb.Brace())
                {
                    foreach (var subItem in item.StartScenes)
                    {
                        using (sb.Brace())
                        {
                            subItem?.Print(sb, "Item");
                        }
                    }
                }
            }
            if (printMask?.PlayerPositiveResponse ?? true)
            {
                sb.AppendItem(item.PlayerPositiveResponse.FormKeyNullable, "PlayerPositiveResponse");
            }
            if (printMask?.PlayerNegativeResponse ?? true)
            {
                sb.AppendItem(item.PlayerNegativeResponse.FormKeyNullable, "PlayerNegativeResponse");
            }
            if (printMask?.PlayerNeutralResponse ?? true)
            {
                sb.AppendItem(item.PlayerNeutralResponse.FormKeyNullable, "PlayerNeutralResponse");
            }
            if (printMask?.PlayerQuestionResponse ?? true)
            {
                sb.AppendItem(item.PlayerQuestionResponse.FormKeyNullable, "PlayerQuestionResponse");
            }
            if (printMask?.PlayerPositiveSubtype ?? true)
            {
                sb.AppendItem(item.PlayerPositiveSubtype.FormKeyNullable, "PlayerPositiveSubtype");
            }
            if (printMask?.PlayerNegativeSubtype ?? true)
            {
                sb.AppendItem(item.PlayerNegativeSubtype.FormKeyNullable, "PlayerNegativeSubtype");
            }
            if (printMask?.PlayerNeutralSubtype ?? true)
            {
                sb.AppendItem(item.PlayerNeutralSubtype.FormKeyNullable, "PlayerNeutralSubtype");
            }
            if (printMask?.PlayerQuestionSubtype ?? true)
            {
                sb.AppendItem(item.PlayerQuestionSubtype.FormKeyNullable, "PlayerQuestionSubtype");
            }
            if ((printMask?.NpcHeadtrackingActorIds?.Overall ?? true)
                && item.NpcHeadtrackingActorIds is {} NpcHeadtrackingActorIdsItem)
            {
                sb.AppendLine("NpcHeadtrackingActorIds =>");
                using (sb.Brace())
                {
                    foreach (var subItem in NpcHeadtrackingActorIdsItem)
                    {
                        using (sb.Brace())
                        {
                            sb.AppendItem(subItem);
                        }
                    }
                }
            }
            if (printMask?.NpcPositiveResponse ?? true)
            {
                sb.AppendItem(item.NpcPositiveResponse.FormKeyNullable, "NpcPositiveResponse");
            }
            if (printMask?.NpcNegativeResponse ?? true)
            {
                sb.AppendItem(item.NpcNegativeResponse.FormKeyNullable, "NpcNegativeResponse");
            }
            if (printMask?.NpcNeutralResponse ?? true)
            {
                sb.AppendItem(item.NpcNeutralResponse.FormKeyNullable, "NpcNeutralResponse");
            }
            if (printMask?.NpcQuestionResponse ?? true)
            {
                sb.AppendItem(item.NpcQuestionResponse.FormKeyNullable, "NpcQuestionResponse");
            }
            if (printMask?.NpcPositiveSubtype ?? true)
            {
                sb.AppendItem(item.NpcPositiveSubtype.FormKeyNullable, "NpcPositiveSubtype");
            }
            if (printMask?.NpcNegativeSubtype ?? true)
            {
                sb.AppendItem(item.NpcNegativeSubtype.FormKeyNullable, "NpcNegativeSubtype");
            }
            if (printMask?.NpcNeutralSubtype ?? true)
            {
                sb.AppendItem(item.NpcNeutralSubtype.FormKeyNullable, "NpcNeutralSubtype");
            }
            if (printMask?.NpcQuestionSubtype ?? true)
            {
                sb.AppendItem(item.NpcQuestionSubtype.FormKeyNullable, "NpcQuestionSubtype");
            }
            if ((printMask?.DialogueTargetActorId ?? true)
                && item.DialogueTargetActorId is {} DialogueTargetActorIdItem)
            {
                sb.AppendItem(DialogueTargetActorIdItem, "DialogueTargetActorId");
            }
            if (printMask?.Packages?.Overall ?? true)
            {
                sb.AppendLine("Packages =>");
                using (sb.Brace())
                {
                    foreach (var subItem in item.Packages)
                    {
                        using (sb.Brace())
                        {
                            sb.AppendItem(subItem.FormKey);
                        }
                    }
                }
            }
            if (printMask?.Topic ?? true)
            {
                sb.AppendItem(item.Topic.FormKeyNullable, "Topic");
            }
            if ((printMask?.LoopingMax ?? true)
                && item.LoopingMax is {} LoopingMaxItem)
            {
                sb.AppendItem(LoopingMaxItem, "LoopingMax");
            }
            if ((printMask?.LoopingMin ?? true)
                && item.LoopingMin is {} LoopingMinItem)
            {
                sb.AppendItem(LoopingMinItem, "LoopingMin");
            }
            if ((printMask?.Camera?.Overall ?? true)
                && item.Camera is {} CameraItem)
            {
                CameraItem?.Print(sb, "Camera");
            }
            if ((printMask?.Emotion ?? true)
                && item.Emotion is {} EmotionItem)
            {
                sb.AppendItem(EmotionItem, "Emotion");
            }
            if ((printMask?.EmotionValue ?? true)
                && item.EmotionValue is {} EmotionValueItem)
            {
                sb.AppendItem(EmotionValueItem, "EmotionValue");
            }
            if ((printMask?.PlayerHeadTrackingActorIds?.Overall ?? true)
                && item.PlayerHeadTrackingActorIds is {} PlayerHeadTrackingActorIdsItem)
            {
                sb.AppendLine("PlayerHeadTrackingActorIds =>");
                using (sb.Brace())
                {
                    foreach (var subItem in PlayerHeadTrackingActorIdsItem)
                    {
                        using (sb.Brace())
                        {
                            sb.AppendItem(subItem);
                        }
                    }
                }
            }
            if (printMask?.DialogueSubtype ?? true)
            {
                sb.AppendItem(item.DialogueSubtype.FormKeyNullable, "DialogueSubtype");
            }
            if (printMask?.AnimArchType ?? true)
            {
                sb.AppendItem(item.AnimArchType.FormKeyNullable, "AnimArchType");
            }
            if (printMask?.AudioOutputOverride ?? true)
            {
                sb.AppendItem(item.AudioOutputOverride.FormKeyNullable, "AudioOutputOverride");
            }
            if ((printMask?.Unused?.Overall ?? true)
                && item.Unused is {} UnusedItem)
            {
                UnusedItem?.Print(sb, "Unused");
            }
        }
        
        #region Equals and Hash
        public virtual bool Equals(
            ISceneActionGetter? lhs,
            ISceneActionGetter? rhs,
            TranslationCrystal? equalsMask)
        {
            if (!EqualsMaskHelper.RefEquality(lhs, rhs, out var isEqual)) return isEqual;
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Type) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Type, rhs.Type, out var lhsType, out var rhsType, out var isTypeEqual))
                {
                    if (!((ASceneActionTypeCommon)((IASceneActionTypeGetter)lhsType).CommonInstance()!).Equals(lhsType, rhsType, equalsMask?.GetSubCrystal((int)SceneAction_FieldIndex.Type))) return false;
                }
                else if (!isTypeEqual) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Name) ?? true))
            {
                if (!string.Equals(lhs.Name, rhs.Name)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.AliasID) ?? true))
            {
                if (lhs.AliasID != rhs.AliasID) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Index) ?? true))
            {
                if (lhs.Index != rhs.Index) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Flags) ?? true))
            {
                if (lhs.Flags != rhs.Flags) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.StartPhase) ?? true))
            {
                if (lhs.StartPhase != rhs.StartPhase) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.EndPhase) ?? true))
            {
                if (lhs.EndPhase != rhs.EndPhase) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.TimerMaxSeconds) ?? true))
            {
                if (!lhs.TimerMaxSeconds.EqualsWithin(rhs.TimerMaxSeconds)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.SetParentQuestStage) ?? true))
            {
                if (lhs.SetParentQuestStage != rhs.SetParentQuestStage) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.TimerMinSeconds) ?? true))
            {
                if (!lhs.TimerMinSeconds.EqualsWithin(rhs.TimerMinSeconds)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.STSC) ?? true))
            {
                if (!MemorySliceExt.SequenceEqual(lhs.STSC, rhs.STSC)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.StartScenes) ?? true))
            {
                if (!lhs.StartScenes.SequenceEqual(rhs.StartScenes, (l, r) => ((StartSceneCommon)((IStartSceneGetter)l).CommonInstance()!).Equals(l, r, equalsMask?.GetSubCrystal((int)SceneAction_FieldIndex.StartScenes)))) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.PlayerPositiveResponse) ?? true))
            {
                if (!lhs.PlayerPositiveResponse.Equals(rhs.PlayerPositiveResponse)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.PlayerNegativeResponse) ?? true))
            {
                if (!lhs.PlayerNegativeResponse.Equals(rhs.PlayerNegativeResponse)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.PlayerNeutralResponse) ?? true))
            {
                if (!lhs.PlayerNeutralResponse.Equals(rhs.PlayerNeutralResponse)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.PlayerQuestionResponse) ?? true))
            {
                if (!lhs.PlayerQuestionResponse.Equals(rhs.PlayerQuestionResponse)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.PlayerPositiveSubtype) ?? true))
            {
                if (!lhs.PlayerPositiveSubtype.Equals(rhs.PlayerPositiveSubtype)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.PlayerNegativeSubtype) ?? true))
            {
                if (!lhs.PlayerNegativeSubtype.Equals(rhs.PlayerNegativeSubtype)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.PlayerNeutralSubtype) ?? true))
            {
                if (!lhs.PlayerNeutralSubtype.Equals(rhs.PlayerNeutralSubtype)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.PlayerQuestionSubtype) ?? true))
            {
                if (!lhs.PlayerQuestionSubtype.Equals(rhs.PlayerQuestionSubtype)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.NpcHeadtrackingActorIds) ?? true))
            {
                if (!lhs.NpcHeadtrackingActorIds.SequenceEqualNullable(rhs.NpcHeadtrackingActorIds)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.NpcPositiveResponse) ?? true))
            {
                if (!lhs.NpcPositiveResponse.Equals(rhs.NpcPositiveResponse)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.NpcNegativeResponse) ?? true))
            {
                if (!lhs.NpcNegativeResponse.Equals(rhs.NpcNegativeResponse)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.NpcNeutralResponse) ?? true))
            {
                if (!lhs.NpcNeutralResponse.Equals(rhs.NpcNeutralResponse)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.NpcQuestionResponse) ?? true))
            {
                if (!lhs.NpcQuestionResponse.Equals(rhs.NpcQuestionResponse)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.NpcPositiveSubtype) ?? true))
            {
                if (!lhs.NpcPositiveSubtype.Equals(rhs.NpcPositiveSubtype)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.NpcNegativeSubtype) ?? true))
            {
                if (!lhs.NpcNegativeSubtype.Equals(rhs.NpcNegativeSubtype)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.NpcNeutralSubtype) ?? true))
            {
                if (!lhs.NpcNeutralSubtype.Equals(rhs.NpcNeutralSubtype)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.NpcQuestionSubtype) ?? true))
            {
                if (!lhs.NpcQuestionSubtype.Equals(rhs.NpcQuestionSubtype)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.DialogueTargetActorId) ?? true))
            {
                if (lhs.DialogueTargetActorId != rhs.DialogueTargetActorId) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Packages) ?? true))
            {
                if (!lhs.Packages.SequenceEqualNullable(rhs.Packages)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Topic) ?? true))
            {
                if (!lhs.Topic.Equals(rhs.Topic)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.LoopingMax) ?? true))
            {
                if (!lhs.LoopingMax.EqualsWithin(rhs.LoopingMax)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.LoopingMin) ?? true))
            {
                if (!lhs.LoopingMin.EqualsWithin(rhs.LoopingMin)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Camera) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Camera, rhs.Camera, out var lhsCamera, out var rhsCamera, out var isCameraEqual))
                {
                    if (!((SceneCameraCommon)((ISceneCameraGetter)lhsCamera).CommonInstance()!).Equals(lhsCamera, rhsCamera, equalsMask?.GetSubCrystal((int)SceneAction_FieldIndex.Camera))) return false;
                }
                else if (!isCameraEqual) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Emotion) ?? true))
            {
                if (lhs.Emotion != rhs.Emotion) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.EmotionValue) ?? true))
            {
                if (lhs.EmotionValue != rhs.EmotionValue) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.PlayerHeadTrackingActorIds) ?? true))
            {
                if (!lhs.PlayerHeadTrackingActorIds.SequenceEqualNullable(rhs.PlayerHeadTrackingActorIds)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.DialogueSubtype) ?? true))
            {
                if (!lhs.DialogueSubtype.Equals(rhs.DialogueSubtype)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.AnimArchType) ?? true))
            {
                if (!lhs.AnimArchType.Equals(rhs.AnimArchType)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.AudioOutputOverride) ?? true))
            {
                if (!lhs.AudioOutputOverride.Equals(rhs.AudioOutputOverride)) return false;
            }
            if ((equalsMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Unused) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Unused, rhs.Unused, out var lhsUnused, out var rhsUnused, out var isUnusedEqual))
                {
                    if (!((ScenePhaseUnusedDataCommon)((IScenePhaseUnusedDataGetter)lhsUnused).CommonInstance()!).Equals(lhsUnused, rhsUnused, equalsMask?.GetSubCrystal((int)SceneAction_FieldIndex.Unused))) return false;
                }
                else if (!isUnusedEqual) return false;
            }
            return true;
        }
        
        public virtual int GetHashCode(ISceneActionGetter item)
        {
            var hash = new HashCode();
            hash.Add(item.Type);
            if (item.Name is {} Nameitem)
            {
                hash.Add(Nameitem);
            }
            if (item.AliasID is {} AliasIDitem)
            {
                hash.Add(AliasIDitem);
            }
            if (item.Index is {} Indexitem)
            {
                hash.Add(Indexitem);
            }
            if (item.Flags is {} Flagsitem)
            {
                hash.Add(Flagsitem);
            }
            if (item.StartPhase is {} StartPhaseitem)
            {
                hash.Add(StartPhaseitem);
            }
            if (item.EndPhase is {} EndPhaseitem)
            {
                hash.Add(EndPhaseitem);
            }
            if (item.TimerMaxSeconds is {} TimerMaxSecondsitem)
            {
                hash.Add(TimerMaxSecondsitem);
            }
            if (item.SetParentQuestStage is {} SetParentQuestStageitem)
            {
                hash.Add(SetParentQuestStageitem);
            }
            if (item.TimerMinSeconds is {} TimerMinSecondsitem)
            {
                hash.Add(TimerMinSecondsitem);
            }
            if (item.STSC is {} STSCItem)
            {
                hash.Add(STSCItem);
            }
            hash.Add(item.StartScenes);
            hash.Add(item.PlayerPositiveResponse);
            hash.Add(item.PlayerNegativeResponse);
            hash.Add(item.PlayerNeutralResponse);
            hash.Add(item.PlayerQuestionResponse);
            hash.Add(item.PlayerPositiveSubtype);
            hash.Add(item.PlayerNegativeSubtype);
            hash.Add(item.PlayerNeutralSubtype);
            hash.Add(item.PlayerQuestionSubtype);
            hash.Add(item.NpcHeadtrackingActorIds);
            hash.Add(item.NpcPositiveResponse);
            hash.Add(item.NpcNegativeResponse);
            hash.Add(item.NpcNeutralResponse);
            hash.Add(item.NpcQuestionResponse);
            hash.Add(item.NpcPositiveSubtype);
            hash.Add(item.NpcNegativeSubtype);
            hash.Add(item.NpcNeutralSubtype);
            hash.Add(item.NpcQuestionSubtype);
            if (item.DialogueTargetActorId is {} DialogueTargetActorIditem)
            {
                hash.Add(DialogueTargetActorIditem);
            }
            hash.Add(item.Packages);
            hash.Add(item.Topic);
            if (item.LoopingMax is {} LoopingMaxitem)
            {
                hash.Add(LoopingMaxitem);
            }
            if (item.LoopingMin is {} LoopingMinitem)
            {
                hash.Add(LoopingMinitem);
            }
            if (item.Camera is {} Cameraitem)
            {
                hash.Add(Cameraitem);
            }
            if (item.Emotion is {} Emotionitem)
            {
                hash.Add(Emotionitem);
            }
            if (item.EmotionValue is {} EmotionValueitem)
            {
                hash.Add(EmotionValueitem);
            }
            hash.Add(item.PlayerHeadTrackingActorIds);
            hash.Add(item.DialogueSubtype);
            hash.Add(item.AnimArchType);
            hash.Add(item.AudioOutputOverride);
            if (item.Unused is {} Unuseditem)
            {
                hash.Add(Unuseditem);
            }
            return hash.ToHashCode();
        }
        
        #endregion
        
        
        public object GetNew()
        {
            return SceneAction.GetNew();
        }
        
        #region Mutagen
        public IEnumerable<IFormLinkGetter> EnumerateFormLinks(ISceneActionGetter obj)
        {
            if (obj.Type is IFormLinkContainerGetter TypelinkCont)
            {
                foreach (var item in TypelinkCont.EnumerateFormLinks())
                {
                    yield return item;
                }
            }
            foreach (var item in obj.StartScenes.SelectMany(f => f.EnumerateFormLinks()))
            {
                yield return FormLinkInformation.Factory(item);
            }
            if (FormLinkInformation.TryFactory(obj.PlayerPositiveResponse, out var PlayerPositiveResponseInfo))
            {
                yield return PlayerPositiveResponseInfo;
            }
            if (FormLinkInformation.TryFactory(obj.PlayerNegativeResponse, out var PlayerNegativeResponseInfo))
            {
                yield return PlayerNegativeResponseInfo;
            }
            if (FormLinkInformation.TryFactory(obj.PlayerNeutralResponse, out var PlayerNeutralResponseInfo))
            {
                yield return PlayerNeutralResponseInfo;
            }
            if (FormLinkInformation.TryFactory(obj.PlayerQuestionResponse, out var PlayerQuestionResponseInfo))
            {
                yield return PlayerQuestionResponseInfo;
            }
            if (FormLinkInformation.TryFactory(obj.PlayerPositiveSubtype, out var PlayerPositiveSubtypeInfo))
            {
                yield return PlayerPositiveSubtypeInfo;
            }
            if (FormLinkInformation.TryFactory(obj.PlayerNegativeSubtype, out var PlayerNegativeSubtypeInfo))
            {
                yield return PlayerNegativeSubtypeInfo;
            }
            if (FormLinkInformation.TryFactory(obj.PlayerNeutralSubtype, out var PlayerNeutralSubtypeInfo))
            {
                yield return PlayerNeutralSubtypeInfo;
            }
            if (FormLinkInformation.TryFactory(obj.PlayerQuestionSubtype, out var PlayerQuestionSubtypeInfo))
            {
                yield return PlayerQuestionSubtypeInfo;
            }
            if (FormLinkInformation.TryFactory(obj.NpcPositiveResponse, out var NpcPositiveResponseInfo))
            {
                yield return NpcPositiveResponseInfo;
            }
            if (FormLinkInformation.TryFactory(obj.NpcNegativeResponse, out var NpcNegativeResponseInfo))
            {
                yield return NpcNegativeResponseInfo;
            }
            if (FormLinkInformation.TryFactory(obj.NpcNeutralResponse, out var NpcNeutralResponseInfo))
            {
                yield return NpcNeutralResponseInfo;
            }
            if (FormLinkInformation.TryFactory(obj.NpcQuestionResponse, out var NpcQuestionResponseInfo))
            {
                yield return NpcQuestionResponseInfo;
            }
            if (FormLinkInformation.TryFactory(obj.NpcPositiveSubtype, out var NpcPositiveSubtypeInfo))
            {
                yield return NpcPositiveSubtypeInfo;
            }
            if (FormLinkInformation.TryFactory(obj.NpcNegativeSubtype, out var NpcNegativeSubtypeInfo))
            {
                yield return NpcNegativeSubtypeInfo;
            }
            if (FormLinkInformation.TryFactory(obj.NpcNeutralSubtype, out var NpcNeutralSubtypeInfo))
            {
                yield return NpcNeutralSubtypeInfo;
            }
            if (FormLinkInformation.TryFactory(obj.NpcQuestionSubtype, out var NpcQuestionSubtypeInfo))
            {
                yield return NpcQuestionSubtypeInfo;
            }
            foreach (var item in obj.Packages)
            {
                yield return FormLinkInformation.Factory(item);
            }
            if (FormLinkInformation.TryFactory(obj.Topic, out var TopicInfo))
            {
                yield return TopicInfo;
            }
            if (FormLinkInformation.TryFactory(obj.DialogueSubtype, out var DialogueSubtypeInfo))
            {
                yield return DialogueSubtypeInfo;
            }
            if (FormLinkInformation.TryFactory(obj.AnimArchType, out var AnimArchTypeInfo))
            {
                yield return AnimArchTypeInfo;
            }
            if (FormLinkInformation.TryFactory(obj.AudioOutputOverride, out var AudioOutputOverrideInfo))
            {
                yield return AudioOutputOverrideInfo;
            }
            yield break;
        }
        
        #endregion
        
    }
    internal partial class SceneActionSetterTranslationCommon
    {
        public static readonly SceneActionSetterTranslationCommon Instance = new SceneActionSetterTranslationCommon();

        #region DeepCopyIn
        public void DeepCopyIn(
            ISceneAction item,
            ISceneActionGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Type) ?? true))
            {
                errorMask?.PushIndex((int)SceneAction_FieldIndex.Type);
                try
                {
                    if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Type) ?? true))
                    {
                        item.Type = rhs.Type.DeepCopy(
                            copyMask: copyMask?.GetSubCrystal((int)SceneAction_FieldIndex.Type),
                            errorMask: errorMask);
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Name) ?? true))
            {
                item.Name = rhs.Name;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.AliasID) ?? true))
            {
                item.AliasID = rhs.AliasID;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Index) ?? true))
            {
                item.Index = rhs.Index;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Flags) ?? true))
            {
                item.Flags = rhs.Flags;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.StartPhase) ?? true))
            {
                item.StartPhase = rhs.StartPhase;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.EndPhase) ?? true))
            {
                item.EndPhase = rhs.EndPhase;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.TimerMaxSeconds) ?? true))
            {
                item.TimerMaxSeconds = rhs.TimerMaxSeconds;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.SetParentQuestStage) ?? true))
            {
                item.SetParentQuestStage = rhs.SetParentQuestStage;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.TimerMinSeconds) ?? true))
            {
                item.TimerMinSeconds = rhs.TimerMinSeconds;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.STSC) ?? true))
            {
                if(rhs.STSC is {} STSCrhs)
                {
                    item.STSC = STSCrhs.ToArray();
                }
                else
                {
                    item.STSC = default;
                }
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.StartScenes) ?? true))
            {
                errorMask?.PushIndex((int)SceneAction_FieldIndex.StartScenes);
                try
                {
                    item.StartScenes.SetTo(
                        rhs.StartScenes
                        .Select(r =>
                        {
                            return r.DeepCopy(
                                errorMask: errorMask,
                                default(TranslationCrystal));
                        }));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.PlayerPositiveResponse) ?? true))
            {
                item.PlayerPositiveResponse.SetTo(rhs.PlayerPositiveResponse.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.PlayerNegativeResponse) ?? true))
            {
                item.PlayerNegativeResponse.SetTo(rhs.PlayerNegativeResponse.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.PlayerNeutralResponse) ?? true))
            {
                item.PlayerNeutralResponse.SetTo(rhs.PlayerNeutralResponse.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.PlayerQuestionResponse) ?? true))
            {
                item.PlayerQuestionResponse.SetTo(rhs.PlayerQuestionResponse.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.PlayerPositiveSubtype) ?? true))
            {
                item.PlayerPositiveSubtype.SetTo(rhs.PlayerPositiveSubtype.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.PlayerNegativeSubtype) ?? true))
            {
                item.PlayerNegativeSubtype.SetTo(rhs.PlayerNegativeSubtype.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.PlayerNeutralSubtype) ?? true))
            {
                item.PlayerNeutralSubtype.SetTo(rhs.PlayerNeutralSubtype.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.PlayerQuestionSubtype) ?? true))
            {
                item.PlayerQuestionSubtype.SetTo(rhs.PlayerQuestionSubtype.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.NpcHeadtrackingActorIds) ?? true))
            {
                errorMask?.PushIndex((int)SceneAction_FieldIndex.NpcHeadtrackingActorIds);
                try
                {
                    if ((rhs.NpcHeadtrackingActorIds != null))
                    {
                        item.NpcHeadtrackingActorIds = 
                            rhs.NpcHeadtrackingActorIds
                            .ToExtendedList<Int32>();
                    }
                    else
                    {
                        item.NpcHeadtrackingActorIds = null;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.NpcPositiveResponse) ?? true))
            {
                item.NpcPositiveResponse.SetTo(rhs.NpcPositiveResponse.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.NpcNegativeResponse) ?? true))
            {
                item.NpcNegativeResponse.SetTo(rhs.NpcNegativeResponse.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.NpcNeutralResponse) ?? true))
            {
                item.NpcNeutralResponse.SetTo(rhs.NpcNeutralResponse.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.NpcQuestionResponse) ?? true))
            {
                item.NpcQuestionResponse.SetTo(rhs.NpcQuestionResponse.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.NpcPositiveSubtype) ?? true))
            {
                item.NpcPositiveSubtype.SetTo(rhs.NpcPositiveSubtype.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.NpcNegativeSubtype) ?? true))
            {
                item.NpcNegativeSubtype.SetTo(rhs.NpcNegativeSubtype.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.NpcNeutralSubtype) ?? true))
            {
                item.NpcNeutralSubtype.SetTo(rhs.NpcNeutralSubtype.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.NpcQuestionSubtype) ?? true))
            {
                item.NpcQuestionSubtype.SetTo(rhs.NpcQuestionSubtype.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.DialogueTargetActorId) ?? true))
            {
                item.DialogueTargetActorId = rhs.DialogueTargetActorId;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Packages) ?? true))
            {
                errorMask?.PushIndex((int)SceneAction_FieldIndex.Packages);
                try
                {
                    item.Packages.SetTo(
                        rhs.Packages
                            .Select(b => (IFormLinkGetter<IPackageGetter>)new FormLink<IPackageGetter>(b.FormKey)));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Topic) ?? true))
            {
                item.Topic.SetTo(rhs.Topic.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.LoopingMax) ?? true))
            {
                item.LoopingMax = rhs.LoopingMax;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.LoopingMin) ?? true))
            {
                item.LoopingMin = rhs.LoopingMin;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Camera) ?? true))
            {
                errorMask?.PushIndex((int)SceneAction_FieldIndex.Camera);
                try
                {
                    if(rhs.Camera is {} rhsCamera)
                    {
                        item.Camera = rhsCamera.DeepCopy(
                            errorMask: errorMask,
                            copyMask?.GetSubCrystal((int)SceneAction_FieldIndex.Camera));
                    }
                    else
                    {
                        item.Camera = default;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Emotion) ?? true))
            {
                item.Emotion = rhs.Emotion;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.EmotionValue) ?? true))
            {
                item.EmotionValue = rhs.EmotionValue;
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.PlayerHeadTrackingActorIds) ?? true))
            {
                errorMask?.PushIndex((int)SceneAction_FieldIndex.PlayerHeadTrackingActorIds);
                try
                {
                    if ((rhs.PlayerHeadTrackingActorIds != null))
                    {
                        item.PlayerHeadTrackingActorIds = 
                            rhs.PlayerHeadTrackingActorIds
                            .ToExtendedList<Int32>();
                    }
                    else
                    {
                        item.PlayerHeadTrackingActorIds = null;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.DialogueSubtype) ?? true))
            {
                item.DialogueSubtype.SetTo(rhs.DialogueSubtype.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.AnimArchType) ?? true))
            {
                item.AnimArchType.SetTo(rhs.AnimArchType.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.AudioOutputOverride) ?? true))
            {
                item.AudioOutputOverride.SetTo(rhs.AudioOutputOverride.FormKeyNullable);
            }
            if ((copyMask?.GetShouldTranslate((int)SceneAction_FieldIndex.Unused) ?? true))
            {
                errorMask?.PushIndex((int)SceneAction_FieldIndex.Unused);
                try
                {
                    if(rhs.Unused is {} rhsUnused)
                    {
                        item.Unused = rhsUnused.DeepCopy(
                            errorMask: errorMask,
                            copyMask?.GetSubCrystal((int)SceneAction_FieldIndex.Unused));
                    }
                    else
                    {
                        item.Unused = default;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            DeepCopyInCustom(
                item: item,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: deepCopy);
        }
        
        partial void DeepCopyInCustom(
            ISceneAction item,
            ISceneActionGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy);
        #endregion
        
        public SceneAction DeepCopy(
            ISceneActionGetter item,
            SceneAction.TranslationMask? copyMask = null)
        {
            SceneAction ret = (SceneAction)((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).GetNew();
            ((SceneActionSetterTranslationCommon)((ISceneActionGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: null,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            return ret;
        }
        
        public SceneAction DeepCopy(
            ISceneActionGetter item,
            out SceneAction.ErrorMask errorMask,
            SceneAction.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            SceneAction ret = (SceneAction)((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).GetNew();
            ((SceneActionSetterTranslationCommon)((ISceneActionGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                ret,
                item,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            errorMask = SceneAction.ErrorMask.Factory(errorMaskBuilder);
            return ret;
        }
        
        public SceneAction DeepCopy(
            ISceneActionGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            SceneAction ret = (SceneAction)((SceneActionCommon)((ISceneActionGetter)item).CommonInstance()!).GetNew();
            ((SceneActionSetterTranslationCommon)((ISceneActionGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: true);
            return ret;
        }
        
    }
    #endregion

}

namespace Mutagen.Bethesda.Fallout4
{
    public partial class SceneAction
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => SceneAction_Registration.Instance;
        public static ILoquiRegistration StaticRegistration => SceneAction_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => SceneActionCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterInstance()
        {
            return SceneActionSetterCommon.Instance;
        }
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => SceneActionSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object ISceneActionGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object ISceneActionGetter.CommonSetterInstance() => this.CommonSetterInstance();
        [DebuggerStepThrough]
        object ISceneActionGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

    }
}

#region Modules
#region Binary Translation
namespace Mutagen.Bethesda.Fallout4
{
    public partial class SceneActionBinaryWriteTranslation : IBinaryWriteTranslator
    {
        public static readonly SceneActionBinaryWriteTranslation Instance = new();

        public static void WriteRecordTypes(
            ISceneActionGetter item,
            MutagenWriter writer,
            TypedWriteParams translationParams)
        {
            SceneActionBinaryWriteTranslation.WriteBinaryType(
                writer: writer,
                item: item);
            StringBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.Name,
                header: translationParams.ConvertToCustom(RecordTypes.NAM0),
                binaryType: StringBinaryType.NullTerminate);
            Int32BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.AliasID,
                header: translationParams.ConvertToCustom(RecordTypes.ALID));
            UInt32BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.Index,
                header: translationParams.ConvertToCustom(RecordTypes.INAM));
            EnumBinaryTranslation<SceneAction.Flag, MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer,
                item.Flags,
                length: 4,
                header: translationParams.ConvertToCustom(RecordTypes.FNAM));
            UInt32BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.StartPhase,
                header: translationParams.ConvertToCustom(RecordTypes.SNAM));
            UInt32BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.EndPhase,
                header: translationParams.ConvertToCustom(RecordTypes.ENAM));
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.TimerMaxSeconds,
                header: translationParams.ConvertToCustom(RecordTypes.SNAM));
            Int16BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.SetParentQuestStage,
                header: translationParams.ConvertToCustom(RecordTypes.SCQS));
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.TimerMinSeconds,
                header: translationParams.ConvertToCustom(RecordTypes.TNAM));
            ByteArrayBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                writer: writer,
                item: item.STSC,
                header: translationParams.ConvertToCustom(RecordTypes.STSC));
            Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<IStartSceneGetter>.Instance.Write(
                writer: writer,
                items: item.StartScenes,
                transl: (MutagenWriter subWriter, IStartSceneGetter subItem, TypedWriteParams conv) =>
                {
                    var Item = subItem;
                    ((StartSceneBinaryWriteTranslation)((IBinaryItem)Item).BinaryWriteTranslator).Write(
                        item: Item,
                        writer: subWriter,
                        translationParams: conv);
                });
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.PlayerPositiveResponse,
                header: translationParams.ConvertToCustom(RecordTypes.PTOP));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.PlayerNegativeResponse,
                header: translationParams.ConvertToCustom(RecordTypes.NTOP));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.PlayerNeutralResponse,
                header: translationParams.ConvertToCustom(RecordTypes.NETO));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.PlayerQuestionResponse,
                header: translationParams.ConvertToCustom(RecordTypes.QTOP));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.PlayerPositiveSubtype,
                header: translationParams.ConvertToCustom(RecordTypes.VENC));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.PlayerNegativeSubtype,
                header: translationParams.ConvertToCustom(RecordTypes.PLVD));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.PlayerNeutralSubtype,
                header: translationParams.ConvertToCustom(RecordTypes.JOUT));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.PlayerQuestionSubtype,
                header: translationParams.ConvertToCustom(RecordTypes.DALC));
            Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<Int32>.Instance.Write(
                writer: writer,
                items: item.NpcHeadtrackingActorIds,
                recordType: translationParams.ConvertToCustom(RecordTypes.DTID),
                transl: Int32BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write);
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.NpcPositiveResponse,
                header: translationParams.ConvertToCustom(RecordTypes.NPOT));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.NpcNegativeResponse,
                header: translationParams.ConvertToCustom(RecordTypes.NNGT));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.NpcNeutralResponse,
                header: translationParams.ConvertToCustom(RecordTypes.NNUT));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.NpcQuestionResponse,
                header: translationParams.ConvertToCustom(RecordTypes.NQUT));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.NpcPositiveSubtype,
                header: translationParams.ConvertToCustom(RecordTypes.NPOS));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.NpcNegativeSubtype,
                header: translationParams.ConvertToCustom(RecordTypes.NNGS));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.NpcNeutralSubtype,
                header: translationParams.ConvertToCustom(RecordTypes.NNUS));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.NpcQuestionSubtype,
                header: translationParams.ConvertToCustom(RecordTypes.NQUS));
            Int32BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.DialogueTargetActorId,
                header: translationParams.ConvertToCustom(RecordTypes.DTGT));
            Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<IFormLinkGetter<IPackageGetter>>.Instance.Write(
                writer: writer,
                items: item.Packages,
                transl: (MutagenWriter subWriter, IFormLinkGetter<IPackageGetter> subItem, TypedWriteParams conv) =>
                {
                    FormLinkBinaryTranslation.Instance.Write(
                        writer: subWriter,
                        item: subItem,
                        header: translationParams.ConvertToCustom(RecordTypes.PNAM));
                });
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.Topic,
                header: translationParams.ConvertToCustom(RecordTypes.DATA));
            SceneActionBinaryWriteTranslation.WriteBinaryHTIDParsing(
                writer: writer,
                item: item);
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.LoopingMax,
                header: translationParams.ConvertToCustom(RecordTypes.DMAX));
            FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.LoopingMin,
                header: translationParams.ConvertToCustom(RecordTypes.DMIN));
            if (item.Camera is {} CameraItem)
            {
                ((SceneCameraBinaryWriteTranslation)((IBinaryItem)CameraItem).BinaryWriteTranslator).Write(
                    item: CameraItem,
                    writer: writer,
                    translationParams: translationParams);
            }
            EnumBinaryTranslation<Emotion, MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer,
                item.Emotion,
                length: 4,
                header: translationParams.ConvertToCustom(RecordTypes.DEMO));
            UInt32BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.EmotionValue,
                header: translationParams.ConvertToCustom(RecordTypes.DEVA));
            Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<Int32>.Instance.Write(
                writer: writer,
                items: item.PlayerHeadTrackingActorIds,
                recordType: translationParams.ConvertToCustom(RecordTypes.HTID),
                transl: Int32BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write);
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.DialogueSubtype,
                header: translationParams.ConvertToCustom(RecordTypes.VENC));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.AnimArchType,
                header: translationParams.ConvertToCustom(RecordTypes.PNAM));
            FormLinkBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.AudioOutputOverride,
                header: translationParams.ConvertToCustom(RecordTypes.ONAM));
            if (item.Unused is {} UnusedItem)
            {
                ((ScenePhaseUnusedDataBinaryWriteTranslation)((IBinaryItem)UnusedItem).BinaryWriteTranslator).Write(
                    item: UnusedItem,
                    writer: writer,
                    translationParams: translationParams);
            }
            using (HeaderExport.Subrecord(writer, RecordTypes.ANAM)) { }
        }

        public static partial void WriteBinaryTypeCustom(
            MutagenWriter writer,
            ISceneActionGetter item);

        public static void WriteBinaryType(
            MutagenWriter writer,
            ISceneActionGetter item)
        {
            WriteBinaryTypeCustom(
                writer: writer,
                item: item);
        }

        public static partial void WriteBinaryHTIDParsingCustom(
            MutagenWriter writer,
            ISceneActionGetter item);

        public static void WriteBinaryHTIDParsing(
            MutagenWriter writer,
            ISceneActionGetter item)
        {
            WriteBinaryHTIDParsingCustom(
                writer: writer,
                item: item);
        }

        public void Write(
            MutagenWriter writer,
            ISceneActionGetter item,
            TypedWriteParams translationParams)
        {
            WriteRecordTypes(
                item: item,
                writer: writer,
                translationParams: translationParams);
        }

        public void Write(
            MutagenWriter writer,
            object item,
            TypedWriteParams translationParams = default)
        {
            Write(
                item: (ISceneActionGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

    }

    internal partial class SceneActionBinaryCreateTranslation
    {
        public static readonly SceneActionBinaryCreateTranslation Instance = new SceneActionBinaryCreateTranslation();

        public static ParseResult FillBinaryRecordTypes(
            ISceneAction item,
            MutagenFrame frame,
            PreviousParse lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            RecordType nextRecordType,
            int contentLength,
            TypedParseParams translationParams = default)
        {
            nextRecordType = translationParams.ConvertToStandard(nextRecordType);
            switch (nextRecordType.TypeInt)
            {
                case RecordTypeInts.ANAM:
                {
                    if (!lastParsed.ParsedIndex.HasValue)
                    {
                        if (lastParsed.ShortCircuit((int)SceneAction_FieldIndex.Type, translationParams)) return ParseResult.Stop;
                        SceneActionBinaryCreateTranslation.FillBinaryTypeCustom(
                            frame: frame.SpawnWithLength(frame.MetaData.Constants.SubConstants.HeaderLength + contentLength),
                            item: item,
                            lastParsed: lastParsed);
                        return new ParseResult((int)SceneAction_FieldIndex.Type, nextRecordType);
                    }
                    else if (lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.Unused)
                    {
                        frame.ReadSubrecord();
                        return ParseResult.Stop;
                    }
                    else
                    {
                        switch (recordParseCount?.GetOrAdd(nextRecordType) ?? 0)
                        {
                            case 0:
                                if (lastParsed.ShortCircuit((int)SceneAction_FieldIndex.Type, translationParams)) return ParseResult.Stop;
                                SceneActionBinaryCreateTranslation.FillBinaryTypeCustom(
                                    frame: frame.SpawnWithLength(frame.MetaData.Constants.SubConstants.HeaderLength + contentLength),
                                    item: item,
                                    lastParsed: lastParsed);
                                return new ParseResult((int)SceneAction_FieldIndex.Type, nextRecordType);
                            case 1:
                                frame.ReadSubrecord();
                                return ParseResult.Stop;
                            default:
                                throw new NotImplementedException();
                        }
                    }
                }
                case RecordTypeInts.NAM0:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Name = StringBinaryTranslation.Instance.Parse(
                        reader: frame.SpawnWithLength(contentLength),
                        stringBinaryType: StringBinaryType.NullTerminate,
                        parseWhole: true);
                    return (int)SceneAction_FieldIndex.Name;
                }
                case RecordTypeInts.ALID:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.AliasID = frame.ReadInt32();
                    return (int)SceneAction_FieldIndex.AliasID;
                }
                case RecordTypeInts.INAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Index = frame.ReadUInt32();
                    return (int)SceneAction_FieldIndex.Index;
                }
                case RecordTypeInts.FNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Flags = EnumBinaryTranslation<SceneAction.Flag, MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: frame,
                        length: contentLength);
                    return (int)SceneAction_FieldIndex.Flags;
                }
                case RecordTypeInts.SNAM:
                {
                    if (!lastParsed.ParsedIndex.HasValue
                        || lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.Flags)
                    {
                        frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                        item.StartPhase = frame.ReadUInt32();
                        return new ParseResult((int)SceneAction_FieldIndex.StartPhase, nextRecordType);
                    }
                    else if (lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.EndPhase)
                    {
                        frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                        item.TimerMaxSeconds = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                        return new ParseResult((int)SceneAction_FieldIndex.TimerMaxSeconds, nextRecordType);
                    }
                    else
                    {
                        switch (recordParseCount?.GetOrAdd(nextRecordType) ?? 0)
                        {
                            case 0:
                                frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                                item.StartPhase = frame.ReadUInt32();
                                return new ParseResult((int)SceneAction_FieldIndex.StartPhase, nextRecordType);
                            case 1:
                                frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                                item.TimerMaxSeconds = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                                return new ParseResult((int)SceneAction_FieldIndex.TimerMaxSeconds, nextRecordType);
                            default:
                                throw new NotImplementedException();
                        }
                    }
                }
                case RecordTypeInts.ENAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.EndPhase = frame.ReadUInt32();
                    return (int)SceneAction_FieldIndex.EndPhase;
                }
                case RecordTypeInts.SCQS:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.SetParentQuestStage = frame.ReadInt16();
                    return (int)SceneAction_FieldIndex.SetParentQuestStage;
                }
                case RecordTypeInts.TNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.TimerMinSeconds = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)SceneAction_FieldIndex.TimerMinSeconds;
                }
                case RecordTypeInts.STSC:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.STSC = ByteArrayBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)SceneAction_FieldIndex.STSC;
                }
                case RecordTypeInts.LCEP:
                case RecordTypeInts.INTT:
                case RecordTypeInts.SSPN:
                case RecordTypeInts.CTDA:
                case RecordTypeInts.CITC:
                {
                    item.StartScenes.SetTo(
                        Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<StartScene>.Instance.Parse(
                            reader: frame,
                            triggeringRecord: StartScene_Registration.TriggerSpecs,
                            translationParams: translationParams,
                            transl: StartScene.TryCreateFromBinary));
                    return (int)SceneAction_FieldIndex.StartScenes;
                }
                case RecordTypeInts.PTOP:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.PlayerPositiveResponse.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)SceneAction_FieldIndex.PlayerPositiveResponse;
                }
                case RecordTypeInts.NTOP:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.PlayerNegativeResponse.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)SceneAction_FieldIndex.PlayerNegativeResponse;
                }
                case RecordTypeInts.NETO:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.PlayerNeutralResponse.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)SceneAction_FieldIndex.PlayerNeutralResponse;
                }
                case RecordTypeInts.QTOP:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.PlayerQuestionResponse.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)SceneAction_FieldIndex.PlayerQuestionResponse;
                }
                case RecordTypeInts.VENC:
                {
                    if (!lastParsed.ParsedIndex.HasValue
                        || lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.PlayerQuestionResponse)
                    {
                        frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                        item.PlayerPositiveSubtype.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                        return new ParseResult((int)SceneAction_FieldIndex.PlayerPositiveSubtype, nextRecordType);
                    }
                    else if (lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.PlayerHeadTrackingActorIds)
                    {
                        frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                        item.DialogueSubtype.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                        return new ParseResult((int)SceneAction_FieldIndex.DialogueSubtype, nextRecordType);
                    }
                    else
                    {
                        switch (recordParseCount?.GetOrAdd(nextRecordType) ?? 0)
                        {
                            case 0:
                                frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                                item.PlayerPositiveSubtype.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                                return new ParseResult((int)SceneAction_FieldIndex.PlayerPositiveSubtype, nextRecordType);
                            case 1:
                                frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                                item.DialogueSubtype.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                                return new ParseResult((int)SceneAction_FieldIndex.DialogueSubtype, nextRecordType);
                            default:
                                throw new NotImplementedException();
                        }
                    }
                }
                case RecordTypeInts.PLVD:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.PlayerNegativeSubtype.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)SceneAction_FieldIndex.PlayerNegativeSubtype;
                }
                case RecordTypeInts.JOUT:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.PlayerNeutralSubtype.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)SceneAction_FieldIndex.PlayerNeutralSubtype;
                }
                case RecordTypeInts.DALC:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.PlayerQuestionSubtype.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)SceneAction_FieldIndex.PlayerQuestionSubtype;
                }
                case RecordTypeInts.DTID:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.NpcHeadtrackingActorIds = 
                        Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<Int32>.Instance.Parse(
                            reader: frame.SpawnWithLength(contentLength),
                            transl: Int32BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse)
                        .CastExtendedList<Int32>();
                    return (int)SceneAction_FieldIndex.NpcHeadtrackingActorIds;
                }
                case RecordTypeInts.NPOT:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.NpcPositiveResponse.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)SceneAction_FieldIndex.NpcPositiveResponse;
                }
                case RecordTypeInts.NNGT:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.NpcNegativeResponse.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)SceneAction_FieldIndex.NpcNegativeResponse;
                }
                case RecordTypeInts.NNUT:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.NpcNeutralResponse.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)SceneAction_FieldIndex.NpcNeutralResponse;
                }
                case RecordTypeInts.NQUT:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.NpcQuestionResponse.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)SceneAction_FieldIndex.NpcQuestionResponse;
                }
                case RecordTypeInts.NPOS:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.NpcPositiveSubtype.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)SceneAction_FieldIndex.NpcPositiveSubtype;
                }
                case RecordTypeInts.NNGS:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.NpcNegativeSubtype.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)SceneAction_FieldIndex.NpcNegativeSubtype;
                }
                case RecordTypeInts.NNUS:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.NpcNeutralSubtype.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)SceneAction_FieldIndex.NpcNeutralSubtype;
                }
                case RecordTypeInts.NQUS:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.NpcQuestionSubtype.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)SceneAction_FieldIndex.NpcQuestionSubtype;
                }
                case RecordTypeInts.DTGT:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.DialogueTargetActorId = frame.ReadInt32();
                    return (int)SceneAction_FieldIndex.DialogueTargetActorId;
                }
                case RecordTypeInts.PNAM:
                {
                    if (!lastParsed.ParsedIndex.HasValue
                        || lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.DialogueTargetActorId)
                    {
                        item.Packages.SetTo(
                            Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<IFormLinkGetter<IPackageGetter>>.Instance.Parse(
                                reader: frame,
                                triggeringRecord: translationParams.ConvertToCustom(RecordTypes.PNAM),
                                transl: FormLinkBinaryTranslation.Instance.Parse));
                        return new ParseResult((int)SceneAction_FieldIndex.Packages, nextRecordType);
                    }
                    else if (lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.DialogueSubtype)
                    {
                        frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                        item.AnimArchType.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                        return new ParseResult((int)SceneAction_FieldIndex.AnimArchType, nextRecordType);
                    }
                    else
                    {
                        switch (recordParseCount?.GetOrAdd(nextRecordType) ?? 0)
                        {
                            case 0:
                                item.Packages.SetTo(
                                    Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<IFormLinkGetter<IPackageGetter>>.Instance.Parse(
                                        reader: frame,
                                        triggeringRecord: translationParams.ConvertToCustom(RecordTypes.PNAM),
                                        transl: FormLinkBinaryTranslation.Instance.Parse));
                                return new ParseResult((int)SceneAction_FieldIndex.Packages, nextRecordType);
                            case 1:
                                frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                                item.AnimArchType.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                                return new ParseResult((int)SceneAction_FieldIndex.AnimArchType, nextRecordType);
                            default:
                                throw new NotImplementedException();
                        }
                    }
                }
                case RecordTypeInts.DATA:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Topic.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)SceneAction_FieldIndex.Topic;
                }
                case RecordTypeInts.HTID:
                {
                    if (!lastParsed.ParsedIndex.HasValue
                        || lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.Topic)
                    {
                        return SceneActionBinaryCreateTranslation.FillBinaryHTIDParsingCustom(
                            frame: frame.SpawnWithLength(frame.MetaData.Constants.SubConstants.HeaderLength + contentLength),
                            item: item,
                            lastParsed: lastParsed);
                    }
                    else if (lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.EmotionValue)
                    {
                        frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                        item.PlayerHeadTrackingActorIds = 
                            Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<Int32>.Instance.Parse(
                                reader: frame.SpawnWithLength(contentLength),
                                transl: Int32BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse)
                            .CastExtendedList<Int32>();
                        return new ParseResult((int)SceneAction_FieldIndex.PlayerHeadTrackingActorIds, nextRecordType);
                    }
                    else
                    {
                        switch (recordParseCount?.GetOrAdd(nextRecordType) ?? 0)
                        {
                            case 0:
                                return SceneActionBinaryCreateTranslation.FillBinaryHTIDParsingCustom(
                                    frame: frame.SpawnWithLength(frame.MetaData.Constants.SubConstants.HeaderLength + contentLength),
                                    item: item,
                                    lastParsed: lastParsed);
                            case 1:
                                frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                                item.PlayerHeadTrackingActorIds = 
                                    Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<Int32>.Instance.Parse(
                                        reader: frame.SpawnWithLength(contentLength),
                                        transl: Int32BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse)
                                    .CastExtendedList<Int32>();
                                return new ParseResult((int)SceneAction_FieldIndex.PlayerHeadTrackingActorIds, nextRecordType);
                            default:
                                throw new NotImplementedException();
                        }
                    }
                }
                case RecordTypeInts.DMAX:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.LoopingMax = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)SceneAction_FieldIndex.LoopingMax;
                }
                case RecordTypeInts.DMIN:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.LoopingMin = FloatBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)SceneAction_FieldIndex.LoopingMin;
                }
                case RecordTypeInts.CRIS:
                {
                    item.Camera = Mutagen.Bethesda.Fallout4.SceneCamera.CreateFromBinary(frame: frame);
                    return (int)SceneAction_FieldIndex.Camera;
                }
                case RecordTypeInts.DEMO:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Emotion = EnumBinaryTranslation<Emotion, MutagenFrame, MutagenWriter>.Instance.Parse(
                        reader: frame,
                        length: contentLength);
                    return (int)SceneAction_FieldIndex.Emotion;
                }
                case RecordTypeInts.DEVA:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.EmotionValue = frame.ReadUInt32();
                    return (int)SceneAction_FieldIndex.EmotionValue;
                }
                case RecordTypeInts.ONAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.AudioOutputOverride.SetTo(FormLinkBinaryTranslation.Instance.Parse(reader: frame));
                    return (int)SceneAction_FieldIndex.AudioOutputOverride;
                }
                case RecordTypeInts.SCHR:
                case RecordTypeInts.SCDA:
                case RecordTypeInts.SCTX:
                case RecordTypeInts.QNAM:
                case RecordTypeInts.SCRO:
                {
                    item.Unused = Mutagen.Bethesda.Fallout4.ScenePhaseUnusedData.CreateFromBinary(
                        frame: frame,
                        translationParams: translationParams.DoNotShortCircuit());
                    return (int)SceneAction_FieldIndex.Unused;
                }
                default:
                    return ParseResult.Stop;
            }
        }

        public static partial void FillBinaryTypeCustom(
            MutagenFrame frame,
            ISceneAction item,
            PreviousParse lastParsed);

        public static partial ParseResult FillBinaryHTIDParsingCustom(
            MutagenFrame frame,
            ISceneAction item,
            PreviousParse lastParsed);

    }

}
namespace Mutagen.Bethesda.Fallout4
{
    #region Binary Write Mixins
    public static class SceneActionBinaryTranslationMixIn
    {
        public static void WriteToBinary(
            this ISceneActionGetter item,
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((SceneActionBinaryWriteTranslation)item.BinaryWriteTranslator).Write(
                item: item,
                writer: writer,
                translationParams: translationParams);
        }

    }
    #endregion


}
namespace Mutagen.Bethesda.Fallout4
{
    internal partial class SceneActionBinaryOverlay :
        PluginBinaryOverlay,
        ISceneActionGetter
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => SceneAction_Registration.Instance;
        public static ILoquiRegistration StaticRegistration => SceneAction_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => SceneActionCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => SceneActionSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object ISceneActionGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object? ISceneActionGetter.CommonSetterInstance() => null;
        [DebuggerStepThrough]
        object ISceneActionGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

        void IPrintable.Print(StructuredStringBuilder sb, string? name) => this.Print(sb, name);

        public IEnumerable<IFormLinkGetter> EnumerateFormLinks() => SceneActionCommon.Instance.EnumerateFormLinks(this);
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => SceneActionBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((SceneActionBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }

        #region Type
        partial void TypeCustomParse(
            OverlayStream stream,
            int finalPos,
            int offset);
        public partial IASceneActionTypeGetter GetTypeCustom();
        public IASceneActionTypeGetter Type => GetTypeCustom();
        #endregion
        #region Name
        private int? _NameLocation;
        public String? Name => _NameLocation.HasValue ? BinaryStringUtility.ProcessWholeToZString(HeaderTranslation.ExtractSubrecordMemory(_recordData, _NameLocation.Value, _package.MetaData.Constants), encoding: _package.MetaData.Encodings.NonTranslated) : default(string?);
        #region Aspects
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        string INamedRequiredGetter.Name => this.Name ?? string.Empty;
        #endregion
        #endregion
        #region AliasID
        private int? _AliasIDLocation;
        public Int32? AliasID => _AliasIDLocation.HasValue ? BinaryPrimitives.ReadInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_recordData, _AliasIDLocation.Value, _package.MetaData.Constants)) : default(Int32?);
        #endregion
        #region Index
        private int? _IndexLocation;
        public UInt32? Index => _IndexLocation.HasValue ? BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_recordData, _IndexLocation.Value, _package.MetaData.Constants)) : default(UInt32?);
        #endregion
        #region Flags
        private int? _FlagsLocation;
        public SceneAction.Flag? Flags => _FlagsLocation.HasValue ? (SceneAction.Flag)BinaryPrimitives.ReadInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_recordData, _FlagsLocation!.Value, _package.MetaData.Constants)) : default(SceneAction.Flag?);
        #endregion
        #region StartPhase
        private int? _StartPhaseLocation;
        public UInt32? StartPhase => _StartPhaseLocation.HasValue ? BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_recordData, _StartPhaseLocation.Value, _package.MetaData.Constants)) : default(UInt32?);
        #endregion
        #region EndPhase
        private int? _EndPhaseLocation;
        public UInt32? EndPhase => _EndPhaseLocation.HasValue ? BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_recordData, _EndPhaseLocation.Value, _package.MetaData.Constants)) : default(UInt32?);
        #endregion
        #region TimerMaxSeconds
        private int? _TimerMaxSecondsLocation;
        public Single? TimerMaxSeconds => _TimerMaxSecondsLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_recordData, _TimerMaxSecondsLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        #region SetParentQuestStage
        private int? _SetParentQuestStageLocation;
        public Int16? SetParentQuestStage => _SetParentQuestStageLocation.HasValue ? BinaryPrimitives.ReadInt16LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_recordData, _SetParentQuestStageLocation.Value, _package.MetaData.Constants)) : default(Int16?);
        #endregion
        #region TimerMinSeconds
        private int? _TimerMinSecondsLocation;
        public Single? TimerMinSeconds => _TimerMinSecondsLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_recordData, _TimerMinSecondsLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        #region STSC
        private int? _STSCLocation;
        public ReadOnlyMemorySlice<Byte>? STSC => _STSCLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_recordData, _STSCLocation.Value, _package.MetaData.Constants) : default(ReadOnlyMemorySlice<byte>?);
        #endregion
        public IReadOnlyList<IStartSceneGetter> StartScenes { get; private set; } = Array.Empty<IStartSceneGetter>();
        #region PlayerPositiveResponse
        private int? _PlayerPositiveResponseLocation;
        public IFormLinkNullableGetter<IDialogTopicGetter> PlayerPositiveResponse => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IDialogTopicGetter>(_package, _recordData, _PlayerPositiveResponseLocation);
        #endregion
        #region PlayerNegativeResponse
        private int? _PlayerNegativeResponseLocation;
        public IFormLinkNullableGetter<IDialogTopicGetter> PlayerNegativeResponse => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IDialogTopicGetter>(_package, _recordData, _PlayerNegativeResponseLocation);
        #endregion
        #region PlayerNeutralResponse
        private int? _PlayerNeutralResponseLocation;
        public IFormLinkNullableGetter<IDialogTopicGetter> PlayerNeutralResponse => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IDialogTopicGetter>(_package, _recordData, _PlayerNeutralResponseLocation);
        #endregion
        #region PlayerQuestionResponse
        private int? _PlayerQuestionResponseLocation;
        public IFormLinkNullableGetter<IDialogTopicGetter> PlayerQuestionResponse => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IDialogTopicGetter>(_package, _recordData, _PlayerQuestionResponseLocation);
        #endregion
        #region PlayerPositiveSubtype
        private int? _PlayerPositiveSubtypeLocation;
        public IFormLinkNullableGetter<IKeywordGetter> PlayerPositiveSubtype => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IKeywordGetter>(_package, _recordData, _PlayerPositiveSubtypeLocation);
        #endregion
        #region PlayerNegativeSubtype
        private int? _PlayerNegativeSubtypeLocation;
        public IFormLinkNullableGetter<IKeywordGetter> PlayerNegativeSubtype => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IKeywordGetter>(_package, _recordData, _PlayerNegativeSubtypeLocation);
        #endregion
        #region PlayerNeutralSubtype
        private int? _PlayerNeutralSubtypeLocation;
        public IFormLinkNullableGetter<IKeywordGetter> PlayerNeutralSubtype => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IKeywordGetter>(_package, _recordData, _PlayerNeutralSubtypeLocation);
        #endregion
        #region PlayerQuestionSubtype
        private int? _PlayerQuestionSubtypeLocation;
        public IFormLinkNullableGetter<IKeywordGetter> PlayerQuestionSubtype => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IKeywordGetter>(_package, _recordData, _PlayerQuestionSubtypeLocation);
        #endregion
        public IReadOnlyList<Int32>? NpcHeadtrackingActorIds { get; private set; }
        #region NpcPositiveResponse
        private int? _NpcPositiveResponseLocation;
        public IFormLinkNullableGetter<IDialogTopicGetter> NpcPositiveResponse => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IDialogTopicGetter>(_package, _recordData, _NpcPositiveResponseLocation);
        #endregion
        #region NpcNegativeResponse
        private int? _NpcNegativeResponseLocation;
        public IFormLinkNullableGetter<IDialogTopicGetter> NpcNegativeResponse => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IDialogTopicGetter>(_package, _recordData, _NpcNegativeResponseLocation);
        #endregion
        #region NpcNeutralResponse
        private int? _NpcNeutralResponseLocation;
        public IFormLinkNullableGetter<IDialogTopicGetter> NpcNeutralResponse => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IDialogTopicGetter>(_package, _recordData, _NpcNeutralResponseLocation);
        #endregion
        #region NpcQuestionResponse
        private int? _NpcQuestionResponseLocation;
        public IFormLinkNullableGetter<IDialogTopicGetter> NpcQuestionResponse => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IDialogTopicGetter>(_package, _recordData, _NpcQuestionResponseLocation);
        #endregion
        #region NpcPositiveSubtype
        private int? _NpcPositiveSubtypeLocation;
        public IFormLinkNullableGetter<IKeywordGetter> NpcPositiveSubtype => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IKeywordGetter>(_package, _recordData, _NpcPositiveSubtypeLocation);
        #endregion
        #region NpcNegativeSubtype
        private int? _NpcNegativeSubtypeLocation;
        public IFormLinkNullableGetter<IKeywordGetter> NpcNegativeSubtype => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IKeywordGetter>(_package, _recordData, _NpcNegativeSubtypeLocation);
        #endregion
        #region NpcNeutralSubtype
        private int? _NpcNeutralSubtypeLocation;
        public IFormLinkNullableGetter<IKeywordGetter> NpcNeutralSubtype => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IKeywordGetter>(_package, _recordData, _NpcNeutralSubtypeLocation);
        #endregion
        #region NpcQuestionSubtype
        private int? _NpcQuestionSubtypeLocation;
        public IFormLinkNullableGetter<IKeywordGetter> NpcQuestionSubtype => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IKeywordGetter>(_package, _recordData, _NpcQuestionSubtypeLocation);
        #endregion
        #region DialogueTargetActorId
        private int? _DialogueTargetActorIdLocation;
        public Int32? DialogueTargetActorId => _DialogueTargetActorIdLocation.HasValue ? BinaryPrimitives.ReadInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_recordData, _DialogueTargetActorIdLocation.Value, _package.MetaData.Constants)) : default(Int32?);
        #endregion
        public IReadOnlyList<IFormLinkGetter<IPackageGetter>> Packages { get; private set; } = Array.Empty<IFormLinkGetter<IPackageGetter>>();
        #region Topic
        private int? _TopicLocation;
        public IFormLinkNullableGetter<IDialogTopicGetter> Topic => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IDialogTopicGetter>(_package, _recordData, _TopicLocation);
        #endregion
        #region HTIDParsing
        public partial ParseResult HTIDParsingCustomParse(
            OverlayStream stream,
            int offset,
            PreviousParse lastParsed);
        #endregion
        #region LoopingMax
        private int? _LoopingMaxLocation;
        public Single? LoopingMax => _LoopingMaxLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_recordData, _LoopingMaxLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        #region LoopingMin
        private int? _LoopingMinLocation;
        public Single? LoopingMin => _LoopingMinLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_recordData, _LoopingMinLocation.Value, _package.MetaData.Constants).Float() : default(Single?);
        #endregion
        #region Camera
        private RangeInt32? _CameraLocation;
        public ISceneCameraGetter? Camera => _CameraLocation.HasValue ? SceneCameraBinaryOverlay.SceneCameraFactory(_recordData.Slice(_CameraLocation!.Value.Min), _package) : default;
        #endregion
        #region Emotion
        private int? _EmotionLocation;
        public Emotion? Emotion => _EmotionLocation.HasValue ? (Emotion)BinaryPrimitives.ReadInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_recordData, _EmotionLocation!.Value, _package.MetaData.Constants)) : default(Emotion?);
        #endregion
        #region EmotionValue
        private int? _EmotionValueLocation;
        public UInt32? EmotionValue => _EmotionValueLocation.HasValue ? BinaryPrimitives.ReadUInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_recordData, _EmotionValueLocation.Value, _package.MetaData.Constants)) : default(UInt32?);
        #endregion
        public IReadOnlyList<Int32>? PlayerHeadTrackingActorIds { get; private set; }
        #region DialogueSubtype
        private int? _DialogueSubtypeLocation;
        public IFormLinkNullableGetter<IKeywordGetter> DialogueSubtype => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IKeywordGetter>(_package, _recordData, _DialogueSubtypeLocation);
        #endregion
        #region AnimArchType
        private int? _AnimArchTypeLocation;
        public IFormLinkNullableGetter<IKeywordGetter> AnimArchType => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<IKeywordGetter>(_package, _recordData, _AnimArchTypeLocation);
        #endregion
        #region AudioOutputOverride
        private int? _AudioOutputOverrideLocation;
        public IFormLinkNullableGetter<ISoundOutputModelGetter> AudioOutputOverride => FormLinkBinaryTranslation.Instance.NullableRecordOverlayFactory<ISoundOutputModelGetter>(_package, _recordData, _AudioOutputOverrideLocation);
        #endregion
        public IScenePhaseUnusedDataGetter? Unused { get; private set; }
        partial void CustomFactoryEnd(
            OverlayStream stream,
            int finalPos,
            int offset);

        partial void CustomCtor();
        protected SceneActionBinaryOverlay(
            MemoryPair memoryPair,
            BinaryOverlayFactoryPackage package)
            : base(
                memoryPair: memoryPair,
                package: package)
        {
            this.CustomCtor();
        }

        public static ISceneActionGetter SceneActionFactory(
            OverlayStream stream,
            BinaryOverlayFactoryPackage package,
            TypedParseParams translationParams = default)
        {
            stream = ExtractTypelessSubrecordRecordMemory(
                stream: stream,
                meta: package.MetaData.Constants,
                translationParams: translationParams,
                memoryPair: out var memoryPair,
                offset: out var offset,
                finalPos: out var finalPos);
            var ret = new SceneActionBinaryOverlay(
                memoryPair: memoryPair,
                package: package);
            ret.FillTypelessSubrecordTypes(
                stream: stream,
                finalPos: stream.Length,
                offset: offset,
                translationParams: translationParams,
                fill: ret.FillRecordType);
            return ret;
        }

        public static ISceneActionGetter SceneActionFactory(
            ReadOnlyMemorySlice<byte> slice,
            BinaryOverlayFactoryPackage package,
            TypedParseParams translationParams = default)
        {
            return SceneActionFactory(
                stream: new OverlayStream(slice, package),
                package: package,
                translationParams: translationParams);
        }

        public ParseResult FillRecordType(
            OverlayStream stream,
            int finalPos,
            int offset,
            RecordType type,
            PreviousParse lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            TypedParseParams translationParams = default)
        {
            type = translationParams.ConvertToStandard(type);
            switch (type.TypeInt)
            {
                case RecordTypeInts.ANAM:
                {
                    if (!lastParsed.ParsedIndex.HasValue)
                    {
                        if (lastParsed.ShortCircuit((int)SceneAction_FieldIndex.Type, translationParams)) return ParseResult.Stop;
                        TypeCustomParse(
                            stream,
                            finalPos,
                            offset);
                        return new ParseResult((int)SceneAction_FieldIndex.Type, type);
                    }
                    else if (lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.Unused)
                    {
                        stream.ReadSubrecord();
                        return ParseResult.Stop;
                    }
                    else
                    {
                        switch (recordParseCount?.GetOrAdd(type) ?? 0)
                        {
                            case 0:
                            {
                                if (lastParsed.ShortCircuit((int)SceneAction_FieldIndex.Type, translationParams)) return ParseResult.Stop;
                                TypeCustomParse(
                                    stream,
                                    finalPos,
                                    offset);
                                return new ParseResult((int)SceneAction_FieldIndex.Type, type);
                            }
                            case 1:
                            {
                                stream.ReadSubrecord();
                                return ParseResult.Stop;
                            }
                            default:
                                throw new NotImplementedException();
                        }
                    }
                }
                case RecordTypeInts.NAM0:
                {
                    _NameLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.Name;
                }
                case RecordTypeInts.ALID:
                {
                    _AliasIDLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.AliasID;
                }
                case RecordTypeInts.INAM:
                {
                    _IndexLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.Index;
                }
                case RecordTypeInts.FNAM:
                {
                    _FlagsLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.Flags;
                }
                case RecordTypeInts.SNAM:
                {
                    if (!lastParsed.ParsedIndex.HasValue
                        || lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.Flags)
                    {
                        _StartPhaseLocation = (stream.Position - offset);
                        return new ParseResult((int)SceneAction_FieldIndex.StartPhase, type);
                    }
                    else if (lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.EndPhase)
                    {
                        _TimerMaxSecondsLocation = (stream.Position - offset);
                        return new ParseResult((int)SceneAction_FieldIndex.TimerMaxSeconds, type);
                    }
                    else
                    {
                        switch (recordParseCount?.GetOrAdd(type) ?? 0)
                        {
                            case 0:
                            {
                                _StartPhaseLocation = (stream.Position - offset);
                                return new ParseResult((int)SceneAction_FieldIndex.StartPhase, type);
                            }
                            case 1:
                            {
                                _TimerMaxSecondsLocation = (stream.Position - offset);
                                return new ParseResult((int)SceneAction_FieldIndex.TimerMaxSeconds, type);
                            }
                            default:
                                throw new NotImplementedException();
                        }
                    }
                }
                case RecordTypeInts.ENAM:
                {
                    _EndPhaseLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.EndPhase;
                }
                case RecordTypeInts.SCQS:
                {
                    _SetParentQuestStageLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.SetParentQuestStage;
                }
                case RecordTypeInts.TNAM:
                {
                    _TimerMinSecondsLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.TimerMinSeconds;
                }
                case RecordTypeInts.STSC:
                {
                    _STSCLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.STSC;
                }
                case RecordTypeInts.LCEP:
                case RecordTypeInts.INTT:
                case RecordTypeInts.SSPN:
                case RecordTypeInts.CTDA:
                case RecordTypeInts.CITC:
                {
                    this.StartScenes = this.ParseRepeatedTypelessSubrecord<IStartSceneGetter>(
                        stream: stream,
                        translationParams: translationParams,
                        trigger: StartScene_Registration.TriggerSpecs,
                        factory: StartSceneBinaryOverlay.StartSceneFactory);
                    return (int)SceneAction_FieldIndex.StartScenes;
                }
                case RecordTypeInts.PTOP:
                {
                    _PlayerPositiveResponseLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.PlayerPositiveResponse;
                }
                case RecordTypeInts.NTOP:
                {
                    _PlayerNegativeResponseLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.PlayerNegativeResponse;
                }
                case RecordTypeInts.NETO:
                {
                    _PlayerNeutralResponseLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.PlayerNeutralResponse;
                }
                case RecordTypeInts.QTOP:
                {
                    _PlayerQuestionResponseLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.PlayerQuestionResponse;
                }
                case RecordTypeInts.VENC:
                {
                    if (!lastParsed.ParsedIndex.HasValue
                        || lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.PlayerQuestionResponse)
                    {
                        _PlayerPositiveSubtypeLocation = (stream.Position - offset);
                        return new ParseResult((int)SceneAction_FieldIndex.PlayerPositiveSubtype, type);
                    }
                    else if (lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.PlayerHeadTrackingActorIds)
                    {
                        _DialogueSubtypeLocation = (stream.Position - offset);
                        return new ParseResult((int)SceneAction_FieldIndex.DialogueSubtype, type);
                    }
                    else
                    {
                        switch (recordParseCount?.GetOrAdd(type) ?? 0)
                        {
                            case 0:
                            {
                                _PlayerPositiveSubtypeLocation = (stream.Position - offset);
                                return new ParseResult((int)SceneAction_FieldIndex.PlayerPositiveSubtype, type);
                            }
                            case 1:
                            {
                                _DialogueSubtypeLocation = (stream.Position - offset);
                                return new ParseResult((int)SceneAction_FieldIndex.DialogueSubtype, type);
                            }
                            default:
                                throw new NotImplementedException();
                        }
                    }
                }
                case RecordTypeInts.PLVD:
                {
                    _PlayerNegativeSubtypeLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.PlayerNegativeSubtype;
                }
                case RecordTypeInts.JOUT:
                {
                    _PlayerNeutralSubtypeLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.PlayerNeutralSubtype;
                }
                case RecordTypeInts.DALC:
                {
                    _PlayerQuestionSubtypeLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.PlayerQuestionSubtype;
                }
                case RecordTypeInts.DTID:
                {
                    this.NpcHeadtrackingActorIds = BinaryOverlayList.FactoryByStartIndexWithTrigger<Int32>(
                        stream: stream,
                        package: _package,
                        finalPos: finalPos,
                        itemLength: 4,
                        getter: (s, p) => BinaryPrimitives.ReadInt32LittleEndian(s));
                    return (int)SceneAction_FieldIndex.NpcHeadtrackingActorIds;
                }
                case RecordTypeInts.NPOT:
                {
                    _NpcPositiveResponseLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.NpcPositiveResponse;
                }
                case RecordTypeInts.NNGT:
                {
                    _NpcNegativeResponseLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.NpcNegativeResponse;
                }
                case RecordTypeInts.NNUT:
                {
                    _NpcNeutralResponseLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.NpcNeutralResponse;
                }
                case RecordTypeInts.NQUT:
                {
                    _NpcQuestionResponseLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.NpcQuestionResponse;
                }
                case RecordTypeInts.NPOS:
                {
                    _NpcPositiveSubtypeLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.NpcPositiveSubtype;
                }
                case RecordTypeInts.NNGS:
                {
                    _NpcNegativeSubtypeLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.NpcNegativeSubtype;
                }
                case RecordTypeInts.NNUS:
                {
                    _NpcNeutralSubtypeLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.NpcNeutralSubtype;
                }
                case RecordTypeInts.NQUS:
                {
                    _NpcQuestionSubtypeLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.NpcQuestionSubtype;
                }
                case RecordTypeInts.DTGT:
                {
                    _DialogueTargetActorIdLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.DialogueTargetActorId;
                }
                case RecordTypeInts.PNAM:
                {
                    if (!lastParsed.ParsedIndex.HasValue
                        || lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.DialogueTargetActorId)
                    {
                        this.Packages = BinaryOverlayList.FactoryByArray<IFormLinkGetter<IPackageGetter>>(
                            mem: stream.RemainingMemory,
                            package: _package,
                            getter: (s, p) => FormLinkBinaryTranslation.Instance.OverlayFactory<IPackageGetter>(p, s),
                            locs: ParseRecordLocations(
                                stream: stream,
                                constants: _package.MetaData.Constants.SubConstants,
                                trigger: RecordTypes.PNAM,
                                skipHeader: true,
                                translationParams: translationParams));
                        return new ParseResult((int)SceneAction_FieldIndex.Packages, type);
                    }
                    else if (lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.DialogueSubtype)
                    {
                        _AnimArchTypeLocation = (stream.Position - offset);
                        return new ParseResult((int)SceneAction_FieldIndex.AnimArchType, type);
                    }
                    else
                    {
                        switch (recordParseCount?.GetOrAdd(type) ?? 0)
                        {
                            case 0:
                            {
                                this.Packages = BinaryOverlayList.FactoryByArray<IFormLinkGetter<IPackageGetter>>(
                                    mem: stream.RemainingMemory,
                                    package: _package,
                                    getter: (s, p) => FormLinkBinaryTranslation.Instance.OverlayFactory<IPackageGetter>(p, s),
                                    locs: ParseRecordLocations(
                                        stream: stream,
                                        constants: _package.MetaData.Constants.SubConstants,
                                        trigger: RecordTypes.PNAM,
                                        skipHeader: true,
                                        translationParams: translationParams));
                                return new ParseResult((int)SceneAction_FieldIndex.Packages, type);
                            }
                            case 1:
                            {
                                _AnimArchTypeLocation = (stream.Position - offset);
                                return new ParseResult((int)SceneAction_FieldIndex.AnimArchType, type);
                            }
                            default:
                                throw new NotImplementedException();
                        }
                    }
                }
                case RecordTypeInts.DATA:
                {
                    _TopicLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.Topic;
                }
                case RecordTypeInts.HTID:
                {
                    if (!lastParsed.ParsedIndex.HasValue
                        || lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.Topic)
                    {
                        return HTIDParsingCustomParse(
                            stream,
                            offset,
                            lastParsed: lastParsed);
                    }
                    else if (lastParsed.ParsedIndex.Value <= (int)SceneAction_FieldIndex.EmotionValue)
                    {
                        this.PlayerHeadTrackingActorIds = BinaryOverlayList.FactoryByStartIndexWithTrigger<Int32>(
                            stream: stream,
                            package: _package,
                            finalPos: finalPos,
                            itemLength: 4,
                            getter: (s, p) => BinaryPrimitives.ReadInt32LittleEndian(s));
                        return new ParseResult((int)SceneAction_FieldIndex.PlayerHeadTrackingActorIds, type);
                    }
                    else
                    {
                        switch (recordParseCount?.GetOrAdd(type) ?? 0)
                        {
                            case 0:
                            {
                                return HTIDParsingCustomParse(
                                    stream,
                                    offset,
                                    lastParsed: lastParsed);
                            }
                            case 1:
                            {
                                this.PlayerHeadTrackingActorIds = BinaryOverlayList.FactoryByStartIndexWithTrigger<Int32>(
                                    stream: stream,
                                    package: _package,
                                    finalPos: finalPos,
                                    itemLength: 4,
                                    getter: (s, p) => BinaryPrimitives.ReadInt32LittleEndian(s));
                                return new ParseResult((int)SceneAction_FieldIndex.PlayerHeadTrackingActorIds, type);
                            }
                            default:
                                throw new NotImplementedException();
                        }
                    }
                }
                case RecordTypeInts.DMAX:
                {
                    _LoopingMaxLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.LoopingMax;
                }
                case RecordTypeInts.DMIN:
                {
                    _LoopingMinLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.LoopingMin;
                }
                case RecordTypeInts.CRIS:
                {
                    _CameraLocation = new RangeInt32((stream.Position - offset), finalPos - offset);
                    return (int)SceneAction_FieldIndex.Camera;
                }
                case RecordTypeInts.DEMO:
                {
                    _EmotionLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.Emotion;
                }
                case RecordTypeInts.DEVA:
                {
                    _EmotionValueLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.EmotionValue;
                }
                case RecordTypeInts.ONAM:
                {
                    _AudioOutputOverrideLocation = (stream.Position - offset);
                    return (int)SceneAction_FieldIndex.AudioOutputOverride;
                }
                case RecordTypeInts.SCHR:
                case RecordTypeInts.SCDA:
                case RecordTypeInts.SCTX:
                case RecordTypeInts.QNAM:
                case RecordTypeInts.SCRO:
                {
                    this.Unused = ScenePhaseUnusedDataBinaryOverlay.ScenePhaseUnusedDataFactory(
                        stream: stream,
                        package: _package,
                        translationParams: translationParams.DoNotShortCircuit());
                    return (int)SceneAction_FieldIndex.Unused;
                }
                default:
                    return ParseResult.Stop;
            }
        }
        #region To String

        public void Print(
            StructuredStringBuilder sb,
            string? name = null)
        {
            SceneActionMixIn.Print(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is not ISceneActionGetter rhs) return false;
            return ((SceneActionCommon)((ISceneActionGetter)this).CommonInstance()!).Equals(this, rhs, equalsMask: null);
        }

        public bool Equals(ISceneActionGetter? obj)
        {
            return ((SceneActionCommon)((ISceneActionGetter)this).CommonInstance()!).Equals(this, obj, equalsMask: null);
        }

        public override int GetHashCode() => ((SceneActionCommon)((ISceneActionGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

    }

}
#endregion

#endregion

