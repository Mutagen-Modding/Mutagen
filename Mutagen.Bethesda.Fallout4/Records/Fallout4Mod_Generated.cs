/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Autogenerated by Loqui.  Do not manually change.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*/
#region Usings
using Loqui;
using Loqui.Internal;
using Mutagen.Bethesda.Binary;
using Mutagen.Bethesda.Fallout4;
using Mutagen.Bethesda.Fallout4.Internals;
using Mutagen.Bethesda.Internals;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Binary;
using Mutagen.Bethesda.Plugins.Binary.Overlay;
using Mutagen.Bethesda.Plugins.Binary.Parameters;
using Mutagen.Bethesda.Plugins.Binary.Streams;
using Mutagen.Bethesda.Plugins.Binary.Translations;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Cache.Internals;
using Mutagen.Bethesda.Plugins.Exceptions;
using Mutagen.Bethesda.Plugins.Internals;
using Mutagen.Bethesda.Plugins.Masters;
using Mutagen.Bethesda.Plugins.Meta;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Plugins.Records.Internals;
using Mutagen.Bethesda.Plugins.Utility;
using Mutagen.Bethesda.Strings;
using Mutagen.Bethesda.Strings.DI;
using Mutagen.Bethesda.Translations.Binary;
using Noggog;
using System;
using System.Buffers.Binary;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.IO.Abstractions;
using System.Linq;
using System.Reactive.Disposables;
using System.Reactive.Linq;
using System.Text;
using System.Threading.Tasks;
#endregion

#nullable enable
namespace Mutagen.Bethesda.Fallout4
{
    #region Class
    public partial class Fallout4Mod :
        IEquatable<IFallout4ModGetter>,
        IFallout4Mod,
        ILoquiObjectSetter<Fallout4Mod>
    {
        #region Ctor
        protected Fallout4Mod()
        {
            _GameSettings_Object = new Fallout4Group<GameSetting>(this);
            _Keywords_Object = new Fallout4Group<Keyword>(this);
            _LocationReferenceTypes_Object = new Fallout4Group<LocationReferenceType>(this);
            _Actions_Object = new Fallout4Group<ActionRecord>(this);
            _Transforms_Object = new Fallout4Group<Transform>(this);
            _Components_Object = new Fallout4Group<Component>(this);
            _TextureSets_Object = new Fallout4Group<TextureSet>(this);
            _Globals_Object = new Fallout4Group<Global>(this);
            _DamageTypes_Object = new Fallout4Group<ADamageType>(this);
            _Classes_Object = new Fallout4Group<Class>(this);
            _Factions_Object = new Fallout4Group<Faction>(this);
            _HeadParts_Object = new Fallout4Group<HeadPart>(this);
            _SoundMarkers_Object = new Fallout4Group<SoundMarker>(this);
            _AcousticSpaces_Object = new Fallout4Group<AcousticSpace>(this);
            _LandscapeTextures_Object = new Fallout4Group<LandscapeTexture>(this);
            _Grasses_Object = new Fallout4Group<Grass>(this);
            _MaterialTypes_Object = new Fallout4Group<MaterialType>(this);
            CustomCtor();
        }
        partial void CustomCtor();
        #endregion

        #region ModHeader
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private readonly Fallout4ModHeader _ModHeader_Object = new Fallout4ModHeader();
        public Fallout4ModHeader ModHeader => _ModHeader_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout4ModHeaderGetter IFallout4ModGetter.ModHeader => _ModHeader_Object;
        #endregion
        #region GameSettings
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout4Group<GameSetting> _GameSettings_Object;
        public Fallout4Group<GameSetting> GameSettings => _GameSettings_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout4GroupGetter<IGameSettingGetter> IFallout4ModGetter.GameSettings => _GameSettings_Object;
        #endregion
        #region Keywords
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout4Group<Keyword> _Keywords_Object;
        public Fallout4Group<Keyword> Keywords => _Keywords_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout4GroupGetter<IKeywordGetter> IFallout4ModGetter.Keywords => _Keywords_Object;
        #endregion
        #region LocationReferenceTypes
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout4Group<LocationReferenceType> _LocationReferenceTypes_Object;
        public Fallout4Group<LocationReferenceType> LocationReferenceTypes => _LocationReferenceTypes_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout4GroupGetter<ILocationReferenceTypeGetter> IFallout4ModGetter.LocationReferenceTypes => _LocationReferenceTypes_Object;
        #endregion
        #region Actions
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout4Group<ActionRecord> _Actions_Object;
        public Fallout4Group<ActionRecord> Actions => _Actions_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout4GroupGetter<IActionRecordGetter> IFallout4ModGetter.Actions => _Actions_Object;
        #endregion
        #region Transforms
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout4Group<Transform> _Transforms_Object;
        public Fallout4Group<Transform> Transforms => _Transforms_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout4GroupGetter<ITransformGetter> IFallout4ModGetter.Transforms => _Transforms_Object;
        #endregion
        #region Components
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout4Group<Component> _Components_Object;
        public Fallout4Group<Component> Components => _Components_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout4GroupGetter<IComponentGetter> IFallout4ModGetter.Components => _Components_Object;
        #endregion
        #region TextureSets
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout4Group<TextureSet> _TextureSets_Object;
        public Fallout4Group<TextureSet> TextureSets => _TextureSets_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout4GroupGetter<ITextureSetGetter> IFallout4ModGetter.TextureSets => _TextureSets_Object;
        #endregion
        #region Globals
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout4Group<Global> _Globals_Object;
        public Fallout4Group<Global> Globals => _Globals_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout4GroupGetter<IGlobalGetter> IFallout4ModGetter.Globals => _Globals_Object;
        #endregion
        #region DamageTypes
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout4Group<ADamageType> _DamageTypes_Object;
        public Fallout4Group<ADamageType> DamageTypes => _DamageTypes_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout4GroupGetter<IADamageTypeGetter> IFallout4ModGetter.DamageTypes => _DamageTypes_Object;
        #endregion
        #region Classes
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout4Group<Class> _Classes_Object;
        public Fallout4Group<Class> Classes => _Classes_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout4GroupGetter<IClassGetter> IFallout4ModGetter.Classes => _Classes_Object;
        #endregion
        #region Factions
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout4Group<Faction> _Factions_Object;
        public Fallout4Group<Faction> Factions => _Factions_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout4GroupGetter<IFactionGetter> IFallout4ModGetter.Factions => _Factions_Object;
        #endregion
        #region HeadParts
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout4Group<HeadPart> _HeadParts_Object;
        public Fallout4Group<HeadPart> HeadParts => _HeadParts_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout4GroupGetter<IHeadPartGetter> IFallout4ModGetter.HeadParts => _HeadParts_Object;
        #endregion
        #region SoundMarkers
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout4Group<SoundMarker> _SoundMarkers_Object;
        public Fallout4Group<SoundMarker> SoundMarkers => _SoundMarkers_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout4GroupGetter<ISoundMarkerGetter> IFallout4ModGetter.SoundMarkers => _SoundMarkers_Object;
        #endregion
        #region AcousticSpaces
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout4Group<AcousticSpace> _AcousticSpaces_Object;
        public Fallout4Group<AcousticSpace> AcousticSpaces => _AcousticSpaces_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout4GroupGetter<IAcousticSpaceGetter> IFallout4ModGetter.AcousticSpaces => _AcousticSpaces_Object;
        #endregion
        #region LandscapeTextures
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout4Group<LandscapeTexture> _LandscapeTextures_Object;
        public Fallout4Group<LandscapeTexture> LandscapeTextures => _LandscapeTextures_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout4GroupGetter<ILandscapeTextureGetter> IFallout4ModGetter.LandscapeTextures => _LandscapeTextures_Object;
        #endregion
        #region Grasses
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout4Group<Grass> _Grasses_Object;
        public Fallout4Group<Grass> Grasses => _Grasses_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout4GroupGetter<IGrassGetter> IFallout4ModGetter.Grasses => _Grasses_Object;
        #endregion
        #region MaterialTypes
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private Fallout4Group<MaterialType> _MaterialTypes_Object;
        public Fallout4Group<MaterialType> MaterialTypes => _MaterialTypes_Object;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IFallout4GroupGetter<IMaterialTypeGetter> IFallout4ModGetter.MaterialTypes => _MaterialTypes_Object;
        #endregion

        #region To String

        public void ToString(
            FileGeneration fg,
            string? name = null)
        {
            Fallout4ModMixIn.ToString(
                item: this,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is not IFallout4ModGetter rhs) return false;
            return ((Fallout4ModCommon)((IFallout4ModGetter)this).CommonInstance()!).Equals(this, rhs, crystal: null);
        }

        public bool Equals(IFallout4ModGetter? obj)
        {
            return ((Fallout4ModCommon)((IFallout4ModGetter)this).CommonInstance()!).Equals(this, obj, crystal: null);
        }

        public override int GetHashCode() => ((Fallout4ModCommon)((IFallout4ModGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        #region Mask
        public class Mask<TItem> :
            IEquatable<Mask<TItem>>,
            IMask<TItem>
        {
            #region Ctors
            public Mask(TItem initialValue)
            {
                this.ModHeader = new MaskItem<TItem, Fallout4ModHeader.Mask<TItem>?>(initialValue, new Fallout4ModHeader.Mask<TItem>(initialValue));
                this.GameSettings = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(initialValue, new Fallout4Group.Mask<TItem>(initialValue));
                this.Keywords = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(initialValue, new Fallout4Group.Mask<TItem>(initialValue));
                this.LocationReferenceTypes = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(initialValue, new Fallout4Group.Mask<TItem>(initialValue));
                this.Actions = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(initialValue, new Fallout4Group.Mask<TItem>(initialValue));
                this.Transforms = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(initialValue, new Fallout4Group.Mask<TItem>(initialValue));
                this.Components = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(initialValue, new Fallout4Group.Mask<TItem>(initialValue));
                this.TextureSets = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(initialValue, new Fallout4Group.Mask<TItem>(initialValue));
                this.Globals = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(initialValue, new Fallout4Group.Mask<TItem>(initialValue));
                this.DamageTypes = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(initialValue, new Fallout4Group.Mask<TItem>(initialValue));
                this.Classes = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(initialValue, new Fallout4Group.Mask<TItem>(initialValue));
                this.Factions = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(initialValue, new Fallout4Group.Mask<TItem>(initialValue));
                this.HeadParts = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(initialValue, new Fallout4Group.Mask<TItem>(initialValue));
                this.SoundMarkers = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(initialValue, new Fallout4Group.Mask<TItem>(initialValue));
                this.AcousticSpaces = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(initialValue, new Fallout4Group.Mask<TItem>(initialValue));
                this.LandscapeTextures = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(initialValue, new Fallout4Group.Mask<TItem>(initialValue));
                this.Grasses = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(initialValue, new Fallout4Group.Mask<TItem>(initialValue));
                this.MaterialTypes = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(initialValue, new Fallout4Group.Mask<TItem>(initialValue));
            }

            public Mask(
                TItem ModHeader,
                TItem GameSettings,
                TItem Keywords,
                TItem LocationReferenceTypes,
                TItem Actions,
                TItem Transforms,
                TItem Components,
                TItem TextureSets,
                TItem Globals,
                TItem DamageTypes,
                TItem Classes,
                TItem Factions,
                TItem HeadParts,
                TItem SoundMarkers,
                TItem AcousticSpaces,
                TItem LandscapeTextures,
                TItem Grasses,
                TItem MaterialTypes)
            {
                this.ModHeader = new MaskItem<TItem, Fallout4ModHeader.Mask<TItem>?>(ModHeader, new Fallout4ModHeader.Mask<TItem>(ModHeader));
                this.GameSettings = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(GameSettings, new Fallout4Group.Mask<TItem>(GameSettings));
                this.Keywords = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(Keywords, new Fallout4Group.Mask<TItem>(Keywords));
                this.LocationReferenceTypes = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(LocationReferenceTypes, new Fallout4Group.Mask<TItem>(LocationReferenceTypes));
                this.Actions = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(Actions, new Fallout4Group.Mask<TItem>(Actions));
                this.Transforms = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(Transforms, new Fallout4Group.Mask<TItem>(Transforms));
                this.Components = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(Components, new Fallout4Group.Mask<TItem>(Components));
                this.TextureSets = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(TextureSets, new Fallout4Group.Mask<TItem>(TextureSets));
                this.Globals = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(Globals, new Fallout4Group.Mask<TItem>(Globals));
                this.DamageTypes = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(DamageTypes, new Fallout4Group.Mask<TItem>(DamageTypes));
                this.Classes = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(Classes, new Fallout4Group.Mask<TItem>(Classes));
                this.Factions = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(Factions, new Fallout4Group.Mask<TItem>(Factions));
                this.HeadParts = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(HeadParts, new Fallout4Group.Mask<TItem>(HeadParts));
                this.SoundMarkers = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(SoundMarkers, new Fallout4Group.Mask<TItem>(SoundMarkers));
                this.AcousticSpaces = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(AcousticSpaces, new Fallout4Group.Mask<TItem>(AcousticSpaces));
                this.LandscapeTextures = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(LandscapeTextures, new Fallout4Group.Mask<TItem>(LandscapeTextures));
                this.Grasses = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(Grasses, new Fallout4Group.Mask<TItem>(Grasses));
                this.MaterialTypes = new MaskItem<TItem, Fallout4Group.Mask<TItem>?>(MaterialTypes, new Fallout4Group.Mask<TItem>(MaterialTypes));
            }

            #pragma warning disable CS8618
            protected Mask()
            {
            }
            #pragma warning restore CS8618

            #endregion

            #region Members
            public MaskItem<TItem, Fallout4ModHeader.Mask<TItem>?>? ModHeader { get; set; }
            public MaskItem<TItem, Fallout4Group.Mask<TItem>?>? GameSettings { get; set; }
            public MaskItem<TItem, Fallout4Group.Mask<TItem>?>? Keywords { get; set; }
            public MaskItem<TItem, Fallout4Group.Mask<TItem>?>? LocationReferenceTypes { get; set; }
            public MaskItem<TItem, Fallout4Group.Mask<TItem>?>? Actions { get; set; }
            public MaskItem<TItem, Fallout4Group.Mask<TItem>?>? Transforms { get; set; }
            public MaskItem<TItem, Fallout4Group.Mask<TItem>?>? Components { get; set; }
            public MaskItem<TItem, Fallout4Group.Mask<TItem>?>? TextureSets { get; set; }
            public MaskItem<TItem, Fallout4Group.Mask<TItem>?>? Globals { get; set; }
            public MaskItem<TItem, Fallout4Group.Mask<TItem>?>? DamageTypes { get; set; }
            public MaskItem<TItem, Fallout4Group.Mask<TItem>?>? Classes { get; set; }
            public MaskItem<TItem, Fallout4Group.Mask<TItem>?>? Factions { get; set; }
            public MaskItem<TItem, Fallout4Group.Mask<TItem>?>? HeadParts { get; set; }
            public MaskItem<TItem, Fallout4Group.Mask<TItem>?>? SoundMarkers { get; set; }
            public MaskItem<TItem, Fallout4Group.Mask<TItem>?>? AcousticSpaces { get; set; }
            public MaskItem<TItem, Fallout4Group.Mask<TItem>?>? LandscapeTextures { get; set; }
            public MaskItem<TItem, Fallout4Group.Mask<TItem>?>? Grasses { get; set; }
            public MaskItem<TItem, Fallout4Group.Mask<TItem>?>? MaterialTypes { get; set; }
            #endregion

            #region Equals
            public override bool Equals(object? obj)
            {
                if (!(obj is Mask<TItem> rhs)) return false;
                return Equals(rhs);
            }

            public bool Equals(Mask<TItem>? rhs)
            {
                if (rhs == null) return false;
                if (!object.Equals(this.ModHeader, rhs.ModHeader)) return false;
                if (!object.Equals(this.GameSettings, rhs.GameSettings)) return false;
                if (!object.Equals(this.Keywords, rhs.Keywords)) return false;
                if (!object.Equals(this.LocationReferenceTypes, rhs.LocationReferenceTypes)) return false;
                if (!object.Equals(this.Actions, rhs.Actions)) return false;
                if (!object.Equals(this.Transforms, rhs.Transforms)) return false;
                if (!object.Equals(this.Components, rhs.Components)) return false;
                if (!object.Equals(this.TextureSets, rhs.TextureSets)) return false;
                if (!object.Equals(this.Globals, rhs.Globals)) return false;
                if (!object.Equals(this.DamageTypes, rhs.DamageTypes)) return false;
                if (!object.Equals(this.Classes, rhs.Classes)) return false;
                if (!object.Equals(this.Factions, rhs.Factions)) return false;
                if (!object.Equals(this.HeadParts, rhs.HeadParts)) return false;
                if (!object.Equals(this.SoundMarkers, rhs.SoundMarkers)) return false;
                if (!object.Equals(this.AcousticSpaces, rhs.AcousticSpaces)) return false;
                if (!object.Equals(this.LandscapeTextures, rhs.LandscapeTextures)) return false;
                if (!object.Equals(this.Grasses, rhs.Grasses)) return false;
                if (!object.Equals(this.MaterialTypes, rhs.MaterialTypes)) return false;
                return true;
            }
            public override int GetHashCode()
            {
                var hash = new HashCode();
                hash.Add(this.ModHeader);
                hash.Add(this.GameSettings);
                hash.Add(this.Keywords);
                hash.Add(this.LocationReferenceTypes);
                hash.Add(this.Actions);
                hash.Add(this.Transforms);
                hash.Add(this.Components);
                hash.Add(this.TextureSets);
                hash.Add(this.Globals);
                hash.Add(this.DamageTypes);
                hash.Add(this.Classes);
                hash.Add(this.Factions);
                hash.Add(this.HeadParts);
                hash.Add(this.SoundMarkers);
                hash.Add(this.AcousticSpaces);
                hash.Add(this.LandscapeTextures);
                hash.Add(this.Grasses);
                hash.Add(this.MaterialTypes);
                return hash.ToHashCode();
            }

            #endregion

            #region All
            public bool All(Func<TItem, bool> eval)
            {
                if (ModHeader != null)
                {
                    if (!eval(this.ModHeader.Overall)) return false;
                    if (this.ModHeader.Specific != null && !this.ModHeader.Specific.All(eval)) return false;
                }
                if (GameSettings != null)
                {
                    if (!eval(this.GameSettings.Overall)) return false;
                    if (this.GameSettings.Specific != null && !this.GameSettings.Specific.All(eval)) return false;
                }
                if (Keywords != null)
                {
                    if (!eval(this.Keywords.Overall)) return false;
                    if (this.Keywords.Specific != null && !this.Keywords.Specific.All(eval)) return false;
                }
                if (LocationReferenceTypes != null)
                {
                    if (!eval(this.LocationReferenceTypes.Overall)) return false;
                    if (this.LocationReferenceTypes.Specific != null && !this.LocationReferenceTypes.Specific.All(eval)) return false;
                }
                if (Actions != null)
                {
                    if (!eval(this.Actions.Overall)) return false;
                    if (this.Actions.Specific != null && !this.Actions.Specific.All(eval)) return false;
                }
                if (Transforms != null)
                {
                    if (!eval(this.Transforms.Overall)) return false;
                    if (this.Transforms.Specific != null && !this.Transforms.Specific.All(eval)) return false;
                }
                if (Components != null)
                {
                    if (!eval(this.Components.Overall)) return false;
                    if (this.Components.Specific != null && !this.Components.Specific.All(eval)) return false;
                }
                if (TextureSets != null)
                {
                    if (!eval(this.TextureSets.Overall)) return false;
                    if (this.TextureSets.Specific != null && !this.TextureSets.Specific.All(eval)) return false;
                }
                if (Globals != null)
                {
                    if (!eval(this.Globals.Overall)) return false;
                    if (this.Globals.Specific != null && !this.Globals.Specific.All(eval)) return false;
                }
                if (DamageTypes != null)
                {
                    if (!eval(this.DamageTypes.Overall)) return false;
                    if (this.DamageTypes.Specific != null && !this.DamageTypes.Specific.All(eval)) return false;
                }
                if (Classes != null)
                {
                    if (!eval(this.Classes.Overall)) return false;
                    if (this.Classes.Specific != null && !this.Classes.Specific.All(eval)) return false;
                }
                if (Factions != null)
                {
                    if (!eval(this.Factions.Overall)) return false;
                    if (this.Factions.Specific != null && !this.Factions.Specific.All(eval)) return false;
                }
                if (HeadParts != null)
                {
                    if (!eval(this.HeadParts.Overall)) return false;
                    if (this.HeadParts.Specific != null && !this.HeadParts.Specific.All(eval)) return false;
                }
                if (SoundMarkers != null)
                {
                    if (!eval(this.SoundMarkers.Overall)) return false;
                    if (this.SoundMarkers.Specific != null && !this.SoundMarkers.Specific.All(eval)) return false;
                }
                if (AcousticSpaces != null)
                {
                    if (!eval(this.AcousticSpaces.Overall)) return false;
                    if (this.AcousticSpaces.Specific != null && !this.AcousticSpaces.Specific.All(eval)) return false;
                }
                if (LandscapeTextures != null)
                {
                    if (!eval(this.LandscapeTextures.Overall)) return false;
                    if (this.LandscapeTextures.Specific != null && !this.LandscapeTextures.Specific.All(eval)) return false;
                }
                if (Grasses != null)
                {
                    if (!eval(this.Grasses.Overall)) return false;
                    if (this.Grasses.Specific != null && !this.Grasses.Specific.All(eval)) return false;
                }
                if (MaterialTypes != null)
                {
                    if (!eval(this.MaterialTypes.Overall)) return false;
                    if (this.MaterialTypes.Specific != null && !this.MaterialTypes.Specific.All(eval)) return false;
                }
                return true;
            }
            #endregion

            #region Any
            public bool Any(Func<TItem, bool> eval)
            {
                if (ModHeader != null)
                {
                    if (eval(this.ModHeader.Overall)) return true;
                    if (this.ModHeader.Specific != null && this.ModHeader.Specific.Any(eval)) return true;
                }
                if (GameSettings != null)
                {
                    if (eval(this.GameSettings.Overall)) return true;
                    if (this.GameSettings.Specific != null && this.GameSettings.Specific.Any(eval)) return true;
                }
                if (Keywords != null)
                {
                    if (eval(this.Keywords.Overall)) return true;
                    if (this.Keywords.Specific != null && this.Keywords.Specific.Any(eval)) return true;
                }
                if (LocationReferenceTypes != null)
                {
                    if (eval(this.LocationReferenceTypes.Overall)) return true;
                    if (this.LocationReferenceTypes.Specific != null && this.LocationReferenceTypes.Specific.Any(eval)) return true;
                }
                if (Actions != null)
                {
                    if (eval(this.Actions.Overall)) return true;
                    if (this.Actions.Specific != null && this.Actions.Specific.Any(eval)) return true;
                }
                if (Transforms != null)
                {
                    if (eval(this.Transforms.Overall)) return true;
                    if (this.Transforms.Specific != null && this.Transforms.Specific.Any(eval)) return true;
                }
                if (Components != null)
                {
                    if (eval(this.Components.Overall)) return true;
                    if (this.Components.Specific != null && this.Components.Specific.Any(eval)) return true;
                }
                if (TextureSets != null)
                {
                    if (eval(this.TextureSets.Overall)) return true;
                    if (this.TextureSets.Specific != null && this.TextureSets.Specific.Any(eval)) return true;
                }
                if (Globals != null)
                {
                    if (eval(this.Globals.Overall)) return true;
                    if (this.Globals.Specific != null && this.Globals.Specific.Any(eval)) return true;
                }
                if (DamageTypes != null)
                {
                    if (eval(this.DamageTypes.Overall)) return true;
                    if (this.DamageTypes.Specific != null && this.DamageTypes.Specific.Any(eval)) return true;
                }
                if (Classes != null)
                {
                    if (eval(this.Classes.Overall)) return true;
                    if (this.Classes.Specific != null && this.Classes.Specific.Any(eval)) return true;
                }
                if (Factions != null)
                {
                    if (eval(this.Factions.Overall)) return true;
                    if (this.Factions.Specific != null && this.Factions.Specific.Any(eval)) return true;
                }
                if (HeadParts != null)
                {
                    if (eval(this.HeadParts.Overall)) return true;
                    if (this.HeadParts.Specific != null && this.HeadParts.Specific.Any(eval)) return true;
                }
                if (SoundMarkers != null)
                {
                    if (eval(this.SoundMarkers.Overall)) return true;
                    if (this.SoundMarkers.Specific != null && this.SoundMarkers.Specific.Any(eval)) return true;
                }
                if (AcousticSpaces != null)
                {
                    if (eval(this.AcousticSpaces.Overall)) return true;
                    if (this.AcousticSpaces.Specific != null && this.AcousticSpaces.Specific.Any(eval)) return true;
                }
                if (LandscapeTextures != null)
                {
                    if (eval(this.LandscapeTextures.Overall)) return true;
                    if (this.LandscapeTextures.Specific != null && this.LandscapeTextures.Specific.Any(eval)) return true;
                }
                if (Grasses != null)
                {
                    if (eval(this.Grasses.Overall)) return true;
                    if (this.Grasses.Specific != null && this.Grasses.Specific.Any(eval)) return true;
                }
                if (MaterialTypes != null)
                {
                    if (eval(this.MaterialTypes.Overall)) return true;
                    if (this.MaterialTypes.Specific != null && this.MaterialTypes.Specific.Any(eval)) return true;
                }
                return false;
            }
            #endregion

            #region Translate
            public Mask<R> Translate<R>(Func<TItem, R> eval)
            {
                var ret = new Fallout4Mod.Mask<R>();
                this.Translate_InternalFill(ret, eval);
                return ret;
            }

            protected void Translate_InternalFill<R>(Mask<R> obj, Func<TItem, R> eval)
            {
                obj.ModHeader = this.ModHeader == null ? null : new MaskItem<R, Fallout4ModHeader.Mask<R>?>(eval(this.ModHeader.Overall), this.ModHeader.Specific?.Translate(eval));
                obj.GameSettings = this.GameSettings == null ? null : new MaskItem<R, Fallout4Group.Mask<R>?>(eval(this.GameSettings.Overall), this.GameSettings.Specific?.Translate(eval));
                obj.Keywords = this.Keywords == null ? null : new MaskItem<R, Fallout4Group.Mask<R>?>(eval(this.Keywords.Overall), this.Keywords.Specific?.Translate(eval));
                obj.LocationReferenceTypes = this.LocationReferenceTypes == null ? null : new MaskItem<R, Fallout4Group.Mask<R>?>(eval(this.LocationReferenceTypes.Overall), this.LocationReferenceTypes.Specific?.Translate(eval));
                obj.Actions = this.Actions == null ? null : new MaskItem<R, Fallout4Group.Mask<R>?>(eval(this.Actions.Overall), this.Actions.Specific?.Translate(eval));
                obj.Transforms = this.Transforms == null ? null : new MaskItem<R, Fallout4Group.Mask<R>?>(eval(this.Transforms.Overall), this.Transforms.Specific?.Translate(eval));
                obj.Components = this.Components == null ? null : new MaskItem<R, Fallout4Group.Mask<R>?>(eval(this.Components.Overall), this.Components.Specific?.Translate(eval));
                obj.TextureSets = this.TextureSets == null ? null : new MaskItem<R, Fallout4Group.Mask<R>?>(eval(this.TextureSets.Overall), this.TextureSets.Specific?.Translate(eval));
                obj.Globals = this.Globals == null ? null : new MaskItem<R, Fallout4Group.Mask<R>?>(eval(this.Globals.Overall), this.Globals.Specific?.Translate(eval));
                obj.DamageTypes = this.DamageTypes == null ? null : new MaskItem<R, Fallout4Group.Mask<R>?>(eval(this.DamageTypes.Overall), this.DamageTypes.Specific?.Translate(eval));
                obj.Classes = this.Classes == null ? null : new MaskItem<R, Fallout4Group.Mask<R>?>(eval(this.Classes.Overall), this.Classes.Specific?.Translate(eval));
                obj.Factions = this.Factions == null ? null : new MaskItem<R, Fallout4Group.Mask<R>?>(eval(this.Factions.Overall), this.Factions.Specific?.Translate(eval));
                obj.HeadParts = this.HeadParts == null ? null : new MaskItem<R, Fallout4Group.Mask<R>?>(eval(this.HeadParts.Overall), this.HeadParts.Specific?.Translate(eval));
                obj.SoundMarkers = this.SoundMarkers == null ? null : new MaskItem<R, Fallout4Group.Mask<R>?>(eval(this.SoundMarkers.Overall), this.SoundMarkers.Specific?.Translate(eval));
                obj.AcousticSpaces = this.AcousticSpaces == null ? null : new MaskItem<R, Fallout4Group.Mask<R>?>(eval(this.AcousticSpaces.Overall), this.AcousticSpaces.Specific?.Translate(eval));
                obj.LandscapeTextures = this.LandscapeTextures == null ? null : new MaskItem<R, Fallout4Group.Mask<R>?>(eval(this.LandscapeTextures.Overall), this.LandscapeTextures.Specific?.Translate(eval));
                obj.Grasses = this.Grasses == null ? null : new MaskItem<R, Fallout4Group.Mask<R>?>(eval(this.Grasses.Overall), this.Grasses.Specific?.Translate(eval));
                obj.MaterialTypes = this.MaterialTypes == null ? null : new MaskItem<R, Fallout4Group.Mask<R>?>(eval(this.MaterialTypes.Overall), this.MaterialTypes.Specific?.Translate(eval));
            }
            #endregion

            #region To String
            public override string ToString()
            {
                return ToString(printMask: null);
            }

            public string ToString(Fallout4Mod.Mask<bool>? printMask = null)
            {
                var fg = new FileGeneration();
                ToString(fg, printMask);
                return fg.ToString();
            }

            public void ToString(FileGeneration fg, Fallout4Mod.Mask<bool>? printMask = null)
            {
                fg.AppendLine($"{nameof(Fallout4Mod.Mask<TItem>)} =>");
                fg.AppendLine("[");
                using (new DepthWrapper(fg))
                {
                    if (printMask?.ModHeader?.Overall ?? true)
                    {
                        ModHeader?.ToString(fg);
                    }
                    if (printMask?.GameSettings?.Overall ?? true)
                    {
                        GameSettings?.ToString(fg);
                    }
                    if (printMask?.Keywords?.Overall ?? true)
                    {
                        Keywords?.ToString(fg);
                    }
                    if (printMask?.LocationReferenceTypes?.Overall ?? true)
                    {
                        LocationReferenceTypes?.ToString(fg);
                    }
                    if (printMask?.Actions?.Overall ?? true)
                    {
                        Actions?.ToString(fg);
                    }
                    if (printMask?.Transforms?.Overall ?? true)
                    {
                        Transforms?.ToString(fg);
                    }
                    if (printMask?.Components?.Overall ?? true)
                    {
                        Components?.ToString(fg);
                    }
                    if (printMask?.TextureSets?.Overall ?? true)
                    {
                        TextureSets?.ToString(fg);
                    }
                    if (printMask?.Globals?.Overall ?? true)
                    {
                        Globals?.ToString(fg);
                    }
                    if (printMask?.DamageTypes?.Overall ?? true)
                    {
                        DamageTypes?.ToString(fg);
                    }
                    if (printMask?.Classes?.Overall ?? true)
                    {
                        Classes?.ToString(fg);
                    }
                    if (printMask?.Factions?.Overall ?? true)
                    {
                        Factions?.ToString(fg);
                    }
                    if (printMask?.HeadParts?.Overall ?? true)
                    {
                        HeadParts?.ToString(fg);
                    }
                    if (printMask?.SoundMarkers?.Overall ?? true)
                    {
                        SoundMarkers?.ToString(fg);
                    }
                    if (printMask?.AcousticSpaces?.Overall ?? true)
                    {
                        AcousticSpaces?.ToString(fg);
                    }
                    if (printMask?.LandscapeTextures?.Overall ?? true)
                    {
                        LandscapeTextures?.ToString(fg);
                    }
                    if (printMask?.Grasses?.Overall ?? true)
                    {
                        Grasses?.ToString(fg);
                    }
                    if (printMask?.MaterialTypes?.Overall ?? true)
                    {
                        MaterialTypes?.ToString(fg);
                    }
                }
                fg.AppendLine("]");
            }
            #endregion

        }

        public class ErrorMask :
            IErrorMask,
            IErrorMask<ErrorMask>
        {
            #region Members
            public Exception? Overall { get; set; }
            private List<string>? _warnings;
            public List<string> Warnings
            {
                get
                {
                    if (_warnings == null)
                    {
                        _warnings = new List<string>();
                    }
                    return _warnings;
                }
            }
            public MaskItem<Exception?, Fallout4ModHeader.ErrorMask?>? ModHeader;
            public MaskItem<Exception?, Fallout4Group.ErrorMask<GameSetting.ErrorMask>?>? GameSettings;
            public MaskItem<Exception?, Fallout4Group.ErrorMask<Keyword.ErrorMask>?>? Keywords;
            public MaskItem<Exception?, Fallout4Group.ErrorMask<LocationReferenceType.ErrorMask>?>? LocationReferenceTypes;
            public MaskItem<Exception?, Fallout4Group.ErrorMask<ActionRecord.ErrorMask>?>? Actions;
            public MaskItem<Exception?, Fallout4Group.ErrorMask<Transform.ErrorMask>?>? Transforms;
            public MaskItem<Exception?, Fallout4Group.ErrorMask<Component.ErrorMask>?>? Components;
            public MaskItem<Exception?, Fallout4Group.ErrorMask<TextureSet.ErrorMask>?>? TextureSets;
            public MaskItem<Exception?, Fallout4Group.ErrorMask<Global.ErrorMask>?>? Globals;
            public MaskItem<Exception?, Fallout4Group.ErrorMask<ADamageType.ErrorMask>?>? DamageTypes;
            public MaskItem<Exception?, Fallout4Group.ErrorMask<Class.ErrorMask>?>? Classes;
            public MaskItem<Exception?, Fallout4Group.ErrorMask<Faction.ErrorMask>?>? Factions;
            public MaskItem<Exception?, Fallout4Group.ErrorMask<HeadPart.ErrorMask>?>? HeadParts;
            public MaskItem<Exception?, Fallout4Group.ErrorMask<SoundMarker.ErrorMask>?>? SoundMarkers;
            public MaskItem<Exception?, Fallout4Group.ErrorMask<AcousticSpace.ErrorMask>?>? AcousticSpaces;
            public MaskItem<Exception?, Fallout4Group.ErrorMask<LandscapeTexture.ErrorMask>?>? LandscapeTextures;
            public MaskItem<Exception?, Fallout4Group.ErrorMask<Grass.ErrorMask>?>? Grasses;
            public MaskItem<Exception?, Fallout4Group.ErrorMask<MaterialType.ErrorMask>?>? MaterialTypes;
            #endregion

            #region IErrorMask
            public object? GetNthMask(int index)
            {
                Fallout4Mod_FieldIndex enu = (Fallout4Mod_FieldIndex)index;
                switch (enu)
                {
                    case Fallout4Mod_FieldIndex.ModHeader:
                        return ModHeader;
                    case Fallout4Mod_FieldIndex.GameSettings:
                        return GameSettings;
                    case Fallout4Mod_FieldIndex.Keywords:
                        return Keywords;
                    case Fallout4Mod_FieldIndex.LocationReferenceTypes:
                        return LocationReferenceTypes;
                    case Fallout4Mod_FieldIndex.Actions:
                        return Actions;
                    case Fallout4Mod_FieldIndex.Transforms:
                        return Transforms;
                    case Fallout4Mod_FieldIndex.Components:
                        return Components;
                    case Fallout4Mod_FieldIndex.TextureSets:
                        return TextureSets;
                    case Fallout4Mod_FieldIndex.Globals:
                        return Globals;
                    case Fallout4Mod_FieldIndex.DamageTypes:
                        return DamageTypes;
                    case Fallout4Mod_FieldIndex.Classes:
                        return Classes;
                    case Fallout4Mod_FieldIndex.Factions:
                        return Factions;
                    case Fallout4Mod_FieldIndex.HeadParts:
                        return HeadParts;
                    case Fallout4Mod_FieldIndex.SoundMarkers:
                        return SoundMarkers;
                    case Fallout4Mod_FieldIndex.AcousticSpaces:
                        return AcousticSpaces;
                    case Fallout4Mod_FieldIndex.LandscapeTextures:
                        return LandscapeTextures;
                    case Fallout4Mod_FieldIndex.Grasses:
                        return Grasses;
                    case Fallout4Mod_FieldIndex.MaterialTypes:
                        return MaterialTypes;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthException(int index, Exception ex)
            {
                Fallout4Mod_FieldIndex enu = (Fallout4Mod_FieldIndex)index;
                switch (enu)
                {
                    case Fallout4Mod_FieldIndex.ModHeader:
                        this.ModHeader = new MaskItem<Exception?, Fallout4ModHeader.ErrorMask?>(ex, null);
                        break;
                    case Fallout4Mod_FieldIndex.GameSettings:
                        this.GameSettings = new MaskItem<Exception?, Fallout4Group.ErrorMask<GameSetting.ErrorMask>?>(ex, null);
                        break;
                    case Fallout4Mod_FieldIndex.Keywords:
                        this.Keywords = new MaskItem<Exception?, Fallout4Group.ErrorMask<Keyword.ErrorMask>?>(ex, null);
                        break;
                    case Fallout4Mod_FieldIndex.LocationReferenceTypes:
                        this.LocationReferenceTypes = new MaskItem<Exception?, Fallout4Group.ErrorMask<LocationReferenceType.ErrorMask>?>(ex, null);
                        break;
                    case Fallout4Mod_FieldIndex.Actions:
                        this.Actions = new MaskItem<Exception?, Fallout4Group.ErrorMask<ActionRecord.ErrorMask>?>(ex, null);
                        break;
                    case Fallout4Mod_FieldIndex.Transforms:
                        this.Transforms = new MaskItem<Exception?, Fallout4Group.ErrorMask<Transform.ErrorMask>?>(ex, null);
                        break;
                    case Fallout4Mod_FieldIndex.Components:
                        this.Components = new MaskItem<Exception?, Fallout4Group.ErrorMask<Component.ErrorMask>?>(ex, null);
                        break;
                    case Fallout4Mod_FieldIndex.TextureSets:
                        this.TextureSets = new MaskItem<Exception?, Fallout4Group.ErrorMask<TextureSet.ErrorMask>?>(ex, null);
                        break;
                    case Fallout4Mod_FieldIndex.Globals:
                        this.Globals = new MaskItem<Exception?, Fallout4Group.ErrorMask<Global.ErrorMask>?>(ex, null);
                        break;
                    case Fallout4Mod_FieldIndex.DamageTypes:
                        this.DamageTypes = new MaskItem<Exception?, Fallout4Group.ErrorMask<ADamageType.ErrorMask>?>(ex, null);
                        break;
                    case Fallout4Mod_FieldIndex.Classes:
                        this.Classes = new MaskItem<Exception?, Fallout4Group.ErrorMask<Class.ErrorMask>?>(ex, null);
                        break;
                    case Fallout4Mod_FieldIndex.Factions:
                        this.Factions = new MaskItem<Exception?, Fallout4Group.ErrorMask<Faction.ErrorMask>?>(ex, null);
                        break;
                    case Fallout4Mod_FieldIndex.HeadParts:
                        this.HeadParts = new MaskItem<Exception?, Fallout4Group.ErrorMask<HeadPart.ErrorMask>?>(ex, null);
                        break;
                    case Fallout4Mod_FieldIndex.SoundMarkers:
                        this.SoundMarkers = new MaskItem<Exception?, Fallout4Group.ErrorMask<SoundMarker.ErrorMask>?>(ex, null);
                        break;
                    case Fallout4Mod_FieldIndex.AcousticSpaces:
                        this.AcousticSpaces = new MaskItem<Exception?, Fallout4Group.ErrorMask<AcousticSpace.ErrorMask>?>(ex, null);
                        break;
                    case Fallout4Mod_FieldIndex.LandscapeTextures:
                        this.LandscapeTextures = new MaskItem<Exception?, Fallout4Group.ErrorMask<LandscapeTexture.ErrorMask>?>(ex, null);
                        break;
                    case Fallout4Mod_FieldIndex.Grasses:
                        this.Grasses = new MaskItem<Exception?, Fallout4Group.ErrorMask<Grass.ErrorMask>?>(ex, null);
                        break;
                    case Fallout4Mod_FieldIndex.MaterialTypes:
                        this.MaterialTypes = new MaskItem<Exception?, Fallout4Group.ErrorMask<MaterialType.ErrorMask>?>(ex, null);
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthMask(int index, object obj)
            {
                Fallout4Mod_FieldIndex enu = (Fallout4Mod_FieldIndex)index;
                switch (enu)
                {
                    case Fallout4Mod_FieldIndex.ModHeader:
                        this.ModHeader = (MaskItem<Exception?, Fallout4ModHeader.ErrorMask?>?)obj;
                        break;
                    case Fallout4Mod_FieldIndex.GameSettings:
                        this.GameSettings = (MaskItem<Exception?, Fallout4Group.ErrorMask<GameSetting.ErrorMask>?>?)obj;
                        break;
                    case Fallout4Mod_FieldIndex.Keywords:
                        this.Keywords = (MaskItem<Exception?, Fallout4Group.ErrorMask<Keyword.ErrorMask>?>?)obj;
                        break;
                    case Fallout4Mod_FieldIndex.LocationReferenceTypes:
                        this.LocationReferenceTypes = (MaskItem<Exception?, Fallout4Group.ErrorMask<LocationReferenceType.ErrorMask>?>?)obj;
                        break;
                    case Fallout4Mod_FieldIndex.Actions:
                        this.Actions = (MaskItem<Exception?, Fallout4Group.ErrorMask<ActionRecord.ErrorMask>?>?)obj;
                        break;
                    case Fallout4Mod_FieldIndex.Transforms:
                        this.Transforms = (MaskItem<Exception?, Fallout4Group.ErrorMask<Transform.ErrorMask>?>?)obj;
                        break;
                    case Fallout4Mod_FieldIndex.Components:
                        this.Components = (MaskItem<Exception?, Fallout4Group.ErrorMask<Component.ErrorMask>?>?)obj;
                        break;
                    case Fallout4Mod_FieldIndex.TextureSets:
                        this.TextureSets = (MaskItem<Exception?, Fallout4Group.ErrorMask<TextureSet.ErrorMask>?>?)obj;
                        break;
                    case Fallout4Mod_FieldIndex.Globals:
                        this.Globals = (MaskItem<Exception?, Fallout4Group.ErrorMask<Global.ErrorMask>?>?)obj;
                        break;
                    case Fallout4Mod_FieldIndex.DamageTypes:
                        this.DamageTypes = (MaskItem<Exception?, Fallout4Group.ErrorMask<ADamageType.ErrorMask>?>?)obj;
                        break;
                    case Fallout4Mod_FieldIndex.Classes:
                        this.Classes = (MaskItem<Exception?, Fallout4Group.ErrorMask<Class.ErrorMask>?>?)obj;
                        break;
                    case Fallout4Mod_FieldIndex.Factions:
                        this.Factions = (MaskItem<Exception?, Fallout4Group.ErrorMask<Faction.ErrorMask>?>?)obj;
                        break;
                    case Fallout4Mod_FieldIndex.HeadParts:
                        this.HeadParts = (MaskItem<Exception?, Fallout4Group.ErrorMask<HeadPart.ErrorMask>?>?)obj;
                        break;
                    case Fallout4Mod_FieldIndex.SoundMarkers:
                        this.SoundMarkers = (MaskItem<Exception?, Fallout4Group.ErrorMask<SoundMarker.ErrorMask>?>?)obj;
                        break;
                    case Fallout4Mod_FieldIndex.AcousticSpaces:
                        this.AcousticSpaces = (MaskItem<Exception?, Fallout4Group.ErrorMask<AcousticSpace.ErrorMask>?>?)obj;
                        break;
                    case Fallout4Mod_FieldIndex.LandscapeTextures:
                        this.LandscapeTextures = (MaskItem<Exception?, Fallout4Group.ErrorMask<LandscapeTexture.ErrorMask>?>?)obj;
                        break;
                    case Fallout4Mod_FieldIndex.Grasses:
                        this.Grasses = (MaskItem<Exception?, Fallout4Group.ErrorMask<Grass.ErrorMask>?>?)obj;
                        break;
                    case Fallout4Mod_FieldIndex.MaterialTypes:
                        this.MaterialTypes = (MaskItem<Exception?, Fallout4Group.ErrorMask<MaterialType.ErrorMask>?>?)obj;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public bool IsInError()
            {
                if (Overall != null) return true;
                if (ModHeader != null) return true;
                if (GameSettings != null) return true;
                if (Keywords != null) return true;
                if (LocationReferenceTypes != null) return true;
                if (Actions != null) return true;
                if (Transforms != null) return true;
                if (Components != null) return true;
                if (TextureSets != null) return true;
                if (Globals != null) return true;
                if (DamageTypes != null) return true;
                if (Classes != null) return true;
                if (Factions != null) return true;
                if (HeadParts != null) return true;
                if (SoundMarkers != null) return true;
                if (AcousticSpaces != null) return true;
                if (LandscapeTextures != null) return true;
                if (Grasses != null) return true;
                if (MaterialTypes != null) return true;
                return false;
            }
            #endregion

            #region To String
            public override string ToString()
            {
                var fg = new FileGeneration();
                ToString(fg, null);
                return fg.ToString();
            }

            public void ToString(FileGeneration fg, string? name = null)
            {
                fg.AppendLine($"{(name ?? "ErrorMask")} =>");
                fg.AppendLine("[");
                using (new DepthWrapper(fg))
                {
                    if (this.Overall != null)
                    {
                        fg.AppendLine("Overall =>");
                        fg.AppendLine("[");
                        using (new DepthWrapper(fg))
                        {
                            fg.AppendLine($"{this.Overall}");
                        }
                        fg.AppendLine("]");
                    }
                    ToString_FillInternal(fg);
                }
                fg.AppendLine("]");
            }
            protected void ToString_FillInternal(FileGeneration fg)
            {
                ModHeader?.ToString(fg);
                GameSettings?.ToString(fg);
                Keywords?.ToString(fg);
                LocationReferenceTypes?.ToString(fg);
                Actions?.ToString(fg);
                Transforms?.ToString(fg);
                Components?.ToString(fg);
                TextureSets?.ToString(fg);
                Globals?.ToString(fg);
                DamageTypes?.ToString(fg);
                Classes?.ToString(fg);
                Factions?.ToString(fg);
                HeadParts?.ToString(fg);
                SoundMarkers?.ToString(fg);
                AcousticSpaces?.ToString(fg);
                LandscapeTextures?.ToString(fg);
                Grasses?.ToString(fg);
                MaterialTypes?.ToString(fg);
            }
            #endregion

            #region Combine
            public ErrorMask Combine(ErrorMask? rhs)
            {
                if (rhs == null) return this;
                var ret = new ErrorMask();
                ret.ModHeader = this.ModHeader.Combine(rhs.ModHeader, (l, r) => l.Combine(r));
                ret.GameSettings = this.GameSettings.Combine(rhs.GameSettings, (l, r) => l.Combine(r));
                ret.Keywords = this.Keywords.Combine(rhs.Keywords, (l, r) => l.Combine(r));
                ret.LocationReferenceTypes = this.LocationReferenceTypes.Combine(rhs.LocationReferenceTypes, (l, r) => l.Combine(r));
                ret.Actions = this.Actions.Combine(rhs.Actions, (l, r) => l.Combine(r));
                ret.Transforms = this.Transforms.Combine(rhs.Transforms, (l, r) => l.Combine(r));
                ret.Components = this.Components.Combine(rhs.Components, (l, r) => l.Combine(r));
                ret.TextureSets = this.TextureSets.Combine(rhs.TextureSets, (l, r) => l.Combine(r));
                ret.Globals = this.Globals.Combine(rhs.Globals, (l, r) => l.Combine(r));
                ret.DamageTypes = this.DamageTypes.Combine(rhs.DamageTypes, (l, r) => l.Combine(r));
                ret.Classes = this.Classes.Combine(rhs.Classes, (l, r) => l.Combine(r));
                ret.Factions = this.Factions.Combine(rhs.Factions, (l, r) => l.Combine(r));
                ret.HeadParts = this.HeadParts.Combine(rhs.HeadParts, (l, r) => l.Combine(r));
                ret.SoundMarkers = this.SoundMarkers.Combine(rhs.SoundMarkers, (l, r) => l.Combine(r));
                ret.AcousticSpaces = this.AcousticSpaces.Combine(rhs.AcousticSpaces, (l, r) => l.Combine(r));
                ret.LandscapeTextures = this.LandscapeTextures.Combine(rhs.LandscapeTextures, (l, r) => l.Combine(r));
                ret.Grasses = this.Grasses.Combine(rhs.Grasses, (l, r) => l.Combine(r));
                ret.MaterialTypes = this.MaterialTypes.Combine(rhs.MaterialTypes, (l, r) => l.Combine(r));
                return ret;
            }
            public static ErrorMask? Combine(ErrorMask? lhs, ErrorMask? rhs)
            {
                if (lhs != null && rhs != null) return lhs.Combine(rhs);
                return lhs ?? rhs;
            }
            #endregion

            #region Factory
            public static ErrorMask Factory(ErrorMaskBuilder errorMask)
            {
                return new ErrorMask();
            }
            #endregion

        }
        public class TranslationMask : ITranslationMask
        {
            #region Members
            private TranslationCrystal? _crystal;
            public readonly bool DefaultOn;
            public bool OnOverall;
            public Fallout4ModHeader.TranslationMask? ModHeader;
            public Fallout4Group.TranslationMask<GameSetting.TranslationMask>? GameSettings;
            public Fallout4Group.TranslationMask<Keyword.TranslationMask>? Keywords;
            public Fallout4Group.TranslationMask<LocationReferenceType.TranslationMask>? LocationReferenceTypes;
            public Fallout4Group.TranslationMask<ActionRecord.TranslationMask>? Actions;
            public Fallout4Group.TranslationMask<Transform.TranslationMask>? Transforms;
            public Fallout4Group.TranslationMask<Component.TranslationMask>? Components;
            public Fallout4Group.TranslationMask<TextureSet.TranslationMask>? TextureSets;
            public Fallout4Group.TranslationMask<Global.TranslationMask>? Globals;
            public Fallout4Group.TranslationMask<ADamageType.TranslationMask>? DamageTypes;
            public Fallout4Group.TranslationMask<Class.TranslationMask>? Classes;
            public Fallout4Group.TranslationMask<Faction.TranslationMask>? Factions;
            public Fallout4Group.TranslationMask<HeadPart.TranslationMask>? HeadParts;
            public Fallout4Group.TranslationMask<SoundMarker.TranslationMask>? SoundMarkers;
            public Fallout4Group.TranslationMask<AcousticSpace.TranslationMask>? AcousticSpaces;
            public Fallout4Group.TranslationMask<LandscapeTexture.TranslationMask>? LandscapeTextures;
            public Fallout4Group.TranslationMask<Grass.TranslationMask>? Grasses;
            public Fallout4Group.TranslationMask<MaterialType.TranslationMask>? MaterialTypes;
            #endregion

            #region Ctors
            public TranslationMask(
                bool defaultOn,
                bool onOverall = true)
            {
                this.DefaultOn = defaultOn;
                this.OnOverall = onOverall;
            }

            #endregion

            public TranslationCrystal GetCrystal()
            {
                if (_crystal != null) return _crystal;
                var ret = new List<(bool On, TranslationCrystal? SubCrystal)>();
                GetCrystal(ret);
                _crystal = new TranslationCrystal(ret.ToArray());
                return _crystal;
            }

            protected void GetCrystal(List<(bool On, TranslationCrystal? SubCrystal)> ret)
            {
                ret.Add((ModHeader != null ? ModHeader.OnOverall : DefaultOn, ModHeader?.GetCrystal()));
                ret.Add((GameSettings != null ? GameSettings.OnOverall : DefaultOn, GameSettings?.GetCrystal()));
                ret.Add((Keywords != null ? Keywords.OnOverall : DefaultOn, Keywords?.GetCrystal()));
                ret.Add((LocationReferenceTypes != null ? LocationReferenceTypes.OnOverall : DefaultOn, LocationReferenceTypes?.GetCrystal()));
                ret.Add((Actions != null ? Actions.OnOverall : DefaultOn, Actions?.GetCrystal()));
                ret.Add((Transforms != null ? Transforms.OnOverall : DefaultOn, Transforms?.GetCrystal()));
                ret.Add((Components != null ? Components.OnOverall : DefaultOn, Components?.GetCrystal()));
                ret.Add((TextureSets != null ? TextureSets.OnOverall : DefaultOn, TextureSets?.GetCrystal()));
                ret.Add((Globals != null ? Globals.OnOverall : DefaultOn, Globals?.GetCrystal()));
                ret.Add((DamageTypes != null ? DamageTypes.OnOverall : DefaultOn, DamageTypes?.GetCrystal()));
                ret.Add((Classes != null ? Classes.OnOverall : DefaultOn, Classes?.GetCrystal()));
                ret.Add((Factions != null ? Factions.OnOverall : DefaultOn, Factions?.GetCrystal()));
                ret.Add((HeadParts != null ? HeadParts.OnOverall : DefaultOn, HeadParts?.GetCrystal()));
                ret.Add((SoundMarkers != null ? SoundMarkers.OnOverall : DefaultOn, SoundMarkers?.GetCrystal()));
                ret.Add((AcousticSpaces != null ? AcousticSpaces.OnOverall : DefaultOn, AcousticSpaces?.GetCrystal()));
                ret.Add((LandscapeTextures != null ? LandscapeTextures.OnOverall : DefaultOn, LandscapeTextures?.GetCrystal()));
                ret.Add((Grasses != null ? Grasses.OnOverall : DefaultOn, Grasses?.GetCrystal()));
                ret.Add((MaterialTypes != null ? MaterialTypes.OnOverall : DefaultOn, MaterialTypes?.GetCrystal()));
            }

            public static implicit operator TranslationMask(bool defaultOn)
            {
                return new TranslationMask(defaultOn: defaultOn, onOverall: defaultOn);
            }

        }
        #endregion

        #region Mutagen
        public static readonly RecordType GrupRecordType = Fallout4Mod_Registration.TriggeringRecordType;
        public override GameRelease GameRelease => GameRelease.Fallout4;
        IGroupGetter<T> IModGetter.GetTopLevelGroup<T>() => this.GetTopLevelGroup<T>();
        IGroupGetter IModGetter.GetTopLevelGroup(Type type) => this.GetTopLevelGroup(type);
        IGroup<T> IMod.GetTopLevelGroup<T>() => this.GetTopLevelGroup<T>();
        IGroup IMod.GetTopLevelGroup(Type type) => this.GetTopLevelGroup(type);
        void IModGetter.WriteToBinary(FilePath path, BinaryWriteParameters? param, IFileSystem? fileSystem) => this.WriteToBinary(path, importMask: null, param: param, fileSystem: fileSystem);
        void IModGetter.WriteToBinaryParallel(FilePath path, BinaryWriteParameters? param, IFileSystem? fileSystem, ParallelWriteParameters? parallelWriteParams) => this.WriteToBinaryParallel(path, param, fileSystem: fileSystem, parallelParam: parallelWriteParams);
        IMask<bool> IEqualsMask.GetEqualsMask(object rhs, EqualsMaskHelper.Include include = EqualsMaskHelper.Include.OnlyFailures) => Fallout4ModMixIn.GetEqualsMask(this, (IFallout4ModGetter)rhs, include);
        public override bool CanUseLocalization => true;
        public override bool UsingLocalization
        {
            get => this.ModHeader.Flags.HasFlag(Fallout4ModHeader.HeaderFlag.Localized);
            set => this.ModHeader.Flags = this.ModHeader.Flags.SetFlag(Fallout4ModHeader.HeaderFlag.Localized, value);
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IList<MasterReference> IMod.MasterReferences => this.ModHeader.MasterReferences;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IReadOnlyList<IMasterReferenceGetter> IModGetter.MasterReferences => this.ModHeader.MasterReferences;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        uint IMod.NextFormID
        {
            get => this.ModHeader.Stats.NextFormID;
            set => this.ModHeader.Stats.NextFormID = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        uint IModGetter.NextFormID => this.ModHeader.Stats.NextFormID;
        public Fallout4Mod(ModKey modKey)
            : base(modKey)
        {
            this.ModHeader.Stats.NextFormID = GetDefaultInitialNextFormID();
            _GameSettings_Object = new Fallout4Group<GameSetting>(this);
            _Keywords_Object = new Fallout4Group<Keyword>(this);
            _LocationReferenceTypes_Object = new Fallout4Group<LocationReferenceType>(this);
            _Actions_Object = new Fallout4Group<ActionRecord>(this);
            _Transforms_Object = new Fallout4Group<Transform>(this);
            _Components_Object = new Fallout4Group<Component>(this);
            _TextureSets_Object = new Fallout4Group<TextureSet>(this);
            _Globals_Object = new Fallout4Group<Global>(this);
            _DamageTypes_Object = new Fallout4Group<ADamageType>(this);
            _Classes_Object = new Fallout4Group<Class>(this);
            _Factions_Object = new Fallout4Group<Faction>(this);
            _HeadParts_Object = new Fallout4Group<HeadPart>(this);
            _SoundMarkers_Object = new Fallout4Group<SoundMarker>(this);
            _AcousticSpaces_Object = new Fallout4Group<AcousticSpace>(this);
            _LandscapeTextures_Object = new Fallout4Group<LandscapeTexture>(this);
            _Grasses_Object = new Fallout4Group<Grass>(this);
            _MaterialTypes_Object = new Fallout4Group<MaterialType>(this);
            CustomCtor();
        }
        public void AddRecords(
            Fallout4Mod rhsMod,
            GroupMask? mask = null)
        {
            if (mask?.GameSettings ?? true)
            {
                this.GameSettings.RecordCache.Set(rhsMod.GameSettings.RecordCache.Items);
            }
            if (mask?.Keywords ?? true)
            {
                this.Keywords.RecordCache.Set(rhsMod.Keywords.RecordCache.Items);
            }
            if (mask?.LocationReferenceTypes ?? true)
            {
                this.LocationReferenceTypes.RecordCache.Set(rhsMod.LocationReferenceTypes.RecordCache.Items);
            }
            if (mask?.Actions ?? true)
            {
                this.Actions.RecordCache.Set(rhsMod.Actions.RecordCache.Items);
            }
            if (mask?.Transforms ?? true)
            {
                this.Transforms.RecordCache.Set(rhsMod.Transforms.RecordCache.Items);
            }
            if (mask?.Components ?? true)
            {
                this.Components.RecordCache.Set(rhsMod.Components.RecordCache.Items);
            }
            if (mask?.TextureSets ?? true)
            {
                this.TextureSets.RecordCache.Set(rhsMod.TextureSets.RecordCache.Items);
            }
            if (mask?.Globals ?? true)
            {
                this.Globals.RecordCache.Set(rhsMod.Globals.RecordCache.Items);
            }
            if (mask?.DamageTypes ?? true)
            {
                this.DamageTypes.RecordCache.Set(rhsMod.DamageTypes.RecordCache.Items);
            }
            if (mask?.Classes ?? true)
            {
                this.Classes.RecordCache.Set(rhsMod.Classes.RecordCache.Items);
            }
            if (mask?.Factions ?? true)
            {
                this.Factions.RecordCache.Set(rhsMod.Factions.RecordCache.Items);
            }
            if (mask?.HeadParts ?? true)
            {
                this.HeadParts.RecordCache.Set(rhsMod.HeadParts.RecordCache.Items);
            }
            if (mask?.SoundMarkers ?? true)
            {
                this.SoundMarkers.RecordCache.Set(rhsMod.SoundMarkers.RecordCache.Items);
            }
            if (mask?.AcousticSpaces ?? true)
            {
                this.AcousticSpaces.RecordCache.Set(rhsMod.AcousticSpaces.RecordCache.Items);
            }
            if (mask?.LandscapeTextures ?? true)
            {
                this.LandscapeTextures.RecordCache.Set(rhsMod.LandscapeTextures.RecordCache.Items);
            }
            if (mask?.Grasses ?? true)
            {
                this.Grasses.RecordCache.Set(rhsMod.Grasses.RecordCache.Items);
            }
            if (mask?.MaterialTypes ?? true)
            {
                this.MaterialTypes.RecordCache.Set(rhsMod.MaterialTypes.RecordCache.Items);
            }
        }

        public override void SyncRecordCount()
        {
            this.ModHeader.Stats.NumRecords = GetRecordCount();
        }

        public uint GetRecordCount()
        {
            uint count = (uint)this.EnumerateMajorRecords().Count();
            count += GameSettings.RecordCache.Count > 0 ? 1 : default(uint);
            count += Keywords.RecordCache.Count > 0 ? 1 : default(uint);
            count += LocationReferenceTypes.RecordCache.Count > 0 ? 1 : default(uint);
            count += Actions.RecordCache.Count > 0 ? 1 : default(uint);
            count += Transforms.RecordCache.Count > 0 ? 1 : default(uint);
            count += Components.RecordCache.Count > 0 ? 1 : default(uint);
            count += TextureSets.RecordCache.Count > 0 ? 1 : default(uint);
            count += Globals.RecordCache.Count > 0 ? 1 : default(uint);
            count += DamageTypes.RecordCache.Count > 0 ? 1 : default(uint);
            count += Classes.RecordCache.Count > 0 ? 1 : default(uint);
            count += Factions.RecordCache.Count > 0 ? 1 : default(uint);
            count += HeadParts.RecordCache.Count > 0 ? 1 : default(uint);
            count += SoundMarkers.RecordCache.Count > 0 ? 1 : default(uint);
            count += AcousticSpaces.RecordCache.Count > 0 ? 1 : default(uint);
            count += LandscapeTextures.RecordCache.Count > 0 ? 1 : default(uint);
            count += Grasses.RecordCache.Count > 0 ? 1 : default(uint);
            count += MaterialTypes.RecordCache.Count > 0 ? 1 : default(uint);
            GetCustomRecordCount((customCount) => count += customCount);
            return count;
        }

        partial void GetCustomRecordCount(Action<uint> setter);

        public IEnumerable<IFormLinkGetter> ContainedFormLinks => Fallout4ModCommon.Instance.GetContainedFormLinks(this);
        public void RemapLinks(IReadOnlyDictionary<FormKey, FormKey> mapping) => Fallout4ModSetterCommon.Instance.RemapLinks(this, mapping);
        [DebuggerStepThrough]
        IEnumerable<IMajorRecordGetter> IMajorRecordGetterEnumerable.EnumerateMajorRecords() => this.EnumerateMajorRecords();
        [DebuggerStepThrough]
        IEnumerable<TMajor> IMajorRecordGetterEnumerable.EnumerateMajorRecords<TMajor>(bool throwIfUnknown) => this.EnumerateMajorRecords<TMajor>(throwIfUnknown: throwIfUnknown);
        [DebuggerStepThrough]
        IEnumerable<IMajorRecordGetter> IMajorRecordGetterEnumerable.EnumerateMajorRecords(Type type, bool throwIfUnknown) => this.EnumerateMajorRecords(type: type, throwIfUnknown: throwIfUnknown);
        [DebuggerStepThrough]
        IEnumerable<IMajorRecord> IMajorRecordEnumerable.EnumerateMajorRecords() => this.EnumerateMajorRecords();
        [DebuggerStepThrough]
        IEnumerable<TMajor> IMajorRecordEnumerable.EnumerateMajorRecords<TMajor>(bool throwIfUnknown) => this.EnumerateMajorRecords<TMajor>(throwIfUnknown: throwIfUnknown);
        [DebuggerStepThrough]
        IEnumerable<IMajorRecord> IMajorRecordEnumerable.EnumerateMajorRecords(Type? type, bool throwIfUnknown) => this.EnumerateMajorRecords(type: type, throwIfUnknown: throwIfUnknown);
        [DebuggerStepThrough]
        void IMajorRecordEnumerable.Remove(FormKey formKey) => this.Remove(formKey);
        [DebuggerStepThrough]
        void IMajorRecordEnumerable.Remove(HashSet<FormKey> formKeys) => this.Remove(formKeys);
        [DebuggerStepThrough]
        void IMajorRecordEnumerable.Remove(IEnumerable<FormKey> formKeys) => this.Remove(formKeys);
        [DebuggerStepThrough]
        void IMajorRecordEnumerable.Remove(FormKey formKey, Type type, bool throwIfUnknown) => this.Remove(formKey, type, throwIfUnknown);
        [DebuggerStepThrough]
        void IMajorRecordEnumerable.Remove(HashSet<FormKey> formKeys, Type type, bool throwIfUnknown) => this.Remove(formKeys, type, throwIfUnknown);
        [DebuggerStepThrough]
        void IMajorRecordEnumerable.Remove(IEnumerable<FormKey> formKeys, Type type, bool throwIfUnknown) => this.Remove(formKeys, type, throwIfUnknown);
        [DebuggerStepThrough]
        void IMajorRecordEnumerable.Remove<TMajor>(FormKey formKey, bool throwIfUnknown) => this.Remove<TMajor>(formKey, throwIfUnknown);
        [DebuggerStepThrough]
        void IMajorRecordEnumerable.Remove<TMajor>(HashSet<FormKey> formKeys, bool throwIfUnknown) => this.Remove<TMajor>(formKeys, throwIfUnknown);
        [DebuggerStepThrough]
        void IMajorRecordEnumerable.Remove<TMajor>(IEnumerable<FormKey> formKeys, bool throwIfUnknown) => this.Remove<TMajor>(formKeys, throwIfUnknown);
        [DebuggerStepThrough]
        void IMajorRecordEnumerable.Remove<TMajor>(TMajor record, bool throwIfUnknown) => this.Remove<TMajor>(record, throwIfUnknown);
        [DebuggerStepThrough]
        void IMajorRecordEnumerable.Remove<TMajor>(IEnumerable<TMajor> records, bool throwIfUnknown) => this.Remove<TMajor>(records, throwIfUnknown);
        [DebuggerStepThrough]
        IEnumerable<IModContext<IFallout4Mod, IFallout4ModGetter, TSetter, TGetter>> IMajorRecordContextEnumerable<IFallout4Mod, IFallout4ModGetter>.EnumerateMajorRecordContexts<TSetter, TGetter>(ILinkCache linkCache, bool throwIfUnknown) => this.EnumerateMajorRecordContexts<TSetter, TGetter>(linkCache, throwIfUnknown: throwIfUnknown);
        [DebuggerStepThrough]
        IEnumerable<IModContext<IFallout4Mod, IFallout4ModGetter, IMajorRecord, IMajorRecordGetter>> IMajorRecordContextEnumerable<IFallout4Mod, IFallout4ModGetter>.EnumerateMajorRecordContexts(ILinkCache linkCache, Type type, bool throwIfUnknown) => this.EnumerateMajorRecordContexts(linkCache, type: type, throwIfUnknown: throwIfUnknown);
        [DebuggerStepThrough]
        IEnumerable<IModContext<TMajor>> IMajorRecordSimpleContextEnumerable.EnumerateMajorRecordSimpleContexts<TMajor>(ILinkCache linkCache, bool throwIfUnknown) => this.EnumerateMajorRecordContexts(linkCache, typeof(TMajor), throwIfUnknown: throwIfUnknown).Select(x => x.AsType<Mutagen.Bethesda.Plugins.Records.IMajorRecordGetter, TMajor>());
        [DebuggerStepThrough]
        IEnumerable<IModContext<IMajorRecordGetter>> IMajorRecordSimpleContextEnumerable.EnumerateMajorRecordSimpleContexts(ILinkCache linkCache, Type type, bool throwIfUnknown) => this.EnumerateMajorRecordContexts(linkCache, type: type, throwIfUnknown: throwIfUnknown);
        #endregion

        #region Binary Translation
        #region Binary Create
        public static Fallout4Mod CreateFromBinary(
            ModPath path,
            GroupMask? importMask = null,
            StringsReadParameters? stringsParam = null,
            bool parallel = true,
            IFileSystem? fileSystem = null)
        {
            try
            {
                using (var reader = new MutagenBinaryReadStream(path, GameRelease.Fallout4, fileSystem: fileSystem))
                {
                    var frame = new MutagenFrame(reader);
                    frame.MetaData.RecordInfoCache = new RecordTypeInfoCacheReader(() => new MutagenBinaryReadStream(path, GameRelease.Fallout4));
                    frame.MetaData.Parallel = parallel;
                    frame.MetaData.ModKey = path.ModKey;
                    frame.MetaData.Absorb(stringsParam);
                    if (reader.Remaining < 12)
                    {
                        throw new ArgumentException("File stream was too short to parse flags");
                    }
                    var flags = reader.GetInt32(offset: 8);
                    if (EnumExt.HasFlag(flags, (int)ModHeaderCommonFlag.Localized))
                    {
                        frame.MetaData.StringsLookup = StringsFolderLookupOverlay.TypicalFactory(GameRelease.Fallout4, path.ModKey, Path.GetDirectoryName(path.Path)!, stringsParam);
                    }
                    return CreateFromBinary(
                        importMask: importMask,
                        frame: frame);
                }
            }
            catch (Exception ex)
            {
                throw RecordException.Enrich(ex, path.ModKey);
            }
        }

        public static Fallout4Mod CreateFromBinary(
            ModPath path,
            ErrorMaskBuilder? errorMask,
            GroupMask? importMask = null,
            StringsReadParameters? stringsParam = null,
            bool parallel = true,
            IFileSystem? fileSystem = null)
        {
            try
            {
                using (var reader = new MutagenBinaryReadStream(path, GameRelease.Fallout4, fileSystem: fileSystem))
                {
                    var frame = new MutagenFrame(reader);
                    frame.MetaData.RecordInfoCache = new RecordTypeInfoCacheReader(() => new MutagenBinaryReadStream(path, GameRelease.Fallout4));
                    frame.MetaData.Parallel = parallel;
                    frame.MetaData.ModKey = path.ModKey;
                    frame.MetaData.Absorb(stringsParam);
                    if (reader.Remaining < 12)
                    {
                        throw new ArgumentException("File stream was too short to parse flags");
                    }
                    var flags = reader.GetInt32(offset: 8);
                    if (EnumExt.HasFlag(flags, (int)ModHeaderCommonFlag.Localized))
                    {
                        frame.MetaData.StringsLookup = StringsFolderLookupOverlay.TypicalFactory(GameRelease.Fallout4, path.ModKey, Path.GetDirectoryName(path.Path)!, stringsParam);
                    }
                    return CreateFromBinary(
                        importMask: importMask,
                        frame: frame);
                }
            }
            catch (Exception ex)
            {
                throw RecordException.Enrich(ex, path.ModKey);
            }
        }

        public static Fallout4Mod CreateFromBinary(
            Stream stream,
            ModKey modKey,
            RecordTypeInfoCacheReader infoCache,
            GroupMask? importMask = null,
            bool parallel = true)
        {
            try
            {
                using (var reader = new MutagenBinaryReadStream(stream, modKey, GameRelease.Fallout4))
                {
                    var frame = new MutagenFrame(reader);
                    frame.MetaData.RecordInfoCache = infoCache;
                    frame.MetaData.Parallel = parallel;
                    frame.MetaData.ModKey = modKey;
                    return CreateFromBinary(
                        importMask: importMask,
                        frame: frame);
                }
            }
            catch (Exception ex)
            {
                throw RecordException.Enrich(ex, modKey);
            }
        }

        public static Fallout4Mod CreateFromBinary(
            Stream stream,
            ModKey modKey,
            RecordTypeInfoCacheReader infoCache,
            ErrorMaskBuilder? errorMask,
            GroupMask? importMask = null,
            bool parallel = true)
        {
            try
            {
                using (var reader = new MutagenBinaryReadStream(stream, modKey, GameRelease.Fallout4))
                {
                    var frame = new MutagenFrame(reader);
                    frame.MetaData.RecordInfoCache = infoCache;
                    frame.MetaData.Parallel = parallel;
                    frame.MetaData.ModKey = modKey;
                    return CreateFromBinary(
                        importMask: importMask,
                        frame: frame);
                }
            }
            catch (Exception ex)
            {
                throw RecordException.Enrich(ex, modKey);
            }
        }

        #endregion

        public static IFallout4ModDisposableGetter CreateFromBinaryOverlay(
            ModPath path,
            StringsReadParameters? stringsParam = null,
            IFileSystem? fileSystem = null)
        {
            return Fallout4ModBinaryOverlay.Fallout4ModFactory(
                path: path,
                stringsParam: stringsParam,
                fileSystem: fileSystem);
        }

        public static IFallout4ModDisposableGetter CreateFromBinaryOverlay(
            Stream stream,
            ModKey modKey)
        {
            return Fallout4ModBinaryOverlay.Fallout4ModFactory(
                stream: new MutagenBinaryReadStream(stream, modKey, GameRelease.Fallout4),
                modKey: modKey,
                shouldDispose: false);
        }

        public static Fallout4Mod CreateFromBinary(
            MutagenFrame frame,
            GroupMask? importMask = null)
        {
            try
            {
                var ret = new Fallout4Mod(modKey: frame.MetaData.ModKey);
                ((Fallout4ModSetterCommon)((IFallout4ModGetter)ret).CommonSetterInstance()!).CopyInFromBinary(
                    item: ret,
                    importMask: importMask,
                    frame: frame);
                return ret;
            }
            catch (Exception ex)
            {
                throw RecordException.Enrich(ex, frame.MetaData.ModKey);
            }
        }

        #endregion

        void IPrintable.ToString(FileGeneration fg, string? name) => this.ToString(fg, name);

        void IClearable.Clear()
        {
            ((Fallout4ModSetterCommon)((IFallout4ModGetter)this).CommonSetterInstance()!).Clear(this);
        }

        internal static Fallout4Mod GetNew()
        {
            return new Fallout4Mod();
        }

    }
    #endregion

    #region Interface
    public partial interface IFallout4Mod :
        IContextMod<IFallout4Mod, IFallout4ModGetter>,
        IFallout4ModGetter,
        IFormLinkContainer,
        ILoquiObjectSetter<IFallout4Mod>,
        IMajorRecordEnumerable,
        IMod
    {
        new Fallout4ModHeader ModHeader { get; }
        new Fallout4Group<GameSetting> GameSettings { get; }
        new Fallout4Group<Keyword> Keywords { get; }
        new Fallout4Group<LocationReferenceType> LocationReferenceTypes { get; }
        new Fallout4Group<ActionRecord> Actions { get; }
        new Fallout4Group<Transform> Transforms { get; }
        new Fallout4Group<Component> Components { get; }
        new Fallout4Group<TextureSet> TextureSets { get; }
        new Fallout4Group<Global> Globals { get; }
        new Fallout4Group<ADamageType> DamageTypes { get; }
        new Fallout4Group<Class> Classes { get; }
        new Fallout4Group<Faction> Factions { get; }
        new Fallout4Group<HeadPart> HeadParts { get; }
        new Fallout4Group<SoundMarker> SoundMarkers { get; }
        new Fallout4Group<AcousticSpace> AcousticSpaces { get; }
        new Fallout4Group<LandscapeTexture> LandscapeTextures { get; }
        new Fallout4Group<Grass> Grasses { get; }
        new Fallout4Group<MaterialType> MaterialTypes { get; }
    }

    public partial interface IFallout4ModGetter :
        ILoquiObject,
        IContextGetterMod<IFallout4Mod, IFallout4ModGetter>,
        IFormLinkContainerGetter,
        ILoquiObject<IFallout4ModGetter>,
        IMajorRecordContextEnumerable<IFallout4Mod, IFallout4ModGetter>,
        IMajorRecordGetterEnumerable,
        IModGetter
    {
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object? CommonSetterInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonSetterTranslationInstance();
        static ILoquiRegistration StaticRegistration => Fallout4Mod_Registration.Instance;
        IFallout4ModHeaderGetter ModHeader { get; }
        IFallout4GroupGetter<IGameSettingGetter> GameSettings { get; }
        IFallout4GroupGetter<IKeywordGetter> Keywords { get; }
        IFallout4GroupGetter<ILocationReferenceTypeGetter> LocationReferenceTypes { get; }
        IFallout4GroupGetter<IActionRecordGetter> Actions { get; }
        IFallout4GroupGetter<ITransformGetter> Transforms { get; }
        IFallout4GroupGetter<IComponentGetter> Components { get; }
        IFallout4GroupGetter<ITextureSetGetter> TextureSets { get; }
        IFallout4GroupGetter<IGlobalGetter> Globals { get; }
        IFallout4GroupGetter<IADamageTypeGetter> DamageTypes { get; }
        IFallout4GroupGetter<IClassGetter> Classes { get; }
        IFallout4GroupGetter<IFactionGetter> Factions { get; }
        IFallout4GroupGetter<IHeadPartGetter> HeadParts { get; }
        IFallout4GroupGetter<ISoundMarkerGetter> SoundMarkers { get; }
        IFallout4GroupGetter<IAcousticSpaceGetter> AcousticSpaces { get; }
        IFallout4GroupGetter<ILandscapeTextureGetter> LandscapeTextures { get; }
        IFallout4GroupGetter<IGrassGetter> Grasses { get; }
        IFallout4GroupGetter<IMaterialTypeGetter> MaterialTypes { get; }

    }

    #endregion

    #region Common MixIn
    public static partial class Fallout4ModMixIn
    {
        public static void Clear(this IFallout4Mod item)
        {
            ((Fallout4ModSetterCommon)((IFallout4ModGetter)item).CommonSetterInstance()!).Clear(item: item);
        }

        public static Fallout4Mod.Mask<bool> GetEqualsMask(
            this IFallout4ModGetter item,
            IFallout4ModGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            return ((Fallout4ModCommon)((IFallout4ModGetter)item).CommonInstance()!).GetEqualsMask(
                item: item,
                rhs: rhs,
                include: include);
        }

        public static string ToString(
            this IFallout4ModGetter item,
            string? name = null,
            Fallout4Mod.Mask<bool>? printMask = null)
        {
            return ((Fallout4ModCommon)((IFallout4ModGetter)item).CommonInstance()!).ToString(
                item: item,
                name: name,
                printMask: printMask);
        }

        public static void ToString(
            this IFallout4ModGetter item,
            FileGeneration fg,
            string? name = null,
            Fallout4Mod.Mask<bool>? printMask = null)
        {
            ((Fallout4ModCommon)((IFallout4ModGetter)item).CommonInstance()!).ToString(
                item: item,
                fg: fg,
                name: name,
                printMask: printMask);
        }

        public static bool Equals(
            this IFallout4ModGetter item,
            IFallout4ModGetter rhs,
            Fallout4Mod.TranslationMask? equalsMask = null)
        {
            return ((Fallout4ModCommon)((IFallout4ModGetter)item).CommonInstance()!).Equals(
                lhs: item,
                rhs: rhs,
                crystal: equalsMask?.GetCrystal());
        }

        public static void DeepCopyIn(
            this IFallout4Mod lhs,
            IFallout4ModGetter rhs)
        {
            ((Fallout4ModSetterTranslationCommon)((IFallout4ModGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: default,
                deepCopy: false);
        }

        public static void DeepCopyIn(
            this IFallout4Mod lhs,
            IFallout4ModGetter rhs,
            Fallout4Mod.TranslationMask? copyMask = null)
        {
            ((Fallout4ModSetterTranslationCommon)((IFallout4ModGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
        }

        public static void DeepCopyIn(
            this IFallout4Mod lhs,
            IFallout4ModGetter rhs,
            out Fallout4Mod.ErrorMask errorMask,
            Fallout4Mod.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            ((Fallout4ModSetterTranslationCommon)((IFallout4ModGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
            errorMask = Fallout4Mod.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void DeepCopyIn(
            this IFallout4Mod lhs,
            IFallout4ModGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            ((Fallout4ModSetterTranslationCommon)((IFallout4ModGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: false);
        }

        public static Fallout4Mod DeepCopy(
            this IFallout4ModGetter item,
            Fallout4Mod.TranslationMask? copyMask = null)
        {
            return ((Fallout4ModSetterTranslationCommon)((IFallout4ModGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask);
        }

        public static Fallout4Mod DeepCopy(
            this IFallout4ModGetter item,
            out Fallout4Mod.ErrorMask errorMask,
            Fallout4Mod.TranslationMask? copyMask = null)
        {
            return ((Fallout4ModSetterTranslationCommon)((IFallout4ModGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: out errorMask);
        }

        public static Fallout4Mod DeepCopy(
            this IFallout4ModGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            return ((Fallout4ModSetterTranslationCommon)((IFallout4ModGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: errorMask);
        }

        #region Mutagen
        public static IGroupGetter<T> GetTopLevelGroup<T>(this IFallout4ModGetter obj)
            where T : IMajorRecordGetter
        {
            return (IGroupGetter<T>)((Fallout4ModCommon)((IFallout4ModGetter)obj).CommonInstance()!).GetGroup(
                obj: obj,
                type: typeof(T));
        }

        public static IGroupGetter GetTopLevelGroup(
            this IFallout4ModGetter obj,
            Type type)
        {
            return (IGroupGetter)((Fallout4ModCommon)((IFallout4ModGetter)obj).CommonInstance()!).GetGroup(
                obj: obj,
                type: type);
        }

        public static IGroup<T> GetTopLevelGroup<T>(this IFallout4Mod obj)
            where T : IMajorRecord
        {
            return (IGroup<T>)((Fallout4ModCommon)((IFallout4ModGetter)obj).CommonInstance()!).GetGroup(
                obj: obj,
                type: typeof(T));
        }

        public static IGroup GetTopLevelGroup(
            this IFallout4Mod obj,
            Type type)
        {
            return (IGroup)((Fallout4ModCommon)((IFallout4ModGetter)obj).CommonInstance()!).GetGroup(
                obj: obj,
                type: type);
        }

        public static void WriteToBinaryParallel(
            this IFallout4ModGetter item,
            Stream stream,
            BinaryWriteParameters? param = null,
            ParallelWriteParameters? parallelParam = null)
        {
            Fallout4ModCommon.WriteParallel(
                item: item,
                stream: stream,
                parallelParam: parallelParam ?? ParallelWriteParameters.Default,
                param: param ?? BinaryWriteParameters.Default,
                modKey: item.ModKey);
        }

        public static void WriteToBinaryParallel(
            this IFallout4ModGetter item,
            string path,
            BinaryWriteParameters? param = null,
            ParallelWriteParameters? parallelParam = null,
            IFileSystem? fileSystem = null)
        {
            param ??= BinaryWriteParameters.Default;
            parallelParam ??= ParallelWriteParameters.Default;
            var modKey = param.RunMasterMatch(
                mod: item,
                path: path);
            param.StringsWriter ??= EnumExt.HasFlag((int)item.ModHeader.Flags, (int)ModHeaderCommonFlag.Localized) ? new StringsWriter(GameRelease.Fallout4, modKey, Path.Combine(Path.GetDirectoryName(path)!, "Strings"), MutagenEncodingProvider.Instance) : null;
            bool disposeStrings = param.StringsWriter != null;
            using (var stream = fileSystem.GetOrDefault().FileStream.Create(path, FileMode.Create, FileAccess.Write))
            {
                Fallout4ModCommon.WriteParallel(
                    item: item,
                    stream: stream,
                    parallelParam: parallelParam,
                    param: param,
                    modKey: modKey);
            }
            if (disposeStrings)
            {
                param.StringsWriter?.Dispose();
            }
        }

        [DebuggerStepThrough]
        public static IEnumerable<IMajorRecordGetter> EnumerateMajorRecords(this IFallout4ModGetter obj)
        {
            return ((Fallout4ModCommon)((IFallout4ModGetter)obj).CommonInstance()!).EnumerateMajorRecords(obj: obj).Catch(e => throw RecordException.Enrich(e, obj.ModKey));
        }

        [DebuggerStepThrough]
        public static IEnumerable<TMajor> EnumerateMajorRecords<TMajor>(
            this IFallout4ModGetter obj,
            bool throwIfUnknown = true)
            where TMajor : class, IMajorRecordGetter
        {
            return ((Fallout4ModCommon)((IFallout4ModGetter)obj).CommonInstance()!).EnumerateMajorRecords(
                obj: obj,
                type: typeof(TMajor),
                throwIfUnknown: throwIfUnknown)
                .Select(m => (TMajor)m)
                .Catch(e => throw RecordException.Enrich(e, obj.ModKey));
        }

        [DebuggerStepThrough]
        public static IEnumerable<IMajorRecordGetter> EnumerateMajorRecords(
            this IFallout4ModGetter obj,
            Type type,
            bool throwIfUnknown = true)
        {
            return ((Fallout4ModCommon)((IFallout4ModGetter)obj).CommonInstance()!).EnumerateMajorRecords(
                obj: obj,
                type: type,
                throwIfUnknown: throwIfUnknown)
                .Select(m => (IMajorRecordGetter)m)
                .Catch(e => throw RecordException.Enrich(e, obj.ModKey));
        }

        [DebuggerStepThrough]
        public static IEnumerable<IMajorRecord> EnumerateMajorRecords(this IFallout4Mod obj)
        {
            return ((Fallout4ModSetterCommon)((IFallout4ModGetter)obj).CommonSetterInstance()!).EnumerateMajorRecords(obj: obj).Catch(e => throw RecordException.Enrich(e, obj.ModKey));
        }

        [DebuggerStepThrough]
        public static IEnumerable<TMajor> EnumerateMajorRecords<TMajor>(this IFallout4Mod obj)
            where TMajor : class, IMajorRecord
        {
            return ((Fallout4ModSetterCommon)((IFallout4ModGetter)obj).CommonSetterInstance()!).EnumerateMajorRecords(
                obj: obj,
                type: typeof(TMajor),
                throwIfUnknown: true)
                .Select(m => (TMajor)m)
                .Catch(e => throw RecordException.Enrich(e, obj.ModKey));
        }

        [DebuggerStepThrough]
        public static IEnumerable<IMajorRecord> EnumerateMajorRecords(
            this IFallout4Mod obj,
            Type? type,
            bool throwIfUnknown = true)
        {
            return ((Fallout4ModSetterCommon)((IFallout4ModGetter)obj).CommonSetterInstance()!).EnumeratePotentiallyTypedMajorRecords(
                obj: obj,
                type: type,
                throwIfUnknown: throwIfUnknown)
                .Select(m => (IMajorRecord)m)
                .Catch(e => throw RecordException.Enrich(e, obj.ModKey));
        }

        [DebuggerStepThrough]
        public static void Remove(
            this IFallout4Mod obj,
            FormKey key)
        {
            var keys = new HashSet<FormKey>();
            keys.Add(key);
            ((Fallout4ModSetterCommon)((IFallout4ModGetter)obj).CommonSetterInstance()!).Remove(
                obj: obj,
                keys: keys);
        }

        [DebuggerStepThrough]
        public static void Remove(
            this IFallout4Mod obj,
            IEnumerable<FormKey> keys)
        {
            ((Fallout4ModSetterCommon)((IFallout4ModGetter)obj).CommonSetterInstance()!).Remove(
                obj: obj,
                keys: keys.ToHashSet());
        }

        [DebuggerStepThrough]
        public static void Remove(
            this IFallout4Mod obj,
            HashSet<FormKey> keys)
        {
            ((Fallout4ModSetterCommon)((IFallout4ModGetter)obj).CommonSetterInstance()!).Remove(
                obj: obj,
                keys: keys);
        }

        [DebuggerStepThrough]
        public static void Remove(
            this IFallout4Mod obj,
            FormKey key,
            Type type,
            bool throwIfUnknown = true)
        {
            var keys = new HashSet<FormKey>();
            keys.Add(key);
            ((Fallout4ModSetterCommon)((IFallout4ModGetter)obj).CommonSetterInstance()!).Remove(
                obj: obj,
                keys: keys,
                type: type,
                throwIfUnknown: throwIfUnknown);
        }

        [DebuggerStepThrough]
        public static void Remove(
            this IFallout4Mod obj,
            IEnumerable<FormKey> keys,
            Type type,
            bool throwIfUnknown = true)
        {
            ((Fallout4ModSetterCommon)((IFallout4ModGetter)obj).CommonSetterInstance()!).Remove(
                obj: obj,
                keys: keys.ToHashSet(),
                type: type,
                throwIfUnknown: throwIfUnknown);
        }

        [DebuggerStepThrough]
        public static void Remove(
            this IFallout4Mod obj,
            HashSet<FormKey> keys,
            Type type,
            bool throwIfUnknown = true)
        {
            ((Fallout4ModSetterCommon)((IFallout4ModGetter)obj).CommonSetterInstance()!).Remove(
                obj: obj,
                keys: keys,
                type: type,
                throwIfUnknown: throwIfUnknown);
        }

        [DebuggerStepThrough]
        public static void Remove<TMajor>(
            this IFallout4Mod obj,
            TMajor record,
            bool throwIfUnknown = true)
            where TMajor : IMajorRecordGetter
        {
            var keys = new HashSet<FormKey>();
            keys.Add(record.FormKey);
            ((Fallout4ModSetterCommon)((IFallout4ModGetter)obj).CommonSetterInstance()!).Remove(
                obj: obj,
                keys: keys,
                type: typeof(TMajor),
                throwIfUnknown: throwIfUnknown);
        }

        [DebuggerStepThrough]
        public static void Remove<TMajor>(
            this IFallout4Mod obj,
            IEnumerable<TMajor> records,
            bool throwIfUnknown = true)
            where TMajor : IMajorRecordGetter
        {
            ((Fallout4ModSetterCommon)((IFallout4ModGetter)obj).CommonSetterInstance()!).Remove(
                obj: obj,
                keys: records.Select(m => m.FormKey).ToHashSet(),
                type: typeof(TMajor),
                throwIfUnknown: throwIfUnknown);
        }

        [DebuggerStepThrough]
        public static void Remove<TMajor>(
            this IFallout4Mod obj,
            FormKey key,
            bool throwIfUnknown = true)
            where TMajor : IMajorRecordGetter
        {
            var keys = new HashSet<FormKey>();
            keys.Add(key);
            ((Fallout4ModSetterCommon)((IFallout4ModGetter)obj).CommonSetterInstance()!).Remove(
                obj: obj,
                keys: keys,
                type: typeof(TMajor),
                throwIfUnknown: throwIfUnknown);
        }

        [DebuggerStepThrough]
        public static void Remove<TMajor>(
            this IFallout4Mod obj,
            IEnumerable<FormKey> keys,
            bool throwIfUnknown = true)
            where TMajor : IMajorRecordGetter
        {
            ((Fallout4ModSetterCommon)((IFallout4ModGetter)obj).CommonSetterInstance()!).Remove(
                obj: obj,
                keys: keys.ToHashSet(),
                type: typeof(TMajor),
                throwIfUnknown: throwIfUnknown);
        }

        [DebuggerStepThrough]
        public static void Remove<TMajor>(
            this IFallout4Mod obj,
            HashSet<FormKey> keys,
            bool throwIfUnknown = true)
            where TMajor : IMajorRecordGetter
        {
            ((Fallout4ModSetterCommon)((IFallout4ModGetter)obj).CommonSetterInstance()!).Remove(
                obj: obj,
                keys: keys,
                type: typeof(TMajor),
                throwIfUnknown: throwIfUnknown);
        }

        [DebuggerStepThrough]
        public static IEnumerable<IModContext<IFallout4Mod, IFallout4ModGetter, TSetter, TGetter>> EnumerateMajorRecordContexts<TSetter, TGetter>(
            this IFallout4ModGetter obj,
            ILinkCache linkCache,
            bool throwIfUnknown = true)
            where TSetter : class, IMajorRecord, TGetter
            where TGetter : class, IMajorRecordGetter
        {
            return ((Fallout4ModCommon)((IFallout4ModGetter)obj).CommonInstance()!).EnumerateMajorRecordContexts(
                obj: obj,
                linkCache: linkCache,
                type: typeof(TGetter),
                throwIfUnknown: throwIfUnknown)
                .Select(m => m.AsType<IFallout4Mod, IFallout4ModGetter, IMajorRecord, IMajorRecordGetter, TSetter, TGetter>())
                .Catch(e => throw RecordException.Enrich(e, obj.ModKey));
        }

        [DebuggerStepThrough]
        public static IEnumerable<IModContext<IFallout4Mod, IFallout4ModGetter, IMajorRecord, IMajorRecordGetter>> EnumerateMajorRecordContexts(
            this IFallout4ModGetter obj,
            ILinkCache linkCache,
            Type type,
            bool throwIfUnknown = true)
        {
            return ((Fallout4ModCommon)((IFallout4ModGetter)obj).CommonInstance()!).EnumerateMajorRecordContexts(
                obj: obj,
                linkCache: linkCache,
                type: type,
                throwIfUnknown: throwIfUnknown);
        }

        #endregion

        #region Binary Translation
        public static void CopyInFromBinary(
            this IFallout4Mod item,
            MutagenFrame frame,
            GroupMask? importMask = null)
        {
            ((Fallout4ModSetterCommon)((IFallout4ModGetter)item).CommonSetterInstance()!).CopyInFromBinary(
                item: item,
                importMask: importMask,
                frame: frame);
        }

        public static void CopyInFromBinary(
            this IFallout4Mod item,
            ModPath path,
            GroupMask? importMask = null,
            StringsReadParameters? stringsParam = null,
            bool parallel = true,
            IFileSystem? fileSystem = null)
        {
            try
            {
                using (var reader = new MutagenBinaryReadStream(path, GameRelease.Fallout4, fileSystem: fileSystem))
                {
                    var frame = new MutagenFrame(reader);
                    frame.MetaData.RecordInfoCache = new RecordTypeInfoCacheReader(() => new MutagenBinaryReadStream(path, GameRelease.Fallout4));
                    frame.MetaData.Parallel = parallel;
                    frame.MetaData.ModKey = path.ModKey;
                    frame.MetaData.Absorb(stringsParam);
                    if (reader.Remaining < 12)
                    {
                        throw new ArgumentException("File stream was too short to parse flags");
                    }
                    var flags = reader.GetInt32(offset: 8);
                    if (EnumExt.HasFlag(flags, (int)ModHeaderCommonFlag.Localized))
                    {
                        frame.MetaData.StringsLookup = StringsFolderLookupOverlay.TypicalFactory(GameRelease.Fallout4, path.ModKey, Path.GetDirectoryName(path.Path)!, stringsParam);
                    }
                    CopyInFromBinary(
                        item: item,
                        importMask: importMask,
                        frame: frame);
                }
            }
            catch (Exception ex)
            {
                throw RecordException.Enrich(ex, path.ModKey);
            }
        }

        public static void CopyInFromBinary(
            this IFallout4Mod item,
            Stream stream,
            ModKey modKey,
            RecordTypeInfoCacheReader infoCache,
            GroupMask? importMask = null,
            bool parallel = true)
        {
            try
            {
                using (var reader = new MutagenBinaryReadStream(stream, modKey, GameRelease.Fallout4))
                {
                    var frame = new MutagenFrame(reader);
                    frame.MetaData.RecordInfoCache = infoCache;
                    frame.MetaData.Parallel = parallel;
                    frame.MetaData.ModKey = modKey;
                    CopyInFromBinary(
                        item: item,
                        importMask: importMask,
                        frame: frame);
                }
            }
            catch (Exception ex)
            {
                throw RecordException.Enrich(ex, modKey);
            }
        }

        #endregion

    }
    #endregion

}

namespace Mutagen.Bethesda.Fallout4.Internals
{
    #region Field Index
    public enum Fallout4Mod_FieldIndex
    {
        ModHeader = 0,
        GameSettings = 1,
        Keywords = 2,
        LocationReferenceTypes = 3,
        Actions = 4,
        Transforms = 5,
        Components = 6,
        TextureSets = 7,
        Globals = 8,
        DamageTypes = 9,
        Classes = 10,
        Factions = 11,
        HeadParts = 12,
        SoundMarkers = 13,
        AcousticSpaces = 14,
        LandscapeTextures = 15,
        Grasses = 16,
        MaterialTypes = 17,
    }
    #endregion

    #region Registration
    public partial class Fallout4Mod_Registration : ILoquiRegistration
    {
        public static readonly Fallout4Mod_Registration Instance = new Fallout4Mod_Registration();

        public static ProtocolKey ProtocolKey => ProtocolDefinition_Fallout4.ProtocolKey;

        public static readonly ObjectKey ObjectKey = new ObjectKey(
            protocolKey: ProtocolDefinition_Fallout4.ProtocolKey,
            msgID: 19,
            version: 0);

        public const string GUID = "9cae6baa-1084-4862-ae0a-07c79b9f2a3a";

        public const ushort AdditionalFieldCount = 18;

        public const ushort FieldCount = 18;

        public static readonly Type MaskType = typeof(Fallout4Mod.Mask<>);

        public static readonly Type ErrorMaskType = typeof(Fallout4Mod.ErrorMask);

        public static readonly Type ClassType = typeof(Fallout4Mod);

        public static readonly Type GetterType = typeof(IFallout4ModGetter);

        public static readonly Type? InternalGetterType = null;

        public static readonly Type SetterType = typeof(IFallout4Mod);

        public static readonly Type? InternalSetterType = null;

        public const string FullName = "Mutagen.Bethesda.Fallout4.Fallout4Mod";

        public const string Name = "Fallout4Mod";

        public const string Namespace = "Mutagen.Bethesda.Fallout4";

        public const byte GenericCount = 0;

        public static readonly Type? GenericRegistrationType = null;

        public static readonly RecordType TriggeringRecordType = RecordTypes.TES4;
        public static readonly Type BinaryWriteTranslation = typeof(Fallout4ModBinaryWriteTranslation);
        #region Interface
        ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;
        ObjectKey ILoquiRegistration.ObjectKey => ObjectKey;
        string ILoquiRegistration.GUID => GUID;
        ushort ILoquiRegistration.FieldCount => FieldCount;
        ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;
        Type ILoquiRegistration.MaskType => MaskType;
        Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;
        Type ILoquiRegistration.ClassType => ClassType;
        Type ILoquiRegistration.SetterType => SetterType;
        Type? ILoquiRegistration.InternalSetterType => InternalSetterType;
        Type ILoquiRegistration.GetterType => GetterType;
        Type? ILoquiRegistration.InternalGetterType => InternalGetterType;
        string ILoquiRegistration.FullName => FullName;
        string ILoquiRegistration.Name => Name;
        string ILoquiRegistration.Namespace => Namespace;
        byte ILoquiRegistration.GenericCount => GenericCount;
        Type? ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;
        ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsLoqui(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsSingleton(ushort index) => throw new NotImplementedException();
        string ILoquiRegistration.GetNthName(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsNthDerivative(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsProtected(ushort index) => throw new NotImplementedException();
        Type ILoquiRegistration.GetNthType(ushort index) => throw new NotImplementedException();
        #endregion

    }
    #endregion

    #region Common
    public partial class Fallout4ModSetterCommon
    {
        public static readonly Fallout4ModSetterCommon Instance = new Fallout4ModSetterCommon();

        partial void ClearPartial();
        
        public void Clear(IFallout4Mod item)
        {
            ClearPartial();
            item.GameSettings.Clear();
            item.Keywords.Clear();
            item.LocationReferenceTypes.Clear();
            item.Actions.Clear();
            item.Transforms.Clear();
            item.Components.Clear();
            item.TextureSets.Clear();
            item.Globals.Clear();
            item.DamageTypes.Clear();
            item.Classes.Clear();
            item.Factions.Clear();
            item.HeadParts.Clear();
            item.SoundMarkers.Clear();
            item.AcousticSpaces.Clear();
            item.LandscapeTextures.Clear();
            item.Grasses.Clear();
            item.MaterialTypes.Clear();
        }
        
        #region Mutagen
        public void RemapLinks(IFallout4Mod obj, IReadOnlyDictionary<FormKey, FormKey> mapping)
        {
            obj.ModHeader.RemapLinks(mapping);
            obj.GameSettings.RemapLinks(mapping);
            obj.Keywords.RemapLinks(mapping);
            obj.LocationReferenceTypes.RemapLinks(mapping);
            obj.Actions.RemapLinks(mapping);
            obj.Transforms.RemapLinks(mapping);
            obj.Components.RemapLinks(mapping);
            obj.TextureSets.RemapLinks(mapping);
            obj.Globals.RemapLinks(mapping);
            obj.DamageTypes.RemapLinks(mapping);
            obj.Classes.RemapLinks(mapping);
            obj.Factions.RemapLinks(mapping);
            obj.HeadParts.RemapLinks(mapping);
            obj.SoundMarkers.RemapLinks(mapping);
            obj.AcousticSpaces.RemapLinks(mapping);
            obj.LandscapeTextures.RemapLinks(mapping);
            obj.Grasses.RemapLinks(mapping);
            obj.MaterialTypes.RemapLinks(mapping);
        }
        
        public IEnumerable<IMajorRecord> EnumerateMajorRecords(IFallout4Mod obj)
        {
            foreach (var item in Fallout4ModCommon.Instance.EnumerateMajorRecords(obj))
            {
                yield return (item as IMajorRecord)!;
            }
        }
        
        public IEnumerable<IMajorRecordGetter> EnumeratePotentiallyTypedMajorRecords(
            IFallout4Mod obj,
            Type? type,
            bool throwIfUnknown)
        {
            if (type == null) return EnumerateMajorRecords(obj);
            return EnumerateMajorRecords(obj, type, throwIfUnknown);
        }
        
        public IEnumerable<IMajorRecordGetter> EnumerateMajorRecords(
            IFallout4Mod obj,
            Type type,
            bool throwIfUnknown)
        {
            foreach (var item in Fallout4ModCommon.Instance.EnumerateMajorRecords(obj, type, throwIfUnknown))
            {
                yield return item;
            }
        }
        
        public void Remove(
            IFallout4Mod obj,
            HashSet<FormKey> keys)
        {
            obj.GameSettings.Remove(keys);
            obj.Keywords.Remove(keys);
            obj.LocationReferenceTypes.Remove(keys);
            obj.Actions.Remove(keys);
            obj.Transforms.Remove(keys);
            obj.Components.Remove(keys);
            obj.TextureSets.Remove(keys);
            obj.Globals.Remove(keys);
            obj.DamageTypes.Remove(keys);
            obj.Classes.Remove(keys);
            obj.Factions.Remove(keys);
            obj.HeadParts.Remove(keys);
            obj.SoundMarkers.Remove(keys);
            obj.AcousticSpaces.Remove(keys);
            obj.LandscapeTextures.Remove(keys);
            obj.Grasses.Remove(keys);
            obj.MaterialTypes.Remove(keys);
        }
        
        public void Remove(
            IFallout4Mod obj,
            HashSet<FormKey> keys,
            Type type,
            bool throwIfUnknown)
        {
            switch (type.Name)
            {
                case "IMajorRecord":
                case "MajorRecord":
                case "IFallout4MajorRecord":
                case "Fallout4MajorRecord":
                case "IMajorRecordGetter":
                case "IFallout4MajorRecordGetter":
                    if (!Fallout4Mod_Registration.SetterType.IsAssignableFrom(obj.GetType())) return;
                    this.Remove(obj, keys);
                    break;
                case "GameSetting":
                case "IGameSettingGetter":
                case "IGameSetting":
                case "IGameSettingInternal":
                case "GameSettingInt":
                case "IGameSettingIntGetter":
                case "IGameSettingInt":
                case "IGameSettingIntInternal":
                case "GameSettingFloat":
                case "IGameSettingFloatGetter":
                case "IGameSettingFloat":
                case "IGameSettingFloatInternal":
                case "GameSettingString":
                case "IGameSettingStringGetter":
                case "IGameSettingString":
                case "IGameSettingStringInternal":
                case "GameSettingBool":
                case "IGameSettingBoolGetter":
                case "IGameSettingBool":
                case "IGameSettingBoolInternal":
                case "GameSettingUInt":
                case "IGameSettingUIntGetter":
                case "IGameSettingUInt":
                case "IGameSettingUIntInternal":
                    obj.GameSettings.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "Keyword":
                case "IKeywordGetter":
                case "IKeyword":
                case "IKeywordInternal":
                    obj.Keywords.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "LocationReferenceType":
                case "ILocationReferenceTypeGetter":
                case "ILocationReferenceType":
                case "ILocationReferenceTypeInternal":
                    obj.LocationReferenceTypes.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "ActionRecord":
                case "IActionRecordGetter":
                case "IActionRecord":
                case "IActionRecordInternal":
                    obj.Actions.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "Transform":
                case "ITransformGetter":
                case "ITransform":
                case "ITransformInternal":
                    obj.Transforms.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "Component":
                case "IComponentGetter":
                case "IComponent":
                case "IComponentInternal":
                    obj.Components.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "TextureSet":
                case "ITextureSetGetter":
                case "ITextureSet":
                case "ITextureSetInternal":
                    obj.TextureSets.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "Global":
                case "IGlobalGetter":
                case "IGlobal":
                case "IGlobalInternal":
                case "GlobalInt":
                case "IGlobalIntGetter":
                case "IGlobalInt":
                case "IGlobalIntInternal":
                case "GlobalShort":
                case "IGlobalShortGetter":
                case "IGlobalShort":
                case "IGlobalShortInternal":
                case "GlobalFloat":
                case "IGlobalFloatGetter":
                case "IGlobalFloat":
                case "IGlobalFloatInternal":
                case "GlobalBool":
                case "IGlobalBoolGetter":
                case "IGlobalBool":
                case "IGlobalBoolInternal":
                    obj.Globals.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "ADamageType":
                case "IADamageTypeGetter":
                case "IADamageType":
                case "IADamageTypeInternal":
                case "DamageType":
                case "IDamageTypeGetter":
                case "IDamageType":
                case "IDamageTypeInternal":
                case "DamageTypeIndexed":
                case "IDamageTypeIndexedGetter":
                case "IDamageTypeIndexed":
                case "IDamageTypeIndexedInternal":
                    obj.DamageTypes.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "Class":
                case "IClassGetter":
                case "IClass":
                case "IClassInternal":
                    obj.Classes.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "Faction":
                case "IFactionGetter":
                case "IFaction":
                case "IFactionInternal":
                    obj.Factions.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "HeadPart":
                case "IHeadPartGetter":
                case "IHeadPart":
                case "IHeadPartInternal":
                    obj.HeadParts.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "SoundMarker":
                case "ISoundMarkerGetter":
                case "ISoundMarker":
                case "ISoundMarkerInternal":
                    obj.SoundMarkers.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "AcousticSpace":
                case "IAcousticSpaceGetter":
                case "IAcousticSpace":
                case "IAcousticSpaceInternal":
                    obj.AcousticSpaces.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "LandscapeTexture":
                case "ILandscapeTextureGetter":
                case "ILandscapeTexture":
                case "ILandscapeTextureInternal":
                    obj.LandscapeTextures.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "Grass":
                case "IGrassGetter":
                case "IGrass":
                case "IGrassInternal":
                    obj.Grasses.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "MaterialType":
                case "IMaterialTypeGetter":
                case "IMaterialType":
                case "IMaterialTypeInternal":
                    obj.MaterialTypes.Remove(
                        type: type,
                        keys: keys);
                    break;
                case "IIdleRelation":
                case "IIdleRelationGetter":
                    Remove(obj, keys, typeof(IActionRecordGetter), throwIfUnknown: throwIfUnknown);
                    break;
                case "IObjectId":
                case "IObjectIdGetter":
                    Remove(obj, keys, typeof(IFactionGetter), throwIfUnknown: throwIfUnknown);
                    Remove(obj, keys, typeof(ITextureSetGetter), throwIfUnknown: throwIfUnknown);
                    break;
                case "IOwner":
                case "IOwnerGetter":
                    Remove(obj, keys, typeof(IFactionGetter), throwIfUnknown: throwIfUnknown);
                    break;
                case "IRelatable":
                case "IRelatableGetter":
                    Remove(obj, keys, typeof(IFactionGetter), throwIfUnknown: throwIfUnknown);
                    break;
                case "IKeywordLinkedReference":
                case "IKeywordLinkedReferenceGetter":
                    Remove(obj, keys, typeof(IKeywordGetter), throwIfUnknown: throwIfUnknown);
                    break;
                case "IRegionTarget":
                case "IRegionTargetGetter":
                    Remove(obj, keys, typeof(ILandscapeTextureGetter), throwIfUnknown: throwIfUnknown);
                    break;
                case "ILocationRecord":
                case "ILocationRecordGetter":
                    Remove(obj, keys, typeof(ILocationReferenceTypeGetter), throwIfUnknown: throwIfUnknown);
                    break;
                default:
                    if (throwIfUnknown)
                    {
                        throw new ArgumentException($"Unknown major record type: {type}");
                    }
                    else
                    {
                        break;
                    }
            }
        }
        
        #endregion
        
        #region Binary Translation
        public virtual void CopyInFromBinary(
            IFallout4Mod item,
            MutagenFrame frame,
            GroupMask? importMask = null)
        {
            PluginUtilityTranslation.ModParse(
                record: item,
                frame: frame,
                importMask: importMask,
                fillStructs: Fallout4ModBinaryCreateTranslation.FillBinaryStructs,
                fillTyped: Fallout4ModBinaryCreateTranslation.FillBinaryRecordTypes);
        }
        
        #endregion
        
    }
    public partial class Fallout4ModCommon
    {
        public static readonly Fallout4ModCommon Instance = new Fallout4ModCommon();

        public Fallout4Mod.Mask<bool> GetEqualsMask(
            IFallout4ModGetter item,
            IFallout4ModGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            var ret = new Fallout4Mod.Mask<bool>(false);
            ((Fallout4ModCommon)((IFallout4ModGetter)item).CommonInstance()!).FillEqualsMask(
                item: item,
                rhs: rhs,
                ret: ret,
                include: include);
            return ret;
        }
        
        public void FillEqualsMask(
            IFallout4ModGetter item,
            IFallout4ModGetter rhs,
            Fallout4Mod.Mask<bool> ret,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            if (rhs == null) return;
            ret.ModHeader = MaskItemExt.Factory(item.ModHeader.GetEqualsMask(rhs.ModHeader, include), include);
            ret.GameSettings = MaskItemExt.Factory(item.GameSettings.GetEqualsMask(rhs.GameSettings, include), include);
            ret.Keywords = MaskItemExt.Factory(item.Keywords.GetEqualsMask(rhs.Keywords, include), include);
            ret.LocationReferenceTypes = MaskItemExt.Factory(item.LocationReferenceTypes.GetEqualsMask(rhs.LocationReferenceTypes, include), include);
            ret.Actions = MaskItemExt.Factory(item.Actions.GetEqualsMask(rhs.Actions, include), include);
            ret.Transforms = MaskItemExt.Factory(item.Transforms.GetEqualsMask(rhs.Transforms, include), include);
            ret.Components = MaskItemExt.Factory(item.Components.GetEqualsMask(rhs.Components, include), include);
            ret.TextureSets = MaskItemExt.Factory(item.TextureSets.GetEqualsMask(rhs.TextureSets, include), include);
            ret.Globals = MaskItemExt.Factory(item.Globals.GetEqualsMask(rhs.Globals, include), include);
            ret.DamageTypes = MaskItemExt.Factory(item.DamageTypes.GetEqualsMask(rhs.DamageTypes, include), include);
            ret.Classes = MaskItemExt.Factory(item.Classes.GetEqualsMask(rhs.Classes, include), include);
            ret.Factions = MaskItemExt.Factory(item.Factions.GetEqualsMask(rhs.Factions, include), include);
            ret.HeadParts = MaskItemExt.Factory(item.HeadParts.GetEqualsMask(rhs.HeadParts, include), include);
            ret.SoundMarkers = MaskItemExt.Factory(item.SoundMarkers.GetEqualsMask(rhs.SoundMarkers, include), include);
            ret.AcousticSpaces = MaskItemExt.Factory(item.AcousticSpaces.GetEqualsMask(rhs.AcousticSpaces, include), include);
            ret.LandscapeTextures = MaskItemExt.Factory(item.LandscapeTextures.GetEqualsMask(rhs.LandscapeTextures, include), include);
            ret.Grasses = MaskItemExt.Factory(item.Grasses.GetEqualsMask(rhs.Grasses, include), include);
            ret.MaterialTypes = MaskItemExt.Factory(item.MaterialTypes.GetEqualsMask(rhs.MaterialTypes, include), include);
        }
        
        public string ToString(
            IFallout4ModGetter item,
            string? name = null,
            Fallout4Mod.Mask<bool>? printMask = null)
        {
            var fg = new FileGeneration();
            ToString(
                item: item,
                fg: fg,
                name: name,
                printMask: printMask);
            return fg.ToString();
        }
        
        public void ToString(
            IFallout4ModGetter item,
            FileGeneration fg,
            string? name = null,
            Fallout4Mod.Mask<bool>? printMask = null)
        {
            if (name == null)
            {
                fg.AppendLine($"Fallout4Mod =>");
            }
            else
            {
                fg.AppendLine($"{name} (Fallout4Mod) =>");
            }
            fg.AppendLine("[");
            using (new DepthWrapper(fg))
            {
                ToStringFields(
                    item: item,
                    fg: fg,
                    printMask: printMask);
            }
            fg.AppendLine("]");
        }
        
        protected static void ToStringFields(
            IFallout4ModGetter item,
            FileGeneration fg,
            Fallout4Mod.Mask<bool>? printMask = null)
        {
            if (printMask?.ModHeader?.Overall ?? true)
            {
                item.ModHeader?.ToString(fg, "ModHeader");
            }
            if (printMask?.GameSettings?.Overall ?? true)
            {
                item.GameSettings?.ToString(fg, "GameSettings");
            }
            if (printMask?.Keywords?.Overall ?? true)
            {
                item.Keywords?.ToString(fg, "Keywords");
            }
            if (printMask?.LocationReferenceTypes?.Overall ?? true)
            {
                item.LocationReferenceTypes?.ToString(fg, "LocationReferenceTypes");
            }
            if (printMask?.Actions?.Overall ?? true)
            {
                item.Actions?.ToString(fg, "Actions");
            }
            if (printMask?.Transforms?.Overall ?? true)
            {
                item.Transforms?.ToString(fg, "Transforms");
            }
            if (printMask?.Components?.Overall ?? true)
            {
                item.Components?.ToString(fg, "Components");
            }
            if (printMask?.TextureSets?.Overall ?? true)
            {
                item.TextureSets?.ToString(fg, "TextureSets");
            }
            if (printMask?.Globals?.Overall ?? true)
            {
                item.Globals?.ToString(fg, "Globals");
            }
            if (printMask?.DamageTypes?.Overall ?? true)
            {
                item.DamageTypes?.ToString(fg, "DamageTypes");
            }
            if (printMask?.Classes?.Overall ?? true)
            {
                item.Classes?.ToString(fg, "Classes");
            }
            if (printMask?.Factions?.Overall ?? true)
            {
                item.Factions?.ToString(fg, "Factions");
            }
            if (printMask?.HeadParts?.Overall ?? true)
            {
                item.HeadParts?.ToString(fg, "HeadParts");
            }
            if (printMask?.SoundMarkers?.Overall ?? true)
            {
                item.SoundMarkers?.ToString(fg, "SoundMarkers");
            }
            if (printMask?.AcousticSpaces?.Overall ?? true)
            {
                item.AcousticSpaces?.ToString(fg, "AcousticSpaces");
            }
            if (printMask?.LandscapeTextures?.Overall ?? true)
            {
                item.LandscapeTextures?.ToString(fg, "LandscapeTextures");
            }
            if (printMask?.Grasses?.Overall ?? true)
            {
                item.Grasses?.ToString(fg, "Grasses");
            }
            if (printMask?.MaterialTypes?.Overall ?? true)
            {
                item.MaterialTypes?.ToString(fg, "MaterialTypes");
            }
        }
        
        #region Equals and Hash
        public virtual bool Equals(
            IFallout4ModGetter? lhs,
            IFallout4ModGetter? rhs,
            TranslationCrystal? crystal)
        {
            if (!EqualsMaskHelper.RefEquality(lhs, rhs, out var isEqual)) return isEqual;
            if ((crystal?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.ModHeader) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.ModHeader, rhs.ModHeader, out var lhsModHeader, out var rhsModHeader, out var isModHeaderEqual))
                {
                    if (!((Fallout4ModHeaderCommon)((IFallout4ModHeaderGetter)lhsModHeader).CommonInstance()!).Equals(lhsModHeader, rhsModHeader, crystal?.GetSubCrystal((int)Fallout4Mod_FieldIndex.ModHeader))) return false;
                }
                else if (!isModHeaderEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.GameSettings) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.GameSettings, rhs.GameSettings, out var lhsGameSettings, out var rhsGameSettings, out var isGameSettingsEqual))
                {
                    if (!object.Equals(lhsGameSettings, rhsGameSettings)) return false;
                }
                else if (!isGameSettingsEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.Keywords) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Keywords, rhs.Keywords, out var lhsKeywords, out var rhsKeywords, out var isKeywordsEqual))
                {
                    if (!object.Equals(lhsKeywords, rhsKeywords)) return false;
                }
                else if (!isKeywordsEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.LocationReferenceTypes) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.LocationReferenceTypes, rhs.LocationReferenceTypes, out var lhsLocationReferenceTypes, out var rhsLocationReferenceTypes, out var isLocationReferenceTypesEqual))
                {
                    if (!object.Equals(lhsLocationReferenceTypes, rhsLocationReferenceTypes)) return false;
                }
                else if (!isLocationReferenceTypesEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.Actions) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Actions, rhs.Actions, out var lhsActions, out var rhsActions, out var isActionsEqual))
                {
                    if (!object.Equals(lhsActions, rhsActions)) return false;
                }
                else if (!isActionsEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.Transforms) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Transforms, rhs.Transforms, out var lhsTransforms, out var rhsTransforms, out var isTransformsEqual))
                {
                    if (!object.Equals(lhsTransforms, rhsTransforms)) return false;
                }
                else if (!isTransformsEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.Components) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Components, rhs.Components, out var lhsComponents, out var rhsComponents, out var isComponentsEqual))
                {
                    if (!object.Equals(lhsComponents, rhsComponents)) return false;
                }
                else if (!isComponentsEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.TextureSets) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.TextureSets, rhs.TextureSets, out var lhsTextureSets, out var rhsTextureSets, out var isTextureSetsEqual))
                {
                    if (!object.Equals(lhsTextureSets, rhsTextureSets)) return false;
                }
                else if (!isTextureSetsEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.Globals) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Globals, rhs.Globals, out var lhsGlobals, out var rhsGlobals, out var isGlobalsEqual))
                {
                    if (!object.Equals(lhsGlobals, rhsGlobals)) return false;
                }
                else if (!isGlobalsEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.DamageTypes) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.DamageTypes, rhs.DamageTypes, out var lhsDamageTypes, out var rhsDamageTypes, out var isDamageTypesEqual))
                {
                    if (!object.Equals(lhsDamageTypes, rhsDamageTypes)) return false;
                }
                else if (!isDamageTypesEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.Classes) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Classes, rhs.Classes, out var lhsClasses, out var rhsClasses, out var isClassesEqual))
                {
                    if (!object.Equals(lhsClasses, rhsClasses)) return false;
                }
                else if (!isClassesEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.Factions) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Factions, rhs.Factions, out var lhsFactions, out var rhsFactions, out var isFactionsEqual))
                {
                    if (!object.Equals(lhsFactions, rhsFactions)) return false;
                }
                else if (!isFactionsEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.HeadParts) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.HeadParts, rhs.HeadParts, out var lhsHeadParts, out var rhsHeadParts, out var isHeadPartsEqual))
                {
                    if (!object.Equals(lhsHeadParts, rhsHeadParts)) return false;
                }
                else if (!isHeadPartsEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.SoundMarkers) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.SoundMarkers, rhs.SoundMarkers, out var lhsSoundMarkers, out var rhsSoundMarkers, out var isSoundMarkersEqual))
                {
                    if (!object.Equals(lhsSoundMarkers, rhsSoundMarkers)) return false;
                }
                else if (!isSoundMarkersEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.AcousticSpaces) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.AcousticSpaces, rhs.AcousticSpaces, out var lhsAcousticSpaces, out var rhsAcousticSpaces, out var isAcousticSpacesEqual))
                {
                    if (!object.Equals(lhsAcousticSpaces, rhsAcousticSpaces)) return false;
                }
                else if (!isAcousticSpacesEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.LandscapeTextures) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.LandscapeTextures, rhs.LandscapeTextures, out var lhsLandscapeTextures, out var rhsLandscapeTextures, out var isLandscapeTexturesEqual))
                {
                    if (!object.Equals(lhsLandscapeTextures, rhsLandscapeTextures)) return false;
                }
                else if (!isLandscapeTexturesEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.Grasses) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Grasses, rhs.Grasses, out var lhsGrasses, out var rhsGrasses, out var isGrassesEqual))
                {
                    if (!object.Equals(lhsGrasses, rhsGrasses)) return false;
                }
                else if (!isGrassesEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.MaterialTypes) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.MaterialTypes, rhs.MaterialTypes, out var lhsMaterialTypes, out var rhsMaterialTypes, out var isMaterialTypesEqual))
                {
                    if (!object.Equals(lhsMaterialTypes, rhsMaterialTypes)) return false;
                }
                else if (!isMaterialTypesEqual) return false;
            }
            return true;
        }
        
        public virtual int GetHashCode(IFallout4ModGetter item)
        {
            var hash = new HashCode();
            hash.Add(item.ModHeader);
            hash.Add(item.GameSettings);
            hash.Add(item.Keywords);
            hash.Add(item.LocationReferenceTypes);
            hash.Add(item.Actions);
            hash.Add(item.Transforms);
            hash.Add(item.Components);
            hash.Add(item.TextureSets);
            hash.Add(item.Globals);
            hash.Add(item.DamageTypes);
            hash.Add(item.Classes);
            hash.Add(item.Factions);
            hash.Add(item.HeadParts);
            hash.Add(item.SoundMarkers);
            hash.Add(item.AcousticSpaces);
            hash.Add(item.LandscapeTextures);
            hash.Add(item.Grasses);
            hash.Add(item.MaterialTypes);
            return hash.ToHashCode();
        }
        
        #endregion
        
        
        public object GetNew()
        {
            return Fallout4Mod.GetNew();
        }
        
        #region Mutagen
        public object GetGroup(
            IFallout4ModGetter obj,
            Type type)
        {
            switch (type.Name)
            {
                case "GameSetting":
                case "IGameSettingGetter":
                case "IGameSetting":
                case "IGameSettingInternal":
                    return obj.GameSettings;
                case "Keyword":
                case "IKeywordGetter":
                case "IKeyword":
                case "IKeywordInternal":
                    return obj.Keywords;
                case "LocationReferenceType":
                case "ILocationReferenceTypeGetter":
                case "ILocationReferenceType":
                case "ILocationReferenceTypeInternal":
                    return obj.LocationReferenceTypes;
                case "ActionRecord":
                case "IActionRecordGetter":
                case "IActionRecord":
                case "IActionRecordInternal":
                    return obj.Actions;
                case "Transform":
                case "ITransformGetter":
                case "ITransform":
                case "ITransformInternal":
                    return obj.Transforms;
                case "Component":
                case "IComponentGetter":
                case "IComponent":
                case "IComponentInternal":
                    return obj.Components;
                case "TextureSet":
                case "ITextureSetGetter":
                case "ITextureSet":
                case "ITextureSetInternal":
                    return obj.TextureSets;
                case "Global":
                case "IGlobalGetter":
                case "IGlobal":
                case "IGlobalInternal":
                    return obj.Globals;
                case "ADamageType":
                case "IADamageTypeGetter":
                case "IADamageType":
                case "IADamageTypeInternal":
                    return obj.DamageTypes;
                case "Class":
                case "IClassGetter":
                case "IClass":
                case "IClassInternal":
                    return obj.Classes;
                case "Faction":
                case "IFactionGetter":
                case "IFaction":
                case "IFactionInternal":
                    return obj.Factions;
                case "HeadPart":
                case "IHeadPartGetter":
                case "IHeadPart":
                case "IHeadPartInternal":
                    return obj.HeadParts;
                case "SoundMarker":
                case "ISoundMarkerGetter":
                case "ISoundMarker":
                case "ISoundMarkerInternal":
                    return obj.SoundMarkers;
                case "AcousticSpace":
                case "IAcousticSpaceGetter":
                case "IAcousticSpace":
                case "IAcousticSpaceInternal":
                    return obj.AcousticSpaces;
                case "LandscapeTexture":
                case "ILandscapeTextureGetter":
                case "ILandscapeTexture":
                case "ILandscapeTextureInternal":
                    return obj.LandscapeTextures;
                case "Grass":
                case "IGrassGetter":
                case "IGrass":
                case "IGrassInternal":
                    return obj.Grasses;
                case "MaterialType":
                case "IMaterialTypeGetter":
                case "IMaterialType":
                case "IMaterialTypeInternal":
                    return obj.MaterialTypes;
                default:
                    throw new ArgumentException($"Unknown major record type: {type}");
            }
        }
        
        public static void WriteParallel(
            IFallout4ModGetter item,
            Stream stream,
            BinaryWriteParameters param,
            ParallelWriteParameters parallelParam,
            ModKey modKey)
        {
            var bundle = new WritingBundle(GameConstants.Fallout4)
            {
                StringsWriter = param.StringsWriter,
                TargetLanguageOverride = param.TargetLanguageOverride,
            };
            var writer = new MutagenWriter(stream, bundle);
            ModHeaderWriteLogic.WriteHeader(
                param: param,
                writer: writer,
                mod: item,
                modHeader: item.ModHeader.DeepCopy(),
                modKey: modKey);
            Stream[] outputStreams = new Stream[17];
            List<Action> toDo = new List<Action>();
            toDo.Add(() => WriteGroupParallel(item.GameSettings, 0, outputStreams, bundle, parallelParam));
            toDo.Add(() => WriteGroupParallel(item.Keywords, 1, outputStreams, bundle, parallelParam));
            toDo.Add(() => WriteGroupParallel(item.LocationReferenceTypes, 2, outputStreams, bundle, parallelParam));
            toDo.Add(() => WriteGroupParallel(item.Actions, 3, outputStreams, bundle, parallelParam));
            toDo.Add(() => WriteGroupParallel(item.Transforms, 4, outputStreams, bundle, parallelParam));
            toDo.Add(() => WriteGroupParallel(item.Components, 5, outputStreams, bundle, parallelParam));
            toDo.Add(() => WriteGroupParallel(item.TextureSets, 6, outputStreams, bundle, parallelParam));
            toDo.Add(() => WriteGroupParallel(item.Globals, 7, outputStreams, bundle, parallelParam));
            toDo.Add(() => WriteGroupParallel(item.DamageTypes, 8, outputStreams, bundle, parallelParam));
            toDo.Add(() => WriteGroupParallel(item.Classes, 9, outputStreams, bundle, parallelParam));
            toDo.Add(() => WriteGroupParallel(item.Factions, 10, outputStreams, bundle, parallelParam));
            toDo.Add(() => WriteGroupParallel(item.HeadParts, 11, outputStreams, bundle, parallelParam));
            toDo.Add(() => WriteGroupParallel(item.SoundMarkers, 12, outputStreams, bundle, parallelParam));
            toDo.Add(() => WriteGroupParallel(item.AcousticSpaces, 13, outputStreams, bundle, parallelParam));
            toDo.Add(() => WriteGroupParallel(item.LandscapeTextures, 14, outputStreams, bundle, parallelParam));
            toDo.Add(() => WriteGroupParallel(item.Grasses, 15, outputStreams, bundle, parallelParam));
            toDo.Add(() => WriteGroupParallel(item.MaterialTypes, 16, outputStreams, bundle, parallelParam));
            Parallel.Invoke(parallelParam.ParallelOptions, toDo.ToArray());
            PluginUtilityTranslation.CompileStreamsInto(
                outputStreams.NotNull(),
                stream);
        }
        
        public static void WriteGroupParallel<T>(
            IFallout4GroupGetter<T> group,
            int targetIndex,
            Stream[] streamDepositArray,
            WritingBundle bundle,
            ParallelWriteParameters parallelParam)
            where T : class, IFallout4MajorRecordGetter, IBinaryItem
        {
            if (group.RecordCache.Count == 0) return;
            var cuts = group.Cut(parallelParam.CutCount).ToArray();
            Stream[] subStreams = new Stream[cuts.Length + 1];
            byte[] groupBytes = new byte[bundle.Constants.GroupConstants.HeaderLength];
            BinaryPrimitives.WriteInt32LittleEndian(groupBytes.AsSpan(), RecordTypes.GRUP.TypeInt);
            var groupByteStream = new MemoryStream(groupBytes);
            using (var stream = new MutagenWriter(groupByteStream, bundle.Constants, dispose: false))
            {
                stream.Position += 8;
                Fallout4GroupBinaryWriteTranslation.WriteEmbedded<T>(group, stream);
            }
            subStreams[0] = groupByteStream;
            Parallel.ForEach(cuts, parallelParam.ParallelOptions, (cutItems, state, counter) =>
            {
                MemoryTributary trib = new MemoryTributary();
                using (var stream = new MutagenWriter(trib, bundle with {}, dispose: false))
                {
                    foreach (var item in cutItems)
                    {
                        item.WriteToBinary(stream);
                    }
                }
                subStreams[(int)counter + 1] = trib;
            });
            PluginUtilityTranslation.CompileSetGroupLength(subStreams, groupBytes);
            streamDepositArray[targetIndex] = new CompositeReadStream(subStreams, resetPositions: true);
        }
        
        public IEnumerable<IFormLinkGetter> GetContainedFormLinks(IFallout4ModGetter obj)
        {
            foreach (var item in obj.ModHeader.ContainedFormLinks)
            {
                yield return item;
            }
            if (obj.GameSettings is IFormLinkContainerGetter GameSettingslinkCont)
            {
                foreach (var item in GameSettingslinkCont.ContainedFormLinks)
                {
                    yield return item;
                }
            }
            if (obj.Keywords is IFormLinkContainerGetter KeywordslinkCont)
            {
                foreach (var item in KeywordslinkCont.ContainedFormLinks)
                {
                    yield return item;
                }
            }
            if (obj.LocationReferenceTypes is IFormLinkContainerGetter LocationReferenceTypeslinkCont)
            {
                foreach (var item in LocationReferenceTypeslinkCont.ContainedFormLinks)
                {
                    yield return item;
                }
            }
            if (obj.Actions is IFormLinkContainerGetter ActionslinkCont)
            {
                foreach (var item in ActionslinkCont.ContainedFormLinks)
                {
                    yield return item;
                }
            }
            if (obj.Transforms is IFormLinkContainerGetter TransformslinkCont)
            {
                foreach (var item in TransformslinkCont.ContainedFormLinks)
                {
                    yield return item;
                }
            }
            if (obj.Components is IFormLinkContainerGetter ComponentslinkCont)
            {
                foreach (var item in ComponentslinkCont.ContainedFormLinks)
                {
                    yield return item;
                }
            }
            if (obj.TextureSets is IFormLinkContainerGetter TextureSetslinkCont)
            {
                foreach (var item in TextureSetslinkCont.ContainedFormLinks)
                {
                    yield return item;
                }
            }
            if (obj.Globals is IFormLinkContainerGetter GlobalslinkCont)
            {
                foreach (var item in GlobalslinkCont.ContainedFormLinks)
                {
                    yield return item;
                }
            }
            if (obj.DamageTypes is IFormLinkContainerGetter DamageTypeslinkCont)
            {
                foreach (var item in DamageTypeslinkCont.ContainedFormLinks)
                {
                    yield return item;
                }
            }
            if (obj.Classes is IFormLinkContainerGetter ClasseslinkCont)
            {
                foreach (var item in ClasseslinkCont.ContainedFormLinks)
                {
                    yield return item;
                }
            }
            if (obj.Factions is IFormLinkContainerGetter FactionslinkCont)
            {
                foreach (var item in FactionslinkCont.ContainedFormLinks)
                {
                    yield return item;
                }
            }
            if (obj.HeadParts is IFormLinkContainerGetter HeadPartslinkCont)
            {
                foreach (var item in HeadPartslinkCont.ContainedFormLinks)
                {
                    yield return item;
                }
            }
            if (obj.SoundMarkers is IFormLinkContainerGetter SoundMarkerslinkCont)
            {
                foreach (var item in SoundMarkerslinkCont.ContainedFormLinks)
                {
                    yield return item;
                }
            }
            if (obj.AcousticSpaces is IFormLinkContainerGetter AcousticSpaceslinkCont)
            {
                foreach (var item in AcousticSpaceslinkCont.ContainedFormLinks)
                {
                    yield return item;
                }
            }
            if (obj.LandscapeTextures is IFormLinkContainerGetter LandscapeTextureslinkCont)
            {
                foreach (var item in LandscapeTextureslinkCont.ContainedFormLinks)
                {
                    yield return item;
                }
            }
            if (obj.Grasses is IFormLinkContainerGetter GrasseslinkCont)
            {
                foreach (var item in GrasseslinkCont.ContainedFormLinks)
                {
                    yield return item;
                }
            }
            if (obj.MaterialTypes is IFormLinkContainerGetter MaterialTypeslinkCont)
            {
                foreach (var item in MaterialTypeslinkCont.ContainedFormLinks)
                {
                    yield return item;
                }
            }
            yield break;
        }
        
        public IEnumerable<IMajorRecordGetter> EnumerateMajorRecords(IFallout4ModGetter obj)
        {
            foreach (var item in obj.GameSettings.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.Keywords.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.LocationReferenceTypes.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.Actions.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.Transforms.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.Components.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.TextureSets.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.Globals.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.DamageTypes.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.Classes.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.Factions.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.HeadParts.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.SoundMarkers.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.AcousticSpaces.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.LandscapeTextures.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.Grasses.EnumerateMajorRecords())
            {
                yield return item;
            }
            foreach (var item in obj.MaterialTypes.EnumerateMajorRecords())
            {
                yield return item;
            }
        }
        
        public IEnumerable<IMajorRecordGetter> EnumeratePotentiallyTypedMajorRecords(
            IFallout4ModGetter obj,
            Type? type,
            bool throwIfUnknown)
        {
            if (type == null) return EnumerateMajorRecords(obj);
            return EnumerateMajorRecords(obj, type, throwIfUnknown);
        }
        
        public IEnumerable<IMajorRecordGetter> EnumerateMajorRecords(
            IFallout4ModGetter obj,
            Type type,
            bool throwIfUnknown)
        {
            switch (type.Name)
            {
                case "IMajorRecord":
                case "MajorRecord":
                case "IFallout4MajorRecord":
                case "Fallout4MajorRecord":
                    if (!Fallout4Mod_Registration.SetterType.IsAssignableFrom(obj.GetType())) yield break;
                    foreach (var item in this.EnumerateMajorRecords(obj))
                    {
                        yield return item;
                    }
                    yield break;
                case "IMajorRecordGetter":
                case "IFallout4MajorRecordGetter":
                    foreach (var item in this.EnumerateMajorRecords(obj))
                    {
                        yield return item;
                    }
                    yield break;
                case "GameSetting":
                case "IGameSettingGetter":
                case "IGameSetting":
                case "IGameSettingInternal":
                    foreach (var item in obj.GameSettings.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "Keyword":
                case "IKeywordGetter":
                case "IKeyword":
                case "IKeywordInternal":
                    foreach (var item in obj.Keywords.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "LocationReferenceType":
                case "ILocationReferenceTypeGetter":
                case "ILocationReferenceType":
                case "ILocationReferenceTypeInternal":
                    foreach (var item in obj.LocationReferenceTypes.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "ActionRecord":
                case "IActionRecordGetter":
                case "IActionRecord":
                case "IActionRecordInternal":
                    foreach (var item in obj.Actions.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "Transform":
                case "ITransformGetter":
                case "ITransform":
                case "ITransformInternal":
                    foreach (var item in obj.Transforms.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "Component":
                case "IComponentGetter":
                case "IComponent":
                case "IComponentInternal":
                    foreach (var item in obj.Components.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "TextureSet":
                case "ITextureSetGetter":
                case "ITextureSet":
                case "ITextureSetInternal":
                    foreach (var item in obj.TextureSets.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "Global":
                case "IGlobalGetter":
                case "IGlobal":
                case "IGlobalInternal":
                    foreach (var item in obj.Globals.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "ADamageType":
                case "IADamageTypeGetter":
                case "IADamageType":
                case "IADamageTypeInternal":
                    foreach (var item in obj.DamageTypes.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "Class":
                case "IClassGetter":
                case "IClass":
                case "IClassInternal":
                    foreach (var item in obj.Classes.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "Faction":
                case "IFactionGetter":
                case "IFaction":
                case "IFactionInternal":
                    foreach (var item in obj.Factions.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "HeadPart":
                case "IHeadPartGetter":
                case "IHeadPart":
                case "IHeadPartInternal":
                    foreach (var item in obj.HeadParts.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "SoundMarker":
                case "ISoundMarkerGetter":
                case "ISoundMarker":
                case "ISoundMarkerInternal":
                    foreach (var item in obj.SoundMarkers.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "AcousticSpace":
                case "IAcousticSpaceGetter":
                case "IAcousticSpace":
                case "IAcousticSpaceInternal":
                    foreach (var item in obj.AcousticSpaces.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "LandscapeTexture":
                case "ILandscapeTextureGetter":
                case "ILandscapeTexture":
                case "ILandscapeTextureInternal":
                    foreach (var item in obj.LandscapeTextures.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "Grass":
                case "IGrassGetter":
                case "IGrass":
                case "IGrassInternal":
                    foreach (var item in obj.Grasses.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                case "MaterialType":
                case "IMaterialTypeGetter":
                case "IMaterialType":
                case "IMaterialTypeInternal":
                    foreach (var item in obj.MaterialTypes.EnumerateMajorRecords(type, throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                default:
                    if (InterfaceEnumerationHelper.TryEnumerateInterfaceRecordsFor(GameCategory.Fallout4, obj, type, out var linkInterfaces))
                    {
                        foreach (var item in linkInterfaces)
                        {
                            yield return item;
                        }
                        yield break;
                    }
                    if (throwIfUnknown)
                    {
                        throw new ArgumentException($"Unknown major record type: {type}");
                    }
                    else
                    {
                        yield break;
                    }
            }
        }
        
        public IEnumerable<IModContext<IFallout4Mod, IFallout4ModGetter, IMajorRecord, IMajorRecordGetter>> EnumerateMajorRecordContexts(
            IFallout4ModGetter obj,
            ILinkCache linkCache)
        {
            foreach (var item in obj.GameSettings)
            {
                yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, GameSetting, IGameSettingGetter>(
                    modKey: obj.ModKey,
                    record: item,
                    group: (m) => m.GameSettings,
                    groupGetter: (m) => m.GameSettings);
            }
            foreach (var item in obj.Keywords)
            {
                yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, Keyword, IKeywordGetter>(
                    modKey: obj.ModKey,
                    record: item,
                    group: (m) => m.Keywords,
                    groupGetter: (m) => m.Keywords);
            }
            foreach (var item in obj.LocationReferenceTypes)
            {
                yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, LocationReferenceType, ILocationReferenceTypeGetter>(
                    modKey: obj.ModKey,
                    record: item,
                    group: (m) => m.LocationReferenceTypes,
                    groupGetter: (m) => m.LocationReferenceTypes);
            }
            foreach (var item in obj.Actions)
            {
                yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, ActionRecord, IActionRecordGetter>(
                    modKey: obj.ModKey,
                    record: item,
                    group: (m) => m.Actions,
                    groupGetter: (m) => m.Actions);
            }
            foreach (var item in obj.Transforms)
            {
                yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, Transform, ITransformGetter>(
                    modKey: obj.ModKey,
                    record: item,
                    group: (m) => m.Transforms,
                    groupGetter: (m) => m.Transforms);
            }
            foreach (var item in obj.Components)
            {
                yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, Component, IComponentGetter>(
                    modKey: obj.ModKey,
                    record: item,
                    group: (m) => m.Components,
                    groupGetter: (m) => m.Components);
            }
            foreach (var item in obj.TextureSets)
            {
                yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, TextureSet, ITextureSetGetter>(
                    modKey: obj.ModKey,
                    record: item,
                    group: (m) => m.TextureSets,
                    groupGetter: (m) => m.TextureSets);
            }
            foreach (var item in obj.Globals)
            {
                yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, Global, IGlobalGetter>(
                    modKey: obj.ModKey,
                    record: item,
                    group: (m) => m.Globals,
                    groupGetter: (m) => m.Globals);
            }
            foreach (var item in obj.DamageTypes)
            {
                yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, ADamageType, IADamageTypeGetter>(
                    modKey: obj.ModKey,
                    record: item,
                    group: (m) => m.DamageTypes,
                    groupGetter: (m) => m.DamageTypes);
            }
            foreach (var item in obj.Classes)
            {
                yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, Class, IClassGetter>(
                    modKey: obj.ModKey,
                    record: item,
                    group: (m) => m.Classes,
                    groupGetter: (m) => m.Classes);
            }
            foreach (var item in obj.Factions)
            {
                yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, Faction, IFactionGetter>(
                    modKey: obj.ModKey,
                    record: item,
                    group: (m) => m.Factions,
                    groupGetter: (m) => m.Factions);
            }
            foreach (var item in obj.HeadParts)
            {
                yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, HeadPart, IHeadPartGetter>(
                    modKey: obj.ModKey,
                    record: item,
                    group: (m) => m.HeadParts,
                    groupGetter: (m) => m.HeadParts);
            }
            foreach (var item in obj.SoundMarkers)
            {
                yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, SoundMarker, ISoundMarkerGetter>(
                    modKey: obj.ModKey,
                    record: item,
                    group: (m) => m.SoundMarkers,
                    groupGetter: (m) => m.SoundMarkers);
            }
            foreach (var item in obj.AcousticSpaces)
            {
                yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, AcousticSpace, IAcousticSpaceGetter>(
                    modKey: obj.ModKey,
                    record: item,
                    group: (m) => m.AcousticSpaces,
                    groupGetter: (m) => m.AcousticSpaces);
            }
            foreach (var item in obj.LandscapeTextures)
            {
                yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, LandscapeTexture, ILandscapeTextureGetter>(
                    modKey: obj.ModKey,
                    record: item,
                    group: (m) => m.LandscapeTextures,
                    groupGetter: (m) => m.LandscapeTextures);
            }
            foreach (var item in obj.Grasses)
            {
                yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, Grass, IGrassGetter>(
                    modKey: obj.ModKey,
                    record: item,
                    group: (m) => m.Grasses,
                    groupGetter: (m) => m.Grasses);
            }
            foreach (var item in obj.MaterialTypes)
            {
                yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, MaterialType, IMaterialTypeGetter>(
                    modKey: obj.ModKey,
                    record: item,
                    group: (m) => m.MaterialTypes,
                    groupGetter: (m) => m.MaterialTypes);
            }
        }
        
        public IEnumerable<IModContext<IFallout4Mod, IFallout4ModGetter, IMajorRecord, IMajorRecordGetter>> EnumerateMajorRecordContexts(
            IFallout4ModGetter obj,
            ILinkCache linkCache,
            Type type,
            bool throwIfUnknown)
        {
            switch (type.Name)
            {
                case "IMajorRecord":
                case "MajorRecord":
                case "IFallout4MajorRecord":
                case "Fallout4MajorRecord":
                    if (!Fallout4Mod_Registration.SetterType.IsAssignableFrom(obj.GetType())) yield break;
                    foreach (var item in this.EnumerateMajorRecordContexts(
                        obj,
                        linkCache: linkCache))
                    {
                        yield return item;
                    }
                    yield break;
                case "IMajorRecordGetter":
                case "IFallout4MajorRecordGetter":
                    foreach (var item in this.EnumerateMajorRecordContexts(
                        obj,
                        linkCache: linkCache))
                    {
                        yield return item;
                    }
                    yield break;
                case "GameSetting":
                case "IGameSettingGetter":
                case "IGameSetting":
                case "IGameSettingInternal":
                    foreach (var item in obj.GameSettings)
                    {
                        yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, GameSetting, IGameSettingGetter>(
                            modKey: obj.ModKey,
                            record: item,
                            group: (m) => m.GameSettings,
                            groupGetter: (m) => m.GameSettings);
                    }
                    yield break;
                case "Keyword":
                case "IKeywordGetter":
                case "IKeyword":
                case "IKeywordInternal":
                    foreach (var item in obj.Keywords)
                    {
                        yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, Keyword, IKeywordGetter>(
                            modKey: obj.ModKey,
                            record: item,
                            group: (m) => m.Keywords,
                            groupGetter: (m) => m.Keywords);
                    }
                    yield break;
                case "LocationReferenceType":
                case "ILocationReferenceTypeGetter":
                case "ILocationReferenceType":
                case "ILocationReferenceTypeInternal":
                    foreach (var item in obj.LocationReferenceTypes)
                    {
                        yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, LocationReferenceType, ILocationReferenceTypeGetter>(
                            modKey: obj.ModKey,
                            record: item,
                            group: (m) => m.LocationReferenceTypes,
                            groupGetter: (m) => m.LocationReferenceTypes);
                    }
                    yield break;
                case "ActionRecord":
                case "IActionRecordGetter":
                case "IActionRecord":
                case "IActionRecordInternal":
                    foreach (var item in obj.Actions)
                    {
                        yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, ActionRecord, IActionRecordGetter>(
                            modKey: obj.ModKey,
                            record: item,
                            group: (m) => m.Actions,
                            groupGetter: (m) => m.Actions);
                    }
                    yield break;
                case "Transform":
                case "ITransformGetter":
                case "ITransform":
                case "ITransformInternal":
                    foreach (var item in obj.Transforms)
                    {
                        yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, Transform, ITransformGetter>(
                            modKey: obj.ModKey,
                            record: item,
                            group: (m) => m.Transforms,
                            groupGetter: (m) => m.Transforms);
                    }
                    yield break;
                case "Component":
                case "IComponentGetter":
                case "IComponent":
                case "IComponentInternal":
                    foreach (var item in obj.Components)
                    {
                        yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, Component, IComponentGetter>(
                            modKey: obj.ModKey,
                            record: item,
                            group: (m) => m.Components,
                            groupGetter: (m) => m.Components);
                    }
                    yield break;
                case "TextureSet":
                case "ITextureSetGetter":
                case "ITextureSet":
                case "ITextureSetInternal":
                    foreach (var item in obj.TextureSets)
                    {
                        yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, TextureSet, ITextureSetGetter>(
                            modKey: obj.ModKey,
                            record: item,
                            group: (m) => m.TextureSets,
                            groupGetter: (m) => m.TextureSets);
                    }
                    yield break;
                case "Global":
                case "IGlobalGetter":
                case "IGlobal":
                case "IGlobalInternal":
                    foreach (var item in obj.Globals)
                    {
                        yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, Global, IGlobalGetter>(
                            modKey: obj.ModKey,
                            record: item,
                            group: (m) => m.Globals,
                            groupGetter: (m) => m.Globals);
                    }
                    yield break;
                case "ADamageType":
                case "IADamageTypeGetter":
                case "IADamageType":
                case "IADamageTypeInternal":
                    foreach (var item in obj.DamageTypes)
                    {
                        yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, ADamageType, IADamageTypeGetter>(
                            modKey: obj.ModKey,
                            record: item,
                            group: (m) => m.DamageTypes,
                            groupGetter: (m) => m.DamageTypes);
                    }
                    yield break;
                case "Class":
                case "IClassGetter":
                case "IClass":
                case "IClassInternal":
                    foreach (var item in obj.Classes)
                    {
                        yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, Class, IClassGetter>(
                            modKey: obj.ModKey,
                            record: item,
                            group: (m) => m.Classes,
                            groupGetter: (m) => m.Classes);
                    }
                    yield break;
                case "Faction":
                case "IFactionGetter":
                case "IFaction":
                case "IFactionInternal":
                    foreach (var item in obj.Factions)
                    {
                        yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, Faction, IFactionGetter>(
                            modKey: obj.ModKey,
                            record: item,
                            group: (m) => m.Factions,
                            groupGetter: (m) => m.Factions);
                    }
                    yield break;
                case "HeadPart":
                case "IHeadPartGetter":
                case "IHeadPart":
                case "IHeadPartInternal":
                    foreach (var item in obj.HeadParts)
                    {
                        yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, HeadPart, IHeadPartGetter>(
                            modKey: obj.ModKey,
                            record: item,
                            group: (m) => m.HeadParts,
                            groupGetter: (m) => m.HeadParts);
                    }
                    yield break;
                case "SoundMarker":
                case "ISoundMarkerGetter":
                case "ISoundMarker":
                case "ISoundMarkerInternal":
                    foreach (var item in obj.SoundMarkers)
                    {
                        yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, SoundMarker, ISoundMarkerGetter>(
                            modKey: obj.ModKey,
                            record: item,
                            group: (m) => m.SoundMarkers,
                            groupGetter: (m) => m.SoundMarkers);
                    }
                    yield break;
                case "AcousticSpace":
                case "IAcousticSpaceGetter":
                case "IAcousticSpace":
                case "IAcousticSpaceInternal":
                    foreach (var item in obj.AcousticSpaces)
                    {
                        yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, AcousticSpace, IAcousticSpaceGetter>(
                            modKey: obj.ModKey,
                            record: item,
                            group: (m) => m.AcousticSpaces,
                            groupGetter: (m) => m.AcousticSpaces);
                    }
                    yield break;
                case "LandscapeTexture":
                case "ILandscapeTextureGetter":
                case "ILandscapeTexture":
                case "ILandscapeTextureInternal":
                    foreach (var item in obj.LandscapeTextures)
                    {
                        yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, LandscapeTexture, ILandscapeTextureGetter>(
                            modKey: obj.ModKey,
                            record: item,
                            group: (m) => m.LandscapeTextures,
                            groupGetter: (m) => m.LandscapeTextures);
                    }
                    yield break;
                case "Grass":
                case "IGrassGetter":
                case "IGrass":
                case "IGrassInternal":
                    foreach (var item in obj.Grasses)
                    {
                        yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, Grass, IGrassGetter>(
                            modKey: obj.ModKey,
                            record: item,
                            group: (m) => m.Grasses,
                            groupGetter: (m) => m.Grasses);
                    }
                    yield break;
                case "MaterialType":
                case "IMaterialTypeGetter":
                case "IMaterialType":
                case "IMaterialTypeInternal":
                    foreach (var item in obj.MaterialTypes)
                    {
                        yield return new GroupModContext<IFallout4Mod, IFallout4ModGetter, MaterialType, IMaterialTypeGetter>(
                            modKey: obj.ModKey,
                            record: item,
                            group: (m) => m.MaterialTypes,
                            groupGetter: (m) => m.MaterialTypes);
                    }
                    yield break;
                case "IIdleRelation":
                case "IIdleRelationGetter":
                {
                    foreach (var item in EnumerateMajorRecordContexts(
                        obj,
                        linkCache: linkCache,
                        type: typeof(IActionRecordGetter),
                        throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                }
                case "IObjectId":
                case "IObjectIdGetter":
                {
                    foreach (var item in EnumerateMajorRecordContexts(
                        obj,
                        linkCache: linkCache,
                        type: typeof(IFactionGetter),
                        throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    foreach (var item in EnumerateMajorRecordContexts(
                        obj,
                        linkCache: linkCache,
                        type: typeof(ITextureSetGetter),
                        throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                }
                case "IOwner":
                case "IOwnerGetter":
                {
                    foreach (var item in EnumerateMajorRecordContexts(
                        obj,
                        linkCache: linkCache,
                        type: typeof(IFactionGetter),
                        throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                }
                case "IRelatable":
                case "IRelatableGetter":
                {
                    foreach (var item in EnumerateMajorRecordContexts(
                        obj,
                        linkCache: linkCache,
                        type: typeof(IFactionGetter),
                        throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                }
                case "IKeywordLinkedReference":
                case "IKeywordLinkedReferenceGetter":
                {
                    foreach (var item in EnumerateMajorRecordContexts(
                        obj,
                        linkCache: linkCache,
                        type: typeof(IKeywordGetter),
                        throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                }
                case "IRegionTarget":
                case "IRegionTargetGetter":
                {
                    foreach (var item in EnumerateMajorRecordContexts(
                        obj,
                        linkCache: linkCache,
                        type: typeof(ILandscapeTextureGetter),
                        throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                }
                case "ILocationRecord":
                case "ILocationRecordGetter":
                {
                    foreach (var item in EnumerateMajorRecordContexts(
                        obj,
                        linkCache: linkCache,
                        type: typeof(ILocationReferenceTypeGetter),
                        throwIfUnknown: throwIfUnknown))
                    {
                        yield return item;
                    }
                    yield break;
                }
                default:
                    if (throwIfUnknown)
                    {
                        throw new ArgumentException($"Unknown major record type: {type}");
                    }
                    else
                    {
                        yield break;
                    }
            }
        }
        
        #endregion
        
    }
    public partial class Fallout4ModSetterTranslationCommon
    {
        public static readonly Fallout4ModSetterTranslationCommon Instance = new Fallout4ModSetterTranslationCommon();

        #region DeepCopyIn
        public void DeepCopyIn(
            IFallout4Mod item,
            IFallout4ModGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            if ((copyMask?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.ModHeader) ?? true))
            {
                errorMask?.PushIndex((int)Fallout4Mod_FieldIndex.ModHeader);
                try
                {
                    item.ModHeader.DeepCopyIn(
                        rhs: rhs.ModHeader,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout4Mod_FieldIndex.ModHeader));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.GameSettings) ?? true))
            {
                errorMask?.PushIndex((int)Fallout4Mod_FieldIndex.GameSettings);
                try
                {
                    item.GameSettings.DeepCopyIn(
                        rhs: rhs.GameSettings,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout4Mod_FieldIndex.GameSettings));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.Keywords) ?? true))
            {
                errorMask?.PushIndex((int)Fallout4Mod_FieldIndex.Keywords);
                try
                {
                    item.Keywords.DeepCopyIn(
                        rhs: rhs.Keywords,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout4Mod_FieldIndex.Keywords));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.LocationReferenceTypes) ?? true))
            {
                errorMask?.PushIndex((int)Fallout4Mod_FieldIndex.LocationReferenceTypes);
                try
                {
                    item.LocationReferenceTypes.DeepCopyIn(
                        rhs: rhs.LocationReferenceTypes,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout4Mod_FieldIndex.LocationReferenceTypes));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.Actions) ?? true))
            {
                errorMask?.PushIndex((int)Fallout4Mod_FieldIndex.Actions);
                try
                {
                    item.Actions.DeepCopyIn(
                        rhs: rhs.Actions,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout4Mod_FieldIndex.Actions));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.Transforms) ?? true))
            {
                errorMask?.PushIndex((int)Fallout4Mod_FieldIndex.Transforms);
                try
                {
                    item.Transforms.DeepCopyIn(
                        rhs: rhs.Transforms,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout4Mod_FieldIndex.Transforms));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.Components) ?? true))
            {
                errorMask?.PushIndex((int)Fallout4Mod_FieldIndex.Components);
                try
                {
                    item.Components.DeepCopyIn(
                        rhs: rhs.Components,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout4Mod_FieldIndex.Components));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.TextureSets) ?? true))
            {
                errorMask?.PushIndex((int)Fallout4Mod_FieldIndex.TextureSets);
                try
                {
                    item.TextureSets.DeepCopyIn(
                        rhs: rhs.TextureSets,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout4Mod_FieldIndex.TextureSets));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.Globals) ?? true))
            {
                errorMask?.PushIndex((int)Fallout4Mod_FieldIndex.Globals);
                try
                {
                    item.Globals.DeepCopyIn(
                        rhs: rhs.Globals,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout4Mod_FieldIndex.Globals));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.DamageTypes) ?? true))
            {
                errorMask?.PushIndex((int)Fallout4Mod_FieldIndex.DamageTypes);
                try
                {
                    item.DamageTypes.DeepCopyIn(
                        rhs: rhs.DamageTypes,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout4Mod_FieldIndex.DamageTypes));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.Classes) ?? true))
            {
                errorMask?.PushIndex((int)Fallout4Mod_FieldIndex.Classes);
                try
                {
                    item.Classes.DeepCopyIn(
                        rhs: rhs.Classes,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout4Mod_FieldIndex.Classes));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.Factions) ?? true))
            {
                errorMask?.PushIndex((int)Fallout4Mod_FieldIndex.Factions);
                try
                {
                    item.Factions.DeepCopyIn(
                        rhs: rhs.Factions,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout4Mod_FieldIndex.Factions));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.HeadParts) ?? true))
            {
                errorMask?.PushIndex((int)Fallout4Mod_FieldIndex.HeadParts);
                try
                {
                    item.HeadParts.DeepCopyIn(
                        rhs: rhs.HeadParts,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout4Mod_FieldIndex.HeadParts));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.SoundMarkers) ?? true))
            {
                errorMask?.PushIndex((int)Fallout4Mod_FieldIndex.SoundMarkers);
                try
                {
                    item.SoundMarkers.DeepCopyIn(
                        rhs: rhs.SoundMarkers,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout4Mod_FieldIndex.SoundMarkers));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.AcousticSpaces) ?? true))
            {
                errorMask?.PushIndex((int)Fallout4Mod_FieldIndex.AcousticSpaces);
                try
                {
                    item.AcousticSpaces.DeepCopyIn(
                        rhs: rhs.AcousticSpaces,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout4Mod_FieldIndex.AcousticSpaces));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.LandscapeTextures) ?? true))
            {
                errorMask?.PushIndex((int)Fallout4Mod_FieldIndex.LandscapeTextures);
                try
                {
                    item.LandscapeTextures.DeepCopyIn(
                        rhs: rhs.LandscapeTextures,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout4Mod_FieldIndex.LandscapeTextures));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.Grasses) ?? true))
            {
                errorMask?.PushIndex((int)Fallout4Mod_FieldIndex.Grasses);
                try
                {
                    item.Grasses.DeepCopyIn(
                        rhs: rhs.Grasses,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout4Mod_FieldIndex.Grasses));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4Mod_FieldIndex.MaterialTypes) ?? true))
            {
                errorMask?.PushIndex((int)Fallout4Mod_FieldIndex.MaterialTypes);
                try
                {
                    item.MaterialTypes.DeepCopyIn(
                        rhs: rhs.MaterialTypes,
                        errorMask: errorMask,
                        copyMask: copyMask?.GetSubCrystal((int)Fallout4Mod_FieldIndex.MaterialTypes));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
        }
        
        #endregion
        
        public Fallout4Mod DeepCopy(
            IFallout4ModGetter item,
            Fallout4Mod.TranslationMask? copyMask = null)
        {
            Fallout4Mod ret = (Fallout4Mod)((Fallout4ModCommon)((IFallout4ModGetter)item).CommonInstance()!).GetNew();
            ((Fallout4ModSetterTranslationCommon)((IFallout4ModGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: null,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            return ret;
        }
        
        public Fallout4Mod DeepCopy(
            IFallout4ModGetter item,
            out Fallout4Mod.ErrorMask errorMask,
            Fallout4Mod.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            Fallout4Mod ret = (Fallout4Mod)((Fallout4ModCommon)((IFallout4ModGetter)item).CommonInstance()!).GetNew();
            ((Fallout4ModSetterTranslationCommon)((IFallout4ModGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                ret,
                item,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            errorMask = Fallout4Mod.ErrorMask.Factory(errorMaskBuilder);
            return ret;
        }
        
        public Fallout4Mod DeepCopy(
            IFallout4ModGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            Fallout4Mod ret = (Fallout4Mod)((Fallout4ModCommon)((IFallout4ModGetter)item).CommonInstance()!).GetNew();
            ((Fallout4ModSetterTranslationCommon)((IFallout4ModGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: true);
            return ret;
        }
        
    }
    #endregion

}

namespace Mutagen.Bethesda.Fallout4
{
    public partial class Fallout4Mod
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => Fallout4Mod_Registration.Instance;
        public static Fallout4Mod_Registration StaticRegistration => Fallout4Mod_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => Fallout4ModCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterInstance()
        {
            return Fallout4ModSetterCommon.Instance;
        }
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => Fallout4ModSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IFallout4ModGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object IFallout4ModGetter.CommonSetterInstance() => this.CommonSetterInstance();
        [DebuggerStepThrough]
        object IFallout4ModGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

    }
}

#region Modules
#region Mutagen
namespace Mutagen.Bethesda.Fallout4
{
    public class GroupMask
    {
        public bool GameSettings;
        public bool Keywords;
        public bool LocationReferenceTypes;
        public bool Actions;
        public bool Transforms;
        public bool Components;
        public bool TextureSets;
        public bool Globals;
        public bool DamageTypes;
        public bool Classes;
        public bool Factions;
        public bool HeadParts;
        public bool SoundMarkers;
        public bool AcousticSpaces;
        public bool LandscapeTextures;
        public bool Grasses;
        public bool MaterialTypes;
        public GroupMask()
        {
        }
        public GroupMask(bool defaultValue)
        {
            GameSettings = defaultValue;
            Keywords = defaultValue;
            LocationReferenceTypes = defaultValue;
            Actions = defaultValue;
            Transforms = defaultValue;
            Components = defaultValue;
            TextureSets = defaultValue;
            Globals = defaultValue;
            DamageTypes = defaultValue;
            Classes = defaultValue;
            Factions = defaultValue;
            HeadParts = defaultValue;
            SoundMarkers = defaultValue;
            AcousticSpaces = defaultValue;
            LandscapeTextures = defaultValue;
            Grasses = defaultValue;
            MaterialTypes = defaultValue;
        }
    }

    public interface IFallout4ModDisposableGetter : IFallout4ModGetter, IModDisposeGetter
    {
    }

}
namespace Mutagen.Bethesda.Fallout4.Internals
{
    public partial class Fallout4Mod_Registration : IModRegistration
    {
        public GameCategory GameCategory => GameCategory.Fallout4;
    }

}
#endregion

#region Binary Translation
namespace Mutagen.Bethesda.Fallout4.Internals
{
    public partial class Fallout4ModBinaryWriteTranslation
    {
        public readonly static Fallout4ModBinaryWriteTranslation Instance = new Fallout4ModBinaryWriteTranslation();

        public static void WriteRecordTypes(
            IFallout4ModGetter item,
            MutagenWriter writer,
            GroupMask? importMask,
            TypedWriteParams? translationParams = null)
        {
            if (importMask?.GameSettings ?? true)
            {
                var GameSettingsItem = item.GameSettings;
                if (GameSettingsItem.RecordCache.Count > 0)
                {
                    ((Fallout4GroupBinaryWriteTranslation)((IBinaryItem)GameSettingsItem).BinaryWriteTranslator).Write<IGameSettingGetter>(
                        item: GameSettingsItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.Keywords ?? true)
            {
                var KeywordsItem = item.Keywords;
                if (KeywordsItem.RecordCache.Count > 0)
                {
                    ((Fallout4GroupBinaryWriteTranslation)((IBinaryItem)KeywordsItem).BinaryWriteTranslator).Write<IKeywordGetter>(
                        item: KeywordsItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.LocationReferenceTypes ?? true)
            {
                var LocationReferenceTypesItem = item.LocationReferenceTypes;
                if (LocationReferenceTypesItem.RecordCache.Count > 0)
                {
                    ((Fallout4GroupBinaryWriteTranslation)((IBinaryItem)LocationReferenceTypesItem).BinaryWriteTranslator).Write<ILocationReferenceTypeGetter>(
                        item: LocationReferenceTypesItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.Actions ?? true)
            {
                var ActionsItem = item.Actions;
                if (ActionsItem.RecordCache.Count > 0)
                {
                    ((Fallout4GroupBinaryWriteTranslation)((IBinaryItem)ActionsItem).BinaryWriteTranslator).Write<IActionRecordGetter>(
                        item: ActionsItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.Transforms ?? true)
            {
                var TransformsItem = item.Transforms;
                if (TransformsItem.RecordCache.Count > 0)
                {
                    ((Fallout4GroupBinaryWriteTranslation)((IBinaryItem)TransformsItem).BinaryWriteTranslator).Write<ITransformGetter>(
                        item: TransformsItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.Components ?? true)
            {
                var ComponentsItem = item.Components;
                if (ComponentsItem.RecordCache.Count > 0)
                {
                    ((Fallout4GroupBinaryWriteTranslation)((IBinaryItem)ComponentsItem).BinaryWriteTranslator).Write<IComponentGetter>(
                        item: ComponentsItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.TextureSets ?? true)
            {
                var TextureSetsItem = item.TextureSets;
                if (TextureSetsItem.RecordCache.Count > 0)
                {
                    ((Fallout4GroupBinaryWriteTranslation)((IBinaryItem)TextureSetsItem).BinaryWriteTranslator).Write<ITextureSetGetter>(
                        item: TextureSetsItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.Globals ?? true)
            {
                var GlobalsItem = item.Globals;
                if (GlobalsItem.RecordCache.Count > 0)
                {
                    ((Fallout4GroupBinaryWriteTranslation)((IBinaryItem)GlobalsItem).BinaryWriteTranslator).Write<IGlobalGetter>(
                        item: GlobalsItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.DamageTypes ?? true)
            {
                var DamageTypesItem = item.DamageTypes;
                if (DamageTypesItem.RecordCache.Count > 0)
                {
                    ((Fallout4GroupBinaryWriteTranslation)((IBinaryItem)DamageTypesItem).BinaryWriteTranslator).Write<IADamageTypeGetter>(
                        item: DamageTypesItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.Classes ?? true)
            {
                var ClassesItem = item.Classes;
                if (ClassesItem.RecordCache.Count > 0)
                {
                    ((Fallout4GroupBinaryWriteTranslation)((IBinaryItem)ClassesItem).BinaryWriteTranslator).Write<IClassGetter>(
                        item: ClassesItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.Factions ?? true)
            {
                var FactionsItem = item.Factions;
                if (FactionsItem.RecordCache.Count > 0)
                {
                    ((Fallout4GroupBinaryWriteTranslation)((IBinaryItem)FactionsItem).BinaryWriteTranslator).Write<IFactionGetter>(
                        item: FactionsItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.HeadParts ?? true)
            {
                var HeadPartsItem = item.HeadParts;
                if (HeadPartsItem.RecordCache.Count > 0)
                {
                    ((Fallout4GroupBinaryWriteTranslation)((IBinaryItem)HeadPartsItem).BinaryWriteTranslator).Write<IHeadPartGetter>(
                        item: HeadPartsItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.SoundMarkers ?? true)
            {
                var SoundMarkersItem = item.SoundMarkers;
                if (SoundMarkersItem.RecordCache.Count > 0)
                {
                    ((Fallout4GroupBinaryWriteTranslation)((IBinaryItem)SoundMarkersItem).BinaryWriteTranslator).Write<ISoundMarkerGetter>(
                        item: SoundMarkersItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.AcousticSpaces ?? true)
            {
                var AcousticSpacesItem = item.AcousticSpaces;
                if (AcousticSpacesItem.RecordCache.Count > 0)
                {
                    ((Fallout4GroupBinaryWriteTranslation)((IBinaryItem)AcousticSpacesItem).BinaryWriteTranslator).Write<IAcousticSpaceGetter>(
                        item: AcousticSpacesItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.LandscapeTextures ?? true)
            {
                var LandscapeTexturesItem = item.LandscapeTextures;
                if (LandscapeTexturesItem.RecordCache.Count > 0)
                {
                    ((Fallout4GroupBinaryWriteTranslation)((IBinaryItem)LandscapeTexturesItem).BinaryWriteTranslator).Write<ILandscapeTextureGetter>(
                        item: LandscapeTexturesItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.Grasses ?? true)
            {
                var GrassesItem = item.Grasses;
                if (GrassesItem.RecordCache.Count > 0)
                {
                    ((Fallout4GroupBinaryWriteTranslation)((IBinaryItem)GrassesItem).BinaryWriteTranslator).Write<IGrassGetter>(
                        item: GrassesItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
            if (importMask?.MaterialTypes ?? true)
            {
                var MaterialTypesItem = item.MaterialTypes;
                if (MaterialTypesItem.RecordCache.Count > 0)
                {
                    ((Fallout4GroupBinaryWriteTranslation)((IBinaryItem)MaterialTypesItem).BinaryWriteTranslator).Write<IMaterialTypeGetter>(
                        item: MaterialTypesItem,
                        writer: writer,
                        translationParams: translationParams);
                }
            }
        }

        public void Write(
            MutagenWriter writer,
            IFallout4ModGetter item,
            ModKey modKey,
            GroupMask? importMask = null,
            BinaryWriteParameters? param = null)
        {
            ModHeaderWriteLogic.WriteHeader(
                param: param,
                writer: writer,
                mod: item,
                modHeader: item.ModHeader.DeepCopy(),
                modKey: modKey);
            WriteRecordTypes(
                item: item,
                writer: writer,
                importMask: importMask);
        }

        public void Write(
            MutagenWriter writer,
            object item,
            ModKey modKey,
            GroupMask? importMask = null,
            BinaryWriteParameters? param = null)
        {
            Write(
                item: (IFallout4ModGetter)item,
                importMask: importMask,
                writer: writer,
                param: param,
                modKey: modKey);
        }

    }

    public partial class Fallout4ModBinaryCreateTranslation
    {
        public readonly static Fallout4ModBinaryCreateTranslation Instance = new Fallout4ModBinaryCreateTranslation();

        public static void FillBinaryStructs(
            IFallout4Mod item,
            MutagenFrame frame)
        {
        }

        public static ParseResult FillBinaryRecordTypes(
            IFallout4Mod item,
            MutagenFrame frame,
            RecordType nextRecordType,
            int contentLength,
            GroupMask? importMask,
            TypedParseParams? translationParams = null)
        {
            nextRecordType = translationParams.ConvertToStandard(nextRecordType);
            switch (nextRecordType.TypeInt)
            {
                case RecordTypeInts.TES4:
                {
                    item.ModHeader.CopyInFromBinary(
                        frame: frame,
                        translationParams: null);
                    return (int)Fallout4Mod_FieldIndex.ModHeader;
                }
                case RecordTypeInts.GMST:
                {
                    if (importMask?.GameSettings ?? true)
                    {
                        item.GameSettings.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout4Mod_FieldIndex.GameSettings;
                }
                case RecordTypeInts.KYWD:
                {
                    if (importMask?.Keywords ?? true)
                    {
                        item.Keywords.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout4Mod_FieldIndex.Keywords;
                }
                case RecordTypeInts.LCRT:
                {
                    if (importMask?.LocationReferenceTypes ?? true)
                    {
                        item.LocationReferenceTypes.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout4Mod_FieldIndex.LocationReferenceTypes;
                }
                case RecordTypeInts.AACT:
                {
                    if (importMask?.Actions ?? true)
                    {
                        item.Actions.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout4Mod_FieldIndex.Actions;
                }
                case RecordTypeInts.TRNS:
                {
                    if (importMask?.Transforms ?? true)
                    {
                        item.Transforms.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout4Mod_FieldIndex.Transforms;
                }
                case RecordTypeInts.CMPO:
                {
                    if (importMask?.Components ?? true)
                    {
                        item.Components.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout4Mod_FieldIndex.Components;
                }
                case RecordTypeInts.TXST:
                {
                    if (importMask?.TextureSets ?? true)
                    {
                        item.TextureSets.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout4Mod_FieldIndex.TextureSets;
                }
                case RecordTypeInts.GLOB:
                {
                    if (importMask?.Globals ?? true)
                    {
                        item.Globals.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout4Mod_FieldIndex.Globals;
                }
                case RecordTypeInts.DMGT:
                {
                    if (importMask?.DamageTypes ?? true)
                    {
                        item.DamageTypes.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout4Mod_FieldIndex.DamageTypes;
                }
                case RecordTypeInts.CLAS:
                {
                    if (importMask?.Classes ?? true)
                    {
                        item.Classes.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout4Mod_FieldIndex.Classes;
                }
                case RecordTypeInts.FACT:
                {
                    if (importMask?.Factions ?? true)
                    {
                        item.Factions.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout4Mod_FieldIndex.Factions;
                }
                case RecordTypeInts.HDPT:
                {
                    if (importMask?.HeadParts ?? true)
                    {
                        item.HeadParts.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout4Mod_FieldIndex.HeadParts;
                }
                case RecordTypeInts.SOUN:
                {
                    if (importMask?.SoundMarkers ?? true)
                    {
                        item.SoundMarkers.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout4Mod_FieldIndex.SoundMarkers;
                }
                case RecordTypeInts.ASPC:
                {
                    if (importMask?.AcousticSpaces ?? true)
                    {
                        item.AcousticSpaces.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout4Mod_FieldIndex.AcousticSpaces;
                }
                case RecordTypeInts.LTEX:
                {
                    if (importMask?.LandscapeTextures ?? true)
                    {
                        item.LandscapeTextures.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout4Mod_FieldIndex.LandscapeTextures;
                }
                case RecordTypeInts.GRAS:
                {
                    if (importMask?.Grasses ?? true)
                    {
                        item.Grasses.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout4Mod_FieldIndex.Grasses;
                }
                case RecordTypeInts.MATT:
                {
                    if (importMask?.MaterialTypes ?? true)
                    {
                        item.MaterialTypes.CopyInFromBinary(
                            frame: frame,
                            translationParams: null);
                    }
                    else
                    {
                        frame.Position += contentLength;
                    }
                    return (int)Fallout4Mod_FieldIndex.MaterialTypes;
                }
                default:
                    frame.Position += contentLength;
                    return default(int?);
            }
        }

    }

}
namespace Mutagen.Bethesda.Fallout4
{
    #region Binary Write Mixins
    public static class Fallout4ModBinaryTranslationMixIn
    {
        public static void WriteToBinary(
            this IFallout4ModGetter item,
            MutagenWriter writer,
            GroupMask? importMask = null,
            BinaryWriteParameters? param = null)
        {
            var modKey = item.ModKey;
            Fallout4ModBinaryWriteTranslation.Instance.Write(
                item: item,
                importMask: importMask,
                writer: writer,
                param: param,
                modKey: modKey);
        }

        public static void WriteToBinary(
            this IFallout4ModGetter item,
            FilePath path,
            BinaryWriteParameters? param = null,
            GroupMask? importMask = null,
            IFileSystem? fileSystem = null)
        {
            param ??= BinaryWriteParameters.Default;
            var modKey = param.RunMasterMatch(
                mod: item,
                path: path);
            param.StringsWriter ??= (EnumExt.HasFlag((int)item.ModHeader.Flags, (int)ModHeaderCommonFlag.Localized) ? new StringsWriter(GameRelease.Fallout4, modKey, Path.Combine(Path.GetDirectoryName(path)!, "Strings"), MutagenEncodingProvider.Instance) : null);
            bool disposeStrings = param.StringsWriter != null;
            var bundle = new WritingBundle(GameRelease.Fallout4)
            {
                StringsWriter = param.StringsWriter,
                CleanNulls = param.CleanNulls,
                TargetLanguageOverride = param.TargetLanguageOverride
            };
            using var memStream = new MemoryTributary();
            using (var writer = new MutagenWriter(
                memStream,
                bundle,
                dispose: false))
            {
                Fallout4ModBinaryWriteTranslation.Instance.Write(
                    item: item,
                    importMask: importMask,
                    writer: writer,
                    param: param,
                    modKey: modKey);
            }
            using (var fs = fileSystem.GetOrDefault().FileStream.Create(path, FileMode.Create, FileAccess.Write))
            {
                memStream.Position = 0;
                memStream.CopyTo(fs);
            }
            if (disposeStrings)
            {
                param.StringsWriter?.Dispose();
            }
        }

        public static void WriteToBinary(
            this IFallout4ModGetter item,
            Stream stream,
            BinaryWriteParameters? param = null,
            GroupMask? importMask = null)
        {
            var modKey = item.ModKey;
            using (var writer = new MutagenWriter(
                stream: stream,
                new WritingBundle(GameRelease.Fallout4),
                dispose: false))
            {
                Fallout4ModBinaryWriteTranslation.Instance.Write(
                    item: item,
                    importMask: importMask,
                    writer: writer,
                    param: param,
                    modKey: modKey);
            }
        }

    }
    #endregion


}
namespace Mutagen.Bethesda.Fallout4.Internals
{
    [DebuggerDisplay("{GameRelease} {ModKey.ToString()}")]
    public partial class Fallout4ModBinaryOverlay : IFallout4ModDisposableGetter
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => Fallout4Mod_Registration.Instance;
        public static Fallout4Mod_Registration StaticRegistration => Fallout4Mod_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => Fallout4ModCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => Fallout4ModSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IFallout4ModGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object? IFallout4ModGetter.CommonSetterInstance() => null;
        [DebuggerStepThrough]
        object IFallout4ModGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

        void IPrintable.ToString(FileGeneration fg, string? name) => this.ToString(fg, name);

        public GameRelease GameRelease => GameRelease.Fallout4;
        IGroupGetter<T> IModGetter.GetTopLevelGroup<T>() => this.GetTopLevelGroup<T>();
        IGroupGetter IModGetter.GetTopLevelGroup(Type type) => this.GetTopLevelGroup(type);
        void IModGetter.WriteToBinary(FilePath path, BinaryWriteParameters? param, IFileSystem? fileSystem) => this.WriteToBinary(path, importMask: null, param: param, fileSystem: fileSystem);
        void IModGetter.WriteToBinaryParallel(FilePath path, BinaryWriteParameters? param, IFileSystem? fileSystem, ParallelWriteParameters? parallelWriteParams) => this.WriteToBinaryParallel(path, param: param, fileSystem: fileSystem, parallelParam: parallelWriteParams);
        IReadOnlyList<IMasterReferenceGetter> IModGetter.MasterReferences => this.ModHeader.MasterReferences;
        public bool CanUseLocalization => true;
        public bool UsingLocalization => this.ModHeader.Flags.HasFlag(Fallout4ModHeader.HeaderFlag.Localized);
        public IEnumerable<IFormLinkGetter> ContainedFormLinks => Fallout4ModCommon.Instance.GetContainedFormLinks(this);
        [DebuggerStepThrough]
        IEnumerable<IModContext<IFallout4Mod, IFallout4ModGetter, TSetter, TGetter>> IMajorRecordContextEnumerable<IFallout4Mod, IFallout4ModGetter>.EnumerateMajorRecordContexts<TSetter, TGetter>(ILinkCache linkCache, bool throwIfUnknown) => this.EnumerateMajorRecordContexts<TSetter, TGetter>(linkCache, throwIfUnknown: throwIfUnknown);
        [DebuggerStepThrough]
        IEnumerable<IModContext<IFallout4Mod, IFallout4ModGetter, IMajorRecord, IMajorRecordGetter>> IMajorRecordContextEnumerable<IFallout4Mod, IFallout4ModGetter>.EnumerateMajorRecordContexts(ILinkCache linkCache, Type type, bool throwIfUnknown) => this.EnumerateMajorRecordContexts(linkCache, type: type, throwIfUnknown: throwIfUnknown);
        [DebuggerStepThrough]
        IEnumerable<IModContext<TMajor>> IMajorRecordSimpleContextEnumerable.EnumerateMajorRecordSimpleContexts<TMajor>(ILinkCache linkCache, bool throwIfUnknown) => this.EnumerateMajorRecordContexts(linkCache, typeof(TMajor), throwIfUnknown: throwIfUnknown).Select(x => x.AsType<Mutagen.Bethesda.Plugins.Records.IMajorRecordGetter, TMajor>());
        [DebuggerStepThrough]
        IEnumerable<IModContext<IMajorRecordGetter>> IMajorRecordSimpleContextEnumerable.EnumerateMajorRecordSimpleContexts(ILinkCache linkCache, Type type, bool throwIfUnknown) => this.EnumerateMajorRecordContexts(linkCache, type: type, throwIfUnknown: throwIfUnknown);
        [DebuggerStepThrough]
        IEnumerable<IMajorRecordGetter> IMajorRecordGetterEnumerable.EnumerateMajorRecords() => this.EnumerateMajorRecords();
        [DebuggerStepThrough]
        IEnumerable<TMajor> IMajorRecordGetterEnumerable.EnumerateMajorRecords<TMajor>(bool throwIfUnknown) => this.EnumerateMajorRecords<TMajor>(throwIfUnknown: throwIfUnknown);
        [DebuggerStepThrough]
        IEnumerable<IMajorRecordGetter> IMajorRecordGetterEnumerable.EnumerateMajorRecords(Type type, bool throwIfUnknown) => this.EnumerateMajorRecords(type: type, throwIfUnknown: throwIfUnknown);
        uint IModGetter.NextFormID => ModHeader.Stats.NextFormID;
        public ModKey ModKey { get; }
        private readonly BinaryOverlayFactoryPackage _package;
        private readonly IBinaryReadStream _data;
        private readonly bool _shouldDispose;
        public void Dispose()
        {
            if (!_shouldDispose) return;
            _data.Dispose();
        }

        #region ModHeader
        private RangeInt64? _ModHeaderLocation;
        private IFallout4ModHeaderGetter? _ModHeader => _ModHeaderLocation.HasValue ? Fallout4ModHeaderBinaryOverlay.Fallout4ModHeaderFactory(new OverlayStream(PluginBinaryOverlay.LockExtractMemory(_data, _ModHeaderLocation!.Value.Min, _ModHeaderLocation!.Value.Max), _package), _package) : default;
        public IFallout4ModHeaderGetter ModHeader => _ModHeader ?? new Fallout4ModHeader();
        #endregion
        #region GameSettings
        private List<RangeInt64>? _GameSettingsLocations;
        private IFallout4GroupGetter<IGameSettingGetter>? _GameSettings => _GameSettingsLocations != null ? Fallout4GroupBinaryOverlay<IGameSettingGetter>.Fallout4GroupFactory(_data, _GameSettingsLocations, _package) : default;
        public IFallout4GroupGetter<IGameSettingGetter> GameSettings => _GameSettings ?? new Fallout4Group<GameSetting>(this);
        #endregion
        #region Keywords
        private List<RangeInt64>? _KeywordsLocations;
        private IFallout4GroupGetter<IKeywordGetter>? _Keywords => _KeywordsLocations != null ? Fallout4GroupBinaryOverlay<IKeywordGetter>.Fallout4GroupFactory(_data, _KeywordsLocations, _package) : default;
        public IFallout4GroupGetter<IKeywordGetter> Keywords => _Keywords ?? new Fallout4Group<Keyword>(this);
        #endregion
        #region LocationReferenceTypes
        private List<RangeInt64>? _LocationReferenceTypesLocations;
        private IFallout4GroupGetter<ILocationReferenceTypeGetter>? _LocationReferenceTypes => _LocationReferenceTypesLocations != null ? Fallout4GroupBinaryOverlay<ILocationReferenceTypeGetter>.Fallout4GroupFactory(_data, _LocationReferenceTypesLocations, _package) : default;
        public IFallout4GroupGetter<ILocationReferenceTypeGetter> LocationReferenceTypes => _LocationReferenceTypes ?? new Fallout4Group<LocationReferenceType>(this);
        #endregion
        #region Actions
        private List<RangeInt64>? _ActionsLocations;
        private IFallout4GroupGetter<IActionRecordGetter>? _Actions => _ActionsLocations != null ? Fallout4GroupBinaryOverlay<IActionRecordGetter>.Fallout4GroupFactory(_data, _ActionsLocations, _package) : default;
        public IFallout4GroupGetter<IActionRecordGetter> Actions => _Actions ?? new Fallout4Group<ActionRecord>(this);
        #endregion
        #region Transforms
        private List<RangeInt64>? _TransformsLocations;
        private IFallout4GroupGetter<ITransformGetter>? _Transforms => _TransformsLocations != null ? Fallout4GroupBinaryOverlay<ITransformGetter>.Fallout4GroupFactory(_data, _TransformsLocations, _package) : default;
        public IFallout4GroupGetter<ITransformGetter> Transforms => _Transforms ?? new Fallout4Group<Transform>(this);
        #endregion
        #region Components
        private List<RangeInt64>? _ComponentsLocations;
        private IFallout4GroupGetter<IComponentGetter>? _Components => _ComponentsLocations != null ? Fallout4GroupBinaryOverlay<IComponentGetter>.Fallout4GroupFactory(_data, _ComponentsLocations, _package) : default;
        public IFallout4GroupGetter<IComponentGetter> Components => _Components ?? new Fallout4Group<Component>(this);
        #endregion
        #region TextureSets
        private List<RangeInt64>? _TextureSetsLocations;
        private IFallout4GroupGetter<ITextureSetGetter>? _TextureSets => _TextureSetsLocations != null ? Fallout4GroupBinaryOverlay<ITextureSetGetter>.Fallout4GroupFactory(_data, _TextureSetsLocations, _package) : default;
        public IFallout4GroupGetter<ITextureSetGetter> TextureSets => _TextureSets ?? new Fallout4Group<TextureSet>(this);
        #endregion
        #region Globals
        private List<RangeInt64>? _GlobalsLocations;
        private IFallout4GroupGetter<IGlobalGetter>? _Globals => _GlobalsLocations != null ? Fallout4GroupBinaryOverlay<IGlobalGetter>.Fallout4GroupFactory(_data, _GlobalsLocations, _package) : default;
        public IFallout4GroupGetter<IGlobalGetter> Globals => _Globals ?? new Fallout4Group<Global>(this);
        #endregion
        #region DamageTypes
        private List<RangeInt64>? _DamageTypesLocations;
        private IFallout4GroupGetter<IADamageTypeGetter>? _DamageTypes => _DamageTypesLocations != null ? Fallout4GroupBinaryOverlay<IADamageTypeGetter>.Fallout4GroupFactory(_data, _DamageTypesLocations, _package) : default;
        public IFallout4GroupGetter<IADamageTypeGetter> DamageTypes => _DamageTypes ?? new Fallout4Group<ADamageType>(this);
        #endregion
        #region Classes
        private List<RangeInt64>? _ClassesLocations;
        private IFallout4GroupGetter<IClassGetter>? _Classes => _ClassesLocations != null ? Fallout4GroupBinaryOverlay<IClassGetter>.Fallout4GroupFactory(_data, _ClassesLocations, _package) : default;
        public IFallout4GroupGetter<IClassGetter> Classes => _Classes ?? new Fallout4Group<Class>(this);
        #endregion
        #region Factions
        private List<RangeInt64>? _FactionsLocations;
        private IFallout4GroupGetter<IFactionGetter>? _Factions => _FactionsLocations != null ? Fallout4GroupBinaryOverlay<IFactionGetter>.Fallout4GroupFactory(_data, _FactionsLocations, _package) : default;
        public IFallout4GroupGetter<IFactionGetter> Factions => _Factions ?? new Fallout4Group<Faction>(this);
        #endregion
        #region HeadParts
        private List<RangeInt64>? _HeadPartsLocations;
        private IFallout4GroupGetter<IHeadPartGetter>? _HeadParts => _HeadPartsLocations != null ? Fallout4GroupBinaryOverlay<IHeadPartGetter>.Fallout4GroupFactory(_data, _HeadPartsLocations, _package) : default;
        public IFallout4GroupGetter<IHeadPartGetter> HeadParts => _HeadParts ?? new Fallout4Group<HeadPart>(this);
        #endregion
        #region SoundMarkers
        private List<RangeInt64>? _SoundMarkersLocations;
        private IFallout4GroupGetter<ISoundMarkerGetter>? _SoundMarkers => _SoundMarkersLocations != null ? Fallout4GroupBinaryOverlay<ISoundMarkerGetter>.Fallout4GroupFactory(_data, _SoundMarkersLocations, _package) : default;
        public IFallout4GroupGetter<ISoundMarkerGetter> SoundMarkers => _SoundMarkers ?? new Fallout4Group<SoundMarker>(this);
        #endregion
        #region AcousticSpaces
        private List<RangeInt64>? _AcousticSpacesLocations;
        private IFallout4GroupGetter<IAcousticSpaceGetter>? _AcousticSpaces => _AcousticSpacesLocations != null ? Fallout4GroupBinaryOverlay<IAcousticSpaceGetter>.Fallout4GroupFactory(_data, _AcousticSpacesLocations, _package) : default;
        public IFallout4GroupGetter<IAcousticSpaceGetter> AcousticSpaces => _AcousticSpaces ?? new Fallout4Group<AcousticSpace>(this);
        #endregion
        #region LandscapeTextures
        private List<RangeInt64>? _LandscapeTexturesLocations;
        private IFallout4GroupGetter<ILandscapeTextureGetter>? _LandscapeTextures => _LandscapeTexturesLocations != null ? Fallout4GroupBinaryOverlay<ILandscapeTextureGetter>.Fallout4GroupFactory(_data, _LandscapeTexturesLocations, _package) : default;
        public IFallout4GroupGetter<ILandscapeTextureGetter> LandscapeTextures => _LandscapeTextures ?? new Fallout4Group<LandscapeTexture>(this);
        #endregion
        #region Grasses
        private List<RangeInt64>? _GrassesLocations;
        private IFallout4GroupGetter<IGrassGetter>? _Grasses => _GrassesLocations != null ? Fallout4GroupBinaryOverlay<IGrassGetter>.Fallout4GroupFactory(_data, _GrassesLocations, _package) : default;
        public IFallout4GroupGetter<IGrassGetter> Grasses => _Grasses ?? new Fallout4Group<Grass>(this);
        #endregion
        #region MaterialTypes
        private List<RangeInt64>? _MaterialTypesLocations;
        private IFallout4GroupGetter<IMaterialTypeGetter>? _MaterialTypes => _MaterialTypesLocations != null ? Fallout4GroupBinaryOverlay<IMaterialTypeGetter>.Fallout4GroupFactory(_data, _MaterialTypesLocations, _package) : default;
        public IFallout4GroupGetter<IMaterialTypeGetter> MaterialTypes => _MaterialTypes ?? new Fallout4Group<MaterialType>(this);
        #endregion
        protected Fallout4ModBinaryOverlay(
            IMutagenReadStream stream,
            ModKey modKey,
            bool shouldDispose)
        {
            this.ModKey = modKey;
            this._data = stream;
            this._package = new BinaryOverlayFactoryPackage(stream.MetaData);
            this._shouldDispose = shouldDispose;
        }

        public static Fallout4ModBinaryOverlay Fallout4ModFactory(
            ModPath path,
            StringsReadParameters? stringsParam = null,
            IFileSystem? fileSystem = null)
        {
            var meta = new ParsingBundle(GameRelease.Fallout4, new MasterReferenceCollection(path.ModKey))
            {
                RecordInfoCache = new RecordTypeInfoCacheReader(() => new MutagenBinaryReadStream(path, GameRelease.Fallout4))
            };
            var stream = new MutagenBinaryReadStream(
                path: path.Path,
                metaData: meta,
                fileSystem: fileSystem);
            try
            {
                meta.Absorb(stringsParam);
                if (stream.Remaining < 12)
                {
                    throw new ArgumentException("File stream was too short to parse flags");
                }
                var flags = stream.GetInt32(offset: 8);
                if (EnumExt.HasFlag(flags, (int)ModHeaderCommonFlag.Localized))
                {
                    meta.StringsLookup = StringsFolderLookupOverlay.TypicalFactory(GameRelease.Fallout4, path.ModKey, Path.GetDirectoryName(path.Path)!, stringsParam);
                }
                return Fallout4ModFactory(
                    stream: stream,
                    path.ModKey,
                    shouldDispose: true);
            }
            catch (Exception)
            {
                stream.Dispose();
                throw;
            }
        }

        public static Fallout4ModBinaryOverlay Fallout4ModFactory(
            IMutagenReadStream stream,
            ModKey modKey,
            bool shouldDispose)
        {
            var ret = new Fallout4ModBinaryOverlay(
                stream: stream,
                modKey: modKey,
                shouldDispose: shouldDispose);
            PluginBinaryOverlay.FillModTypes(
                stream: stream,
                package: ret._package,
                fill: ret.FillRecordType);
            return ret;
        }


        public ParseResult FillRecordType(
            IBinaryReadStream stream,
            long finalPos,
            int offset,
            RecordType type,
            PreviousParse lastParsed,
            TypedParseParams? parseParams = null)
        {
            type = parseParams.ConvertToStandard(type);
            switch (type.TypeInt)
            {
                case RecordTypeInts.TES4:
                {
                    _ModHeaderLocation = new RangeInt64((stream.Position - offset), finalPos - offset);
                    _package.MetaData.MasterReferences!.SetTo(
                        this.ModHeader.MasterReferences.Select(
                            master => new MasterReference()
                            {
                                Master = master.Master,
                                FileSize = master.FileSize,
                            }));
                    return (int)Fallout4Mod_FieldIndex.ModHeader;
                }
                case RecordTypeInts.GMST:
                {
                    _GameSettingsLocations ??= new();
                    _GameSettingsLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout4Mod_FieldIndex.GameSettings;
                }
                case RecordTypeInts.KYWD:
                {
                    _KeywordsLocations ??= new();
                    _KeywordsLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout4Mod_FieldIndex.Keywords;
                }
                case RecordTypeInts.LCRT:
                {
                    _LocationReferenceTypesLocations ??= new();
                    _LocationReferenceTypesLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout4Mod_FieldIndex.LocationReferenceTypes;
                }
                case RecordTypeInts.AACT:
                {
                    _ActionsLocations ??= new();
                    _ActionsLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout4Mod_FieldIndex.Actions;
                }
                case RecordTypeInts.TRNS:
                {
                    _TransformsLocations ??= new();
                    _TransformsLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout4Mod_FieldIndex.Transforms;
                }
                case RecordTypeInts.CMPO:
                {
                    _ComponentsLocations ??= new();
                    _ComponentsLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout4Mod_FieldIndex.Components;
                }
                case RecordTypeInts.TXST:
                {
                    _TextureSetsLocations ??= new();
                    _TextureSetsLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout4Mod_FieldIndex.TextureSets;
                }
                case RecordTypeInts.GLOB:
                {
                    _GlobalsLocations ??= new();
                    _GlobalsLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout4Mod_FieldIndex.Globals;
                }
                case RecordTypeInts.DMGT:
                {
                    _DamageTypesLocations ??= new();
                    _DamageTypesLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout4Mod_FieldIndex.DamageTypes;
                }
                case RecordTypeInts.CLAS:
                {
                    _ClassesLocations ??= new();
                    _ClassesLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout4Mod_FieldIndex.Classes;
                }
                case RecordTypeInts.FACT:
                {
                    _FactionsLocations ??= new();
                    _FactionsLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout4Mod_FieldIndex.Factions;
                }
                case RecordTypeInts.HDPT:
                {
                    _HeadPartsLocations ??= new();
                    _HeadPartsLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout4Mod_FieldIndex.HeadParts;
                }
                case RecordTypeInts.SOUN:
                {
                    _SoundMarkersLocations ??= new();
                    _SoundMarkersLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout4Mod_FieldIndex.SoundMarkers;
                }
                case RecordTypeInts.ASPC:
                {
                    _AcousticSpacesLocations ??= new();
                    _AcousticSpacesLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout4Mod_FieldIndex.AcousticSpaces;
                }
                case RecordTypeInts.LTEX:
                {
                    _LandscapeTexturesLocations ??= new();
                    _LandscapeTexturesLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout4Mod_FieldIndex.LandscapeTextures;
                }
                case RecordTypeInts.GRAS:
                {
                    _GrassesLocations ??= new();
                    _GrassesLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout4Mod_FieldIndex.Grasses;
                }
                case RecordTypeInts.MATT:
                {
                    _MaterialTypesLocations ??= new();
                    _MaterialTypesLocations.Add(new RangeInt64((stream.Position - offset), finalPos - offset));
                    return (int)Fallout4Mod_FieldIndex.MaterialTypes;
                }
                default:
                    return default(int?);
            }
        }
        #region To String

        public void ToString(
            FileGeneration fg,
            string? name = null)
        {
            Fallout4ModMixIn.ToString(
                item: this,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is not IFallout4ModGetter rhs) return false;
            return ((Fallout4ModCommon)((IFallout4ModGetter)this).CommonInstance()!).Equals(this, rhs, crystal: null);
        }

        public bool Equals(IFallout4ModGetter? obj)
        {
            return ((Fallout4ModCommon)((IFallout4ModGetter)this).CommonInstance()!).Equals(this, obj, crystal: null);
        }

        public override int GetHashCode() => ((Fallout4ModCommon)((IFallout4ModGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        IMask<bool> IEqualsMask.GetEqualsMask(object rhs, EqualsMaskHelper.Include include = EqualsMaskHelper.Include.OnlyFailures) => Fallout4ModMixIn.GetEqualsMask(this, (IFallout4ModGetter)rhs, include);
    }

}
#endregion

#endregion

