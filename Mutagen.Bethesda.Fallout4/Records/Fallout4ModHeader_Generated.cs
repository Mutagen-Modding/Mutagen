/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Autogenerated by Loqui.  Do not manually change.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
*/
#region Usings
using Loqui;
using Loqui.Interfaces;
using Loqui.Internal;
using Mutagen.Bethesda.Binary;
using Mutagen.Bethesda.Fallout4;
using Mutagen.Bethesda.Fallout4.Internals;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Binary.Headers;
using Mutagen.Bethesda.Plugins.Binary.Overlay;
using Mutagen.Bethesda.Plugins.Binary.Streams;
using Mutagen.Bethesda.Plugins.Binary.Translations;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Exceptions;
using Mutagen.Bethesda.Plugins.Internals;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Plugins.Records.Internals;
using Mutagen.Bethesda.Plugins.Records.Mapping;
using Mutagen.Bethesda.Translations.Binary;
using Noggog;
using Noggog.StructuredStrings;
using Noggog.StructuredStrings.CSharp;
using RecordTypeInts = Mutagen.Bethesda.Fallout4.Internals.RecordTypeInts;
using RecordTypes = Mutagen.Bethesda.Fallout4.Internals.RecordTypes;
using System.Buffers.Binary;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Reactive.Disposables;
using System.Reactive.Linq;
#endregion

#nullable enable
namespace Mutagen.Bethesda.Fallout4
{
    #region Class
    public partial class Fallout4ModHeader :
        IEquatable<IFallout4ModHeaderGetter>,
        IFallout4ModHeader,
        ILoquiObjectSetter<Fallout4ModHeader>
    {
        #region Ctor
        public Fallout4ModHeader()
        {
            CustomCtor();
        }
        partial void CustomCtor();
        #endregion

        #region Flags
        public Fallout4ModHeader.HeaderFlag Flags { get; set; } = default;
        #endregion
        #region FormID
        public UInt32 FormID { get; set; } = default;
        #endregion
        #region Version
        public Int32 Version { get; set; } = default;
        #endregion
        #region FormVersion
        public UInt16 FormVersion { get; set; } = default;
        #endregion
        #region Version2
        public UInt16 Version2 { get; set; } = default;
        #endregion
        #region Stats
        public ModStats Stats { get; set; } = new ModStats();
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IModStatsGetter IFallout4ModHeaderGetter.Stats => Stats;
        #endregion
        #region TypeOffsets
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected MemorySlice<Byte>? _TypeOffsets;
        public MemorySlice<Byte>? TypeOffsets
        {
            get => this._TypeOffsets;
            set => this._TypeOffsets = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ReadOnlyMemorySlice<Byte>? IFallout4ModHeaderGetter.TypeOffsets => this.TypeOffsets;
        #endregion
        #region Deleted
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected MemorySlice<Byte>? _Deleted;
        public MemorySlice<Byte>? Deleted
        {
            get => this._Deleted;
            set => this._Deleted = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ReadOnlyMemorySlice<Byte>? IFallout4ModHeaderGetter.Deleted => this.Deleted;
        #endregion
        #region Author
        public String? Author { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        String? IFallout4ModHeaderGetter.Author => this.Author;
        #endregion
        #region Description
        public String? Description { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        String? IFallout4ModHeaderGetter.Description => this.Description;
        #endregion
        #region MasterReferences
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private ExtendedList<MasterReference> _MasterReferences = new ExtendedList<MasterReference>();
        public ExtendedList<MasterReference> MasterReferences
        {
            get => this._MasterReferences;
            init => this._MasterReferences = value;
        }
        #region Interface Members
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IReadOnlyList<IMasterReferenceGetter> IFallout4ModHeaderGetter.MasterReferences => _MasterReferences;
        #endregion

        #endregion
        #region OverriddenForms
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private ExtendedList<IFormLinkGetter<IFallout4MajorRecordGetter>>? _OverriddenForms;
        public ExtendedList<IFormLinkGetter<IFallout4MajorRecordGetter>>? OverriddenForms
        {
            get => this._OverriddenForms;
            set => this._OverriddenForms = value;
        }
        #region Interface Members
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IReadOnlyList<IFormLinkGetter<IFallout4MajorRecordGetter>>? IFallout4ModHeaderGetter.OverriddenForms => _OverriddenForms;
        #endregion

        #endregion
        #region Screenshot
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected MemorySlice<Byte>? _Screenshot;
        public MemorySlice<Byte>? Screenshot
        {
            get => this._Screenshot;
            set => this._Screenshot = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ReadOnlyMemorySlice<Byte>? IFallout4ModHeaderGetter.Screenshot => this.Screenshot;
        #endregion
        #region TransientTypes
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private ExtendedList<TransientType> _TransientTypes = new ExtendedList<TransientType>();
        public ExtendedList<TransientType> TransientTypes
        {
            get => this._TransientTypes;
            init => this._TransientTypes = value;
        }
        #region Interface Members
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IReadOnlyList<ITransientTypeGetter> IFallout4ModHeaderGetter.TransientTypes => _TransientTypes;
        #endregion

        #endregion
        #region INTV
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected MemorySlice<Byte>? _INTV;
        public MemorySlice<Byte>? INTV
        {
            get => this._INTV;
            set => this._INTV = value;
        }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ReadOnlyMemorySlice<Byte>? IFallout4ModHeaderGetter.INTV => this.INTV;
        #endregion
        #region INCC
        public Int32? INCC { get; set; }
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Int32? IFallout4ModHeaderGetter.INCC => this.INCC;
        #endregion

        #region To String

        public void Print(
            StructuredStringBuilder sb,
            string? name = null)
        {
            Fallout4ModHeaderMixIn.Print(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is not IFallout4ModHeaderGetter rhs) return false;
            return ((Fallout4ModHeaderCommon)((IFallout4ModHeaderGetter)this).CommonInstance()!).Equals(this, rhs, crystal: null);
        }

        public bool Equals(IFallout4ModHeaderGetter? obj)
        {
            return ((Fallout4ModHeaderCommon)((IFallout4ModHeaderGetter)this).CommonInstance()!).Equals(this, obj, crystal: null);
        }

        public override int GetHashCode() => ((Fallout4ModHeaderCommon)((IFallout4ModHeaderGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

        #region Mask
        public class Mask<TItem> :
            IEquatable<Mask<TItem>>,
            IMask<TItem>
        {
            #region Ctors
            public Mask(TItem initialValue)
            {
                this.Flags = initialValue;
                this.FormID = initialValue;
                this.Version = initialValue;
                this.FormVersion = initialValue;
                this.Version2 = initialValue;
                this.Stats = new MaskItem<TItem, ModStats.Mask<TItem>?>(initialValue, new ModStats.Mask<TItem>(initialValue));
                this.TypeOffsets = initialValue;
                this.Deleted = initialValue;
                this.Author = initialValue;
                this.Description = initialValue;
                this.MasterReferences = new MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, MasterReference.Mask<TItem>?>>?>(initialValue, Enumerable.Empty<MaskItemIndexed<TItem, MasterReference.Mask<TItem>?>>());
                this.OverriddenForms = new MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>(initialValue, Enumerable.Empty<(int Index, TItem Value)>());
                this.Screenshot = initialValue;
                this.TransientTypes = new MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, TransientType.Mask<TItem>?>>?>(initialValue, Enumerable.Empty<MaskItemIndexed<TItem, TransientType.Mask<TItem>?>>());
                this.INTV = initialValue;
                this.INCC = initialValue;
            }

            public Mask(
                TItem Flags,
                TItem FormID,
                TItem Version,
                TItem FormVersion,
                TItem Version2,
                TItem Stats,
                TItem TypeOffsets,
                TItem Deleted,
                TItem Author,
                TItem Description,
                TItem MasterReferences,
                TItem OverriddenForms,
                TItem Screenshot,
                TItem TransientTypes,
                TItem INTV,
                TItem INCC)
            {
                this.Flags = Flags;
                this.FormID = FormID;
                this.Version = Version;
                this.FormVersion = FormVersion;
                this.Version2 = Version2;
                this.Stats = new MaskItem<TItem, ModStats.Mask<TItem>?>(Stats, new ModStats.Mask<TItem>(Stats));
                this.TypeOffsets = TypeOffsets;
                this.Deleted = Deleted;
                this.Author = Author;
                this.Description = Description;
                this.MasterReferences = new MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, MasterReference.Mask<TItem>?>>?>(MasterReferences, Enumerable.Empty<MaskItemIndexed<TItem, MasterReference.Mask<TItem>?>>());
                this.OverriddenForms = new MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>(OverriddenForms, Enumerable.Empty<(int Index, TItem Value)>());
                this.Screenshot = Screenshot;
                this.TransientTypes = new MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, TransientType.Mask<TItem>?>>?>(TransientTypes, Enumerable.Empty<MaskItemIndexed<TItem, TransientType.Mask<TItem>?>>());
                this.INTV = INTV;
                this.INCC = INCC;
            }

            #pragma warning disable CS8618
            protected Mask()
            {
            }
            #pragma warning restore CS8618

            #endregion

            #region Members
            public TItem Flags;
            public TItem FormID;
            public TItem Version;
            public TItem FormVersion;
            public TItem Version2;
            public MaskItem<TItem, ModStats.Mask<TItem>?>? Stats { get; set; }
            public TItem TypeOffsets;
            public TItem Deleted;
            public TItem Author;
            public TItem Description;
            public MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, MasterReference.Mask<TItem>?>>?>? MasterReferences;
            public MaskItem<TItem, IEnumerable<(int Index, TItem Value)>?>? OverriddenForms;
            public TItem Screenshot;
            public MaskItem<TItem, IEnumerable<MaskItemIndexed<TItem, TransientType.Mask<TItem>?>>?>? TransientTypes;
            public TItem INTV;
            public TItem INCC;
            #endregion

            #region Equals
            public override bool Equals(object? obj)
            {
                if (!(obj is Mask<TItem> rhs)) return false;
                return Equals(rhs);
            }

            public bool Equals(Mask<TItem>? rhs)
            {
                if (rhs == null) return false;
                if (!object.Equals(this.Flags, rhs.Flags)) return false;
                if (!object.Equals(this.FormID, rhs.FormID)) return false;
                if (!object.Equals(this.Version, rhs.Version)) return false;
                if (!object.Equals(this.FormVersion, rhs.FormVersion)) return false;
                if (!object.Equals(this.Version2, rhs.Version2)) return false;
                if (!object.Equals(this.Stats, rhs.Stats)) return false;
                if (!object.Equals(this.TypeOffsets, rhs.TypeOffsets)) return false;
                if (!object.Equals(this.Deleted, rhs.Deleted)) return false;
                if (!object.Equals(this.Author, rhs.Author)) return false;
                if (!object.Equals(this.Description, rhs.Description)) return false;
                if (!object.Equals(this.MasterReferences, rhs.MasterReferences)) return false;
                if (!object.Equals(this.OverriddenForms, rhs.OverriddenForms)) return false;
                if (!object.Equals(this.Screenshot, rhs.Screenshot)) return false;
                if (!object.Equals(this.TransientTypes, rhs.TransientTypes)) return false;
                if (!object.Equals(this.INTV, rhs.INTV)) return false;
                if (!object.Equals(this.INCC, rhs.INCC)) return false;
                return true;
            }
            public override int GetHashCode()
            {
                var hash = new HashCode();
                hash.Add(this.Flags);
                hash.Add(this.FormID);
                hash.Add(this.Version);
                hash.Add(this.FormVersion);
                hash.Add(this.Version2);
                hash.Add(this.Stats);
                hash.Add(this.TypeOffsets);
                hash.Add(this.Deleted);
                hash.Add(this.Author);
                hash.Add(this.Description);
                hash.Add(this.MasterReferences);
                hash.Add(this.OverriddenForms);
                hash.Add(this.Screenshot);
                hash.Add(this.TransientTypes);
                hash.Add(this.INTV);
                hash.Add(this.INCC);
                return hash.ToHashCode();
            }

            #endregion

            #region All
            public bool All(Func<TItem, bool> eval)
            {
                if (!eval(this.Flags)) return false;
                if (!eval(this.FormID)) return false;
                if (!eval(this.Version)) return false;
                if (!eval(this.FormVersion)) return false;
                if (!eval(this.Version2)) return false;
                if (Stats != null)
                {
                    if (!eval(this.Stats.Overall)) return false;
                    if (this.Stats.Specific != null && !this.Stats.Specific.All(eval)) return false;
                }
                if (!eval(this.TypeOffsets)) return false;
                if (!eval(this.Deleted)) return false;
                if (!eval(this.Author)) return false;
                if (!eval(this.Description)) return false;
                if (this.MasterReferences != null)
                {
                    if (!eval(this.MasterReferences.Overall)) return false;
                    if (this.MasterReferences.Specific != null)
                    {
                        foreach (var item in this.MasterReferences.Specific)
                        {
                            if (!eval(item.Overall)) return false;
                            if (item.Specific != null && !item.Specific.All(eval)) return false;
                        }
                    }
                }
                if (this.OverriddenForms != null)
                {
                    if (!eval(this.OverriddenForms.Overall)) return false;
                    if (this.OverriddenForms.Specific != null)
                    {
                        foreach (var item in this.OverriddenForms.Specific)
                        {
                            if (!eval(item.Value)) return false;
                        }
                    }
                }
                if (!eval(this.Screenshot)) return false;
                if (this.TransientTypes != null)
                {
                    if (!eval(this.TransientTypes.Overall)) return false;
                    if (this.TransientTypes.Specific != null)
                    {
                        foreach (var item in this.TransientTypes.Specific)
                        {
                            if (!eval(item.Overall)) return false;
                            if (item.Specific != null && !item.Specific.All(eval)) return false;
                        }
                    }
                }
                if (!eval(this.INTV)) return false;
                if (!eval(this.INCC)) return false;
                return true;
            }
            #endregion

            #region Any
            public bool Any(Func<TItem, bool> eval)
            {
                if (eval(this.Flags)) return true;
                if (eval(this.FormID)) return true;
                if (eval(this.Version)) return true;
                if (eval(this.FormVersion)) return true;
                if (eval(this.Version2)) return true;
                if (Stats != null)
                {
                    if (eval(this.Stats.Overall)) return true;
                    if (this.Stats.Specific != null && this.Stats.Specific.Any(eval)) return true;
                }
                if (eval(this.TypeOffsets)) return true;
                if (eval(this.Deleted)) return true;
                if (eval(this.Author)) return true;
                if (eval(this.Description)) return true;
                if (this.MasterReferences != null)
                {
                    if (eval(this.MasterReferences.Overall)) return true;
                    if (this.MasterReferences.Specific != null)
                    {
                        foreach (var item in this.MasterReferences.Specific)
                        {
                            if (!eval(item.Overall)) return false;
                            if (item.Specific != null && !item.Specific.All(eval)) return false;
                        }
                    }
                }
                if (this.OverriddenForms != null)
                {
                    if (eval(this.OverriddenForms.Overall)) return true;
                    if (this.OverriddenForms.Specific != null)
                    {
                        foreach (var item in this.OverriddenForms.Specific)
                        {
                            if (!eval(item.Value)) return false;
                        }
                    }
                }
                if (eval(this.Screenshot)) return true;
                if (this.TransientTypes != null)
                {
                    if (eval(this.TransientTypes.Overall)) return true;
                    if (this.TransientTypes.Specific != null)
                    {
                        foreach (var item in this.TransientTypes.Specific)
                        {
                            if (!eval(item.Overall)) return false;
                            if (item.Specific != null && !item.Specific.All(eval)) return false;
                        }
                    }
                }
                if (eval(this.INTV)) return true;
                if (eval(this.INCC)) return true;
                return false;
            }
            #endregion

            #region Translate
            public Mask<R> Translate<R>(Func<TItem, R> eval)
            {
                var ret = new Fallout4ModHeader.Mask<R>();
                this.Translate_InternalFill(ret, eval);
                return ret;
            }

            protected void Translate_InternalFill<R>(Mask<R> obj, Func<TItem, R> eval)
            {
                obj.Flags = eval(this.Flags);
                obj.FormID = eval(this.FormID);
                obj.Version = eval(this.Version);
                obj.FormVersion = eval(this.FormVersion);
                obj.Version2 = eval(this.Version2);
                obj.Stats = this.Stats == null ? null : new MaskItem<R, ModStats.Mask<R>?>(eval(this.Stats.Overall), this.Stats.Specific?.Translate(eval));
                obj.TypeOffsets = eval(this.TypeOffsets);
                obj.Deleted = eval(this.Deleted);
                obj.Author = eval(this.Author);
                obj.Description = eval(this.Description);
                if (MasterReferences != null)
                {
                    obj.MasterReferences = new MaskItem<R, IEnumerable<MaskItemIndexed<R, MasterReference.Mask<R>?>>?>(eval(this.MasterReferences.Overall), Enumerable.Empty<MaskItemIndexed<R, MasterReference.Mask<R>?>>());
                    if (MasterReferences.Specific != null)
                    {
                        var l = new List<MaskItemIndexed<R, MasterReference.Mask<R>?>>();
                        obj.MasterReferences.Specific = l;
                        foreach (var item in MasterReferences.Specific)
                        {
                            MaskItemIndexed<R, MasterReference.Mask<R>?>? mask = item == null ? null : new MaskItemIndexed<R, MasterReference.Mask<R>?>(item.Index, eval(item.Overall), item.Specific?.Translate(eval));
                            if (mask == null) continue;
                            l.Add(mask);
                        }
                    }
                }
                if (OverriddenForms != null)
                {
                    obj.OverriddenForms = new MaskItem<R, IEnumerable<(int Index, R Value)>?>(eval(this.OverriddenForms.Overall), Enumerable.Empty<(int Index, R Value)>());
                    if (OverriddenForms.Specific != null)
                    {
                        var l = new List<(int Index, R Item)>();
                        obj.OverriddenForms.Specific = l;
                        foreach (var item in OverriddenForms.Specific)
                        {
                            R mask = eval(item.Value);
                            l.Add((item.Index, mask));
                        }
                    }
                }
                obj.Screenshot = eval(this.Screenshot);
                if (TransientTypes != null)
                {
                    obj.TransientTypes = new MaskItem<R, IEnumerable<MaskItemIndexed<R, TransientType.Mask<R>?>>?>(eval(this.TransientTypes.Overall), Enumerable.Empty<MaskItemIndexed<R, TransientType.Mask<R>?>>());
                    if (TransientTypes.Specific != null)
                    {
                        var l = new List<MaskItemIndexed<R, TransientType.Mask<R>?>>();
                        obj.TransientTypes.Specific = l;
                        foreach (var item in TransientTypes.Specific)
                        {
                            MaskItemIndexed<R, TransientType.Mask<R>?>? mask = item == null ? null : new MaskItemIndexed<R, TransientType.Mask<R>?>(item.Index, eval(item.Overall), item.Specific?.Translate(eval));
                            if (mask == null) continue;
                            l.Add(mask);
                        }
                    }
                }
                obj.INTV = eval(this.INTV);
                obj.INCC = eval(this.INCC);
            }
            #endregion

            #region To String
            public override string ToString() => this.Print();

            public string Print(Fallout4ModHeader.Mask<bool>? printMask = null)
            {
                var sb = new StructuredStringBuilder();
                Print(sb, printMask);
                return sb.ToString();
            }

            public void Print(StructuredStringBuilder sb, Fallout4ModHeader.Mask<bool>? printMask = null)
            {
                sb.AppendLine($"{nameof(Fallout4ModHeader.Mask<TItem>)} =>");
                using (sb.Brace())
                {
                    if (printMask?.Flags ?? true)
                    {
                        sb.AppendItem(Flags, "Flags");
                    }
                    if (printMask?.FormID ?? true)
                    {
                        sb.AppendItem(FormID, "FormID");
                    }
                    if (printMask?.Version ?? true)
                    {
                        sb.AppendItem(Version, "Version");
                    }
                    if (printMask?.FormVersion ?? true)
                    {
                        sb.AppendItem(FormVersion, "FormVersion");
                    }
                    if (printMask?.Version2 ?? true)
                    {
                        sb.AppendItem(Version2, "Version2");
                    }
                    if (printMask?.Stats?.Overall ?? true)
                    {
                        Stats?.Print(sb);
                    }
                    if (printMask?.TypeOffsets ?? true)
                    {
                        sb.AppendItem(TypeOffsets, "TypeOffsets");
                    }
                    if (printMask?.Deleted ?? true)
                    {
                        sb.AppendItem(Deleted, "Deleted");
                    }
                    if (printMask?.Author ?? true)
                    {
                        sb.AppendItem(Author, "Author");
                    }
                    if (printMask?.Description ?? true)
                    {
                        sb.AppendItem(Description, "Description");
                    }
                    if ((printMask?.MasterReferences?.Overall ?? true)
                        && MasterReferences is {} MasterReferencesItem)
                    {
                        sb.AppendLine("MasterReferences =>");
                        using (sb.Brace())
                        {
                            sb.AppendItem(MasterReferencesItem.Overall);
                            if (MasterReferencesItem.Specific != null)
                            {
                                foreach (var subItem in MasterReferencesItem.Specific)
                                {
                                    using (sb.Brace())
                                    {
                                        subItem?.Print(sb);
                                    }
                                }
                            }
                        }
                    }
                    if ((printMask?.OverriddenForms?.Overall ?? true)
                        && OverriddenForms is {} OverriddenFormsItem)
                    {
                        sb.AppendLine("OverriddenForms =>");
                        using (sb.Brace())
                        {
                            sb.AppendItem(OverriddenFormsItem.Overall);
                            if (OverriddenFormsItem.Specific != null)
                            {
                                foreach (var subItem in OverriddenFormsItem.Specific)
                                {
                                    using (sb.Brace())
                                    {
                                        {
                                            sb.AppendItem(subItem);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (printMask?.Screenshot ?? true)
                    {
                        sb.AppendItem(Screenshot, "Screenshot");
                    }
                    if ((printMask?.TransientTypes?.Overall ?? true)
                        && TransientTypes is {} TransientTypesItem)
                    {
                        sb.AppendLine("TransientTypes =>");
                        using (sb.Brace())
                        {
                            sb.AppendItem(TransientTypesItem.Overall);
                            if (TransientTypesItem.Specific != null)
                            {
                                foreach (var subItem in TransientTypesItem.Specific)
                                {
                                    using (sb.Brace())
                                    {
                                        subItem?.Print(sb);
                                    }
                                }
                            }
                        }
                    }
                    if (printMask?.INTV ?? true)
                    {
                        sb.AppendItem(INTV, "INTV");
                    }
                    if (printMask?.INCC ?? true)
                    {
                        sb.AppendItem(INCC, "INCC");
                    }
                }
            }
            #endregion

        }

        public class ErrorMask :
            IErrorMask,
            IErrorMask<ErrorMask>
        {
            #region Members
            public Exception? Overall { get; set; }
            private List<string>? _warnings;
            public List<string> Warnings
            {
                get
                {
                    if (_warnings == null)
                    {
                        _warnings = new List<string>();
                    }
                    return _warnings;
                }
            }
            public Exception? Flags;
            public Exception? FormID;
            public Exception? Version;
            public Exception? FormVersion;
            public Exception? Version2;
            public MaskItem<Exception?, ModStats.ErrorMask?>? Stats;
            public Exception? TypeOffsets;
            public Exception? Deleted;
            public Exception? Author;
            public Exception? Description;
            public MaskItem<Exception?, IEnumerable<MaskItem<Exception?, MasterReference.ErrorMask?>>?>? MasterReferences;
            public MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>? OverriddenForms;
            public Exception? Screenshot;
            public MaskItem<Exception?, IEnumerable<MaskItem<Exception?, TransientType.ErrorMask?>>?>? TransientTypes;
            public Exception? INTV;
            public Exception? INCC;
            #endregion

            #region IErrorMask
            public object? GetNthMask(int index)
            {
                Fallout4ModHeader_FieldIndex enu = (Fallout4ModHeader_FieldIndex)index;
                switch (enu)
                {
                    case Fallout4ModHeader_FieldIndex.Flags:
                        return Flags;
                    case Fallout4ModHeader_FieldIndex.FormID:
                        return FormID;
                    case Fallout4ModHeader_FieldIndex.Version:
                        return Version;
                    case Fallout4ModHeader_FieldIndex.FormVersion:
                        return FormVersion;
                    case Fallout4ModHeader_FieldIndex.Version2:
                        return Version2;
                    case Fallout4ModHeader_FieldIndex.Stats:
                        return Stats;
                    case Fallout4ModHeader_FieldIndex.TypeOffsets:
                        return TypeOffsets;
                    case Fallout4ModHeader_FieldIndex.Deleted:
                        return Deleted;
                    case Fallout4ModHeader_FieldIndex.Author:
                        return Author;
                    case Fallout4ModHeader_FieldIndex.Description:
                        return Description;
                    case Fallout4ModHeader_FieldIndex.MasterReferences:
                        return MasterReferences;
                    case Fallout4ModHeader_FieldIndex.OverriddenForms:
                        return OverriddenForms;
                    case Fallout4ModHeader_FieldIndex.Screenshot:
                        return Screenshot;
                    case Fallout4ModHeader_FieldIndex.TransientTypes:
                        return TransientTypes;
                    case Fallout4ModHeader_FieldIndex.INTV:
                        return INTV;
                    case Fallout4ModHeader_FieldIndex.INCC:
                        return INCC;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthException(int index, Exception ex)
            {
                Fallout4ModHeader_FieldIndex enu = (Fallout4ModHeader_FieldIndex)index;
                switch (enu)
                {
                    case Fallout4ModHeader_FieldIndex.Flags:
                        this.Flags = ex;
                        break;
                    case Fallout4ModHeader_FieldIndex.FormID:
                        this.FormID = ex;
                        break;
                    case Fallout4ModHeader_FieldIndex.Version:
                        this.Version = ex;
                        break;
                    case Fallout4ModHeader_FieldIndex.FormVersion:
                        this.FormVersion = ex;
                        break;
                    case Fallout4ModHeader_FieldIndex.Version2:
                        this.Version2 = ex;
                        break;
                    case Fallout4ModHeader_FieldIndex.Stats:
                        this.Stats = new MaskItem<Exception?, ModStats.ErrorMask?>(ex, null);
                        break;
                    case Fallout4ModHeader_FieldIndex.TypeOffsets:
                        this.TypeOffsets = ex;
                        break;
                    case Fallout4ModHeader_FieldIndex.Deleted:
                        this.Deleted = ex;
                        break;
                    case Fallout4ModHeader_FieldIndex.Author:
                        this.Author = ex;
                        break;
                    case Fallout4ModHeader_FieldIndex.Description:
                        this.Description = ex;
                        break;
                    case Fallout4ModHeader_FieldIndex.MasterReferences:
                        this.MasterReferences = new MaskItem<Exception?, IEnumerable<MaskItem<Exception?, MasterReference.ErrorMask?>>?>(ex, null);
                        break;
                    case Fallout4ModHeader_FieldIndex.OverriddenForms:
                        this.OverriddenForms = new MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>(ex, null);
                        break;
                    case Fallout4ModHeader_FieldIndex.Screenshot:
                        this.Screenshot = ex;
                        break;
                    case Fallout4ModHeader_FieldIndex.TransientTypes:
                        this.TransientTypes = new MaskItem<Exception?, IEnumerable<MaskItem<Exception?, TransientType.ErrorMask?>>?>(ex, null);
                        break;
                    case Fallout4ModHeader_FieldIndex.INTV:
                        this.INTV = ex;
                        break;
                    case Fallout4ModHeader_FieldIndex.INCC:
                        this.INCC = ex;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public void SetNthMask(int index, object obj)
            {
                Fallout4ModHeader_FieldIndex enu = (Fallout4ModHeader_FieldIndex)index;
                switch (enu)
                {
                    case Fallout4ModHeader_FieldIndex.Flags:
                        this.Flags = (Exception?)obj;
                        break;
                    case Fallout4ModHeader_FieldIndex.FormID:
                        this.FormID = (Exception?)obj;
                        break;
                    case Fallout4ModHeader_FieldIndex.Version:
                        this.Version = (Exception?)obj;
                        break;
                    case Fallout4ModHeader_FieldIndex.FormVersion:
                        this.FormVersion = (Exception?)obj;
                        break;
                    case Fallout4ModHeader_FieldIndex.Version2:
                        this.Version2 = (Exception?)obj;
                        break;
                    case Fallout4ModHeader_FieldIndex.Stats:
                        this.Stats = (MaskItem<Exception?, ModStats.ErrorMask?>?)obj;
                        break;
                    case Fallout4ModHeader_FieldIndex.TypeOffsets:
                        this.TypeOffsets = (Exception?)obj;
                        break;
                    case Fallout4ModHeader_FieldIndex.Deleted:
                        this.Deleted = (Exception?)obj;
                        break;
                    case Fallout4ModHeader_FieldIndex.Author:
                        this.Author = (Exception?)obj;
                        break;
                    case Fallout4ModHeader_FieldIndex.Description:
                        this.Description = (Exception?)obj;
                        break;
                    case Fallout4ModHeader_FieldIndex.MasterReferences:
                        this.MasterReferences = (MaskItem<Exception?, IEnumerable<MaskItem<Exception?, MasterReference.ErrorMask?>>?>)obj;
                        break;
                    case Fallout4ModHeader_FieldIndex.OverriddenForms:
                        this.OverriddenForms = (MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>)obj;
                        break;
                    case Fallout4ModHeader_FieldIndex.Screenshot:
                        this.Screenshot = (Exception?)obj;
                        break;
                    case Fallout4ModHeader_FieldIndex.TransientTypes:
                        this.TransientTypes = (MaskItem<Exception?, IEnumerable<MaskItem<Exception?, TransientType.ErrorMask?>>?>)obj;
                        break;
                    case Fallout4ModHeader_FieldIndex.INTV:
                        this.INTV = (Exception?)obj;
                        break;
                    case Fallout4ModHeader_FieldIndex.INCC:
                        this.INCC = (Exception?)obj;
                        break;
                    default:
                        throw new ArgumentException($"Index is out of range: {index}");
                }
            }

            public bool IsInError()
            {
                if (Overall != null) return true;
                if (Flags != null) return true;
                if (FormID != null) return true;
                if (Version != null) return true;
                if (FormVersion != null) return true;
                if (Version2 != null) return true;
                if (Stats != null) return true;
                if (TypeOffsets != null) return true;
                if (Deleted != null) return true;
                if (Author != null) return true;
                if (Description != null) return true;
                if (MasterReferences != null) return true;
                if (OverriddenForms != null) return true;
                if (Screenshot != null) return true;
                if (TransientTypes != null) return true;
                if (INTV != null) return true;
                if (INCC != null) return true;
                return false;
            }
            #endregion

            #region To String
            public override string ToString() => this.Print();

            public void Print(StructuredStringBuilder sb, string? name = null)
            {
                sb.AppendLine($"{(name ?? "ErrorMask")} =>");
                using (sb.Brace())
                {
                    if (this.Overall != null)
                    {
                        sb.AppendLine("Overall =>");
                        using (sb.Brace())
                        {
                            sb.AppendLine($"{this.Overall}");
                        }
                    }
                    PrintFillInternal(sb);
                }
            }
            protected void PrintFillInternal(StructuredStringBuilder sb)
            {
                {
                    sb.AppendItem(Flags, "Flags");
                }
                {
                    sb.AppendItem(FormID, "FormID");
                }
                {
                    sb.AppendItem(Version, "Version");
                }
                {
                    sb.AppendItem(FormVersion, "FormVersion");
                }
                {
                    sb.AppendItem(Version2, "Version2");
                }
                Stats?.Print(sb);
                {
                    sb.AppendItem(TypeOffsets, "TypeOffsets");
                }
                {
                    sb.AppendItem(Deleted, "Deleted");
                }
                {
                    sb.AppendItem(Author, "Author");
                }
                {
                    sb.AppendItem(Description, "Description");
                }
                if (MasterReferences is {} MasterReferencesItem)
                {
                    sb.AppendLine("MasterReferences =>");
                    using (sb.Brace())
                    {
                        sb.AppendItem(MasterReferencesItem.Overall);
                        if (MasterReferencesItem.Specific != null)
                        {
                            foreach (var subItem in MasterReferencesItem.Specific)
                            {
                                using (sb.Brace())
                                {
                                    subItem?.Print(sb);
                                }
                            }
                        }
                    }
                }
                if (OverriddenForms is {} OverriddenFormsItem)
                {
                    sb.AppendLine("OverriddenForms =>");
                    using (sb.Brace())
                    {
                        sb.AppendItem(OverriddenFormsItem.Overall);
                        if (OverriddenFormsItem.Specific != null)
                        {
                            foreach (var subItem in OverriddenFormsItem.Specific)
                            {
                                using (sb.Brace())
                                {
                                    {
                                        sb.AppendItem(subItem);
                                    }
                                }
                            }
                        }
                    }
                }
                {
                    sb.AppendItem(Screenshot, "Screenshot");
                }
                if (TransientTypes is {} TransientTypesItem)
                {
                    sb.AppendLine("TransientTypes =>");
                    using (sb.Brace())
                    {
                        sb.AppendItem(TransientTypesItem.Overall);
                        if (TransientTypesItem.Specific != null)
                        {
                            foreach (var subItem in TransientTypesItem.Specific)
                            {
                                using (sb.Brace())
                                {
                                    subItem?.Print(sb);
                                }
                            }
                        }
                    }
                }
                {
                    sb.AppendItem(INTV, "INTV");
                }
                {
                    sb.AppendItem(INCC, "INCC");
                }
            }
            #endregion

            #region Combine
            public ErrorMask Combine(ErrorMask? rhs)
            {
                if (rhs == null) return this;
                var ret = new ErrorMask();
                ret.Flags = this.Flags.Combine(rhs.Flags);
                ret.FormID = this.FormID.Combine(rhs.FormID);
                ret.Version = this.Version.Combine(rhs.Version);
                ret.FormVersion = this.FormVersion.Combine(rhs.FormVersion);
                ret.Version2 = this.Version2.Combine(rhs.Version2);
                ret.Stats = this.Stats.Combine(rhs.Stats, (l, r) => l.Combine(r));
                ret.TypeOffsets = this.TypeOffsets.Combine(rhs.TypeOffsets);
                ret.Deleted = this.Deleted.Combine(rhs.Deleted);
                ret.Author = this.Author.Combine(rhs.Author);
                ret.Description = this.Description.Combine(rhs.Description);
                ret.MasterReferences = new MaskItem<Exception?, IEnumerable<MaskItem<Exception?, MasterReference.ErrorMask?>>?>(ExceptionExt.Combine(this.MasterReferences?.Overall, rhs.MasterReferences?.Overall), ExceptionExt.Combine(this.MasterReferences?.Specific, rhs.MasterReferences?.Specific));
                ret.OverriddenForms = new MaskItem<Exception?, IEnumerable<(int Index, Exception Value)>?>(ExceptionExt.Combine(this.OverriddenForms?.Overall, rhs.OverriddenForms?.Overall), ExceptionExt.Combine(this.OverriddenForms?.Specific, rhs.OverriddenForms?.Specific));
                ret.Screenshot = this.Screenshot.Combine(rhs.Screenshot);
                ret.TransientTypes = new MaskItem<Exception?, IEnumerable<MaskItem<Exception?, TransientType.ErrorMask?>>?>(ExceptionExt.Combine(this.TransientTypes?.Overall, rhs.TransientTypes?.Overall), ExceptionExt.Combine(this.TransientTypes?.Specific, rhs.TransientTypes?.Specific));
                ret.INTV = this.INTV.Combine(rhs.INTV);
                ret.INCC = this.INCC.Combine(rhs.INCC);
                return ret;
            }
            public static ErrorMask? Combine(ErrorMask? lhs, ErrorMask? rhs)
            {
                if (lhs != null && rhs != null) return lhs.Combine(rhs);
                return lhs ?? rhs;
            }
            #endregion

            #region Factory
            public static ErrorMask Factory(ErrorMaskBuilder errorMask)
            {
                return new ErrorMask();
            }
            #endregion

        }
        public class TranslationMask : ITranslationMask
        {
            #region Members
            private TranslationCrystal? _crystal;
            public readonly bool DefaultOn;
            public bool OnOverall;
            public bool Flags;
            public bool FormID;
            public bool Version;
            public bool FormVersion;
            public bool Version2;
            public ModStats.TranslationMask? Stats;
            public bool TypeOffsets;
            public bool Deleted;
            public bool Author;
            public bool Description;
            public MasterReference.TranslationMask? MasterReferences;
            public bool OverriddenForms;
            public bool Screenshot;
            public TransientType.TranslationMask? TransientTypes;
            public bool INTV;
            public bool INCC;
            #endregion

            #region Ctors
            public TranslationMask(
                bool defaultOn,
                bool onOverall = true)
            {
                this.DefaultOn = defaultOn;
                this.OnOverall = onOverall;
                this.Flags = defaultOn;
                this.FormID = defaultOn;
                this.Version = defaultOn;
                this.FormVersion = defaultOn;
                this.Version2 = defaultOn;
                this.TypeOffsets = defaultOn;
                this.Deleted = defaultOn;
                this.Author = defaultOn;
                this.Description = defaultOn;
                this.OverriddenForms = defaultOn;
                this.Screenshot = defaultOn;
                this.INTV = defaultOn;
                this.INCC = defaultOn;
            }

            #endregion

            public TranslationCrystal GetCrystal()
            {
                if (_crystal != null) return _crystal;
                var ret = new List<(bool On, TranslationCrystal? SubCrystal)>();
                GetCrystal(ret);
                _crystal = new TranslationCrystal(ret.ToArray());
                return _crystal;
            }

            protected void GetCrystal(List<(bool On, TranslationCrystal? SubCrystal)> ret)
            {
                ret.Add((Flags, null));
                ret.Add((FormID, null));
                ret.Add((Version, null));
                ret.Add((FormVersion, null));
                ret.Add((Version2, null));
                ret.Add((Stats != null ? Stats.OnOverall : DefaultOn, Stats?.GetCrystal()));
                ret.Add((TypeOffsets, null));
                ret.Add((Deleted, null));
                ret.Add((Author, null));
                ret.Add((Description, null));
                ret.Add((MasterReferences == null ? DefaultOn : !MasterReferences.GetCrystal().CopyNothing, MasterReferences?.GetCrystal()));
                ret.Add((OverriddenForms, null));
                ret.Add((Screenshot, null));
                ret.Add((TransientTypes == null ? DefaultOn : !TransientTypes.GetCrystal().CopyNothing, TransientTypes?.GetCrystal()));
                ret.Add((INTV, null));
                ret.Add((INCC, null));
            }

            public static implicit operator TranslationMask(bool defaultOn)
            {
                return new TranslationMask(defaultOn: defaultOn, onOverall: defaultOn);
            }

        }
        #endregion

        #region Mutagen
        public static readonly RecordType GrupRecordType = Fallout4ModHeader_Registration.TriggeringRecordType;
        public IEnumerable<IFormLinkGetter> EnumerateFormLinks() => Fallout4ModHeaderCommon.Instance.EnumerateFormLinks(this);
        public void RemapLinks(IReadOnlyDictionary<FormKey, FormKey> mapping) => Fallout4ModHeaderSetterCommon.Instance.RemapLinks(this, mapping);
        #endregion

        #region Binary Translation
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => Fallout4ModHeaderBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((Fallout4ModHeaderBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }
        #region Binary Create
        public static Fallout4ModHeader CreateFromBinary(
            MutagenFrame frame,
            TypedParseParams translationParams = default)
        {
            var ret = new Fallout4ModHeader();
            ((Fallout4ModHeaderSetterCommon)((IFallout4ModHeaderGetter)ret).CommonSetterInstance()!).CopyInFromBinary(
                item: ret,
                frame: frame,
                translationParams: translationParams);
            return ret;
        }

        #endregion

        public static bool TryCreateFromBinary(
            MutagenFrame frame,
            out Fallout4ModHeader item,
            TypedParseParams translationParams = default)
        {
            var startPos = frame.Position;
            item = CreateFromBinary(
                frame: frame,
                translationParams: translationParams);
            return startPos != frame.Position;
        }
        #endregion

        void IPrintable.Print(StructuredStringBuilder sb, string? name) => this.Print(sb, name);

        void IClearable.Clear()
        {
            ((Fallout4ModHeaderSetterCommon)((IFallout4ModHeaderGetter)this).CommonSetterInstance()!).Clear(this);
        }

        internal static Fallout4ModHeader GetNew()
        {
            return new Fallout4ModHeader();
        }

    }
    #endregion

    #region Interface
    public partial interface IFallout4ModHeader :
        IFallout4ModHeaderGetter,
        IFormLinkContainer,
        ILoquiObjectSetter<IFallout4ModHeader>
    {
        new Fallout4ModHeader.HeaderFlag Flags { get; set; }
        new UInt32 FormID { get; set; }
        new Int32 Version { get; set; }
        new UInt16 FormVersion { get; set; }
        new UInt16 Version2 { get; set; }
        new ModStats Stats { get; set; }
        new MemorySlice<Byte>? TypeOffsets { get; set; }
        new MemorySlice<Byte>? Deleted { get; set; }
        new String? Author { get; set; }
        new String? Description { get; set; }
        new ExtendedList<MasterReference> MasterReferences { get; }
        new ExtendedList<IFormLinkGetter<IFallout4MajorRecordGetter>>? OverriddenForms { get; set; }
        new MemorySlice<Byte>? Screenshot { get; set; }
        new ExtendedList<TransientType> TransientTypes { get; }
        new MemorySlice<Byte>? INTV { get; set; }
        new Int32? INCC { get; set; }
    }

    public partial interface IFallout4ModHeaderGetter :
        ILoquiObject,
        IBinaryItem,
        IFormLinkContainerGetter,
        ILoquiObject<IFallout4ModHeaderGetter>
    {
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object? CommonSetterInstance();
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        object CommonSetterTranslationInstance();
        static ILoquiRegistration StaticRegistration => Fallout4ModHeader_Registration.Instance;
        Fallout4ModHeader.HeaderFlag Flags { get; }
        UInt32 FormID { get; }
        Int32 Version { get; }
        UInt16 FormVersion { get; }
        UInt16 Version2 { get; }
        IModStatsGetter Stats { get; }
        ReadOnlyMemorySlice<Byte>? TypeOffsets { get; }
        ReadOnlyMemorySlice<Byte>? Deleted { get; }
        String? Author { get; }
        String? Description { get; }
        IReadOnlyList<IMasterReferenceGetter> MasterReferences { get; }
        IReadOnlyList<IFormLinkGetter<IFallout4MajorRecordGetter>>? OverriddenForms { get; }
        ReadOnlyMemorySlice<Byte>? Screenshot { get; }
        IReadOnlyList<ITransientTypeGetter> TransientTypes { get; }
        ReadOnlyMemorySlice<Byte>? INTV { get; }
        Int32? INCC { get; }

    }

    #endregion

    #region Common MixIn
    public static partial class Fallout4ModHeaderMixIn
    {
        public static void Clear(this IFallout4ModHeader item)
        {
            ((Fallout4ModHeaderSetterCommon)((IFallout4ModHeaderGetter)item).CommonSetterInstance()!).Clear(item: item);
        }

        public static Fallout4ModHeader.Mask<bool> GetEqualsMask(
            this IFallout4ModHeaderGetter item,
            IFallout4ModHeaderGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            return ((Fallout4ModHeaderCommon)((IFallout4ModHeaderGetter)item).CommonInstance()!).GetEqualsMask(
                item: item,
                rhs: rhs,
                include: include);
        }

        public static string Print(
            this IFallout4ModHeaderGetter item,
            string? name = null,
            Fallout4ModHeader.Mask<bool>? printMask = null)
        {
            return ((Fallout4ModHeaderCommon)((IFallout4ModHeaderGetter)item).CommonInstance()!).Print(
                item: item,
                name: name,
                printMask: printMask);
        }

        public static void Print(
            this IFallout4ModHeaderGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            Fallout4ModHeader.Mask<bool>? printMask = null)
        {
            ((Fallout4ModHeaderCommon)((IFallout4ModHeaderGetter)item).CommonInstance()!).Print(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
        }

        public static bool Equals(
            this IFallout4ModHeaderGetter item,
            IFallout4ModHeaderGetter rhs,
            Fallout4ModHeader.TranslationMask? equalsMask = null)
        {
            return ((Fallout4ModHeaderCommon)((IFallout4ModHeaderGetter)item).CommonInstance()!).Equals(
                lhs: item,
                rhs: rhs,
                crystal: equalsMask?.GetCrystal());
        }

        public static void DeepCopyIn(
            this IFallout4ModHeader lhs,
            IFallout4ModHeaderGetter rhs)
        {
            ((Fallout4ModHeaderSetterTranslationCommon)((IFallout4ModHeaderGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: default,
                deepCopy: false);
        }

        public static void DeepCopyIn(
            this IFallout4ModHeader lhs,
            IFallout4ModHeaderGetter rhs,
            Fallout4ModHeader.TranslationMask? copyMask = null)
        {
            ((Fallout4ModHeaderSetterTranslationCommon)((IFallout4ModHeaderGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: default,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
        }

        public static void DeepCopyIn(
            this IFallout4ModHeader lhs,
            IFallout4ModHeaderGetter rhs,
            out Fallout4ModHeader.ErrorMask errorMask,
            Fallout4ModHeader.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            ((Fallout4ModHeaderSetterTranslationCommon)((IFallout4ModHeaderGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: false);
            errorMask = Fallout4ModHeader.ErrorMask.Factory(errorMaskBuilder);
        }

        public static void DeepCopyIn(
            this IFallout4ModHeader lhs,
            IFallout4ModHeaderGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask)
        {
            ((Fallout4ModHeaderSetterTranslationCommon)((IFallout4ModHeaderGetter)lhs).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: lhs,
                rhs: rhs,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: false);
        }

        public static Fallout4ModHeader DeepCopy(
            this IFallout4ModHeaderGetter item,
            Fallout4ModHeader.TranslationMask? copyMask = null)
        {
            return ((Fallout4ModHeaderSetterTranslationCommon)((IFallout4ModHeaderGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask);
        }

        public static Fallout4ModHeader DeepCopy(
            this IFallout4ModHeaderGetter item,
            out Fallout4ModHeader.ErrorMask errorMask,
            Fallout4ModHeader.TranslationMask? copyMask = null)
        {
            return ((Fallout4ModHeaderSetterTranslationCommon)((IFallout4ModHeaderGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: out errorMask);
        }

        public static Fallout4ModHeader DeepCopy(
            this IFallout4ModHeaderGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            return ((Fallout4ModHeaderSetterTranslationCommon)((IFallout4ModHeaderGetter)item).CommonSetterTranslationInstance()!).DeepCopy(
                item: item,
                copyMask: copyMask,
                errorMask: errorMask);
        }

        #region Binary Translation
        public static void CopyInFromBinary(
            this IFallout4ModHeader item,
            MutagenFrame frame,
            TypedParseParams translationParams = default)
        {
            ((Fallout4ModHeaderSetterCommon)((IFallout4ModHeaderGetter)item).CommonSetterInstance()!).CopyInFromBinary(
                item: item,
                frame: frame,
                translationParams: translationParams);
        }

        #endregion

    }
    #endregion

}

namespace Mutagen.Bethesda.Fallout4
{
    #region Field Index
    internal enum Fallout4ModHeader_FieldIndex
    {
        Flags = 0,
        FormID = 1,
        Version = 2,
        FormVersion = 3,
        Version2 = 4,
        Stats = 5,
        TypeOffsets = 6,
        Deleted = 7,
        Author = 8,
        Description = 9,
        MasterReferences = 10,
        OverriddenForms = 11,
        Screenshot = 12,
        TransientTypes = 13,
        INTV = 14,
        INCC = 15,
    }
    #endregion

    #region Registration
    internal partial class Fallout4ModHeader_Registration : ILoquiRegistration
    {
        public static readonly Fallout4ModHeader_Registration Instance = new Fallout4ModHeader_Registration();

        public static ProtocolKey ProtocolKey => ProtocolDefinition_Fallout4.ProtocolKey;

        public static readonly ObjectKey ObjectKey = new ObjectKey(
            protocolKey: ProtocolDefinition_Fallout4.ProtocolKey,
            msgID: 20,
            version: 0);

        public const string GUID = "84816323-6afc-412f-a0ef-8dff92fbb30b";

        public const ushort AdditionalFieldCount = 16;

        public const ushort FieldCount = 16;

        public static readonly Type MaskType = typeof(Fallout4ModHeader.Mask<>);

        public static readonly Type ErrorMaskType = typeof(Fallout4ModHeader.ErrorMask);

        public static readonly Type ClassType = typeof(Fallout4ModHeader);

        public static readonly Type GetterType = typeof(IFallout4ModHeaderGetter);

        public static readonly Type? InternalGetterType = null;

        public static readonly Type SetterType = typeof(IFallout4ModHeader);

        public static readonly Type? InternalSetterType = null;

        public const string FullName = "Mutagen.Bethesda.Fallout4.Fallout4ModHeader";

        public const string Name = "Fallout4ModHeader";

        public const string Namespace = "Mutagen.Bethesda.Fallout4";

        public const byte GenericCount = 0;

        public static readonly Type? GenericRegistrationType = null;

        public static readonly RecordType TriggeringRecordType = RecordTypes.TES4;
        public static RecordTriggerSpecs TriggerSpecs => _recordSpecs.Value;
        private static readonly Lazy<RecordTriggerSpecs> _recordSpecs = new Lazy<RecordTriggerSpecs>(() =>
        {
            var triggers = RecordCollection.Factory(RecordTypes.TES4);
            var all = RecordCollection.Factory(
                RecordTypes.TES4,
                RecordTypes.HEDR,
                RecordTypes.OFST,
                RecordTypes.DELE,
                RecordTypes.CNAM,
                RecordTypes.SNAM,
                RecordTypes.MAST,
                RecordTypes.DATA,
                RecordTypes.ONAM,
                RecordTypes.XXXX,
                RecordTypes.SCRN,
                RecordTypes.TNAM,
                RecordTypes.INTV,
                RecordTypes.INCC);
            return new RecordTriggerSpecs(allRecordTypes: all, triggeringRecordTypes: triggers);
        });
        public static readonly Type BinaryWriteTranslation = typeof(Fallout4ModHeaderBinaryWriteTranslation);
        #region Interface
        ProtocolKey ILoquiRegistration.ProtocolKey => ProtocolKey;
        ObjectKey ILoquiRegistration.ObjectKey => ObjectKey;
        string ILoquiRegistration.GUID => GUID;
        ushort ILoquiRegistration.FieldCount => FieldCount;
        ushort ILoquiRegistration.AdditionalFieldCount => AdditionalFieldCount;
        Type ILoquiRegistration.MaskType => MaskType;
        Type ILoquiRegistration.ErrorMaskType => ErrorMaskType;
        Type ILoquiRegistration.ClassType => ClassType;
        Type ILoquiRegistration.SetterType => SetterType;
        Type? ILoquiRegistration.InternalSetterType => InternalSetterType;
        Type ILoquiRegistration.GetterType => GetterType;
        Type? ILoquiRegistration.InternalGetterType => InternalGetterType;
        string ILoquiRegistration.FullName => FullName;
        string ILoquiRegistration.Name => Name;
        string ILoquiRegistration.Namespace => Namespace;
        byte ILoquiRegistration.GenericCount => GenericCount;
        Type? ILoquiRegistration.GenericRegistrationType => GenericRegistrationType;
        ushort? ILoquiRegistration.GetNameIndex(StringCaseAgnostic name) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsEnumerable(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsLoqui(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.GetNthIsSingleton(ushort index) => throw new NotImplementedException();
        string ILoquiRegistration.GetNthName(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsNthDerivative(ushort index) => throw new NotImplementedException();
        bool ILoquiRegistration.IsProtected(ushort index) => throw new NotImplementedException();
        Type ILoquiRegistration.GetNthType(ushort index) => throw new NotImplementedException();
        #endregion

    }
    #endregion

    #region Common
    internal partial class Fallout4ModHeaderSetterCommon
    {
        public static readonly Fallout4ModHeaderSetterCommon Instance = new Fallout4ModHeaderSetterCommon();

        partial void ClearPartial();
        
        public void Clear(IFallout4ModHeader item)
        {
            ClearPartial();
            item.Flags = default;
            item.FormID = default;
            item.Version = default;
            item.FormVersion = default;
            item.Version2 = default;
            item.Stats.Clear();
            item.TypeOffsets = default;
            item.Deleted = default;
            item.Author = default;
            item.Description = default;
            item.MasterReferences.Clear();
            item.OverriddenForms = null;
            item.Screenshot = default;
            item.TransientTypes.Clear();
            item.INTV = default;
            item.INCC = default;
        }
        
        #region Mutagen
        public void RemapLinks(IFallout4ModHeader obj, IReadOnlyDictionary<FormKey, FormKey> mapping)
        {
            obj.OverriddenForms?.RemapLinks(mapping);
            obj.TransientTypes.RemapLinks(mapping);
        }
        
        #endregion
        
        #region Binary Translation
        public virtual void CopyInFromBinary(
            IFallout4ModHeader item,
            MutagenFrame frame,
            TypedParseParams translationParams)
        {
            frame = frame.SpawnWithFinalPosition(HeaderTranslation.ParseRecord(
                frame.Reader,
                translationParams.ConvertToCustom(RecordTypes.TES4)));
            PluginUtilityTranslation.RecordParse(
                record: item,
                frame: frame,
                translationParams: translationParams,
                fillStructs: Fallout4ModHeaderBinaryCreateTranslation.FillBinaryStructs,
                fillTyped: Fallout4ModHeaderBinaryCreateTranslation.FillBinaryRecordTypes);
        }
        
        #endregion
        
    }
    internal partial class Fallout4ModHeaderCommon
    {
        public static readonly Fallout4ModHeaderCommon Instance = new Fallout4ModHeaderCommon();

        public Fallout4ModHeader.Mask<bool> GetEqualsMask(
            IFallout4ModHeaderGetter item,
            IFallout4ModHeaderGetter rhs,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            var ret = new Fallout4ModHeader.Mask<bool>(false);
            ((Fallout4ModHeaderCommon)((IFallout4ModHeaderGetter)item).CommonInstance()!).FillEqualsMask(
                item: item,
                rhs: rhs,
                ret: ret,
                include: include);
            return ret;
        }
        
        public void FillEqualsMask(
            IFallout4ModHeaderGetter item,
            IFallout4ModHeaderGetter rhs,
            Fallout4ModHeader.Mask<bool> ret,
            EqualsMaskHelper.Include include = EqualsMaskHelper.Include.All)
        {
            ret.Flags = item.Flags == rhs.Flags;
            ret.FormID = item.FormID == rhs.FormID;
            ret.Version = item.Version == rhs.Version;
            ret.FormVersion = item.FormVersion == rhs.FormVersion;
            ret.Version2 = item.Version2 == rhs.Version2;
            ret.Stats = MaskItemExt.Factory(item.Stats.GetEqualsMask(rhs.Stats, include), include);
            ret.TypeOffsets = MemorySliceExt.Equal(item.TypeOffsets, rhs.TypeOffsets);
            ret.Deleted = MemorySliceExt.Equal(item.Deleted, rhs.Deleted);
            ret.Author = string.Equals(item.Author, rhs.Author);
            ret.Description = string.Equals(item.Description, rhs.Description);
            ret.MasterReferences = item.MasterReferences.CollectionEqualsHelper(
                rhs.MasterReferences,
                (loqLhs, loqRhs) => loqLhs.GetEqualsMask(loqRhs, include),
                include);
            ret.OverriddenForms = item.OverriddenForms.CollectionEqualsHelper(
                rhs.OverriddenForms,
                (l, r) => object.Equals(l, r),
                include);
            ret.Screenshot = MemorySliceExt.Equal(item.Screenshot, rhs.Screenshot);
            ret.TransientTypes = item.TransientTypes.CollectionEqualsHelper(
                rhs.TransientTypes,
                (loqLhs, loqRhs) => loqLhs.GetEqualsMask(loqRhs, include),
                include);
            ret.INTV = MemorySliceExt.Equal(item.INTV, rhs.INTV);
            ret.INCC = item.INCC == rhs.INCC;
        }
        
        public string Print(
            IFallout4ModHeaderGetter item,
            string? name = null,
            Fallout4ModHeader.Mask<bool>? printMask = null)
        {
            var sb = new StructuredStringBuilder();
            Print(
                item: item,
                sb: sb,
                name: name,
                printMask: printMask);
            return sb.ToString();
        }
        
        public void Print(
            IFallout4ModHeaderGetter item,
            StructuredStringBuilder sb,
            string? name = null,
            Fallout4ModHeader.Mask<bool>? printMask = null)
        {
            if (name == null)
            {
                sb.AppendLine($"Fallout4ModHeader =>");
            }
            else
            {
                sb.AppendLine($"{name} (Fallout4ModHeader) =>");
            }
            using (sb.Brace())
            {
                ToStringFields(
                    item: item,
                    sb: sb,
                    printMask: printMask);
            }
        }
        
        protected static void ToStringFields(
            IFallout4ModHeaderGetter item,
            StructuredStringBuilder sb,
            Fallout4ModHeader.Mask<bool>? printMask = null)
        {
            if (printMask?.Flags ?? true)
            {
                sb.AppendItem(item.Flags, "Flags");
            }
            if (printMask?.FormID ?? true)
            {
                sb.AppendItem(item.FormID, "FormID");
            }
            if (printMask?.Version ?? true)
            {
                sb.AppendItem(item.Version, "Version");
            }
            if (printMask?.FormVersion ?? true)
            {
                sb.AppendItem(item.FormVersion, "FormVersion");
            }
            if (printMask?.Version2 ?? true)
            {
                sb.AppendItem(item.Version2, "Version2");
            }
            if (printMask?.Stats?.Overall ?? true)
            {
                item.Stats?.Print(sb, "Stats");
            }
            if ((printMask?.TypeOffsets ?? true)
                && item.TypeOffsets is {} TypeOffsetsItem)
            {
                sb.AppendLine($"TypeOffsets => {SpanExt.ToHexString(TypeOffsetsItem)}");
            }
            if ((printMask?.Deleted ?? true)
                && item.Deleted is {} DeletedItem)
            {
                sb.AppendLine($"Deleted => {SpanExt.ToHexString(DeletedItem)}");
            }
            if ((printMask?.Author ?? true)
                && item.Author is {} AuthorItem)
            {
                sb.AppendItem(AuthorItem, "Author");
            }
            if ((printMask?.Description ?? true)
                && item.Description is {} DescriptionItem)
            {
                sb.AppendItem(DescriptionItem, "Description");
            }
            if (printMask?.MasterReferences?.Overall ?? true)
            {
                sb.AppendLine("MasterReferences =>");
                using (sb.Brace())
                {
                    foreach (var subItem in item.MasterReferences)
                    {
                        using (sb.Brace())
                        {
                            subItem?.Print(sb, "Item");
                        }
                    }
                }
            }
            if ((printMask?.OverriddenForms?.Overall ?? true)
                && item.OverriddenForms is {} OverriddenFormsItem)
            {
                sb.AppendLine("OverriddenForms =>");
                using (sb.Brace())
                {
                    foreach (var subItem in OverriddenFormsItem)
                    {
                        using (sb.Brace())
                        {
                            sb.AppendItem(subItem.FormKey);
                        }
                    }
                }
            }
            if ((printMask?.Screenshot ?? true)
                && item.Screenshot is {} ScreenshotItem)
            {
                sb.AppendLine($"Screenshot => {SpanExt.ToHexString(ScreenshotItem)}");
            }
            if (printMask?.TransientTypes?.Overall ?? true)
            {
                sb.AppendLine("TransientTypes =>");
                using (sb.Brace())
                {
                    foreach (var subItem in item.TransientTypes)
                    {
                        using (sb.Brace())
                        {
                            subItem?.Print(sb, "Item");
                        }
                    }
                }
            }
            if ((printMask?.INTV ?? true)
                && item.INTV is {} INTVItem)
            {
                sb.AppendLine($"INTV => {SpanExt.ToHexString(INTVItem)}");
            }
            if ((printMask?.INCC ?? true)
                && item.INCC is {} INCCItem)
            {
                sb.AppendItem(INCCItem, "INCC");
            }
        }
        
        #region Equals and Hash
        public virtual bool Equals(
            IFallout4ModHeaderGetter? lhs,
            IFallout4ModHeaderGetter? rhs,
            TranslationCrystal? crystal)
        {
            if (!EqualsMaskHelper.RefEquality(lhs, rhs, out var isEqual)) return isEqual;
            if ((crystal?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.Flags) ?? true))
            {
                if (lhs.Flags != rhs.Flags) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.FormID) ?? true))
            {
                if (lhs.FormID != rhs.FormID) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.Version) ?? true))
            {
                if (lhs.Version != rhs.Version) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.FormVersion) ?? true))
            {
                if (lhs.FormVersion != rhs.FormVersion) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.Version2) ?? true))
            {
                if (lhs.Version2 != rhs.Version2) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.Stats) ?? true))
            {
                if (EqualsMaskHelper.RefEquality(lhs.Stats, rhs.Stats, out var lhsStats, out var rhsStats, out var isStatsEqual))
                {
                    if (!((ModStatsCommon)((IModStatsGetter)lhsStats).CommonInstance()!).Equals(lhsStats, rhsStats, crystal?.GetSubCrystal((int)Fallout4ModHeader_FieldIndex.Stats))) return false;
                }
                else if (!isStatsEqual) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.TypeOffsets) ?? true))
            {
                if (!MemorySliceExt.Equal(lhs.TypeOffsets, rhs.TypeOffsets)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.Deleted) ?? true))
            {
                if (!MemorySliceExt.Equal(lhs.Deleted, rhs.Deleted)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.Author) ?? true))
            {
                if (!string.Equals(lhs.Author, rhs.Author)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.Description) ?? true))
            {
                if (!string.Equals(lhs.Description, rhs.Description)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.MasterReferences) ?? true))
            {
                if (!lhs.MasterReferences.SequenceEqual(rhs.MasterReferences, (l, r) => ((MasterReferenceCommon)((IMasterReferenceGetter)l).CommonInstance()!).Equals(l, r, crystal?.GetSubCrystal((int)Fallout4ModHeader_FieldIndex.MasterReferences)))) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.OverriddenForms) ?? true))
            {
                if (!lhs.OverriddenForms.SequenceEqualNullable(rhs.OverriddenForms)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.Screenshot) ?? true))
            {
                if (!MemorySliceExt.Equal(lhs.Screenshot, rhs.Screenshot)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.TransientTypes) ?? true))
            {
                if (!lhs.TransientTypes.SequenceEqual(rhs.TransientTypes, (l, r) => ((TransientTypeCommon)((ITransientTypeGetter)l).CommonInstance()!).Equals(l, r, crystal?.GetSubCrystal((int)Fallout4ModHeader_FieldIndex.TransientTypes)))) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.INTV) ?? true))
            {
                if (!MemorySliceExt.Equal(lhs.INTV, rhs.INTV)) return false;
            }
            if ((crystal?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.INCC) ?? true))
            {
                if (lhs.INCC != rhs.INCC) return false;
            }
            return true;
        }
        
        public virtual int GetHashCode(IFallout4ModHeaderGetter item)
        {
            var hash = new HashCode();
            hash.Add(item.Flags);
            hash.Add(item.FormID);
            hash.Add(item.Version);
            hash.Add(item.FormVersion);
            hash.Add(item.Version2);
            hash.Add(item.Stats);
            if (item.TypeOffsets is {} TypeOffsetsItem)
            {
                hash.Add(TypeOffsetsItem);
            }
            if (item.Deleted is {} DeletedItem)
            {
                hash.Add(DeletedItem);
            }
            if (item.Author is {} Authoritem)
            {
                hash.Add(Authoritem);
            }
            if (item.Description is {} Descriptionitem)
            {
                hash.Add(Descriptionitem);
            }
            hash.Add(item.MasterReferences);
            hash.Add(item.OverriddenForms);
            if (item.Screenshot is {} ScreenshotItem)
            {
                hash.Add(ScreenshotItem);
            }
            hash.Add(item.TransientTypes);
            if (item.INTV is {} INTVItem)
            {
                hash.Add(INTVItem);
            }
            if (item.INCC is {} INCCitem)
            {
                hash.Add(INCCitem);
            }
            return hash.ToHashCode();
        }
        
        #endregion
        
        
        public object GetNew()
        {
            return Fallout4ModHeader.GetNew();
        }
        
        #region Mutagen
        public IEnumerable<IFormLinkGetter> EnumerateFormLinks(IFallout4ModHeaderGetter obj)
        {
            if (obj.OverriddenForms is {} OverriddenFormsItem)
            {
                foreach (var item in OverriddenFormsItem)
                {
                    yield return FormLinkInformation.Factory(item);
                }
            }
            foreach (var item in obj.TransientTypes.SelectMany(f => f.EnumerateFormLinks()))
            {
                yield return FormLinkInformation.Factory(item);
            }
            yield break;
        }
        
        #endregion
        
    }
    internal partial class Fallout4ModHeaderSetterTranslationCommon
    {
        public static readonly Fallout4ModHeaderSetterTranslationCommon Instance = new Fallout4ModHeaderSetterTranslationCommon();

        #region DeepCopyIn
        public void DeepCopyIn(
            IFallout4ModHeader item,
            IFallout4ModHeaderGetter rhs,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask,
            bool deepCopy)
        {
            if ((copyMask?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.Flags) ?? true))
            {
                item.Flags = rhs.Flags;
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.FormID) ?? true))
            {
                item.FormID = rhs.FormID;
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.Version) ?? true))
            {
                item.Version = rhs.Version;
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.FormVersion) ?? true))
            {
                item.FormVersion = rhs.FormVersion;
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.Version2) ?? true))
            {
                item.Version2 = rhs.Version2;
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.Stats) ?? true))
            {
                errorMask?.PushIndex((int)Fallout4ModHeader_FieldIndex.Stats);
                try
                {
                    if ((copyMask?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.Stats) ?? true))
                    {
                        item.Stats = rhs.Stats.DeepCopy(
                            copyMask: copyMask?.GetSubCrystal((int)Fallout4ModHeader_FieldIndex.Stats),
                            errorMask: errorMask);
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.TypeOffsets) ?? true))
            {
                if(rhs.TypeOffsets is {} TypeOffsetsrhs)
                {
                    item.TypeOffsets = TypeOffsetsrhs.ToArray();
                }
                else
                {
                    item.TypeOffsets = default;
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.Deleted) ?? true))
            {
                if(rhs.Deleted is {} Deletedrhs)
                {
                    item.Deleted = Deletedrhs.ToArray();
                }
                else
                {
                    item.Deleted = default;
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.Author) ?? true))
            {
                item.Author = rhs.Author;
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.Description) ?? true))
            {
                item.Description = rhs.Description;
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.MasterReferences) ?? true))
            {
                errorMask?.PushIndex((int)Fallout4ModHeader_FieldIndex.MasterReferences);
                try
                {
                    item.MasterReferences.SetTo(
                        rhs.MasterReferences
                        .Select(r =>
                        {
                            return r.DeepCopy(
                                errorMask: errorMask,
                                default(TranslationCrystal));
                        }));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.OverriddenForms) ?? true))
            {
                errorMask?.PushIndex((int)Fallout4ModHeader_FieldIndex.OverriddenForms);
                try
                {
                    if ((rhs.OverriddenForms != null))
                    {
                        item.OverriddenForms = 
                            rhs.OverriddenForms
                            .Select(r => (IFormLinkGetter<IFallout4MajorRecordGetter>)new FormLink<IFallout4MajorRecordGetter>(r.FormKey))
                            .ToExtendedList<IFormLinkGetter<IFallout4MajorRecordGetter>>();
                    }
                    else
                    {
                        item.OverriddenForms = null;
                    }
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.Screenshot) ?? true))
            {
                if(rhs.Screenshot is {} Screenshotrhs)
                {
                    item.Screenshot = Screenshotrhs.ToArray();
                }
                else
                {
                    item.Screenshot = default;
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.TransientTypes) ?? true))
            {
                errorMask?.PushIndex((int)Fallout4ModHeader_FieldIndex.TransientTypes);
                try
                {
                    item.TransientTypes.SetTo(
                        rhs.TransientTypes
                        .Select(r =>
                        {
                            return r.DeepCopy(
                                errorMask: errorMask,
                                default(TranslationCrystal));
                        }));
                }
                catch (Exception ex)
                when (errorMask != null)
                {
                    errorMask.ReportException(ex);
                }
                finally
                {
                    errorMask?.PopIndex();
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.INTV) ?? true))
            {
                if(rhs.INTV is {} INTVrhs)
                {
                    item.INTV = INTVrhs.ToArray();
                }
                else
                {
                    item.INTV = default;
                }
            }
            if ((copyMask?.GetShouldTranslate((int)Fallout4ModHeader_FieldIndex.INCC) ?? true))
            {
                item.INCC = rhs.INCC;
            }
        }
        
        #endregion
        
        public Fallout4ModHeader DeepCopy(
            IFallout4ModHeaderGetter item,
            Fallout4ModHeader.TranslationMask? copyMask = null)
        {
            Fallout4ModHeader ret = (Fallout4ModHeader)((Fallout4ModHeaderCommon)((IFallout4ModHeaderGetter)item).CommonInstance()!).GetNew();
            ((Fallout4ModHeaderSetterTranslationCommon)((IFallout4ModHeaderGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: null,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            return ret;
        }
        
        public Fallout4ModHeader DeepCopy(
            IFallout4ModHeaderGetter item,
            out Fallout4ModHeader.ErrorMask errorMask,
            Fallout4ModHeader.TranslationMask? copyMask = null)
        {
            var errorMaskBuilder = new ErrorMaskBuilder();
            Fallout4ModHeader ret = (Fallout4ModHeader)((Fallout4ModHeaderCommon)((IFallout4ModHeaderGetter)item).CommonInstance()!).GetNew();
            ((Fallout4ModHeaderSetterTranslationCommon)((IFallout4ModHeaderGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                ret,
                item,
                errorMask: errorMaskBuilder,
                copyMask: copyMask?.GetCrystal(),
                deepCopy: true);
            errorMask = Fallout4ModHeader.ErrorMask.Factory(errorMaskBuilder);
            return ret;
        }
        
        public Fallout4ModHeader DeepCopy(
            IFallout4ModHeaderGetter item,
            ErrorMaskBuilder? errorMask,
            TranslationCrystal? copyMask = null)
        {
            Fallout4ModHeader ret = (Fallout4ModHeader)((Fallout4ModHeaderCommon)((IFallout4ModHeaderGetter)item).CommonInstance()!).GetNew();
            ((Fallout4ModHeaderSetterTranslationCommon)((IFallout4ModHeaderGetter)ret).CommonSetterTranslationInstance()!).DeepCopyIn(
                item: ret,
                rhs: item,
                errorMask: errorMask,
                copyMask: copyMask,
                deepCopy: true);
            return ret;
        }
        
    }
    #endregion

}

namespace Mutagen.Bethesda.Fallout4
{
    public partial class Fallout4ModHeader
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => Fallout4ModHeader_Registration.Instance;
        public static ILoquiRegistration StaticRegistration => Fallout4ModHeader_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => Fallout4ModHeaderCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterInstance()
        {
            return Fallout4ModHeaderSetterCommon.Instance;
        }
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => Fallout4ModHeaderSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IFallout4ModHeaderGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object IFallout4ModHeaderGetter.CommonSetterInstance() => this.CommonSetterInstance();
        [DebuggerStepThrough]
        object IFallout4ModHeaderGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

    }
}

#region Modules
#region Binary Translation
namespace Mutagen.Bethesda.Fallout4
{
    public partial class Fallout4ModHeaderBinaryWriteTranslation : IBinaryWriteTranslator
    {
        public static readonly Fallout4ModHeaderBinaryWriteTranslation Instance = new Fallout4ModHeaderBinaryWriteTranslation();

        public static void WriteEmbedded(
            IFallout4ModHeaderGetter item,
            MutagenWriter writer)
        {
            EnumBinaryTranslation<Fallout4ModHeader.HeaderFlag, MutagenFrame, MutagenWriter>.Instance.Write(
                writer,
                item.Flags,
                length: 4);
            writer.Write(item.FormID);
            writer.Write(item.Version);
            writer.Write(item.FormVersion);
            writer.Write(item.Version2);
        }

        public static void WriteRecordTypes(
            IFallout4ModHeaderGetter item,
            MutagenWriter writer,
            TypedWriteParams translationParams)
        {
            var StatsItem = item.Stats;
            ((ModStatsBinaryWriteTranslation)((IBinaryItem)StatsItem).BinaryWriteTranslator).Write(
                item: StatsItem,
                writer: writer,
                translationParams: translationParams);
            ByteArrayBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                writer: writer,
                item: item.TypeOffsets,
                header: translationParams.ConvertToCustom(RecordTypes.OFST));
            ByteArrayBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                writer: writer,
                item: item.Deleted,
                header: translationParams.ConvertToCustom(RecordTypes.DELE));
            StringBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.Author,
                header: translationParams.ConvertToCustom(RecordTypes.CNAM),
                binaryType: StringBinaryType.NullTerminate);
            StringBinaryTranslation.Instance.WriteNullable(
                writer: writer,
                item: item.Description,
                header: translationParams.ConvertToCustom(RecordTypes.SNAM),
                binaryType: StringBinaryType.NullTerminate);
            Fallout4ModHeaderBinaryWriteTranslation.WriteBinaryMasterReferences(
                writer: writer,
                item: item);
            Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<IFormLinkGetter<IFallout4MajorRecordGetter>>.Instance.Write(
                writer: writer,
                items: item.OverriddenForms,
                recordType: translationParams.ConvertToCustom(RecordTypes.ONAM),
                overflowRecord: RecordTypes.XXXX,
                transl: (MutagenWriter subWriter, IFormLinkGetter<IFallout4MajorRecordGetter> subItem, TypedWriteParams conv) =>
                {
                    FormLinkBinaryTranslation.Instance.Write(
                        writer: subWriter,
                        item: subItem);
                });
            ByteArrayBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                writer: writer,
                item: item.Screenshot,
                header: translationParams.ConvertToCustom(RecordTypes.SCRN));
            Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<ITransientTypeGetter>.Instance.Write(
                writer: writer,
                items: item.TransientTypes,
                transl: (MutagenWriter subWriter, ITransientTypeGetter subItem, TypedWriteParams conv) =>
                {
                    var Item = subItem;
                    ((TransientTypeBinaryWriteTranslation)((IBinaryItem)Item).BinaryWriteTranslator).Write(
                        item: Item,
                        writer: subWriter,
                        translationParams: conv);
                });
            ByteArrayBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Write(
                writer: writer,
                item: item.INTV,
                header: translationParams.ConvertToCustom(RecordTypes.INTV));
            Int32BinaryTranslation<MutagenFrame, MutagenWriter>.Instance.WriteNullable(
                writer: writer,
                item: item.INCC,
                header: translationParams.ConvertToCustom(RecordTypes.INCC));
        }

        public static partial void WriteBinaryMasterReferencesCustom(
            MutagenWriter writer,
            IFallout4ModHeaderGetter item);

        public static void WriteBinaryMasterReferences(
            MutagenWriter writer,
            IFallout4ModHeaderGetter item)
        {
            WriteBinaryMasterReferencesCustom(
                writer: writer,
                item: item);
        }

        public void Write(
            MutagenWriter writer,
            IFallout4ModHeaderGetter item,
            TypedWriteParams translationParams)
        {
            using (HeaderExport.Record(
                writer: writer,
                record: translationParams.ConvertToCustom(RecordTypes.TES4)))
            {
                WriteEmbedded(
                    item: item,
                    writer: writer);
                WriteRecordTypes(
                    item: item,
                    writer: writer,
                    translationParams: translationParams);
            }
        }

        public void Write(
            MutagenWriter writer,
            object item,
            TypedWriteParams translationParams = default)
        {
            Write(
                item: (IFallout4ModHeaderGetter)item,
                writer: writer,
                translationParams: translationParams);
        }

    }

    internal partial class Fallout4ModHeaderBinaryCreateTranslation
    {
        public static readonly Fallout4ModHeaderBinaryCreateTranslation Instance = new Fallout4ModHeaderBinaryCreateTranslation();

        public static void FillBinaryStructs(
            IFallout4ModHeader item,
            MutagenFrame frame)
        {
            item.Flags = EnumBinaryTranslation<Fallout4ModHeader.HeaderFlag, MutagenFrame, MutagenWriter>.Instance.Parse(
                reader: frame,
                length: 4);
            item.FormID = frame.ReadUInt32();
            item.Version = frame.ReadInt32();
            item.FormVersion = frame.ReadUInt16();
            item.Version2 = frame.ReadUInt16();
        }

        public static ParseResult FillBinaryRecordTypes(
            IFallout4ModHeader item,
            MutagenFrame frame,
            PreviousParse lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            RecordType nextRecordType,
            int contentLength,
            TypedParseParams translationParams = default)
        {
            nextRecordType = translationParams.ConvertToStandard(nextRecordType);
            switch (nextRecordType.TypeInt)
            {
                case RecordTypeInts.HEDR:
                {
                    item.Stats = Mutagen.Bethesda.Fallout4.ModStats.CreateFromBinary(frame: frame);
                    return (int)Fallout4ModHeader_FieldIndex.Stats;
                }
                case RecordTypeInts.OFST:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.TypeOffsets = ByteArrayBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)Fallout4ModHeader_FieldIndex.TypeOffsets;
                }
                case RecordTypeInts.DELE:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Deleted = ByteArrayBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)Fallout4ModHeader_FieldIndex.Deleted;
                }
                case RecordTypeInts.CNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Author = StringBinaryTranslation.Instance.Parse(
                        reader: frame.SpawnWithLength(contentLength),
                        stringBinaryType: StringBinaryType.NullTerminate);
                    return (int)Fallout4ModHeader_FieldIndex.Author;
                }
                case RecordTypeInts.SNAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Description = StringBinaryTranslation.Instance.Parse(
                        reader: frame.SpawnWithLength(contentLength),
                        stringBinaryType: StringBinaryType.NullTerminate);
                    return (int)Fallout4ModHeader_FieldIndex.Description;
                }
                case RecordTypeInts.MAST:
                {
                    Fallout4ModHeaderBinaryCreateTranslation.FillBinaryMasterReferencesCustom(
                        frame: frame.SpawnWithLength(frame.MetaData.Constants.SubConstants.HeaderLength + contentLength),
                        item: item);
                    return (int)Fallout4ModHeader_FieldIndex.MasterReferences;
                }
                case RecordTypeInts.ONAM:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.OverriddenForms = 
                        Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<IFormLinkGetter<IFallout4MajorRecordGetter>>.Instance.Parse(
                            reader: frame.SpawnWithLength(contentLength),
                            transl: FormLinkBinaryTranslation.Instance.Parse)
                        .CastExtendedList<IFormLinkGetter<IFallout4MajorRecordGetter>>();
                    return (int)Fallout4ModHeader_FieldIndex.OverriddenForms;
                }
                case RecordTypeInts.SCRN:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.Screenshot = ByteArrayBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)Fallout4ModHeader_FieldIndex.Screenshot;
                }
                case RecordTypeInts.TNAM:
                {
                    item.TransientTypes.SetTo(
                        Mutagen.Bethesda.Plugins.Binary.Translations.ListBinaryTranslation<TransientType>.Instance.Parse(
                            reader: frame,
                            triggeringRecord: TransientType_Registration.TriggerSpecs,
                            translationParams: translationParams,
                            transl: TransientType.TryCreateFromBinary));
                    return (int)Fallout4ModHeader_FieldIndex.TransientTypes;
                }
                case RecordTypeInts.INTV:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.INTV = ByteArrayBinaryTranslation<MutagenFrame, MutagenWriter>.Instance.Parse(reader: frame.SpawnWithLength(contentLength));
                    return (int)Fallout4ModHeader_FieldIndex.INTV;
                }
                case RecordTypeInts.INCC:
                {
                    frame.Position += frame.MetaData.Constants.SubConstants.HeaderLength;
                    item.INCC = frame.ReadInt32();
                    return (int)Fallout4ModHeader_FieldIndex.INCC;
                }
                case RecordTypeInts.XXXX:
                {
                    var overflowHeader = frame.ReadSubrecord();
                    return ParseResult.OverrideLength(BinaryPrimitives.ReadUInt32LittleEndian(overflowHeader.Content));
                }
                default:
                    frame.Position += contentLength + frame.MetaData.Constants.SubConstants.HeaderLength;
                    return default(int?);
            }
        }

        public static partial void FillBinaryMasterReferencesCustom(
            MutagenFrame frame,
            IFallout4ModHeader item);

    }

}
namespace Mutagen.Bethesda.Fallout4
{
    #region Binary Write Mixins
    public static class Fallout4ModHeaderBinaryTranslationMixIn
    {
        public static void WriteToBinary(
            this IFallout4ModHeaderGetter item,
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((Fallout4ModHeaderBinaryWriteTranslation)item.BinaryWriteTranslator).Write(
                item: item,
                writer: writer,
                translationParams: translationParams);
        }

    }
    #endregion


}
namespace Mutagen.Bethesda.Fallout4
{
    internal partial class Fallout4ModHeaderBinaryOverlay :
        PluginBinaryOverlay,
        IFallout4ModHeaderGetter
    {
        #region Common Routing
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILoquiRegistration ILoquiObject.Registration => Fallout4ModHeader_Registration.Instance;
        public static ILoquiRegistration StaticRegistration => Fallout4ModHeader_Registration.Instance;
        [DebuggerStepThrough]
        protected object CommonInstance() => Fallout4ModHeaderCommon.Instance;
        [DebuggerStepThrough]
        protected object CommonSetterTranslationInstance() => Fallout4ModHeaderSetterTranslationCommon.Instance;
        [DebuggerStepThrough]
        object IFallout4ModHeaderGetter.CommonInstance() => this.CommonInstance();
        [DebuggerStepThrough]
        object? IFallout4ModHeaderGetter.CommonSetterInstance() => null;
        [DebuggerStepThrough]
        object IFallout4ModHeaderGetter.CommonSetterTranslationInstance() => this.CommonSetterTranslationInstance();

        #endregion

        void IPrintable.Print(StructuredStringBuilder sb, string? name) => this.Print(sb, name);

        public IEnumerable<IFormLinkGetter> EnumerateFormLinks() => Fallout4ModHeaderCommon.Instance.EnumerateFormLinks(this);
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected object BinaryWriteTranslator => Fallout4ModHeaderBinaryWriteTranslation.Instance;
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        object IBinaryItem.BinaryWriteTranslator => this.BinaryWriteTranslator;
        void IBinaryItem.WriteToBinary(
            MutagenWriter writer,
            TypedWriteParams translationParams = default)
        {
            ((Fallout4ModHeaderBinaryWriteTranslation)this.BinaryWriteTranslator).Write(
                item: this,
                writer: writer,
                translationParams: translationParams);
        }

        public Fallout4ModHeader.HeaderFlag Flags => (Fallout4ModHeader.HeaderFlag)BinaryPrimitives.ReadInt32LittleEndian(_structData.Span.Slice(0x0, 0x4));
        public UInt32 FormID => BinaryPrimitives.ReadUInt32LittleEndian(_structData.Slice(0x4, 0x4));
        public Int32 Version => BinaryPrimitives.ReadInt32LittleEndian(_structData.Slice(0x8, 0x4));
        public UInt16 FormVersion => BinaryPrimitives.ReadUInt16LittleEndian(_structData.Slice(0xC, 0x2));
        public UInt16 Version2 => BinaryPrimitives.ReadUInt16LittleEndian(_structData.Slice(0xE, 0x2));
        #region Stats
        private RangeInt32? _StatsLocation;
        private IModStatsGetter? _Stats => _StatsLocation.HasValue ? ModStatsBinaryOverlay.ModStatsFactory(_recordData.Slice(_StatsLocation!.Value.Min), _package) : default;
        public IModStatsGetter Stats => _Stats ?? new ModStats();
        #endregion
        #region TypeOffsets
        private int? _TypeOffsetsLocation;
        public ReadOnlyMemorySlice<Byte>? TypeOffsets => _TypeOffsetsLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_recordData, _TypeOffsetsLocation.Value, _package.MetaData.Constants) : default(ReadOnlyMemorySlice<byte>?);
        #endregion
        #region Deleted
        private int? _DeletedLocation;
        public ReadOnlyMemorySlice<Byte>? Deleted => _DeletedLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_recordData, _DeletedLocation.Value, _package.MetaData.Constants) : default(ReadOnlyMemorySlice<byte>?);
        #endregion
        #region Author
        private int? _AuthorLocation;
        public String? Author => _AuthorLocation.HasValue ? BinaryStringUtility.ProcessWholeToZString(HeaderTranslation.ExtractSubrecordMemory(_recordData, _AuthorLocation.Value, _package.MetaData.Constants), encoding: _package.MetaData.Encodings.NonTranslated) : default(string?);
        #endregion
        #region Description
        private int? _DescriptionLocation;
        public String? Description => _DescriptionLocation.HasValue ? BinaryStringUtility.ProcessWholeToZString(HeaderTranslation.ExtractSubrecordMemory(_recordData, _DescriptionLocation.Value, _package.MetaData.Constants), encoding: _package.MetaData.Encodings.NonTranslated) : default(string?);
        #endregion
        public IReadOnlyList<IMasterReferenceGetter> MasterReferences { get; private set; } = Array.Empty<IMasterReferenceGetter>();
        public IReadOnlyList<IFormLinkGetter<IFallout4MajorRecordGetter>>? OverriddenForms { get; private set; }
        #region Screenshot
        private int? _ScreenshotLocation;
        public ReadOnlyMemorySlice<Byte>? Screenshot => _ScreenshotLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_recordData, _ScreenshotLocation.Value, _package.MetaData.Constants) : default(ReadOnlyMemorySlice<byte>?);
        #endregion
        public IReadOnlyList<ITransientTypeGetter> TransientTypes { get; private set; } = Array.Empty<ITransientTypeGetter>();
        #region INTV
        private int? _INTVLocation;
        public ReadOnlyMemorySlice<Byte>? INTV => _INTVLocation.HasValue ? HeaderTranslation.ExtractSubrecordMemory(_recordData, _INTVLocation.Value, _package.MetaData.Constants) : default(ReadOnlyMemorySlice<byte>?);
        #endregion
        #region INCC
        private int? _INCCLocation;
        public Int32? INCC => _INCCLocation.HasValue ? BinaryPrimitives.ReadInt32LittleEndian(HeaderTranslation.ExtractSubrecordMemory(_recordData, _INCCLocation.Value, _package.MetaData.Constants)) : default(Int32?);
        #endregion
        partial void CustomFactoryEnd(
            OverlayStream stream,
            int finalPos,
            int offset);

        partial void CustomCtor();
        protected Fallout4ModHeaderBinaryOverlay(
            MemoryPair memoryPair,
            BinaryOverlayFactoryPackage package)
            : base(
                memoryPair: memoryPair,
                package: package)
        {
            this.CustomCtor();
        }

        public static IFallout4ModHeaderGetter Fallout4ModHeaderFactory(
            OverlayStream stream,
            BinaryOverlayFactoryPackage package,
            TypedParseParams translationParams = default)
        {
            stream = ExtractRecordMemory(
                stream: stream,
                meta: package.MetaData.Constants,
                memoryPair: out var memoryPair,
                offset: out var offset,
                finalPos: out var finalPos);
            var ret = new Fallout4ModHeaderBinaryOverlay(
                memoryPair: memoryPair,
                package: package);
            ret.CustomFactoryEnd(
                stream: stream,
                finalPos: finalPos,
                offset: offset);
            ret.FillSubrecordTypes(
                stream: stream,
                finalPos: finalPos,
                offset: offset,
                translationParams: translationParams,
                fill: ret.FillRecordType);
            return ret;
        }

        public static IFallout4ModHeaderGetter Fallout4ModHeaderFactory(
            ReadOnlyMemorySlice<byte> slice,
            BinaryOverlayFactoryPackage package,
            TypedParseParams translationParams = default)
        {
            return Fallout4ModHeaderFactory(
                stream: new OverlayStream(slice, package),
                package: package,
                translationParams: translationParams);
        }

        public ParseResult FillRecordType(
            OverlayStream stream,
            int finalPos,
            int offset,
            RecordType type,
            PreviousParse lastParsed,
            Dictionary<RecordType, int>? recordParseCount,
            TypedParseParams translationParams = default)
        {
            type = translationParams.ConvertToStandard(type);
            switch (type.TypeInt)
            {
                case RecordTypeInts.HEDR:
                {
                    _StatsLocation = new RangeInt32((stream.Position - offset), finalPos - offset);
                    return (int)Fallout4ModHeader_FieldIndex.Stats;
                }
                case RecordTypeInts.OFST:
                {
                    _TypeOffsetsLocation = (stream.Position - offset);
                    return (int)Fallout4ModHeader_FieldIndex.TypeOffsets;
                }
                case RecordTypeInts.DELE:
                {
                    _DeletedLocation = (stream.Position - offset);
                    return (int)Fallout4ModHeader_FieldIndex.Deleted;
                }
                case RecordTypeInts.CNAM:
                {
                    _AuthorLocation = (stream.Position - offset);
                    return (int)Fallout4ModHeader_FieldIndex.Author;
                }
                case RecordTypeInts.SNAM:
                {
                    _DescriptionLocation = (stream.Position - offset);
                    return (int)Fallout4ModHeader_FieldIndex.Description;
                }
                case RecordTypeInts.MAST:
                {
                    this.MasterReferences = this.ParseRepeatedTypelessSubrecord<IMasterReferenceGetter>(
                        stream: stream,
                        translationParams: translationParams,
                        trigger: MasterReference_Registration.TriggerSpecs,
                        factory: MasterReferenceBinaryOverlay.MasterReferenceFactory);
                    return (int)Fallout4ModHeader_FieldIndex.MasterReferences;
                }
                case RecordTypeInts.ONAM:
                {
                    var subMeta = stream.ReadSubrecordHeader();
                    var subLen = finalPos - stream.Position;
                    this.OverriddenForms = BinaryOverlayList.FactoryByStartIndex<IFormLinkGetter<IFallout4MajorRecordGetter>>(
                        mem: stream.RemainingMemory.Slice(0, subLen),
                        package: _package,
                        itemLength: 4,
                        getter: (s, p) => new FormLink<IFallout4MajorRecordGetter>(FormKey.Factory(p.MetaData.MasterReferences!, BinaryPrimitives.ReadUInt32LittleEndian(s))));
                    stream.Position += subLen;
                    return (int)Fallout4ModHeader_FieldIndex.OverriddenForms;
                }
                case RecordTypeInts.SCRN:
                {
                    _ScreenshotLocation = (stream.Position - offset);
                    return (int)Fallout4ModHeader_FieldIndex.Screenshot;
                }
                case RecordTypeInts.TNAM:
                {
                    this.TransientTypes = BinaryOverlayList.FactoryByArray<ITransientTypeGetter>(
                        mem: stream.RemainingMemory,
                        package: _package,
                        translationParams: translationParams,
                        getter: (s, p, recConv) => TransientTypeBinaryOverlay.TransientTypeFactory(new OverlayStream(s, p), p, recConv),
                        locs: ParseRecordLocations(
                            stream: stream,
                            trigger: TransientType_Registration.TriggerSpecs,
                            triggersAlwaysAreNewRecords: true,
                            constants: _package.MetaData.Constants.SubConstants,
                            skipHeader: false));
                    return (int)Fallout4ModHeader_FieldIndex.TransientTypes;
                }
                case RecordTypeInts.INTV:
                {
                    _INTVLocation = (stream.Position - offset);
                    return (int)Fallout4ModHeader_FieldIndex.INTV;
                }
                case RecordTypeInts.INCC:
                {
                    _INCCLocation = (stream.Position - offset);
                    return (int)Fallout4ModHeader_FieldIndex.INCC;
                }
                case RecordTypeInts.XXXX:
                {
                    var overflowHeader = stream.ReadSubrecord();
                    return ParseResult.OverrideLength(BinaryPrimitives.ReadUInt32LittleEndian(overflowHeader.Content));
                }
                default:
                    return default(int?);
            }
        }
        #region To String

        public void Print(
            StructuredStringBuilder sb,
            string? name = null)
        {
            Fallout4ModHeaderMixIn.Print(
                item: this,
                sb: sb,
                name: name);
        }

        #endregion

        #region Equals and Hash
        public override bool Equals(object? obj)
        {
            if (obj is not IFallout4ModHeaderGetter rhs) return false;
            return ((Fallout4ModHeaderCommon)((IFallout4ModHeaderGetter)this).CommonInstance()!).Equals(this, rhs, crystal: null);
        }

        public bool Equals(IFallout4ModHeaderGetter? obj)
        {
            return ((Fallout4ModHeaderCommon)((IFallout4ModHeaderGetter)this).CommonInstance()!).Equals(this, obj, crystal: null);
        }

        public override int GetHashCode() => ((Fallout4ModHeaderCommon)((IFallout4ModHeaderGetter)this).CommonInstance()!).GetHashCode(this);

        #endregion

    }

}
#endregion

#endregion

